"use strict";
/*
 * Copyright 2019-2020 Unbounded Systems, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseJsonMessages = exports.run = exports.commonDefaults = void 0;
const tslib_1 = require("tslib");
const decamelize_1 = tslib_1.__importDefault(require("decamelize"));
const execa_1 = tslib_1.__importDefault(require("execa"));
const npm_run_path_1 = tslib_1.__importDefault(require("npm-run-path"));
const ci_report_1 = require("../ci_report");
const noArgOptions = [
    "noProgress",
];
exports.commonDefaults = {
    loglevel: "normal",
    pipeOutput: false,
    noProgress: true,
};
const npmPath = npm_run_path_1.default({ cwd: __dirname });
/**
 * NOTE: This function is purposely NOT async.
 * The childProc object that execa returns gives the caller a lot of flexibility
 * in how to consume the results, especially including consuming the
 * output streams in real time, without waiting for the target process to exit.
 * So we take care to pass exactly that object back, NOT a promise to that object.
 */
function run(action, options, args) {
    // tslint:disable-next-line:prefer-const
    let _a = Object.assign(Object.assign({}, exports.commonDefaults), options), { boolNoArgOptions = [], loglevel, pipeOutput } = _a, opts = tslib_1.__rest(_a, ["boolNoArgOptions", "loglevel", "pipeOutput"]);
    boolNoArgOptions.push(...noArgOptions);
    const finalOpts = optionsBoolToUndef(opts, boolNoArgOptions);
    const finalArgs = [action];
    if (loglevel === "silent")
        finalArgs.push("--silent");
    if (loglevel === "verbose")
        finalArgs.push("--verbose");
    for (const opt of Object.keys(finalOpts)) {
        const flag = "--" + decamelize_1.default(opt, "-");
        finalArgs.push(flag);
        const val = finalOpts[opt];
        if (val !== undefined)
            finalArgs.push(val.toString());
    }
    if (args)
        finalArgs.push(...args);
    const env = { PATH: npmPath };
    const childProc = execa_1.default("yarn", finalArgs, {
        all: true,
        env,
        stripFinalNewline: false,
    });
    const logStop = logStart(childProc.pid, finalArgs);
    if (pipeOutput) {
        childProc.stdout.pipe(process.stdout);
        childProc.stderr.pipe(process.stdout);
    }
    // We want to return the original childProc object, so this creates a
    // separate Promise chain that we do not pass back.
    childProc
        .catch((err) => {
        // Make the error message slightly more helpful.
        // Promise catches are guaranteed to execute in the order they
        // are registered, so this catch will augment the error object
        // before any callers of run see it.
        let msg = `yarn ${action} failed: `;
        if (err.all)
            msg += `${err.shortMessage}\n${err.all}`;
        else
            msg += err.message;
        err.message = msg;
        throw err;
    })
        .then((child) => logStop(child.all), (err) => logStop(err.all || err.message || err))
        .catch(() => { });
    return childProc;
}
exports.run = run;
function optionsBoolToUndef(options, keys) {
    const ret = Object.assign({}, options);
    for (const k of keys) {
        if (ret[k])
            ret[k] = undefined;
        else
            delete ret[k];
    }
    return ret;
}
function parseJsonMessages(output, typeFilter) {
    const lines = output.split(/\r?\n/g);
    let objs = lines.map((l) => {
        try {
            return JSON.parse(l);
        }
        catch (e) {
            return { type: "MessageError", data: e.message };
        }
    });
    if (typeFilter)
        objs = objs.filter((o) => o != null && o.type === typeFilter);
    return objs;
}
exports.parseJsonMessages = parseJsonMessages;
function logStart(pid, args) {
    const logger = ci_report_1.ciMaybeCreateLogger(`yarn-${pid}`);
    if (!logger)
        return () => { };
    const argstr = `yarn ${args.join(" ")}`;
    logger.log(`RUN ${argstr}`);
    logger.logps();
    return (output) => {
        logger.log(`DONE ${argstr}`);
        logger.log(`OUTPUT`, output);
        logger.close();
    };
}
//# sourceMappingURL=common.js.map