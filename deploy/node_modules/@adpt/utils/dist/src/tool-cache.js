"use strict";
/*
 * Copyright 2020 Unbounded Systems, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.fetchToCache = void 0;
const tslib_1 = require("tslib");
const fs_extra_1 = require("fs-extra");
const node_fetch_1 = tslib_1.__importDefault(require("node-fetch"));
const p_defer_1 = tslib_1.__importDefault(require("p-defer"));
const path_1 = tslib_1.__importDefault(require("path"));
const tar_1 = tslib_1.__importDefault(require("tar"));
const url_1 = require("url");
const crypto_1 = require("./crypto");
const internal_error_1 = require("./internal_error");
const xdg_1 = require("./xdg");
function isFileOptions(opt) {
    return opt.untar !== true;
}
const cacheMap = new Map();
const cacheKey = ({ name, url, version }) => `${name}-${version}-${url}`;
async function fetchToCache(options) {
    const key = cacheKey(options);
    const { name, url, version } = options;
    const entry = cacheMap.get(key);
    if (entry)
        return entry.promise;
    const deferred = p_defer_1.default();
    cacheMap.set(key, deferred);
    try {
        const toolsCacheBase = path_1.default.join(xdg_1.xdgCacheDir(), "tools");
        const sha = crypto_1.sha256hex(url).slice(0, 5);
        const tag = version ? `${version}-${sha}` : sha;
        const dir = path_1.default.join(toolsCacheBase, name, tag);
        const complete = path_1.default.join(dir, ".complete");
        let file;
        if (isFileOptions(options)) {
            const urlObj = new url_1.URL(url);
            const baseName = options.file || urlObj.pathname.split("/").slice(-1)[0];
            if (!baseName) {
                throw new Error(`Cannot determine a local file name to use for fetching ${name}. ` +
                    `Use the 'file' option.`);
            }
            file = path_1.default.join(dir, baseName);
        }
        // TODO: With multiple processes, they can race and both attempt
        // a download at the same time. Use proper-lockfile to serialize
        // access and provide liveliness check to recover from an aborted
        // download.
        if (!(await fs_extra_1.pathExists(complete))) {
            await fs_extra_1.ensureDir(dir, 0o700);
            const response = await node_fetch_1.default(url);
            if (response.status !== 200)
                throw new Error(`Could not get ${name} from ${url}: ${response.statusText}`);
            if (isFileOptions(options)) {
                if (!file)
                    throw new internal_error_1.InternalError(`file cannot be null`);
                await downloadFile(file, response, options);
            }
            else {
                await downloadTar(dir, response, options);
            }
            await fs_extra_1.writeFile(complete, "");
        }
        deferred.resolve({ dir, file });
    }
    catch (err) {
        deferred.reject(err);
    }
    return deferred.promise;
}
exports.fetchToCache = fetchToCache;
async function downloadFile(file, response, options) {
    const mode = options.mode != null ? options.mode : 0o500;
    // If another process has a download in progress, don't allow
    // us to corrupt it (flags: "wx").
    // TODO: If a previous fetch was aborted and left this file,
    // this will always fail until the download file is manually
    // deleted. See above TODO for fix.
    const fileStream = fs_extra_1.createWriteStream(`${file}.download`, { mode, flags: "wx" });
    await waitForStreams(response.body, fileStream, options);
    // Only allow a completed file to occupy the 'file' path
    await fs_extra_1.rename(`${file}.download`, file);
}
async function downloadTar(dir, response, options) {
    const tarOptions = Object.assign(Object.assign({}, (options.tarOptions || {})), { cwd: dir });
    const tarStream = tar_1.default.extract(tarOptions || {}, options.fileList);
    await waitForStreams(response.body, tarStream, options);
}
async function waitForStreams(from, to, { name, url }) {
    return new Promise((res, rej) => {
        let err;
        to.on("close", res);
        to.on("error", (e) => {
            if (!err) {
                rej(e);
                err = e;
            }
            else {
                // tslint:disable-next-line: no-console
                console.error(`Unhandled error while writing ${name} from ${url}:`, e);
            }
        });
        from.on("error", (e) => {
            if (!err) {
                rej(e);
                err = e;
            }
            else {
                // tslint:disable-next-line: no-console
                console.error(`Unhandled error downloading ${name} from ${url}:`, e);
            }
        });
        from.pipe(to);
    });
}
//# sourceMappingURL=tool-cache.js.map