import { Graph } from "graphlib";
import { Handle } from "../handle";
import { AdaptElement, AdaptMountedElement, ElementID, FinalDomElement } from "../jsx";
import { Deployment } from "../server/deployment";
import { DeployOpID } from "../server/deployment_data";
import { Status } from "../status";
import { Action, Dependency, DeployHelpers, EPPrimitiveDependencies, ExecuteComplete, ExecuteOptions, ExecutionPlan, ExecutionPlanOptions, GoalStatus, Relation } from "./deploy_types";
import { EPNode, EPNodeId, EPObject, ExecutePassOptions, StatusTracker, WaitInfo } from "./deploy_types_private";
export declare function createExecutionPlan(options: ExecutionPlanOptions): ExecutionPlan;
export declare function getWaitInfo(goalStatus: GoalStatus, e: AdaptElement | Handle, helpers: DeployHelpers): WaitInfo;
/**
 * Dependency types:
 *
 * - FinishStart: This is also referrred to as a "soft" FinishStart
 *   dependency. It is current the only type of dependency that users can
 *   manually specify, which is done via a `dependsOn` method or related
 *   mechanism. These dependencies are inserted into the plan graph,
 *   but are really checked/enforced by the Relations associated with the
 *   node, not solely by the graph. The reason for this is to support
 *   Relation types besides just a strict dependency, such as a
 *   Relation with a logical "OR". This enables creating a dependency like
 *   waiting for one instance of a failover group to be deployed, rather than
 *   waiting for all instances to be deployed.
 *   When executing a plan, a node that has only incomplete FinishStart
 *   (soft) dependencies remaining will get signaled to check its Relations
 *   every time one of the node's dependencies change to a finished state.
 *
 * - FinishStartHard: This dependency type is the more traditional strict
 *   dependency one might expect in a dependency graph. When N1 depends
 *   on N2 with FinishStartHard type, N1 will not start until N2 finishes.
 *   A node will never get signaled to do any work or check its Relations as long
 *   as it has any FinishStartHard dependencies remaining in the graph. This
 *   dependency type is currently only created via `plan.addSavedDependencies`,
 *   which is used for saved/reanimated DOMs. Note that a node's Relations will
 *   not necessarily have or enforce these dependencies, so the graph must do all
 *   the enforcing.
 *
 * - StartStart: When N1 depends on N2 with a StartStart type, N1 will not start
 *   until N2 has started. These dependencies are created automatically
 *   between an Element and its parent and/or predecessors in the DOM via
 *   `plan.setParent`.
 */
export declare enum DependencyType {
    FinishStart = "FinishStart",
    FinishStartHard = "FinishStartHard",
    StartStart = "StartStart"
}
export interface EPEdge {
    edgeType: DependencyType;
}
export interface EPDependency {
    id: EPNodeId;
    type: DependencyType;
}
export interface EPDependencies {
    [epNodeId: string]: {
        elementId?: ElementID;
        detail: string;
        deps: EPDependency[];
    };
}
export interface ExecutionPlanImplOptions {
    deployment: Deployment;
    deployOpID: DeployOpID;
    goalStatus: GoalStatus;
}
export declare class ExecutionPlanImpl implements ExecutionPlan {
    readonly deployment: Deployment;
    readonly deployOpID: DeployOpID;
    readonly goalStatus: GoalStatus;
    readonly helpers: DeployHelpersFactory;
    protected graph: Graph;
    protected nextWaitId: number;
    protected _primitiveDependencies?: EPPrimitiveDependencies;
    protected waitInfoIds: WeakMap<WaitInfo, string>;
    /** Nodes that are complete or have been replaced in the graph by actions */
    protected nonGraph: Map<string, EPNode>;
    constructor(options: ExecutionPlanImplOptions);
    check(): void;
    addElem(element: AdaptMountedElement, goalStatus: GoalStatus): void;
    addAction(action: Action): EPNode | undefined;
    addWaitInfo(nodeOrWI: WaitInfo | EPNode, goalStatus: GoalStatus): EPNode;
    addSavedDependencies(saved: EPPrimitiveDependencies): void;
    /**
     * Now used only in unit test. Should eventually be removed.
     */
    updateElemWaitInfo(refresh?: boolean): void;
    addNode(node: EPNode): void;
    removeDep(obj: EPObject, dependsOn: EPNode): void;
    removeNode(node: EPNode): void;
    predecessors(n: EPNode, edgeType?: DependencyType | "all"): EPNode[];
    successors(n: EPNode, edgeType?: DependencyType | "all"): EPNode[];
    /**
     * Returns the set of nodes that `n` is acting on behalf of. For an
     * Element node, this will always be an empty array and for an Action
     * node, there should always be at least one node in the array.
     */
    actingFor(n: EPObject): EPNode[];
    setParent(n: EPObject, parent: EPObject): void;
    /** Returns nodes active in the graph */
    get nodes(): EPNode[];
    /** Returns only nodes NOT active in the graph */
    get nonGraphNodes(): EPNode[];
    /** Returns both graph and non-graph nodes */
    get allNodes(): EPNode[];
    get elems(): AdaptMountedElement[];
    get leaves(): EPNode[];
    getId: (obj: EPObject, create?: boolean) => EPNodeId;
    getNode: (idOrObj: EPNodeId | EPObject) => EPNode;
    hasNode: (idOrObj: EPNodeId | EPObject) => boolean;
    toDependencies(type: DependencyType | "all"): EPDependencies;
    print(): string;
    get primitiveDependencies(): EPPrimitiveDependencies;
    computePrimitiveDependencies(dom: FinalDomElement | null): void;
    protected getIdInternal: (obj: EPObject, create?: boolean) => EPNodeId | undefined;
    protected getNodeInternal: (idOrObj: EPNodeId | EPObject) => EPNode | undefined;
    protected getEdgeInternal: (idOrObj1: EPNodeId | EPObject, idOrObj2: EPNodeId | EPObject) => EPEdge | undefined;
    /**
     * The direction of the dependency has to be reversed for Destroy
     * so that things are destroyed in "reverse order" (actually by
     * walking the graph in the opposite order). But a single graph
     * contains some things that are being Deployed and some that are
     * being Destroyed.
     * The arguments to the function (obj, dependsOn) identify two EPNodes.
     * Each of those two EPNodes could have goalStatus Deployed or Destroyed,
     * so there are 4 possible combinations:
     *   A) Deployed, Deployed
     *      This is the simple case where `dependsOn` should be Deployed
     *      before `obj` is Deployed. The edge is `obj` -> `dependsOn`.
     *   B) Destroyed, Destroyed
     *      Also simple. If `dependsOn` must be Deployed before `obj`, then
     *      it's reversed for Destroyed and `obj` must be Destroyed before
     *      `dependsOn`. The edge is `dependsOn` -> `obj`.
     *   C) Destroyed, Deployed
     *      The valid way this can happen when used with an actual old DOM
     *      and new DOM is that `obj` is from the old DOM. The new DOM does
     *      not contain this node and therefore *cannot* have a dependency
     *      on it. The dependency here can be ignored safely. No edge.
     *   D) Deployed, Destroyed
     *      This doesn't make sense right now because there's not really a
     *      way for a "living" component in the new DOM to get a reference
     *      to something being deleted from the old DOM. This is currently
     *      an error.
     */
    protected addEdge(obj: EPObject, dependsOn: EPObject, edgeType?: DependencyType): void;
    protected addEdgeInternal(obj: EPObject, dependsOn: EPObject, edgeType: DependencyType): void;
    protected removeEdgeInternal(obj: EPObject, dependsOn: EPObject): void;
    /**
     * Retrieve predecessors or successors from the graph, optionally
     * filtered for a particular DependencyType.
     */
    protected neighbors(n: EPNode, edgeType: DependencyType | "all", which: "predecessors" | "successors"): EPNode[];
    /**
     * Given an Element node N, returns the set of primitive Element
     * nodes that are descendents of N (including N if it's a
     * primitive Element node).
     * If `prune` is true, stop recursively traversing descendents at the first
     * primitive Element node found.
     */
    protected primitiveDependencyTargets: (n: EPNode, prune: boolean) => EPNode[];
    protected printCycleGroups: (group: string[]) => string;
    /**
     * Actions always act on behalf of one or more Elements. The Action node
     * replaces the Element nodes in the graph. This means that all of the
     * Element nodes' dependencies are moved over to the Action node and the
     * Element nodes are then removed from the graph.
     */
    protected setActingFor(actionNode: EPNode, elNode: EPObject): void;
    protected isStartStartCycle(cycle: string[]): boolean;
    protected breakCycle(cycle: string[]): void;
}
export declare function isExecutionPlanImpl(val: any): val is ExecutionPlanImpl;
export declare function execute(options: ExecuteOptions): Promise<ExecuteComplete>;
export declare function executePass(opts: ExecutePassOptions): Promise<void>;
declare class DeployHelpersFactory {
    protected plan: ExecutionPlanImpl;
    elementStatus: <S extends Status = Status>(handle: Handle) => Promise<S | Status | undefined>;
    protected nodeStatus_: StatusTracker | null;
    constructor(plan: ExecutionPlanImpl, deployment: Deployment);
    get nodeStatus(): StatusTracker;
    set nodeStatus(t: StatusTracker);
    isDeployed: (d: Dependency) => boolean;
    makeDependsOn: (current: Handle) => (hands: Handle | Handle[]) => Relation;
    create: (elem: AdaptMountedElement) => DeployHelpers;
}
export {};
//# sourceMappingURL=execution_plan.d.ts.map