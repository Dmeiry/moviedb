"use strict";
/*
 * Copyright 2019-2020 Unbounded Systems, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.executePass = exports.execute = exports.isExecutionPlanImpl = exports.ExecutionPlanImpl = exports.DependencyType = exports.getWaitInfo = exports.createExecutionPlan = void 0;
const tslib_1 = require("tslib");
const utils_1 = require("@adpt/utils");
const async_lock_1 = tslib_1.__importDefault(require("async-lock"));
const debug_1 = tslib_1.__importDefault(require("debug"));
const graphlib_1 = require("graphlib");
const lodash_1 = require("lodash");
const p_queue_1 = tslib_1.__importDefault(require("p-queue"));
const p_timeout_1 = tslib_1.__importDefault(require("p-timeout"));
const util_1 = require("util");
const dom_1 = require("../dom");
const dom_utils_1 = require("../dom_utils");
const error_1 = require("../error");
const handle_1 = require("../handle");
const jsx_1 = require("../jsx");
const deploy_types_1 = require("./deploy_types");
const deploy_types_private_1 = require("./deploy_types_private");
const deployed_when_queue_1 = require("./deployed_when_queue");
const relation_utils_1 = require("./relation_utils");
const relations_1 = require("./relations");
const status_tracker_1 = require("./status_tracker");
const debugExecute = debug_1.default("adapt:deploy:execute");
const debugExecuteDetail = debug_1.default("adapt:detail:deploy:execute");
function createExecutionPlan(options) {
    const plan = new ExecutionPlanImpl(options);
    function addParents(e) {
        const kids = e.buildData.origChildren || [];
        kids.forEach((child) => jsx_1.isElement(child) && plan.setParent(child, e));
        const succ = e.buildData.successor;
        if (succ)
            plan.setParent(succ, e);
    }
    const { actions, diff, newDom } = options;
    diff.added.forEach((e) => plan.addElem(e, deploy_types_1.DeployStatus.Deployed));
    diff.commonNew.forEach((e) => plan.addElem(e, deploy_types_1.DeployStatus.Deployed));
    diff.deleted.forEach((e) => plan.addElem(e, deploy_types_1.DeployStatus.Destroyed));
    diff.added.forEach(addParents);
    diff.commonNew.forEach(addParents);
    diff.deleted.forEach(addParents);
    debugExecuteDetail(`Plan before deps`, plan.print());
    debugExecuteDetail(`Saved deps`, options.dependencies);
    plan.addSavedDependencies(options.dependencies);
    // Force memoization of primitiveDependencies. MUST happen before actions
    // are added because adding actions removes primitive Elements from the
    // graph and collapses dependencies.
    plan.computePrimitiveDependencies(newDom);
    actions.forEach((a) => plan.addAction(a));
    return plan;
}
exports.createExecutionPlan = createExecutionPlan;
function getWaitInfo(goalStatus, e, helpers) {
    const hand = handle_1.isHandle(e) ? e : e.props.handle;
    const elem = hand.mountedOrig;
    if (elem === undefined)
        throw new error_1.InternalError("element has no mountedOrig!");
    if (elem === null)
        throw new error_1.ElementNotInDom();
    if (!elem.built()) {
        return {
            deployedWhen: () => true,
            description: elem.componentName,
        };
    }
    const dependsOn = elem.dependsOn(goalStatus, helpers);
    if (dependsOn && !deploy_types_1.isDependsOn(dependsOn)) {
        throw new utils_1.UserError(`Component '${elem.componentName}' dependsOn ` +
            `method returned a value that is not a DependsOn object. ` +
            `[Element id: ${elem.id}] returned: ${util_1.inspect(dependsOn)}`);
    }
    const wi = {
        description: dependsOn ? dependsOn.description : elem.componentName,
        deployedWhen: (gs) => elem.deployedWhen(gs, helpers),
    };
    if (dependsOn)
        wi.dependsOn = dependsOn;
    return wi;
}
exports.getWaitInfo = getWaitInfo;
const elIdToNodeId = (id) => "E:" + id;
const elToNodeId = (e) => "E:" + e.id;
/**
 * Dependency types:
 *
 * - FinishStart: This is also referrred to as a "soft" FinishStart
 *   dependency. It is current the only type of dependency that users can
 *   manually specify, which is done via a `dependsOn` method or related
 *   mechanism. These dependencies are inserted into the plan graph,
 *   but are really checked/enforced by the Relations associated with the
 *   node, not solely by the graph. The reason for this is to support
 *   Relation types besides just a strict dependency, such as a
 *   Relation with a logical "OR". This enables creating a dependency like
 *   waiting for one instance of a failover group to be deployed, rather than
 *   waiting for all instances to be deployed.
 *   When executing a plan, a node that has only incomplete FinishStart
 *   (soft) dependencies remaining will get signaled to check its Relations
 *   every time one of the node's dependencies change to a finished state.
 *
 * - FinishStartHard: This dependency type is the more traditional strict
 *   dependency one might expect in a dependency graph. When N1 depends
 *   on N2 with FinishStartHard type, N1 will not start until N2 finishes.
 *   A node will never get signaled to do any work or check its Relations as long
 *   as it has any FinishStartHard dependencies remaining in the graph. This
 *   dependency type is currently only created via `plan.addSavedDependencies`,
 *   which is used for saved/reanimated DOMs. Note that a node's Relations will
 *   not necessarily have or enforce these dependencies, so the graph must do all
 *   the enforcing.
 *
 * - StartStart: When N1 depends on N2 with a StartStart type, N1 will not start
 *   until N2 has started. These dependencies are created automatically
 *   between an Element and its parent and/or predecessors in the DOM via
 *   `plan.setParent`.
 */
var DependencyType;
(function (DependencyType) {
    DependencyType["FinishStart"] = "FinishStart";
    DependencyType["FinishStartHard"] = "FinishStartHard";
    DependencyType["StartStart"] = "StartStart";
})(DependencyType = exports.DependencyType || (exports.DependencyType = {}));
class ExecutionPlanImpl {
    constructor(options) {
        this.graph = new graphlib_1.Graph({ compound: true });
        this.nextWaitId = 0;
        this.waitInfoIds = new WeakMap();
        /** Nodes that are complete or have been replaced in the graph by actions */
        this.nonGraph = new Map();
        this.getId = (obj, create = false) => {
            const id = this.getIdInternal(obj, create);
            if (!id)
                throw new Error(`ID not found (${idOrObjInfo(obj)})`);
            return id;
        };
        this.getNode = (idOrObj) => {
            const node = this.getNodeInternal(idOrObj);
            if (!node)
                throw new Error(`Node not found (${idOrObjInfo(idOrObj)})`);
            return node;
        };
        this.hasNode = (idOrObj) => {
            return this.getNodeInternal(idOrObj) != null;
        };
        /*
         * Class-internal methods
         */
        this.getIdInternal = (obj, create = false) => {
            const wiId = (w) => {
                let id = this.waitInfoIds.get(w);
                if (!id) {
                    if (!create)
                        return undefined;
                    id = "W:" + this.nextWaitId++;
                    this.waitInfoIds.set(w, id);
                }
                return id;
            };
            if (jsx_1.isMountedElement(obj))
                return elToNodeId(obj);
            if (deploy_types_private_1.isWaitInfo(obj))
                return wiId(obj);
            if (jsx_1.isMountedElement(obj.element))
                return elToNodeId(obj.element);
            if (deploy_types_private_1.isWaitInfo(obj.waitInfo))
                return wiId(obj.waitInfo);
            throw new error_1.InternalError(`Invalid object in getId (${obj})`);
        };
        this.getNodeInternal = (idOrObj) => {
            const id = typeof idOrObj === "string" ? idOrObj :
                this.getIdInternal(idOrObj);
            if (!id)
                return undefined;
            return this.graph.node(id) || this.nonGraph.get(id);
        };
        this.getEdgeInternal = (idOrObj1, idOrObj2) => {
            const n1 = this.getNodeInternal(idOrObj1);
            const n2 = this.getNodeInternal(idOrObj2);
            if (!n1 || !n2)
                return undefined;
            const id1 = this.getIdInternal(n1);
            const id2 = this.getIdInternal(n2);
            if (!id1 || !id2)
                return undefined;
            return this.graph.edge(id1, id2);
        };
        /**
         * Given an Element node N, returns the set of primitive Element
         * nodes that are descendents of N (including N if it's a
         * primitive Element node).
         * If `prune` is true, stop recursively traversing descendents at the first
         * primitive Element node found.
         */
        this.primitiveDependencyTargets = (n, prune) => {
            const prims = new Set();
            function addPrims(node) {
                const el = node.element;
                if (!el)
                    return;
                if (jsx_1.isPrimitiveElement(el)) {
                    prims.add(node);
                    if (prune)
                        return;
                }
                node.children.forEach(addPrims);
            }
            addPrims(n);
            return [...prims];
        };
        this.printCycleGroups = (group) => {
            if (group.length < 1)
                throw new error_1.InternalError(`Cycle group with no members`);
            const nodeDesc = (n, pad = 0) => {
                var _a;
                const desc = ((_a = n.element) === null || _a === void 0 ? void 0 : _a.path) || `Action: ${n.waitInfo.description}`;
                return desc.padEnd(pad);
            };
            const ids = [...group, group[0]];
            const nodes = ids.map(this.getNode);
            let padLen = nodes.map((n) => nodeDesc(n).length).reduce((max, cur) => Math.max(max, cur));
            padLen = Math.min(padLen, 65);
            // The dependency type from (i-1) to (i).
            const depType = (i) => {
                if (i === 0)
                    return "";
                const e = this.getEdgeInternal(ids[i - 1], ids[i]);
                return `[${(e === null || e === void 0 ? void 0 : e.edgeType) || "??"}]`;
            };
            const short = (n, i) => {
                const dt = depType(i);
                const idx = i === ids.length - 1 ? 0 : i;
                return `${idx.toString().padStart(2)}: ${nodeDesc(n, padLen)}  ${dt}`;
            };
            const detail = (n, i) => {
                const info = [];
                const niceId = n.element ? n.element.id : this.getId(n).slice(2);
                info.push(`${i.toString().padStart(2)}: ${nodeDesc(n)}`);
                if (n.element)
                    info.push(`    key: ${n.element.props.key}`);
                info.push(`    id: ${niceId}`);
                return info.join("\n");
            };
            let output = `Dependencies:\n  ${nodes.map(short).join("\n   -> ")}\n`;
            nodes.pop();
            output += `Details:\n${nodes.map(detail).join("\n")}`;
            return output;
        };
        this.goalStatus = options.goalStatus;
        this.deployment = options.deployment;
        this.deployOpID = options.deployOpID;
        this.helpers = new DeployHelpersFactory(this, this.deployment);
    }
    /*
     * Public interfaces
     */
    check() {
        // findCycles reports IDs in the opposite direction than we want to
        // work with.
        const allCycles = graphlib_1.alg.findCycles(this.graph).map((c) => c.reverse());
        if (allCycles.length === 0)
            return;
        const toReport = [];
        // Cycles that consist solely of StartStart dependencies can be
        // safely broken.
        for (const c of allCycles) {
            if (this.isStartStartCycle(c))
                this.breakCycle(c);
            else
                toReport.push(c);
        }
        if (toReport.length > 0) {
            const cycles = toReport.map(this.printCycleGroups).join("\n");
            if (debugExecute.enabled) {
                debugExecute(`Execution plan dependencies:\n${this.print()}`);
            }
            throw new utils_1.UserError(`There are circular dependencies present in this deployment:\n${cycles}`);
        }
    }
    /*
     * Semi-private interfaces (for use by this file)
     */
    addElem(element, goalStatus) {
        if (!element || this.hasNode(element))
            return;
        const helpers = this.helpers.create(element);
        const waitInfo = getWaitInfo(goalStatus, element, helpers);
        const children = new Set();
        const node = { children, element, goalStatus, waitInfo };
        this.addNode(node);
        this.addWaitInfo(node, goalStatus);
    }
    addAction(action) {
        if (action.type === deploy_types_1.ChangeType.none)
            return undefined;
        const node = {
            children: new Set(),
            goalStatus: changeTypeToGoalStatus(action.type),
            waitInfo: {
                description: action.detail,
                action: action.act,
                actingFor: action.changes,
                activeAction: true,
                deployedWhen: () => true,
                logAction: true,
            }
        };
        this.addNode(node);
        action.changes.forEach((c) => {
            if (c.type === deploy_types_1.ChangeType.none)
                return;
            this.addElem(c.element, changeTypeToGoalStatus(c.type));
            const elNode = this.getNode(c.element);
            elNode.waitInfo.activeAction = true;
            elNode.waitInfo.description = action.detail;
            this.setActingFor(node, c.element);
        });
        return node;
    }
    addWaitInfo(nodeOrWI, goalStatus) {
        let node;
        let waitInfo;
        if (deploy_types_private_1.isWaitInfo(nodeOrWI)) {
            node = {
                children: new Set(),
                goalStatus,
                waitInfo: nodeOrWI,
            };
            waitInfo = nodeOrWI;
            this.addNode(node);
        }
        else {
            node = nodeOrWI;
            waitInfo = node.waitInfo;
        }
        if (waitInfo.dependsOn) {
            const hands = relation_utils_1.relatedHandles(waitInfo.dependsOn);
            hands.forEach((h) => {
                if (!h.associated) {
                    // TODO: Add info about the handle, like traceback for
                    // where it was created.
                    throw new utils_1.UserError(`A Component dependsOn method returned a DependsOn ` +
                        `object '${waitInfo.description}' that contains ` +
                        `a Handle that is not associated with any Element`);
                }
                const el = toBuiltElem(h);
                if (el) {
                    // If el has already been added, its goal
                    // status won't change.
                    this.addElem(el, goalStatus);
                    this.addEdge(node, el);
                }
            });
        }
        return node;
    }
    addSavedDependencies(saved) {
        for (const [id, depList] of Object.entries(saved)) {
            const node = this.getNode(elIdToNodeId(id));
            for (const dep of depList) {
                this.addEdge(node, this.getNode(elIdToNodeId(dep)), DependencyType.FinishStartHard);
            }
        }
    }
    /**
     * Now used only in unit test. Should eventually be removed.
     */
    updateElemWaitInfo(refresh = false) {
        this.nodes.forEach((n) => {
            const el = n.element;
            if (el == null)
                return;
            if (n.waitInfo != null && !refresh)
                throw new error_1.InternalError(`Expected EPNode.waitInfo to be null`);
            const helpers = this.helpers.create(el);
            n.waitInfo = getWaitInfo(n.goalStatus, el, helpers);
            this.addWaitInfo(n, n.goalStatus);
        });
    }
    addNode(node) {
        if (this.hasNode(node))
            return;
        this.graph.setNode(this.getId(node, true), node);
    }
    removeDep(obj, dependsOn) {
        this.removeEdgeInternal(obj, dependsOn);
    }
    removeNode(node) {
        const id = this.getId(node);
        this.graph.removeNode(id);
        this.nonGraph.set(id, node);
    }
    predecessors(n, edgeType = "all") {
        return this.neighbors(n, edgeType, "predecessors");
    }
    successors(n, edgeType = "all") {
        return this.neighbors(n, edgeType, "successors");
    }
    /**
     * Returns the set of nodes that `n` is acting on behalf of. For an
     * Element node, this will always be an empty array and for an Action
     * node, there should always be at least one node in the array.
     */
    actingFor(n) {
        var _a;
        const node = this.getNode(n);
        const fols = ((_a = node.waitInfo.actingFor) === null || _a === void 0 ? void 0 : _a.map((c) => c.element)) || [];
        return fols.map(this.getNode);
    }
    setParent(n, parent) {
        n = this.getNode(n);
        parent = this.getNode(parent);
        parent.children.add(n);
        this.addEdge(n, parent, DependencyType.StartStart);
    }
    /** Returns nodes active in the graph */
    get nodes() {
        return this.graph.nodes().map(this.getNode);
    }
    /** Returns only nodes NOT active in the graph */
    get nonGraphNodes() {
        return [...this.nonGraph.values()];
    }
    /** Returns both graph and non-graph nodes */
    get allNodes() {
        return [...this.nodes, ...this.nonGraph.values()];
    }
    get elems() {
        return this.nodes
            .map((n) => n.element)
            .filter(utils_1.notNull);
    }
    get leaves() {
        return this.graph.sinks().map(this.getNode);
    }
    toDependencies(type) {
        const detail = (n) => {
            const w = n.waitInfo;
            if (w)
                return w.description;
            else if (n.element)
                return n.element.id;
            return "unknown";
        };
        const getDeps = (node, id) => {
            const succs = this.neighbors(node, type, "successors");
            const deps = succs.map((n) => {
                const nId = this.getId(n);
                const edge = this.getEdgeInternal(id, nId);
                if (!edge)
                    throw new error_1.InternalError(`Consistency check failed: successor without edge ${id}->${nId}`);
                return {
                    id: nId,
                    type: edge.edgeType,
                };
            });
            const entry = { detail: detail(node), deps };
            if (node.element)
                entry.elementId = node.element.id;
            return entry;
        };
        const ret = {};
        const ids = graphlib_1.alg.isAcyclic(this.graph) ?
            graphlib_1.alg.topsort(this.graph) : this.graph.nodes();
        // Insert starting with leaves for a more human-readable ordering
        for (let i = ids.length - 1; i >= 0; i--) {
            const id = ids[i];
            const node = this.getNode(id);
            ret[id] = getDeps(node, id);
        }
        return ret;
    }
    print() {
        const epDeps = this.toDependencies("all");
        const depIDs = Object.keys(epDeps);
        if (depIDs.length === 0)
            return "<empty>";
        const succs = (id) => {
            const list = epDeps[id] && epDeps[id].deps;
            if (!list || list.length === 0)
                return "    <none>";
            return list.map((s) => `    ${name(s.id)} [${s.type}]`).join("\n");
        };
        const name = (id) => {
            const w = this.getNode(id).waitInfo;
            if (w)
                id += ` (${w.description})`;
            return id;
        };
        const printDeps = (ids) => ids
            .map((id) => `  ${name(id)}\n${succs(id)}`);
        const byGoal = {};
        const insert = (id, goal) => {
            const l = byGoal[goal] || [];
            l.push(id);
            byGoal[goal] = l;
        };
        for (const id of depIDs) {
            insert(id, this.getNode(id).goalStatus);
        }
        const lines = [];
        for (const goal of Object.keys(byGoal).sort()) {
            let gName = goal;
            try {
                gName = deploy_types_1.goalToInProgress(goal);
            }
            catch (e) { /* */ }
            lines.push(`${gName}:`, ...printDeps(byGoal[goal]));
        }
        return lines.join("\n");
    }
    get primitiveDependencies() {
        if (this._primitiveDependencies)
            return this._primitiveDependencies;
        throw new error_1.InternalError(`Must call computePrimitiveDependencies before accessing primitiveDependencies`);
    }
    computePrimitiveDependencies(dom) {
        const domEls = new Set();
        dom_utils_1.domForEach(dom, (el) => domEls.add(el));
        const isInDom = (n) => n.element && domEls.has(n.element);
        const work = new Map();
        const workFrom = (fromId) => {
            const exists = work.get(fromId);
            if (exists)
                return exists;
            const f = new Set();
            work.set(fromId, f);
            return f;
        };
        const addDep = (from, to) => {
            if (!from.element)
                throw new error_1.InternalError(`Node '${this.getId(from)}' has no element `);
            const fromId = from.element.id;
            if (!to.element)
                throw new error_1.InternalError(`Node '${this.getId(to)}' has no element `);
            const toId = to.element.id;
            workFrom(fromId).add(toId);
        };
        const ids = graphlib_1.alg.isAcyclic(this.graph) ?
            graphlib_1.alg.topsort(this.graph) : this.graph.nodes();
        // Insert starting with leaves for a more human-readable ordering
        for (let i = ids.length - 1; i >= 0; i--) {
            const id = ids[i];
            const node = this.getNode(id);
            // Because the start of a node is gated by automatic StartStart
            // dependencies between parents and their children, we only need the
            // pruned dependencies for the "from" set of nodes (prune=true).
            const fromPrims = this.primitiveDependencyTargets(node, true)
                .filter(isInDom);
            const succs = this.neighbors(node, DependencyType.FinishStart, "successors")
                .concat(this.neighbors(node, DependencyType.FinishStartHard, "successors"));
            // The finish of a node doesn't necessarily include its children
            // because nodes can have custom deployedWhen functions. So ensure
            // we get the complete (non-pruned) set of nodes for the "to"
            // nodes (prune=false).
            const toPrims = lodash_1.flatten(succs.map((s) => this.primitiveDependencyTargets(s, false)))
                .filter(isInDom);
            for (const from of fromPrims) {
                for (const to of toPrims) {
                    addDep(from, to);
                }
            }
        }
        const finalDeps = {};
        for (const [from, toSet] of work.entries()) {
            finalDeps[from] = [...toSet];
        }
        this._primitiveDependencies = finalDeps;
    }
    /**
     * The direction of the dependency has to be reversed for Destroy
     * so that things are destroyed in "reverse order" (actually by
     * walking the graph in the opposite order). But a single graph
     * contains some things that are being Deployed and some that are
     * being Destroyed.
     * The arguments to the function (obj, dependsOn) identify two EPNodes.
     * Each of those two EPNodes could have goalStatus Deployed or Destroyed,
     * so there are 4 possible combinations:
     *   A) Deployed, Deployed
     *      This is the simple case where `dependsOn` should be Deployed
     *      before `obj` is Deployed. The edge is `obj` -> `dependsOn`.
     *   B) Destroyed, Destroyed
     *      Also simple. If `dependsOn` must be Deployed before `obj`, then
     *      it's reversed for Destroyed and `obj` must be Destroyed before
     *      `dependsOn`. The edge is `dependsOn` -> `obj`.
     *   C) Destroyed, Deployed
     *      The valid way this can happen when used with an actual old DOM
     *      and new DOM is that `obj` is from the old DOM. The new DOM does
     *      not contain this node and therefore *cannot* have a dependency
     *      on it. The dependency here can be ignored safely. No edge.
     *   D) Deployed, Destroyed
     *      This doesn't make sense right now because there's not really a
     *      way for a "living" component in the new DOM to get a reference
     *      to something being deleted from the old DOM. This is currently
     *      an error.
     */
    addEdge(obj, dependsOn, edgeType = DependencyType.FinishStart) {
        obj = this.getNode(obj);
        dependsOn = this.getNode(dependsOn);
        let a;
        let b;
        if (edgeType === DependencyType.StartStart) {
            a = obj;
            b = dependsOn;
        }
        else {
            const goals = `${obj.goalStatus},${dependsOn.goalStatus}`;
            switch (goals) {
                case "Deployed,Deployed":
                    a = obj;
                    b = dependsOn;
                    break;
                case "Destroyed,Destroyed":
                    a = dependsOn;
                    b = obj;
                    break;
                case "Destroyed,Deployed": return; // Intentionally no edge
                case "Deployed,Destroyed":
                default:
                    throw new error_1.InternalError(`Unable to create dependency for ` +
                        `invalid goal pair '${goals}'`);
            }
        }
        this.addEdgeInternal(a, b, edgeType);
    }
    addEdgeInternal(obj, dependsOn, edgeType) {
        const e = { edgeType };
        const objId = this.getId(obj);
        const depId = this.getId(dependsOn);
        const existing = this.graph.edge(objId, depId);
        if (existing) {
            const pair = `${existing.edgeType},${edgeType}`;
            switch (pair) {
                case "FinishStart,FinishStart":
                case "FinishStartHard,FinishStartHard":
                case "StartStart,StartStart":
                    return; // No change requested
                case "FinishStart,FinishStartHard":
                    break; // Allowed to upgrade to more restrictive type
                case "FinishStartHard,FinishStart":
                    return; // Leave it at the more restrictive type
                case "FinishStart,StartStart":
                case "FinishStartHard,StartStart":
                case "StartStart,FinishStart":
                case "StartStart,FinishStartHard":
                    throw new Error(`Attempt to add multiple dependencies between the same Elements. ` +
                        `DependencyTypes=${pair} ${objId}->${depId}`);
                default:
                    throw new error_1.InternalError(`Unhandled dependency types: ${pair}`);
            }
        }
        this.graph.setEdge(objId, depId, e);
    }
    removeEdgeInternal(obj, dependsOn) {
        const objId = this.getId(obj);
        this.graph.removeEdge(objId, this.getId(dependsOn));
    }
    /**
     * Retrieve predecessors or successors from the graph, optionally
     * filtered for a particular DependencyType.
     */
    neighbors(n, edgeType, which) {
        const nId = this.getId(n);
        // Nodes that have been pulled out of the graph have no neighbors
        if (this.nonGraph.has(nId))
            return [];
        let nbors = this.graph[which](nId);
        if (nbors == null)
            throw new error_1.InternalError(`Requested node that's not in graph id=${nId}`);
        if (edgeType !== "all") {
            const getEdge = (nborId) => {
                const from = which === "predecessors" ? nborId : nId;
                const to = which === "predecessors" ? nId : nborId;
                const e = this.graph.edge(from, to);
                if (!e)
                    throw new error_1.InternalError(`No edge '${from}' -> '${to}' but in ${which}`);
                return e;
            };
            nbors = nbors.filter((nbor) => getEdge(nbor).edgeType === edgeType);
        }
        return nbors.map(this.getNode);
    }
    /**
     * Actions always act on behalf of one or more Elements. The Action node
     * replaces the Element nodes in the graph. This means that all of the
     * Element nodes' dependencies are moved over to the Action node and the
     * Element nodes are then removed from the graph.
     */
    setActingFor(actionNode, elNode) {
        elNode = this.getNode(elNode);
        this.successors(elNode).forEach((succ) => {
            const e = this.getEdgeInternal(elNode, succ);
            if (!e) {
                throw new error_1.InternalError(`Internal consistency check failed. ` +
                    `node has a successor, but no edge`);
            }
            this.removeEdgeInternal(elNode, succ);
            // Don't create a circular dependency to the actionNode. This can
            // happen when a single Action serves multiple Elements that have
            // dependencies between each other. Simply ignore those.
            if (actionNode === succ)
                return;
            this.addEdgeInternal(actionNode, succ, e.edgeType);
        });
        this.predecessors(elNode).forEach((pred) => {
            const e = this.getEdgeInternal(pred, elNode);
            if (!e) {
                throw new error_1.InternalError(`Internal consistency check failed. ` +
                    `node has a predecessor, but no edge`);
            }
            this.removeEdgeInternal(pred, elNode);
            // Don't create a circular dependency to the actionNode. This can
            // happen when a single Action serves multiple Elements that have
            // dependencies between each other. Simply ignore those.
            if (actionNode === pred)
                return;
            this.addEdgeInternal(pred, actionNode, e.edgeType);
        });
        this.removeNode(elNode);
    }
    isStartStartCycle(cycle) {
        for (let i = 0; i < cycle.length; ++i) {
            const e = this.getEdgeInternal(cycle[i], cycle[(i + 1) % cycle.length]);
            if ((e === null || e === void 0 ? void 0 : e.edgeType) !== DependencyType.StartStart)
                return false;
        }
        return true;
    }
    breakCycle(cycle) {
        debugExecuteDetail(`Breaking StartStart Cycle by removing ${cycle[0]} -> ${cycle[1]}`);
        this.removeEdgeInternal(this.getNode(cycle[0]), this.getNode(cycle[1]));
    }
}
exports.ExecutionPlanImpl = ExecutionPlanImpl;
function isExecutionPlanImpl(val) {
    return lodash_1.isObject(val) && val instanceof ExecutionPlanImpl;
}
exports.isExecutionPlanImpl = isExecutionPlanImpl;
function debugExecId(id, ...args) {
    debugExecute(`* ${id.padEnd(26)}`, ...args);
}
function debugExecDetailId(id, ...args) {
    debugExecuteDetail(`* ${id.padEnd(26)}`, ...args);
}
const defaultExecuteOptions = {
    concurrency: Infinity,
    ignoreDeleteErrors: false,
    dryRun: false,
    pollDelayMs: 1000,
    timeoutMs: 0,
};
async function execute(options) {
    const opts = Object.assign(Object.assign({}, defaultExecuteOptions), options);
    const plan = opts.plan;
    const timeoutTime = opts.timeoutMs ? Date.now() + opts.timeoutMs : 0;
    if (!isExecutionPlanImpl(plan))
        throw new error_1.InternalError(`plan is not an ExecutionPlanImpl`);
    const deployOpID = plan.deployOpID;
    const nodeStatus = await status_tracker_1.createStatusTracker({
        deployment: plan.deployment,
        deployOpID,
        dryRun: opts.dryRun,
        goalStatus: plan.goalStatus,
        nodes: plan.allNodes,
        taskObserver: opts.taskObserver,
    });
    plan.helpers.nodeStatus = nodeStatus;
    try {
        while (true) {
            const stepNum = nodeStatus.stepID ? nodeStatus.stepID.deployStepNum : "DR";
            const stepStr = `${deployOpID}.${stepNum}`;
            debugExecute(`\n\n-----------------------------\n\n` +
                `**** Starting execution step ${stepStr}`);
            debugExecute(`\nExecution plan:\n${plan.print()}`);
            await executePass(Object.assign(Object.assign({}, opts), { nodeStatus, timeoutTime }));
            const { stateChanged } = await opts.processStateUpdates();
            const ret = await nodeStatus.complete(stateChanged);
            debugExecute(`**** execution step ${stepStr} status: ${ret.deploymentStatus}\nSummary:`, util_1.inspect(ret), "\n", nodeStatus.debug(plan.getId), "\n-----------------------------\n\n");
            // Keep polling until we're done or the state changes, which means
            // we should do a re-build.
            if (ret.deploymentStatus === deploy_types_1.DeployOpStatus.StateChanged ||
                deploy_types_1.isFinalStatus(ret.deploymentStatus)) {
                debugExecute(`**** Execution completed`);
                return ret;
            }
            await utils_1.sleep(opts.pollDelayMs);
        }
    }
    catch (err) {
        err = utils_1.ensureError(err);
        opts.logger.error(`Deploy operation failed: ${err.message}`);
        let stateChanged = false;
        try {
            const upd = await opts.processStateUpdates();
            if (upd.stateChanged)
                stateChanged = true;
        }
        catch (err2) {
            err2 = utils_1.ensureError(err2);
            opts.logger.error(`Error processing state updates during error handling: ${err2.message}`);
        }
        debugExecute(`**** Execution failed:`, util_1.inspect(err));
        if (err.name === "TimeoutError") {
            await Promise.all(plan.allNodes
                .filter((n) => !nodeIsFinal(n, nodeStatus))
                .map((n) => nodeStatus.set(n, deploy_types_1.DeployStatus.Failed, err)));
            return nodeStatus.complete(stateChanged);
        }
        else {
            throw err;
        }
    }
}
exports.execute = execute;
async function executePass(opts) {
    const { dryRun, logger, nodeStatus, plan } = opts;
    if (!isExecutionPlanImpl(plan))
        throw new error_1.InternalError(`plan is not an ExecutionPlanImpl`);
    const locks = new async_lock_1.default();
    const queue = new p_queue_1.default({ concurrency: opts.concurrency });
    let stopExecuting = false;
    const dwQueue = new deployed_when_queue_1.DeployedWhenQueue(debugExecDetailId);
    const fatalErrors = [];
    // If an action is on behalf of some Elements, those nodes take on
    // the status of the action in certain cases.
    const signalActingFor = async (node, stat, err) => {
        const w = node.waitInfo;
        if (!w || !w.actingFor)
            return;
        if (shouldNotifyActingFor(stat)) {
            await Promise.all(w.actingFor.map(async (c) => {
                const n = plan.getNode(c.element);
                if (!nodeStatus.isActive(n))
                    return;
                const s = err ? err :
                    stat === deploy_types_1.DeployStatusExt.Deploying ? deploy_types_1.DeployStatusExt.ProxyDeploying :
                        stat === deploy_types_1.DeployStatusExt.Destroying ? deploy_types_1.DeployStatusExt.ProxyDestroying :
                            stat;
                await updateStatus(n, s, c.detail);
            }));
        }
        // Queue the actingFor Elements for successful final states so they
        // can run their deployedWhen and possibly also transition to a
        // final state.
        if (shouldQueueActingFor(stat)) {
            w.actingFor
                .map((c) => plan.getNode(c.element))
                .forEach(queueRun);
        }
    };
    const signalPreds = (n, stat) => {
        let toSignal;
        if (deploy_types_1.isFinalStatus(stat)) {
            // Signal predecessors that depend on our Finish
            toSignal = plan.predecessors(n, DependencyType.FinishStart)
                .concat(plan.predecessors(n, DependencyType.FinishStartHard));
        }
        else if (deploy_types_1.isInProgress(stat) || deploy_types_1.isProxying(stat)) {
            // Signal predecessors that depend on our Start
            toSignal = plan.predecessors(n, DependencyType.StartStart);
        }
        else {
            return;
        }
        // Each toSignal dependency has been satisfied. In successful cases,
        // remove all the dependencies onto `n`.
        // In the error case, leave dependencies in place so the
        // predecessors can use those relationships to realize they depend
        // on an errored node and signal their predecessors.
        if (stat !== deploy_types_1.DeployStatus.Failed) {
            toSignal.forEach((pred) => plan.removeDep(pred, n));
        }
        toSignal.forEach(queueRun);
    };
    const fatalError = (err) => {
        stopExecuting = true;
        fatalErrors.push(utils_1.ensureError(err));
    };
    const queueRun = (n) => queue.add(() => run(n)).catch(fatalError);
    const run = async (n) => {
        const id = plan.getId(n);
        await locks.acquire(id, () => runLocked(n, id));
    };
    const runLocked = async (n, id) => {
        let errorLogged = false;
        try {
            if (stopExecuting)
                return debugExecId(id, `TIMED OUT: Can't start task`);
            const stat = nodeStatus.get(n);
            if (deploy_types_1.isFinalStatus(stat))
                return debugExecId(id, `Already complete`);
            if (!(isWaiting(stat) || deploy_types_1.isInProgress(stat))) {
                throw new error_1.InternalError(`Unexpected node status ${stat}: ${id}`);
            }
            if (!dependenciesMet(n, id))
                return;
            debugExecId(id, `  Dependencies met`);
            const w = n.waitInfo;
            if (w) {
                let errorIgnored = false;
                if (!(deploy_types_1.isInProgress(stat) || deploy_types_1.isProxying(stat))) {
                    await updateStatus(n, deploy_types_1.goalToInProgress(n.goalStatus)); // now in progress
                    if (w.action) {
                        debugExecId(id, `ACTION: Doing ${w.description}`);
                        if (w.logAction)
                            logger.info(`Doing ${w.description}`);
                        try {
                            if (!dryRun)
                                await w.action();
                        }
                        catch (err) {
                            if (n.goalStatus === deploy_types_1.GoalStatus.Destroyed && opts.ignoreDeleteErrors) {
                                errorIgnored = true;
                                logger.warning(`--Error (ignored) while ${w.description}\n${err}\n----------`);
                            }
                            else {
                                logger.error(`--Error while ${w.description}\n${err}\n----------`);
                                errorLogged = true;
                                throw err;
                            }
                        }
                    }
                }
                if (!errorIgnored) {
                    const wStat = await w.deployedWhen(n.goalStatus);
                    if (wStat !== true) {
                        const statStr = relation_utils_1.waitStatusToString(wStat);
                        debugExecId(id, `NOT COMPLETE: ${w.description}: ${statStr}`);
                        nodeStatus.output(n, statStr);
                        dwQueue.enqueue(n, id, wStat);
                        return;
                    }
                }
                debugExecId(id, `COMPLETE${errorIgnored ? "(error ignored)" : ""}: ${w.description}`);
            }
            else {
                debugExecId(id, `  No wait info`);
                // Go through normal state transition to
                // trigger correct downstream events to TaskObservers.
                await updateStatus(n, deploy_types_1.goalToInProgress(n.goalStatus));
            }
            await updateStatus(n, n.goalStatus);
            plan.removeNode(n);
        }
        catch (err) {
            err = utils_1.ensureError(err);
            debugExecId(id, `FAILED: ${err}`);
            await updateStatus(n, err);
            if (!errorLogged) {
                logger.error(`Error while ${deploy_types_1.goalToInProgress(n.goalStatus).toLowerCase()} ` +
                    `${nodeDescription(n)}: ${utils_1.formatUserError(err)}`);
            }
            if (err.name === "InternalError")
                throw err;
        }
    };
    const updateStatus = async (n, stat, description) => {
        if (stopExecuting)
            return false;
        const { err, deployStatus } = lodash_1.isError(stat) ?
            { err: stat, deployStatus: deploy_types_1.DeployStatus.Failed } :
            { err: undefined, deployStatus: stat };
        debugExecId(plan.getId(n), `STATUS: ${deployStatus}${err ? ": " + err : ""}`);
        const changed = await nodeStatus.set(n, deployStatus, err, description);
        if (changed) {
            await signalActingFor(n, deployStatus, err);
            signalPreds(n, deployStatus);
            if (deploy_types_1.isFinalStatus(deployStatus) && n.element) {
                dwQueue.completed(n.element, queueRun);
            }
        }
        return changed;
    };
    const mkIdStr = (ids) => ids.join(" > ");
    const softDepsReady = (n, ids) => {
        // If this node is being Deployed, just look at its own WaitInfo
        if (n.goalStatus === deploy_types_1.DeployStatus.Deployed) {
            return waitIsReady(n, false, ids);
        }
        // But if the node is being Destroyed, we instead evaluate all of our
        // successors' WaitInfos, each in the inverse direction.
        const succs = plan.successors(n, DependencyType.FinishStart)
            .concat(plan.successors(n, DependencyType.FinishStartHard));
        debugExecDetailId(mkIdStr(ids), `  Evaluating: ${succs.length} successors`);
        for (const s of succs) {
            // TODO: There probably needs to be a check here comparing
            // goalStatus for s and n, similar to addEdge.
            const sId = plan.getId(s);
            if (!waitIsReady(s, true, [...ids, sId]))
                return false;
            // Evaluate successor's actingFor the same way
            const actingFor = plan.actingFor(s);
            for (const a of actingFor) {
                const aId = plan.getId(a);
                if (!waitIsReady(a, true, [...ids, sId, aId]))
                    return false;
            }
        }
        return true;
    };
    const waitIsReady = (n, invert, ids) => {
        const w = n.waitInfo;
        let dep = w && w.dependsOn;
        if (invert && dep)
            dep = relation_utils_1.relationInverse(dep);
        if (debugExecute.enabled) {
            const idStr = mkIdStr(ids);
            const desc = !w ? "no soft dep" :
                dep ? `soft dep (${w.description}) - Relation${invert ? " (inverted)" : ""}: ${relation_utils_1.relationToString(dep)}` :
                    `no soft dep (${w.description})`;
            debugExecDetailId(idStr, `  Evaluating: ${desc}`);
            if (!dep)
                return true;
            const relStatus = relation_utils_1.relationIsReadyStatus(dep);
            debugExecId(idStr, `  Relation status:`, relStatus === true ? "READY" : relStatus);
            return relStatus === true;
        }
        return dep ? relation_utils_1.relationIsReady(dep) : true;
    };
    const dependenciesMet = (n, id) => {
        const hardDeps = plan.successors(n, DependencyType.FinishStartHard);
        // Check for errors in our dependencies first. Throws on errored dep.
        hardDeps.forEach((d) => nodeIsDeployed(d, id, nodeStatus));
        if (hardDeps.length > 0) {
            debugExecId(id, `Dependencies not met: ${hardDeps.length} FinishStartHard dependencies remaining`);
            return false;
        }
        if (!softDepsReady(n, [id])) {
            debugExecId(id, `Dependencies not met: FinishStart (soft) dependencies remaining`);
            return false;
        }
        const actingFor = plan.actingFor(n);
        debugExecDetailId(id, `  Evaluating: ${actingFor.length} actingFor elements`);
        for (const a of actingFor) {
            const aStat = nodeStatus.get(a);
            const aId = plan.getId(a);
            if (!isWaiting(aStat)) {
                throw new error_1.InternalError(`Invalid status ${aStat} for actingFor element ${aId}`);
            }
            if (!softDepsReady(a, [id, aId])) {
                debugExecId(id, `Dependencies not met: actingFor elements have incomplete dependencies`);
                return false;
            }
        }
        return true;
    };
    /*
     * Main execute code path
     */
    try {
        // Queue any non-graph nodes that are already in progress so they
        // can check their completions.
        plan.nonGraphNodes.filter((n) => nodeIsActive(n, nodeStatus)).forEach(queueRun);
        // Queue the leaf nodes that have no dependencies
        plan.leaves.forEach(queueRun);
        // Then wait for all promises to resolve
        let pIdle = queue.onIdle();
        if (opts.timeoutMs && opts.timeoutTime) {
            const msg = `Deploy operation timed out after ${opts.timeoutMs / 1000} seconds`;
            const timeLeft = opts.timeoutTime - Date.now();
            if (timeLeft <= 0)
                throw new p_timeout_1.default.TimeoutError(msg);
            pIdle = p_timeout_1.default(pIdle, timeLeft, msg);
        }
        await pIdle;
    }
    catch (err) {
        fatalError(err);
    }
    if (fatalErrors.length > 1)
        throw new utils_1.MultiError(fatalErrors);
    else if (fatalErrors.length === 1)
        throw fatalErrors[0];
}
exports.executePass = executePass;
function shouldNotifyActingFor(status) {
    switch (status) {
        case deploy_types_1.DeployStatus.Deploying:
        case deploy_types_1.DeployStatus.Destroying:
        //case DeployStatus.Retrying:
        case deploy_types_1.DeployStatus.Failed:
            return true;
        default:
            return false;
    }
}
function shouldQueueActingFor(status) {
    switch (status) {
        case deploy_types_1.DeployStatus.Deployed:
        case deploy_types_1.DeployStatus.Destroyed:
            return true;
        default:
            return false;
    }
}
function isWaiting(stat) {
    return (stat === deploy_types_1.DeployStatusExt.Waiting ||
        stat === deploy_types_1.DeployStatusExt.ProxyDeploying ||
        stat === deploy_types_1.DeployStatusExt.ProxyDestroying);
}
function changeTypeToGoalStatus(ct) {
    switch (ct) {
        case deploy_types_1.ChangeType.none:
        case deploy_types_1.ChangeType.create:
        case deploy_types_1.ChangeType.modify:
        case deploy_types_1.ChangeType.replace:
            return deploy_types_1.DeployStatus.Deployed;
        case deploy_types_1.ChangeType.delete:
            return deploy_types_1.DeployStatus.Destroyed;
        default:
            throw new error_1.InternalError(`Bad ChangeType '${ct}'`);
    }
}
function toBuiltElemOrWaitInfo(val) {
    return deploy_types_private_1.isWaitInfo(val) ? val : toBuiltElem(val);
}
function toBuiltElem(val) {
    if (jsx_1.isMountedElement(val)) {
        if (val.built())
            return val;
        val = val.props.handle;
    }
    if (!handle_1.isHandle(val)) {
        throw new Error(`Attempt to convert an invalid object to Element or WaitInfo: ${util_1.inspect(val)}`);
    }
    const elem = val.nextMounted((el) => jsx_1.isMountedElement(el) && el.built());
    if (elem === undefined)
        throw new error_1.InternalError("Handle has no built Element!");
    return elem;
}
function nodeIsDeployed(n, id, tracker) {
    const sStat = tracker.get(n);
    if (sStat === n.goalStatus)
        return true; // Dependency met
    if (sStat === deploy_types_1.DeployStatusExt.Failed) {
        throw new utils_1.UserError(`A dependency failed to deploy successfully`);
    }
    if (isWaiting(sStat) || deploy_types_1.isInProgress(sStat))
        return false;
    throw new error_1.InternalError(`Invalid status ${sStat} for ${id}`);
}
function nodeDescription(n) {
    if (n.waitInfo)
        return n.waitInfo.description;
    if (n.element)
        return `${n.element.componentName} (id=${n.element.id})`;
    return "Unknown node";
}
function nodeIsActive(n, tracker) {
    const sStat = tracker.get(n);
    return deploy_types_1.isInProgress(sStat) || deploy_types_1.isProxying(sStat);
}
function nodeIsFinal(n, tracker) {
    const sStat = tracker.get(n);
    return deploy_types_1.isFinalStatus(sStat);
}
function idOrObjInfo(idOrObj) {
    return typeof idOrObj === "string" ? idOrObj :
        deploy_types_private_1.isWaitInfo(idOrObj) ? idOrObj.description :
            jsx_1.isMountedElement(idOrObj) ? idOrObj.id :
                idOrObj.element ? idOrObj.element.id :
                    idOrObj.waitInfo ? idOrObj.waitInfo.description :
                        "unknown";
}
class DeployHelpersFactory {
    constructor(plan, deployment) {
        this.plan = plan;
        this.nodeStatus_ = null;
        this.isDeployed = (d) => {
            if (deploy_types_1.isRelation(d))
                return relation_utils_1.relationIsReady(d);
            const elOrWait = toBuiltElemOrWaitInfo(d);
            if (elOrWait === null)
                return true; // Handle built to null - null is deployed
            const n = this.plan.getNode(elOrWait);
            return nodeIsDeployed(n, this.plan.getId(n), this.nodeStatus);
        };
        this.makeDependsOn = (current) => (hands) => {
            const toEdge = (h) => relations_1.Edge(current, h, this.isDeployed);
            return relations_1.And(...utils_1.toArray(hands).map(toEdge));
        };
        this.create = (elem) => ({
            elementStatus: this.elementStatus,
            isDeployed: this.isDeployed,
            dependsOn: this.makeDependsOn(elem.props.handle),
        });
        this.elementStatus = dom_1.makeElementStatus();
    }
    get nodeStatus() {
        if (this.nodeStatus_ == null) {
            throw new Error(`Cannot get nodeStatus except during plan execution`);
        }
        return this.nodeStatus_;
    }
    set nodeStatus(t) {
        this.nodeStatus_ = t;
    }
}
//# sourceMappingURL=execution_plan.js.map