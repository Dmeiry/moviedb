import Adapt, { BuiltinProps } from "@adpt/core";
import { DockerBuildOptions, NameTagString } from "../docker";
import { Environment } from "../env";
/**
 * Props for {@link nodejs.LocalNodeImage}
 *
 * @public
 */
export interface LocalNodeImageProps extends Partial<BuiltinProps> {
    /** Source directory for the Node.js program */
    srcDir: string;
    /** Build options */
    options?: NodeImageBuildOptions;
}
/**
 * Locally builds a docker image for a {@link https://www.nodejs.org | Node.js} program.
 *
 * @remarks
 * Implements {@link docker.DockerImageInstance}.
 *
 * See {@link nodejs.LocalNodeImageProps}.
 *
 * @public
 */
export declare function LocalNodeImage(props: LocalNodeImageProps): Adapt.JSX.Element | null;
/**
 * Options controlling how the Docker image is built in
 * {@link nodejs.LocalNodeImage}.
 * @public
 */
export interface NodeImageBuildOptions extends DockerBuildOptions {
    /**
     * Base Docker image used to build {@link nodejs.LocalNodeImage}.
     *
     * @defaultValue "node:14-stretch-slim"
     */
    baseImage?: NameTagString;
    /**
     * Environment variables that should be present during docker build
     *
     * @remarks
     * This adds an `ARG <varName>` line to the Dockerfile for every variable in env, and sets the
     * variable in the environment before running `docker build`.
     */
    buildArgs?: Environment;
    /**
     * Default command to run in container
     *
     * @remarks
     *
     * If this is a string, the Dockerfile used to build the image will use
     * shell form for the command, i.e., `CMD <cmd value>`.  If this
     * is an array of string, exec form will be used instead, i.e.,
     * `CMD ["cmd[0]", "cmd[1]", "cmd[2]", ...]`.
     *
     * If `cmd` is not specified, the default command of `node` with
     * the value of `main` from the top-level package.json will be used.
     */
    cmd?: string | string[];
    /**
     * Node version used to build {@link nodejs.LocalNodeImage}.
     *
     * @defaultValue 14
     *
     * @remarks
     * If baseImage is specified, this option is ignored and baseImage
     * is used instead.  Otherwise, `node:${nodeVersion}-stretch-slim` is
     * used as the baseImage.
     */
    nodeVersion?: number | string;
    /**
     * Build an image that allows for better layer caching of node_modules
     *
     * Copies all `package.json`, `yarn.lock`, `package-log.json`, and `npm-shrinkwrap.json`
     * files, then installs node_modules, then copies all the source files, and
     * reruns install.  This allows the first install of node_modules to be its
     * own cacheable layer that does not need to be rebuilt when the source code
     * changes, only when one of the aforementioned files changes.
     *
     * There are certain caveats to using this option.  First, if `baseImage` or
     * nodeVersion runs npm version 7 or later (nodeVersion \>= 15), or you are
     * using yarn, any lifecycle scripts you have cannot fail if the full source
     * directory is not present.  Neither yarn nor npm have a way to
     * install node_modules, run the lifecycle scripts for dependencies, but
     * skip these scripts for the main package.  As a result, the preinstall
     * run will run the lifecycle scripts without the full source present.
     * It appears that npm versions prior to 7 don't run the lifecycle scripts
     * for the main package, so this should not be an issue.  Caveat emptor.
     *
     * @defaultValue false
     */
    optimizedImage?: boolean;
    /**
     * Package manager to use in build steps in the generated Dockerfile
     * that builds {@link nodejs.LocalNodeImage}.
     *
     * @defaultValue "npm"
     */
    packageManager?: "npm" | "yarn" | string;
    /**
     * Scripts that are defined in your
     * {@link https://docs.npmjs.com/files/package.json | package.json file}
     * that should be run during the image build.
     */
    runNpmScripts?: string | string[];
}
//# sourceMappingURL=LocalNodeImage.d.ts.map