"use strict";
/*
 * Copyright 2019-2021 Unbounded Systems, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.LocalNodeImage = void 0;
const tslib_1 = require("tslib");
const core_1 = tslib_1.__importStar(require("@adpt/core"));
const dockerignore_1 = tslib_1.__importDefault(require("@balena/dockerignore"));
const fs_extra_1 = tslib_1.__importDefault(require("fs-extra"));
const glob_promise_1 = tslib_1.__importDefault(require("glob-promise"));
const lodash_1 = tslib_1.__importStar(require("lodash"));
const path_1 = tslib_1.__importDefault(require("path"));
const docker_1 = require("../docker");
const env_1 = require("../env");
function argLines(env) {
    const pairs = env_1.mergeEnvPairs(env);
    if (!pairs)
        return "";
    const lines = pairs.map((v) => `ARG ${v.name}`);
    return lines.join("\n");
}
async function collectPackageManagerFiles(dir) {
    var _a;
    if (!await fs_extra_1.default.pathExists(dir))
        return [];
    const pkgJsonPath = path_1.default.join(dir, "package.json");
    if (!await fs_extra_1.default.pathExists(pkgJsonPath))
        return [];
    const ret = ["package.json"];
    if (await fs_extra_1.default.pathExists(path_1.default.join(dir, "yarn.lock")))
        ret.push("yarn.lock");
    if (await fs_extra_1.default.pathExists(path_1.default.join(dir, "package-lock.json")))
        ret.push("package-lock.json");
    if (await fs_extra_1.default.pathExists(path_1.default.join(dir, "npm-shrinkwrap.json")))
        ret.push("npm-shrinkwrap.json");
    const pkgInfo = await fs_extra_1.default.readJson(pkgJsonPath);
    const workspacesGlobs = (_a = pkgInfo === null || pkgInfo === void 0 ? void 0 : pkgInfo.workspaces) !== null && _a !== void 0 ? _a : [];
    if (!Array.isArray(workspacesGlobs))
        return ret;
    const workspaces = lodash_1.default.uniq(lodash_1.default.flatten(await Promise.all(workspacesGlobs
        .map((w) => lodash_1.isString(w) ? glob_promise_1.default(w, { cwd: dir }) : []))));
    const workspaceFileCollections = await Promise.all(workspaces.map(async (w) => 
    // Note that the join below explicitly uses "/"" since the OS path sep may not be valid in Dockerfile
    (await collectPackageManagerFiles(path_1.default.join(dir, w))).map((f) => [w, f].join("/"))));
    const workspaceFiles = lodash_1.default.uniq(lodash_1.default.flatten(workspaceFileCollections)).sort();
    ret.push(...workspaceFiles);
    return ret;
}
async function filterDockerIgnore(ignoreFile, paths) {
    const ig = dockerignore_1.default().add(ignoreFile.split("\n"));
    return ig.filter(paths);
}
function generateCopyCommands(basePath, paths) {
    if (paths.length === 0)
        return "";
    return paths.map((p) => {
        const dirname = path_1.default.dirname(p);
        const dest = `${basePath}${dirname === "." ? "" : `/${dirname}`}`;
        return `COPY ["${p}", "${dest}/"]`;
    }).join("\n") + "\n";
}
/**
 * Locally builds a docker image for a {@link https://www.nodejs.org | Node.js} program.
 *
 * @remarks
 * Implements {@link docker.DockerImageInstance}.
 *
 * See {@link nodejs.LocalNodeImageProps}.
 *
 * @public
 */
function LocalNodeImage(props) {
    const opts = Object.assign(Object.assign({}, defaultContainerBuildOptions), (props.options || {}));
    const [imgProps, setImgProps] = core_1.useState(undefined);
    const img = core_1.handle();
    setImgProps(async () => {
        const srcDir = path_1.default.resolve(props.srcDir);
        if (!(await fs_extra_1.default.pathExists(srcDir)))
            throw new Error(`Source directory ${srcDir} not found`);
        const dockerignorePath = path_1.default.join(srcDir, ".dockerignore");
        const dockerignoreFile = (await fs_extra_1.default.pathExists(dockerignorePath))
            ? (await fs_extra_1.default.readFile(dockerignorePath)).toString()
            : "";
        const pkgInfo = await fs_extra_1.default.readJson(path_1.default.join(srcDir, "package.json"));
        const pkgMgrFiles = await filterDockerIgnore(dockerignoreFile, await collectPackageManagerFiles(srcDir));
        const copyPkgMgrFiles = generateCopyCommands("/app", pkgMgrFiles);
        const main = pkgInfo.main ? pkgInfo.main : "index.js";
        const runNpmScripts = opts.runNpmScripts;
        const scripts = lodash_1.isArray(runNpmScripts) ? runNpmScripts :
            lodash_1.isString(runNpmScripts) ? [runNpmScripts] :
                [];
        const runCommands = scripts.map((s) => `RUN ${opts.packageManager} run ${s}`).join("\n");
        const { baseImage, nodeVersion, cmd } = opts;
        const cmdString = lodash_1.isArray(cmd)
            ? `[${cmd.map((c) => `"${c}"`).join(",")}]`
            : (cmd !== null && cmd !== void 0 ? cmd : `["node", "${main}"]`);
        const pkgMgrInstallOptions = opts.packageManager === "yarn" ? " --prefer-offline" : "";
        // Note that we collect files needed for npm or yarn install of node_modules and copy them
        // first, then we install node_modules, and then copy the source code.  This should result in a
        // much smaller set of top-layers that are likely to change, resulting in faster incremental
        // builds, pushes, and updates.  The large node_modules install layer only need be rebuilt and
        // repushed when package.json or yarn.lock/package-lock.json files change, not on every source code
        // change and rebuild.
        return {
            dockerfile: `
                    FROM ${baseImage !== null && baseImage !== void 0 ? baseImage : `node:${nodeVersion}-stretch-slim`}
                    ENV TINI_VERSION v0.18.0
                    ADD https://github.com/krallin/tini/releases/download/\${TINI_VERSION}/tini /tini
                    ENTRYPOINT ["/tini", "--"]
                    WORKDIR /app
                    ${argLines(opts.buildArgs)}
                    RUN chmod +x /tini
                    ${opts.optimizedImage ? copyPkgMgrFiles : ""}
                    ${opts.optimizedImage ? `RUN ${opts.packageManager} install` : ""}
                    CMD ${cmdString}
                    ADD . /app
                    RUN ${opts.packageManager} install${pkgMgrInstallOptions}
                    ${runCommands}
                `,
            contextDir: srcDir,
            options: opts,
        };
    });
    core_1.useMethodFrom(img, "image");
    core_1.useMethodFrom(img, "latestImage");
    core_1.useMethodFrom(img, "pushTo");
    return imgProps ? core_1.default.createElement(docker_1.LocalDockerImage, Object.assign({ handle: img }, imgProps)) : null;
}
exports.LocalNodeImage = LocalNodeImage;
const defaultContainerBuildOptions = {
    imageName: "node-service",
    nodeVersion: 14,
    optimizedImage: false,
    packageManager: "npm",
    uniqueTag: true,
    buildArgs: {}
};
//# sourceMappingURL=LocalNodeImage.js.map