"use strict";
/*
 * Copyright 2019-2021 Unbounded Systems, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.useResource = exports.useResources = exports.isResourcePodTemplate = exports.makeClusterInfo = void 0;
const tslib_1 = require("tslib");
const core_1 = require("@adpt/core");
const yaml = tslib_1.__importStar(require("js-yaml"));
const lodash_1 = tslib_1.__importDefault(require("lodash"));
const util = tslib_1.__importStar(require("util"));
const env_1 = require("../env");
const kubectl_1 = require("./kubectl");
const Resource_1 = require("./Resource");
async function getKubeconfigFromPath(path) {
    const kenv = path ? { KUBECONFIG: path } : {};
    const result = await kubectl_1.kubectl(["config", "view", "-o", "json", "--flatten"], { env: env_1.mergeEnvSimple(process.env, kenv) });
    const json = result.stdout;
    const ret = JSON.parse(json);
    if (ret.clusters === null)
        ret.clusters = [];
    return ret;
}
async function getKubeconfig(configStr) {
    const errors = [];
    let kubeconfig;
    //JSON
    try {
        kubeconfig = JSON.parse(configStr);
    }
    catch (e) {
        errors.push({ attempt: "as JSON", message: e.message });
    }
    //FIXME(manishv) better validation of returned data here
    if ((kubeconfig != null) && !lodash_1.default.isObject(kubeconfig)) {
        throw new Error(`Invalid kubeconfig in JSON from ${configStr}`);
    }
    if (lodash_1.default.isArray(kubeconfig))
        throw new Error(`Invalid array kubeconfig in JSON from ${configStr}`);
    if (kubeconfig !== undefined)
        return kubeconfig;
    //YAML
    try {
        kubeconfig = yaml.safeLoad(configStr); //FIXME(manishv) Put a Kubeconfig schema to validate YAML
    }
    catch (e) {
        errors.push({ attempt: "as YAML", message: e.message });
    }
    if ((kubeconfig != null) && !lodash_1.default.isObject(kubeconfig)) {
        if (lodash_1.default.isString(kubeconfig)) {
            kubeconfig = undefined; //Try this as a path, since a path will look like a valid YAML
        }
        else {
            throw new Error(`Invalid kubeconfig in YAML from ${configStr}`);
        }
    }
    if (lodash_1.default.isArray(kubeconfig))
        throw new Error(`Invalid array kubeconfig in YAML from ${configStr}`);
    if (kubeconfig !== undefined)
        return kubeconfig;
    try {
        return getKubeconfigFromPath(configStr);
    }
    catch (e) {
        errors.push({ attempt: "from KUBECONFIG", message: e.message });
    }
    throw new Error(errors.map((e) => `Could not get kubeconfig ${e.attempt}:\n${e.message}\n-------\n`).join("\n"));
}
/**
 * Make a {@link k8s.ClusterInfo} object suitable for use with k8s resources
 *
 * @remarks
 *
 * This function will take a set of options and generate a {@link k8s.ClusterInfo}
 * object that contains the kubeconfig, registryPrefix for private images, and any other
 * relevant information for the cluster
 *
 * See {@link k8s.MakeClusterInfoOptions} for information on how the information
 * is computed.
 *
 * @returns A {@link k8s.ClusterInfo} object.
 *
 * @public
 */
async function makeClusterInfo(options) {
    const registryPrefix = options.registryPrefix;
    if (options.kubeconfig === undefined) {
        return { kubeconfig: await getKubeconfigFromPath(process.env.KUBECONFIG), registryPrefix };
    }
    if (lodash_1.default.isString(options.kubeconfig)) {
        return { kubeconfig: await getKubeconfig(options.kubeconfig), registryPrefix };
    }
    if (lodash_1.default.isObject(options.kubeconfig)) {
        return { kubeconfig: options.kubeconfig, registryPrefix };
    }
    throw new Error(`Illegal kubeconfig option in ${util.inspect(options)}`);
}
exports.makeClusterInfo = makeClusterInfo;
/** @internal */
function isResourcePodTemplate(x) {
    if (!core_1.isElement(x))
        return false;
    if (!Resource_1.isResource(x))
        return false;
    if (x.props.apiVersion !== "v1" && x.props.kind === "Pod" && x.props.isTemplate === true)
        return true;
    return false;
}
exports.isResourcePodTemplate = isResourcePodTemplate;
function isNotReady(x, nr) {
    return lodash_1.default.isEqual(x, nr);
}
/**
 * Hook that allows a prop to be either an array of handle to k8s resources and values
 *
 * @param initial - initial value of the prop, before the handles are be resolved
 * @param notReady - is a marker value to indicate that a handle's value isn't available yet
 * @param kinds - an array of legal k8s Kinds that a prop handle can point to
 * @param thisResourceName - the name of the resource using the hook, for error messages
 * @param propName - the name of the prop being resolved, again for error messages
 *
 * @returns A two element array, the first element is the current value, the second the update function
 *
 * This hook will start by returning the initial value and an update function that updates
 * the value the hook returns.  The update function takes 2 arguments - the prop value which
 * is an array with a mix of values and handles to be resolved, and a function that receives
 * the elements that any handles point to along with that elements props.  This function
 * can be passed by the caller of update to resolve handles as appropriate for the component.
 *
 * For example, {@link k8s.ClusterRoleBinding} uses this hook to resolve the subjects prop,
 * which is an array of other objects (typically {@link ServiceAccount}) that a particular
 * {@link k8s.ClusterRole} should point to.  When ClusterRoleBinding calls the update method,
 * it passes a function that will convert a {@link k8s.Resource} element of Kind `ServiceAccount`
 * to the underlying `Subject` object that kubernetes expects, namely
 * `{ apiGroup: "", kind: "ServiceAccount", name: resourceIdToName(elem, deployID), namespace: <element namespace> }`
 *
 * @example
 * ```
 * function MyResource({ serviceAccountNames }: { serviceAccountNames: (string | Handle)[]}) {
 *   const { deployID } = useBuildHelpers();
 *   const [ resolvedServiceAccountNames, updateSANs] = useResources({
 *      initial: [],
 *      notReady: null,
 *      kinds: ["ServiceAccount"],
 *      thisResourceName: "MyResources",
 *      propName: "serviceAccountNames",
 *   });
 *
 *   updateSANs(serviceAccountNames, (e, props) => {
 *      return {
 *        apiGroup: (e.metadata.apiVersion?.split("/")[0]) || "",
 *        name: resourceElementToName(e, deployID),
 *        namespace: props.metadata.namespace,
 *      }
 *   });
 *
 *   return null;
 * }
 * ```
 *
 * @beta
 */
function useResources({ initial, notReady, kinds, thisResourceName, propName, }) {
    const [value, updateState] = core_1.useState(initial);
    return [
        value,
        (props, f) => {
            updateState(async () => {
                return Promise.all(props.map(async (prop) => {
                    if (!core_1.isHandle(prop))
                        return prop;
                    if (!prop.target)
                        return notReady;
                    if (!core_1.isMountedElement(prop.target))
                        return notReady;
                    if (prop.target.componentType !== Resource_1.Resource) {
                        throw new Error(`${thisResourceName} cannot handle ${propName} of type ${prop.target.componentType.name}`);
                    }
                    const targetProps = prop.target.props;
                    if (!kinds.includes(targetProps.kind)) {
                        throw new Error(`${thisResourceName} cannot handle ${propName} of kind ${targetProps.kind}`);
                    }
                    return f(prop.target, targetProps);
                }));
            });
        }
    ];
}
exports.useResources = useResources;
/**
 * Hook to allow conversion of a prop that could be a value or a handle
 *
 * This function behaves similarly to {@link k8s.useResources}, but works for
 * a prop that is either a Handle or a single value instead of an array of
 * Handles and values.
 *
 * See {@link k8s.useResources} for more detailed documentation.
 *
 * @beta
 */
function useResource(opts) {
    const [vals, update] = useResources(Object.assign(Object.assign({}, opts), { initial: isNotReady(opts.initial, opts.notReady) ? [] : [opts.initial] }));
    return [
        vals[0],
        (prop, f) => update([prop], f)
    ];
}
exports.useResource = useResource;
//# sourceMappingURL=utils.js.map