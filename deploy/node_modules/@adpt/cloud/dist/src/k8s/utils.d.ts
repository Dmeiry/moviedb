import { AdaptElement, AdaptMountedElement, Handle } from "@adpt/core";
import { DockerSplitRegistryInfo } from "../docker";
import { ClusterInfo, Kubeconfig, ResourcePod, ResourceProps } from "./common";
/**
 * Options for {@link k8s.makeClusterInfo}
 *
 * @public
 */
export interface MakeClusterInfoOptions {
    /**
     * A Javascript Object representing a valid kubeconfig, or a YAML string, or a path to a kubeconfig file.
     *
     * @remarks
     * If this is a Javascript object, it will be treated like a parsed kubeconfig.  If this is a string,
     * {@link k8s.makeClusterInfo} will first attempt to parse it as JSON.  If that fails, it will attempt
     * to parse it as YAML.  If that fails it will treat the string as a path of configs (like with the `KUBECONFIG`
     * environment variable).
     *
     * If kubeconfig is missing {@link k8s.makeClusterInfo} will use the `KUBECONFIG` environment variable to build
     * a suitable config using `kubectl config view --flatten` and return that as the kubeconfig in the resulting
     * {@link k8s.ClusterInfo}
     */
    kubeconfig?: Kubeconfig | string;
    /**
     * URL to the docker registry that this cluster uses to pull private images.
     *
     * @remarks
     * This is identical to the `registryPrefix` field in {@link k8s.ClusterInfo}.  It will
     * be returned verbatim in the resulting {@link k8s.ClusterInfo} object.
     */
    registryPrefix?: string | DockerSplitRegistryInfo;
}
/**
 * Make a {@link k8s.ClusterInfo} object suitable for use with k8s resources
 *
 * @remarks
 *
 * This function will take a set of options and generate a {@link k8s.ClusterInfo}
 * object that contains the kubeconfig, registryPrefix for private images, and any other
 * relevant information for the cluster
 *
 * See {@link k8s.MakeClusterInfoOptions} for information on how the information
 * is computed.
 *
 * @returns A {@link k8s.ClusterInfo} object.
 *
 * @public
 */
export declare function makeClusterInfo(options: MakeClusterInfoOptions): Promise<ClusterInfo>;
/** @internal */
export declare function isResourcePodTemplate(x: any): x is AdaptElement<ResourcePod>;
/**
 * Hook that allows a prop to be either an array of handle to k8s resources and values
 *
 * @param initial - initial value of the prop, before the handles are be resolved
 * @param notReady - is a marker value to indicate that a handle's value isn't available yet
 * @param kinds - an array of legal k8s Kinds that a prop handle can point to
 * @param thisResourceName - the name of the resource using the hook, for error messages
 * @param propName - the name of the prop being resolved, again for error messages
 *
 * @returns A two element array, the first element is the current value, the second the update function
 *
 * This hook will start by returning the initial value and an update function that updates
 * the value the hook returns.  The update function takes 2 arguments - the prop value which
 * is an array with a mix of values and handles to be resolved, and a function that receives
 * the elements that any handles point to along with that elements props.  This function
 * can be passed by the caller of update to resolve handles as appropriate for the component.
 *
 * For example, {@link k8s.ClusterRoleBinding} uses this hook to resolve the subjects prop,
 * which is an array of other objects (typically {@link ServiceAccount}) that a particular
 * {@link k8s.ClusterRole} should point to.  When ClusterRoleBinding calls the update method,
 * it passes a function that will convert a {@link k8s.Resource} element of Kind `ServiceAccount`
 * to the underlying `Subject` object that kubernetes expects, namely
 * `{ apiGroup: "", kind: "ServiceAccount", name: resourceIdToName(elem, deployID), namespace: <element namespace> }`
 *
 * @example
 * ```
 * function MyResource({ serviceAccountNames }: { serviceAccountNames: (string | Handle)[]}) {
 *   const { deployID } = useBuildHelpers();
 *   const [ resolvedServiceAccountNames, updateSANs] = useResources({
 *      initial: [],
 *      notReady: null,
 *      kinds: ["ServiceAccount"],
 *      thisResourceName: "MyResources",
 *      propName: "serviceAccountNames",
 *   });
 *
 *   updateSANs(serviceAccountNames, (e, props) => {
 *      return {
 *        apiGroup: (e.metadata.apiVersion?.split("/")[0]) || "",
 *        name: resourceElementToName(e, deployID),
 *        namespace: props.metadata.namespace,
 *      }
 *   });
 *
 *   return null;
 * }
 * ```
 *
 * @beta
 */
export declare function useResources<ValT, NotReadyT>({ initial, notReady, kinds, thisResourceName, propName, }: {
    initial: ValT[];
    notReady: NotReadyT;
    kinds: string[];
    thisResourceName: string;
    propName: string;
}): [
    (ValT | NotReadyT)[],
    (props: (ValT | Handle)[], f: (e: AdaptMountedElement, props: ResourceProps) => Promise<ValT> | ValT) => void
];
/**
 * Hook to allow conversion of a prop that could be a value or a handle
 *
 * This function behaves similarly to {@link k8s.useResources}, but works for
 * a prop that is either a Handle or a single value instead of an array of
 * Handles and values.
 *
 * See {@link k8s.useResources} for more detailed documentation.
 *
 * @beta
 */
export declare function useResource<ValT, NotReadyT>(opts: {
    initial: ValT | NotReadyT;
    notReady: NotReadyT;
    kinds: string[];
    thisResourceName: string;
    propName: string;
}): [
    ValT | NotReadyT,
    (prop: ValT | Handle, f: (e: AdaptMountedElement, props: ResourceProps) => Promise<ValT> | ValT) => void
];
//# sourceMappingURL=utils.d.ts.map