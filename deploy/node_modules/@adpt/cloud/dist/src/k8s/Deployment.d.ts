import Adapt, { BuildData, BuildHelpers, DeferredComponent, ObserveForStatus, WithChildren } from "@adpt/core";
import { ClusterInfo, LabelSelector, Metadata, PodTemplateSpec, ResourceBase, ResourcePropsWithConfig } from "./common";
/** @public */
export interface DeploymentUpdateStrategyRecreate {
    type: "Recreate";
}
/** @public */
export interface RollingUpdateDeployment {
    /**
     * The maximum number of pods that can be scheduled above the desired number of pods.
     *
     * Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
     * This can not be 0 if MaxUnavailable is 0.
     * Absolute number is calculated from percentage by rounding up.
     * Defaults to 25%.
     *
     * @example
     * When this is set to 30%, the new ReplicaSet can be scaled up immediately when the rolling update starts,
     * such that the total number of old and new pods do not exceed 130% of desired pods. Once old pods have been
     * killed, new ReplicaSet can be scaled up further, ensuring that total number of pods running at any time
     * during the update is at most 130% of desired pods.
     */
    maxSurge?: number | string;
    /**
     * The maximum number of pods that can be unavailable during the update.
     *
     * Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
     * Absolute number is calculated from percentage by rounding down.
     * This can not be 0 if MaxSurge is 0. Defaults to 25%.
     *
     * @example
     * When this is set to 30%, the old ReplicaSet can be scaled down to 70% of desired pods
     * immediately when the rolling update starts. Once new pods are ready, old ReplicaSet
     * can be scaled down further, followed by scaling up the new ReplicaSet, ensuring that
     * the total number of pods available at all times during the update is at least 70% of
     * desired pods.
     */
    maxUnavailable?: number | string;
}
/** Rolling update configuration for {@link k8s.DeploymentUpdateStrategy } */
interface DeploymentUpdateStrategyRollingUpdate {
    type: "RollingUpdate";
    rollingUpdate?: RollingUpdateDeployment;
}
/**
 * Update Strategy for {@link k8s.Deployment}
 *
 * @public
 */
declare type DeploymentUpdateStrategy = DeploymentUpdateStrategyRollingUpdate | DeploymentUpdateStrategyRecreate;
/**
 * Spec for {@link k8s.Deployment} for use in {@link k8s.Resource}
 *
 * @public
 */
export declare type DeploymentSpec = Exclude<DeploymentProps, ResourceBase> & {
    template: PodTemplateSpec;
};
/**
 * Props for {@link k8s.Deployment}
 *
 * @public
 */
export interface DeploymentProps extends WithChildren {
    /** Information about the k8s cluster (ip address, auth info, etc.) */
    config: ClusterInfo;
    /** k8s metadata */
    metadata: Metadata;
    /**
     * The minimum number of seconds for which a newly created pod should
     * be ready without any of its container crashing, for it to be considered
     * available. Defaults to 0 (pod will be considered available as soon as it is ready).
     */
    minReadySeconds: number;
    /** Indicates that the deployment is paused */
    paused: boolean;
    /**
     * The maximum time in seconds for a deployment to make progress before it is considered to be failed.
     *
     * The deployment controller will continue to process failed deployments and a condition with a
     * ProgressDeadlineExceeded reason will be surfaced in the deployment status. Note that progress
     * will not be estimated during the time a deployment is paused. Defaults to 600s.
     */
    progressDeadlineSeconds: number;
    /**
     * Number of desired pods.
     *
     * Defaults to 1. 0 is not allowed.
     *
     * @defaultValue 1
     */
    replicas: number;
    /**
     * The number of old ReplicaSets to retain to allow rollback.
     *
     * This is a pointer to distinguish between explicit zero and not specified. Defaults to 10.
     *
     * @defaultValue 10
     */
    revisionHistoryLimit: number;
    /**
     * Label selector for pods.
     *
     * Existing ReplicaSets whose pods are selected by this will be the ones affected by this deployment.
     * It must match the pod template's labels.
     *
     * @remarks
     *
     * With Adapt, this is optional.  If not specified, adapt will pick a selector that will work with the pods
     * it creates as part of this {@link k8s.Deployment}
     */
    selector?: LabelSelector;
    /**
     * An deployment strategy to use to replace existing pods with new ones
     */
    strategy: DeploymentUpdateStrategy;
}
/**
 * Component for Kubernetes Deployment
 *
 * @public
 */
export declare class Deployment extends DeferredComponent<DeploymentProps> {
    static defaultProps: {
        metadata: {};
        paused: boolean;
        replicas: number;
        progressDeadlineSeconds: number;
        minReadySeconds: number;
        revisionHistoryLimit: number;
        strategy: {
            type: string;
            rollingUpdate: {
                maxSurge: string;
                maxUnavailable: string;
            };
        };
    };
    constructor(props: DeploymentProps);
    build(helpers: BuildHelpers): Adapt.JSX.Element | null;
    deployedWhen: () => true | Adapt.Waiting;
    status(_observe: ObserveForStatus, buildData: BuildData): Promise<Adapt.Status | undefined>;
}
declare function deployedWhen(statusObj: unknown): true | Adapt.Waiting;
/** @internal */
export declare const deploymentResourceInfo: {
    kind: string;
    deployedWhen: typeof deployedWhen;
    statusQuery: (props: ResourcePropsWithConfig, observe: ObserveForStatus, buildData: BuildData) => Promise<any>;
};
export {};
//# sourceMappingURL=Deployment.d.ts.map