import Adapt, { BuildData, BuildHelpers, DeferredComponent, ObserveForStatus, WithChildren } from "@adpt/core";
import { ClusterInfo, LabelSelector, Metadata, PodTemplateSpec, ResourceBase, ResourcePropsWithConfig } from "./common";
interface DaemonSetUpdateStrategyOnDelete {
    type: "OnDelete";
}
/** Rolling update configuration for {@link k8s.DaemonSetUpdateStrategy } */
interface DaemonSetUpdateStrategyRollingUpdate {
    type: "RollingUpdate";
    rollingUpdate: {
        /**
         * The maximum number of DaemonSet pods that can be unavailable during the update.
         * Value can be an absolute number (ex: 5) or a percentage of total number of
         * DaemonSet pods at the start of the update (ex: 10%).
         * Absolute number is calculated from percentage by rounding up. This cannot be 0.
         * Default value is 1.
         *
         * @example
         * when this is set to 30%, at most 30% of the total number of nodes that should
         * be running the daemon pod (i.e. status.desiredNumberScheduled) can have their
         * pods stopped for an update at any given time. The update starts by stopping at
         * most 30% of those DaemonSet pods and then brings up new DaemonSet pods in their
         * place. Once the new pods are available, it then proceeds onto other DaemonSet pods,
         * thus ensuring that at least 70% of original number of DaemonSet pods are available
         * at all times during the update.
         */
        maxUnavailable: number | string;
    };
}
/**
 * Update Strategy for {@link k8s.DaemonSet}
 *
 * @public
 */
declare type DaemonSetUpdateStrategy = DaemonSetUpdateStrategyRollingUpdate | DaemonSetUpdateStrategyOnDelete;
/**
 * Spec for {@link k8s.DaemonSet} for use in {@link k8s.Resource}
 *
 * @public
 */
export declare type DaemonSetSpec = Exclude<DaemonSetProps, ResourceBase> & {
    template: PodTemplateSpec;
};
/**
 * Props for {@link k8s.DaemonSet}
 *
 * @public
 */
interface DaemonSetProps extends WithChildren {
    /** Information about the k8s cluster (ip address, auth info, etc.) */
    config: ClusterInfo;
    /** k8s metadata */
    metadata: Metadata;
    /**
     * The minimum number of seconds for which a newly created DaemonSet pod should
     * be ready without any of its container crashing, for it to be considered
     * available. Defaults to 0 (pod will be considered available as soon as it is ready).
     */
    minReadySeconds: number;
    /**
     * The number of old history to retain to allow rollback. This is a pointer to
     * distinguish between explicit zero and not specified. Defaults to 10.
     */
    revisionHistoryLimit: number;
    /**
     * A label query over pods that are managed by the daemon set.
     * Must match in order to be controlled. It must match the pod template's labels.
     * More Info: {@link https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors}
     *
     * @remarks
     *
     * With Adapt, this is optional.  If not specified, adapt will pick a selector that will work with the pods
     * it creates as part of this {@link k8s.DaemonSet}
     */
    selector?: LabelSelector;
    /**
     * An update stratgey to replace existing DaemonSet pods with new pods
     */
    updateStrategy: DaemonSetUpdateStrategy;
}
/**
 * Component for Kubernetes DaemonSet
 *
 * @public
 */
export declare class DaemonSet extends DeferredComponent<DaemonSetProps> {
    static defaultProps: {
        metadata: {};
        minReadySeconds: number;
        revisionHistoryLimit: number;
        updateStrategy: {
            type: string;
            rollingUpdate: {
                maxUnavailable: number;
            };
        };
    };
    constructor(props: DaemonSetProps);
    build(helpers: BuildHelpers): Adapt.JSX.Element;
    status(_observe: ObserveForStatus, buildData: BuildData): Promise<Adapt.Status | undefined>;
}
declare function deployedWhen(statusObj: unknown): true | Adapt.Waiting;
/** @internal */
export declare const daemonSetResourceInfo: {
    kind: string;
    deployedWhen: typeof deployedWhen;
    statusQuery: (props: ResourcePropsWithConfig, observe: ObserveForStatus, buildData: BuildData) => Promise<any>;
};
export {};
//# sourceMappingURL=DaemonSet.d.ts.map