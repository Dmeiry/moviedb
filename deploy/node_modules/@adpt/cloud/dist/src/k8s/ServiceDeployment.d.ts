import Adapt, { BuildHelpers, ComponentType, DeferredComponent, WithChildren } from "@adpt/core";
import { OmitT } from "type-ops";
import { ServiceProps as AbsServiceProps } from "../Service";
import { ClusterInfo } from "./common";
import { K8sContainerProps } from "./Container";
import { Deployment, DeploymentProps } from "./Deployment";
import { PodProps } from "./Pod";
import { ServiceProps } from "./Service";
interface AllowableComponentProps extends WithChildren {
    config?: ClusterInfo;
}
/**
 * Props for {@link k8s.ServiceDeployment}
 *
 * @public
 */
export interface ServiceDeploymentProps<T extends AllowableComponentProps = DeploymentProps> extends AbsServiceProps {
    config: ClusterInfo;
    serviceProps?: Partial<ServiceProps>;
    component: ComponentType<T>;
    componentProps: T;
    podProps?: Partial<PodProps>;
    containerProps?: Partial<OmitT<K8sContainerProps, "image">>;
}
/**
 * A component for mapping a group of abstract {@link Container}s and
 * {@link NetworkService}s to Kubernetes {@link k8s.Pod}s and
 * {@link k8s.K8sContainer}s.
 *
 * @remarks
 * This component is intended to be used to replace {@link Container} and
 * {@link NetworkService} components that are grouped together, as the
 * only children of a common parent in a pattern that looks like this:
 *
 * ```tsx
 * <Service>
 *   <Container ... />
 *   <Container ... />
 *   <NetworkService ... />
 * </Service>
 * ```
 *
 * `ServiceDeployment` would map those abstract components into corresponding
 * k8s components like this:
 * ```tsx
 * <Group>
 *   <docker.RegistryDockerImage ... /> //If props.config specifies a registry
 *   <k8s.Deployment ... >
 *     <Pod isTemplate>
 *       <k8s.K8sContainer ... />
 *     </Pod>
 *   </k8s.Deployment>
 *   <docker.RegistryDockerImage ... /> //If props.config specifies a registry
 *   <k8s.Deployment ... >
 *     <Pod isTemplate>
 *       <k8s.K8sContainer ... />
 *     </Pod>
 *   </k8s.Pod>
 *   <k8s.Service ... />
 * </Group>
 * ```
 * An example style rule to do this is:
 * ```tsx
 * {Adapt.rule((matchedProps) => {
 *     const { handle, ...remainingProps } = matchedProps;
 *     return <ServiceDeployment config={kubeconfig} {...remainingProps} />;
 * })}
 * ```
 * `ServiceDeployment` also requires the `config` prop which specifies
 * connection and authentication information for the Kubernetes cluster on
 * which these objects should be created.
 *
 * @public
 */
export declare class ServiceDeployment<T extends AllowableComponentProps> extends DeferredComponent<ServiceDeploymentProps<T>> {
    static defaultProps: {
        component: typeof Deployment;
        componentProps: {
            replicas: number;
        };
    };
    build(helpers: BuildHelpers): Adapt.JSX.Element;
}
export {};
//# sourceMappingURL=ServiceDeployment.d.ts.map