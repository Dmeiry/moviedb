/// <reference types="node" />
import Adapt, { AdaptElement, BuildData, ObserveForStatus, SFCDeclProps } from "@adpt/core";
import { ClusterInfo, Metadata, ResourceProps, ResourcePropsWithConfig } from "./common";
import { Manifest } from "./manifest_support";
/**
 * Props for the {@link k8s.Secret} resource
 *
 * @public
 */
interface SecretProps {
    /** Information about the k8s cluster (ip address, auth info, etc.) */
    config: ClusterInfo;
    /** k8s metadata */
    metadata: Metadata;
    /**
     * Data contains the secret data.
     *
     * Each key must consist of alphanumeric characters, '-', '_' or '.'.
     * The serialized form of the secret data is a base64 encoded string, representing the arbitrary
     * (possibly non-string) data value here. Described in {@link https://tools.ietf.org/html/rfc4648#section-4}.
     *
     * @remarks
     *
     *  {@link k8s.Secret} will base64 encode all buffer data, but leave the string data intact.  It
     * is up to the user of {@link k8s.Secret | Secret} to mak sure the string is a valid base64
     * encoding.
     */
    data: {
        [key: string]: string | Buffer;
    };
    /**
     * stringData allows specifying non-binary secret data in string form.
     *
     * It is provided as a write-only convenience method. All keys and values are merged into the data field on write,
     * overwriting any existing values. It is never output when reading from the API.
     */
    stringData: {
        [key: string]: string;
    };
    /**
     * Used to facilitate programmatic handling of secret data.
     */
    type?: string;
}
declare const defaultProps: {
    metadata: {};
    data: {};
    stringData: {};
};
/**
 * k8s Secret resource
 *
 * @param propsIn - props for Secret as specifed in {@link k8s.SecretProps}
 *
 * @public
 */
export declare function Secret(propsIn: SFCDeclProps<SecretProps, typeof defaultProps>): Adapt.JSX.Element;
/** @internal */
export declare const secretResourceInfo: {
    kind: string;
    deployedWhen: () => true;
    statusQuery: (props: ResourcePropsWithConfig, observe: ObserveForStatus, buildData: BuildData) => Promise<any>;
    makeManifest: (manifest: Manifest, elem: AdaptElement<ResourceProps>, _deployID: string) => {
        data: {
            [key: string]: string;
        } | undefined;
        stringData: {
            [key: string]: string;
        } | undefined;
        type: string | undefined;
        apiVersion: string; /**
         * stringData allows specifying non-binary secret data in string form.
         *
         * It is provided as a write-only convenience method. All keys and values are merged into the data field on write,
         * overwriting any existing values. It is never output when reading from the API.
         */
        kind: string;
        metadata: import("./manifest_support").MetadataInRequest;
        spec?: import("./DaemonSet").DaemonSetSpec | import("./common").CRSpec | import("./Pod").PodSpec | import("./Service").ServiceSpec | import("./Deployment").DeploymentSpec | undefined;
    };
};
export {};
//# sourceMappingURL=Secret.d.ts.map