import { FIXME_NeedsProperType } from "@adpt/utils";
import db from "debug";
import { ExecaReturnValue } from "execa";
import { OmitT, WithPartialT } from "type-ops";
import { Config, ContainerStatus } from "../Container";
import { Environment } from "../env";
import { ImageRefDockerHost, WithId } from "./image-ref";
import { DockerBuildOptions, DockerContainerProps, DockerGlobalOptions, File, ImageIdString, ImageNameString, NameTagString, RepoDigestString } from "./types";
export declare const debug: db.Debugger;
export declare const debugOut: db.Debugger;
export declare const exec: (cmd: string, args: string[], options?: import("@adpt/utils").DebugExecOptions | undefined) => Promise<ExecaReturnValue<string>>;
export declare const pickGlobals: (opts: DockerGlobalOptions) => DockerGlobalOptions;
export declare const defaultDockerHost: string;
/**
 * Common version of busybox to use internally.
 * @internal
 */
export declare const busyboxImage = "busybox:1";
export declare function writeFiles(pwd: string, files: File[]): Promise<void>;
export declare function buildFilesImage(files: File[], opts: BuildFilesImageOptions): Promise<WithId<ImageRefDockerHost>>;
export interface BuildFilesImageOptions extends DockerGlobalOptions {
    /**
     * If set, adds a Docker LABEL to the built image with the DeployID.
     */
    deployID?: string;
}
export declare function withFilesImage<T>(files: File[] | undefined, opts: BuildFilesImageOptions, fn: (img: WithId<ImageRefDockerHost> | undefined) => T | Promise<T>): Promise<T>;
export interface ExecDockerOptions extends DockerGlobalOptions {
    requestBuildKit?: boolean;
    stdin?: string;
    env?: Environment;
}
/** @internal */
export declare function execDocker(argsIn: string[], options: ExecDockerOptions): Promise<ExecaReturnValue>;
export declare const defaultDockerBuildOptions: {
    requestBuildKit: boolean;
    forceRm: boolean;
    uniqueTag: boolean;
};
export declare function dockerBuild(dockerfile: string, contextPath: string, options?: DockerBuildOptions): Promise<WithId<ImageRefDockerHost>>;
/**
 * Fetch the image id for a Docker image
 *
 * @internal
 */
export declare function dockerImageId(name: string, opts?: DockerGlobalOptions): Promise<ImageIdString | undefined>;
export interface DockerTagOptions extends DockerGlobalOptions {
    existing: ImageNameString | ImageIdString;
    newTag: NameTagString;
}
export declare function dockerTag(options: DockerTagOptions): Promise<void>;
export interface DockerRemoveImageOptions extends DockerGlobalOptions {
    nameOrId: ImageNameString | ImageIdString;
    force?: boolean;
}
export declare function dockerRemoveImage(options: DockerRemoveImageOptions): Promise<void>;
export declare function createTag(baseTag: string | undefined, appendUnique: boolean): string | undefined;
export interface InspectReport extends ContainerStatus {
}
export interface NetworkInspectReport {
    Id: string;
    Created: string;
    Name: string;
    Driver: string;
    Scope: "local" | string;
    EnableIPv6: boolean;
    IPAM: {
        Driver: string;
        Options: null | FIXME_NeedsProperType;
        Config: FIXME_NeedsProperType[];
    };
    Internal: boolean;
    Attachable: boolean;
    Ingress: boolean;
    ConfigFrom: {
        Network: string;
    };
    ConfigOnly: boolean;
    Containers: {
        [id: string]: {
            Name: string;
            EndpointId: string;
            MacAddress: string;
            IPv4Address: string;
            IPv6Address: string;
        };
    };
    Options: {
        [name: string]: string;
    };
}
export interface ImageInspectReport {
    Id: string;
    Config: Config;
    [key: string]: FIXME_NeedsProperType;
}
export interface DockerInspectOptions extends DockerGlobalOptions {
    type?: "container" | "image" | "network";
}
/**
 * Run docker inspect and return the parsed output
 *
 * @internal
 */
export declare function dockerInspect(namesOrIds: string[], opts: {
    type: "image";
} & DockerInspectOptions): Promise<ImageInspectReport[]>;
export declare function dockerInspect(namesOrIds: string[], opts: {
    type: "network";
} & DockerInspectOptions): Promise<NetworkInspectReport[]>;
export declare function dockerInspect(namesOrIds: string[], opts: {
    type: "container";
} & DockerInspectOptions): Promise<InspectReport[]>;
export declare function dockerInspect(namesOrIds: string[], opts?: DockerInspectOptions): Promise<InspectReport[] | NetworkInspectReport[] | ImageInspectReport[]>;
export declare type NetworkReport = NetworkInspectReport[];
/**
 * Return a list of all network names
 *
 * @internal
 */
export declare function dockerNetworkLs(opts: DockerGlobalOptions): Promise<string[]>;
/**
 * Return all networks and their inspect reports
 *
 * @internal
 */
export declare function dockerNetworks(opts: DockerGlobalOptions): Promise<NetworkReport>;
/**
 * Run docker stop
 *
 * @internal
 */
export declare function dockerStop(namesOrIds: string[], opts: DockerGlobalOptions): Promise<void>;
/**
 * Run docker rm
 *
 * @internal
 */
export declare function dockerRm(namesOrIds: string[], opts: DockerGlobalOptions): Promise<void>;
/**
 * Options for {@link docker.dockerRun}
 *
 * @internal
 */
export interface DockerRunOptions extends OmitT<WithPartialT<DockerContainerProps, "dockerHost">, "networks"> {
    background?: boolean;
    name?: string;
    image: ImageNameString;
    network?: string;
}
/**
 * Run a container via docker run
 *
 * @internal
 */
export declare function dockerRun(options: DockerRunOptions): Promise<ExecaReturnValue<string>>;
/**
 * Attach containers to given networks
 *
 * @internal
 */
export declare function dockerNetworkConnect(containerNameOrId: string, networks: string[], opts: {
    alreadyConnectedError?: boolean;
} & ExecDockerOptions): Promise<void>;
/**
 * Detach containers from given networks
 *
 * @internal
 */
export declare function dockerNetworkDisconnect(containerNameOrId: string, networks: string[], opts: {
    alreadyDisconnectedError?: boolean;
} & ExecDockerOptions): Promise<void>;
/**
 * Options for dockerPush.
 *
 * @internal
 */
export interface DockerPushOptions extends DockerGlobalOptions {
    nameTag: NameTagString;
}
/**
 * Push an image to a registry
 *
 * @internal
 */
export declare function dockerPush(opts: DockerPushOptions): Promise<void>;
/**
 * Options for dockerPull.
 *
 * @internal
 */
export interface DockerPullOptions extends DockerGlobalOptions {
    /**
     * Image to pull.
     * @remarks
     * See {@link docker.ImageNameString} for more details. If the registry
     * portion of imageName is absent, the official Docker registry is
     * assumed.
     */
    imageName: ImageNameString;
}
/**
 * Information about an image that has been successfully pulled from a
 * registry.
 *
 * @internal
 */
export interface DockerPullInfo {
    id: ImageIdString;
    registryDigest: RepoDigestString;
}
/**
 * Push an image to a registry
 *
 * @internal
 */
export declare function dockerPull(opts: DockerPullOptions): Promise<DockerPullInfo>;
//# sourceMappingURL=cli.d.ts.map