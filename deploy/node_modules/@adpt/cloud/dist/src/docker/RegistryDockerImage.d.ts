import { ChangeType, DependsOnMethod, Handle } from "@adpt/core";
import { Action } from "../action";
import { DockerImageInstance, DockerPushableImageInstance } from "./DockerImage";
import { ImageRefRegistry } from "./image-ref";
import { DockerSplitRegistryInfo, RegistryString } from "./types";
/**
 * Props for {@link docker.RegistryDockerImage}
 * @public
 */
export interface RegistryDockerImageProps {
    /**
     * Handle for image source
     * @remarks
     * Currently, only handle to LocalDockerImage components and compatible
     * interfaces are supported.
     * @privateRemarks
     * FIXME(manishv) support string refs to other registries and handles of
     * other registry images
     */
    imageSrc: Handle<DockerPushableImageInstance>;
    /**
     * Registry and path where the image should be pushed and pulled
     *
     * @remarks
     * If this parameter is a string, registryPrefix will be used for both push and pull
     *
     * If registryPrefix is of the form `{ external: string, internal: string }`, docker images wil be
     * pushed to `external` and image strings will refer to `internal`.
     *
     * Registry prefixes can be of the form `domain/path/elements`, for example `gcr.io/myproject`.
     * However, the registryPrefix should not include the final name, use newPathTag instead.
     *
     * Note(manishv)
     * This is a bit of a hack to allow one hostname or IP address to push images from outside
     * a particular environment (say k8s) and a different URL for that environment to pull
     * images.
     *
     * A good example of this is a k3s-dind (k3s docker-in-docker) instance of kubernetes where
     * a private registry is running on a docker network attached to the k3s-dind instance, but where we
     * want to push {@link docker.LocalDockerImage} built images to that registry.  Since
     * {@link docker.LocalDockerImage | LocalDockerImage} is outside the k3s-dind environment, it must
     * use a host accessible network to push to the registry.  However, since the k3s-dind instance sees
     * the registry from within Docker, it must use a different address to pull the images for use.
     *
     * Once network scopes are fully supported, this interface will change to whatever is appropriate.  It
     * is best if you can arrange to have the same URL or registry string work for all access regardless
     * of which network the registry, Adapt host, and ultimate container running environment is uses.
     */
    registryPrefix: RegistryString | DockerSplitRegistryInfo;
    /**
     * Path and tag to be used for the image in the new registry in
     * `path:tag` or `path` format.
     * @remarks
     * The entire path and tag are blindly concatenated to the domain and path
     * in registryPrefix to form the full ref that will be used to push the
     * image.
     *
     * If omitted, the last component of the path and the tag from the source
     * image is used. The newPathTag should not include the registry
     * hostname/port prefix. If the `:tag` portion of `path:tag` is omitted,
     * the tag `latest` will be used.
     */
    newPathTag?: string;
    /**
     * Path and tag to be used for the image in the new registry in
     * `path:tag` or `path` format.
     * @deprecated This prop has been renamed to `newPathTag`. The functionality
     * for both props is the same and if both are set, `newPathTag` takes
     * priority.
     * @remarks
     * If omitted, the path and tag from the source image is used. The
     * newTag should not include the registry hostname/port prefix. If the
     * `:tag` portion of `path:tag` is omitted, the tag `latest` will be used.
     */
    newTag?: string;
}
interface State {
    image?: ImageRefRegistry;
    registryPrefix?: DockerSplitRegistryInfo;
}
/**
 * Represents a Docker image in a registry.
 * @remarks
 * If the image does not exist in the specified registry, it will be pushed
 * to that registry.
 * @public
 */
export declare class RegistryDockerImage extends Action<RegistryDockerImageProps, State> implements DockerImageInstance {
    private latestImage_?;
    private latestRegistryUrl_?;
    private registry;
    constructor(props: RegistryDockerImageProps);
    /**
     * Returns information about the version of the Docker image that reflects
     * the current set of props for the component and has been pushed to the
     * registry.
     * @remarks
     * Returns undefined if the `props.imageSrc` component's `latestImage` method
     * returns undefined (depending on the component referenced by
     * `props.imageSrc`, that may indicate the source image has not been built).
     * Also returns undefined if the current image has not yet been
     * pushed to the registry.
     */
    image(): ImageRefRegistry | undefined;
    /**
     * Returns information about the most current version of the Docker image
     * that has been pushed to the registry.
     * @remarks
     * Returns undefined if no image has ever been pushed by this component.
     */
    latestImage(): ImageRefRegistry | undefined;
    /** @internal */
    initialState(): {};
    /** @internal */
    shouldAct(diff: ChangeType): false | {
        act: boolean;
        detail: string;
    };
    /** @internal */
    dependsOn: DependsOnMethod;
    /** @internal */
    action(op: ChangeType): Promise<void>;
    private currentNameTag;
    private getNewPathTag;
    private srcImageName;
}
export {};
//# sourceMappingURL=RegistryDockerImage.d.ts.map