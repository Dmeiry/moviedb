import { ChangeType, DeployOpID, GoalStatus } from "@adpt/core";
import { Action, ActionContext, ShouldAct } from "../action";
import { BuildKitBuildOptions, BuildKitOutput } from "./bk-types";
import { DockerPushableImageInstance } from "./DockerImage";
import { ImageRefRegistry, WithId } from "./image-ref";
import { File, Stage } from "./types";
/**
 * Props for {@link docker.BuildKitImage}
 *
 * @public
 */
export interface BuildKitImageProps {
    /** Directory for use as the build context */
    contextDir?: string;
    /**
     * Contents of the dockerfile
     *
     * @remarks
     * Should not be used if dockerfileName is set
     */
    dockerfile?: string;
    /**
     * Path to a local Dockerfile in the Adapt project.
     *
     * @remarks
     * This path is relative to the root of the Adapt project.
     * Should not be used if `dockerfile` is set.
     */
    dockerfileName?: string;
    /**
     * Extra files that should be included during the docker build
     *
     * @remarks
     * BuildKitImage uses a multi-stage build process.  It first creates
     * a temporary image that includes the files specified in this field.
     * This temporary image is then made available to the `dockerfile` with
     * stage name `files` and can then be copied into the final image, as
     * desired, using `COPY` or `ADD` commands in the `dockerfile`.
     *
     * @example
     * To create a final Docker image that contains a file that has some
     * programmatically created content, use the `dockerfile` prop along
     * with the `files` prop like this:
     * ```tsx
     * const files = [{
     *   path: '/path/to/myfile.txt',
     *   contents: 'contents for myfile\n'
     * }];
     * const dockerfile = `
     *   FROM alpine
     *   COPY --from=files /path/to/myfile.txt /app/myfile.txt
     *   ...
     * `;
     * return <BuildKitImage files={files} dockerfile={dockerfile} />
     * ```
     */
    files?: File[];
    /**
     * Options to control the behavior of docker build
     */
    options?: BuildKitBuildOptions;
    /**
     * Directs BuildKit where to store the built image.
     */
    output: BuildKitOutput;
    /**
     * Extra stages to include in a multi-stage docker build
     */
    stages?: Stage[];
}
/**
 * @internal
 */
export interface BuildKitImageState {
    deployOpID?: DeployOpID;
    image?: WithId<ImageRefRegistry>;
    imagePropsJson?: string;
    prevUniqueNameTag?: string;
}
/**
 * Locally builds a docker image
 *
 * @remarks
 * See {@link docker.BuildKitImageProps}.
 *
 * @public
 */
export declare class BuildKitImage extends Action<BuildKitImageProps, BuildKitImageState> implements DockerPushableImageInstance {
    static defaultProps: {
        options: {};
    };
    deployedWhenIsTrivial: boolean;
    private image_?;
    private imagePropsJson_?;
    private options_;
    constructor(props: BuildKitImageProps);
    buildComplete(): boolean;
    ready(): boolean;
    image(): WithId<ImageRefRegistry> | undefined;
    pushTo({ ref }: {
        ref: string;
    }): Promise<undefined | WithId<ImageRefRegistry>>;
    latestImage(): WithId<ImageRefRegistry> | undefined;
    /**
     * User-facing name to display in status messages.
     */
    displayName(): string;
    /**
     * Implementations for Action base class
     * @internal
     */
    shouldAct(op: ChangeType): Promise<ShouldAct>;
    /**
     * Implementations for Action base class
     * @internal
     */
    action(op: ChangeType, ctx: ActionContext): Promise<void>;
    /** @internal */
    initialState(): {};
    /** @internal */
    deployedWhen: (goalStatus: GoalStatus) => true | import("@adpt/core").Waiting;
    /** @internal */
    protected get imagePropsJson(): string;
}
//# sourceMappingURL=BuildKitImage.d.ts.map