"use strict";
/*
 * Copyright 2019-2021 Unbounded Systems, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.RegistryDockerImage = void 0;
const core_1 = require("@adpt/core");
const lodash_1 = require("lodash");
const url_1 = require("url");
const action_1 = require("../action");
const image_ref_1 = require("./image-ref");
function buildNameTag(url, pathTag) {
    const ir = image_ref_1.imageRef([url.replace(/\/$/, ""), pathTag].join("/"), true);
    return ir.nameTag;
}
function urlToRegistryString(registryPrefix) {
    let ret;
    if (registryPrefix.startsWith("http")) {
        const parsed = new url_1.URL(registryPrefix);
        ret = parsed.host + parsed.pathname;
    }
    else {
        ret = registryPrefix;
    }
    if (ret.endsWith("/"))
        ret = ret.slice(0, -1);
    return ret;
}
function normalizeRegistryUrl(url) {
    if (typeof url === "string") {
        const urlString = urlToRegistryString(url);
        url = { external: urlString, internal: urlString };
    }
    return {
        external: urlToRegistryString(url.external),
        internal: urlToRegistryString(url.internal)
    };
}
function extractBasePathTag(imageHandle) {
    let pathTag;
    if (typeof imageHandle === "string") {
        pathTag = imageHandle;
    }
    else {
        const ref = core_1.callInstanceMethod(imageHandle, undefined, "latestImage");
        if (ref === undefined)
            return undefined;
        pathTag = ref.tag ? ref.pathTag : ref.path;
    }
    if (pathTag === undefined)
        return undefined;
    const pathTagSplit = pathTag.split("/");
    return pathTagSplit[pathTagSplit.length - 1];
}
/**
 * Represents a Docker image in a registry.
 * @remarks
 * If the image does not exist in the specified registry, it will be pushed
 * to that registry.
 * @public
 */
class RegistryDockerImage extends action_1.Action {
    constructor(props) {
        super(props);
        /** @internal */
        this.dependsOn = (_goalStatus, helpers) => {
            if (!core_1.isHandle(this.props.imageSrc))
                return undefined;
            return helpers.dependsOn(this.props.imageSrc);
        };
        this.registry = normalizeRegistryUrl(props.registryPrefix);
    }
    /**
     * Returns information about the version of the Docker image that reflects
     * the current set of props for the component and has been pushed to the
     * registry.
     * @remarks
     * Returns undefined if the `props.imageSrc` component's `latestImage` method
     * returns undefined (depending on the component referenced by
     * `props.imageSrc`, that may indicate the source image has not been built).
     * Also returns undefined if the current image has not yet been
     * pushed to the registry.
     */
    image() {
        const srcImage = core_1.callInstanceMethod(this.props.imageSrc, undefined, "latestImage");
        const latestImg = this.latestImage();
        const latestReg = this.latestRegistryUrl_ || this.state.registryPrefix;
        if (!srcImage || !latestImg || !latestReg)
            return undefined;
        if (srcImage.id === latestImg.id &&
            this.currentNameTag() === latestImg.nameTag &&
            lodash_1.isEqual(this.registry, latestReg)) {
            return latestImg;
        }
        return undefined; // Pushed image is not current
    }
    /**
     * Returns information about the most current version of the Docker image
     * that has been pushed to the registry.
     * @remarks
     * Returns undefined if no image has ever been pushed by this component.
     */
    latestImage() { return this.latestImage_ || this.state.image; }
    /** @internal */
    initialState() { return {}; }
    /** @internal */
    shouldAct(diff) {
        if (diff === core_1.ChangeType.delete)
            return false;
        let name = this.getNewPathTag() || this.srcImageName();
        name = name ? ` '${name}'` : "";
        return { act: true, detail: `Pushing image${name} to ${this.registry.external}` };
    }
    /** @internal */
    async action(op) {
        if (op === core_1.ChangeType.delete || op === core_1.ChangeType.none)
            return;
        const ref = this.currentNameTag();
        const info = await core_1.callInstanceMethod(this.props.imageSrc, undefined, "pushTo", { ref });
        if (info === undefined) {
            throw new Error(`Image source component did not push image to registry`);
        }
        this.latestImage_ = Object.assign({}, info);
        this.latestRegistryUrl_ = this.registry;
        this.setState({
            image: this.latestImage_,
            registryPrefix: this.latestRegistryUrl_,
        });
    }
    currentNameTag() {
        const newPathTag = this.getNewPathTag();
        if (newPathTag !== undefined)
            return buildNameTag(this.registry.internal, newPathTag);
        return buildNameTag(this.registry.internal, extractBasePathTag(this.props.imageSrc));
    }
    getNewPathTag() {
        return this.props.newPathTag || this.props.newTag;
    }
    srcImageName() {
        return core_1.callFirstInstanceWithMethod(this.props.imageSrc, undefined, "displayName");
    }
}
exports.RegistryDockerImage = RegistryDockerImage;
//# sourceMappingURL=RegistryDockerImage.js.map