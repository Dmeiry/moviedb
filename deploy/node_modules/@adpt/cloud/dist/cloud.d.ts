/// <reference types="node" />
import { AdaptElementOrNull } from '@adpt/core';
import { FIXME_NeedsProperType } from '@adpt/utils';

export declare namespace action {
/**
   * Type guard for {@link action.ShouldActDetail}.
   * @public
   */
  export declare function isShouldActDetail(val: any): val is ShouldActDetail;/**
   * Transforms a {@link action.ShouldAct} into an {@link action.ShouldActDetail}.
   * @internal
   */
  export declare function toDetail(val: ShouldAct): {
      act: boolean;
      detail: string;
  };/**
   * Type guard for Action FinalDomElements.
   * @internal
   */
  export declare function isActionFinalElement(val: any): val is FinalDomElement;/**
   * Returns the component instance for an {@link action.Action} component.
   * @internal
   */
  export declare function getActionInstance(el: FinalDomElement): Action | null;/**
   * Detailed information on why an action should be taken.
   * @public
   */
  export declare interface ShouldActDetail {
      /**
       * True if the action should be performed.
       */
      act: boolean;
      /**
       * Explanation of why the action should be performed.
       */
      detail: string;
  }/**
   * Return type for {@link action.Action.shouldAct} that describes whether an
   * action should be taken and why.
   * @public
   */
  export declare type ShouldAct = false | ShouldActDetail;/**
   * Helper information for an {@link action.Action} component.
   * @public
   */
  export declare interface ActionContext {
      /** Various pieces of data about the current element and build cycle */
      buildData: BuildData;
      /** A location to put files that need to be persisted as state */
      dataDir: string;
      /** Interface to use for logging messages.  Prefer to using stderr or stdout */
      logger: MessageLogger;
  }/**
   * Component that can be inherited to perform actions during deploy
   *
   * @public
   */
  export declare class Action<P extends object = {}, S extends object = {}> extends PrimitiveComponent<P, S> {
      /**
       * Calculates whether or not any action is needed based on state/props/observation
       *
       * @returns false if no action needed, `{ act: true, detail: <user-facing description of action> }`.
       */
      shouldAct(_op: ChangeType, _ctx: ActionContext): ShouldAct | Promise<ShouldAct>;
      action(_op: ChangeType, _ctx: ActionContext): void | Promise<void>;
  }/**
   * Properties for the {@link action.Command | Command} component.
   * @public
   */
  export declare interface CommandProps {
      shouldRun?: string[];
      shouldDelete?: string[];
      run: string[];
      delete?: string[];
  }/**
   * Primitive component that can be used to interact with commands via the
   * OS shell to implement actions in Adapt.
   * @public
   */
  export declare class Command extends Action<CommandProps> {
      shouldAct(op: ChangeType, ctx: ActionContext): Promise<ShouldActDetail>;
      action(op: ChangeType, ctx: ActionContext): Promise<void>;
  }/**
   * Type guard for {@link action.ShouldActDetail}.
   * @public
   */
  export declare function isShouldActDetail(val: any): val is ShouldActDetail;/**
   * Transforms a {@link action.ShouldAct} into an {@link action.ShouldActDetail}.
   * @internal
   */
  export declare function toDetail(val: ShouldAct): {
      act: boolean;
      detail: string;
  };/**
   * Type guard for Action FinalDomElements.
   * @internal
   */
  export declare function isActionFinalElement(val: any): val is FinalDomElement;/**
   * Returns the component instance for an {@link action.Action} component.
   * @internal
   */
  export declare function getActionInstance(el: FinalDomElement): Action | null;/**
   * Detailed information on why an action should be taken.
   * @public
   */
  export declare interface ShouldActDetail {
      /**
       * True if the action should be performed.
       */
      act: boolean;
      /**
       * Explanation of why the action should be performed.
       */
      detail: string;
  }/**
   * Return type for {@link action.Action.shouldAct} that describes whether an
   * action should be taken and why.
   * @public
   */
  export declare type ShouldAct = false | ShouldActDetail;/**
   * Helper information for an {@link action.Action} component.
   * @public
   */
  export declare interface ActionContext {
      /** Various pieces of data about the current element and build cycle */
      buildData: BuildData;
      /** A location to put files that need to be persisted as state */
      dataDir: string;
      /** Interface to use for logging messages.  Prefer to using stderr or stdout */
      logger: MessageLogger;
  }/**
   * Component that can be inherited to perform actions during deploy
   *
   * @public
   */
  export declare class Action<P extends object = {}, S extends object = {}> extends PrimitiveComponent<P, S> {
      /**
       * Calculates whether or not any action is needed based on state/props/observation
       *
       * @returns false if no action needed, `{ act: true, detail: <user-facing description of action> }`.
       */
      shouldAct(_op: ChangeType, _ctx: ActionContext): ShouldAct | Promise<ShouldAct>;
      action(_op: ChangeType, _ctx: ActionContext): void | Promise<void>;
  }/**
   * Properties for the {@link action.Command | Command} component.
   * @public
   */
  export declare interface CommandProps {
      shouldRun?: string[];
      shouldDelete?: string[];
      run: string[];
      delete?: string[];
  }/**
   * Primitive component that can be used to interact with commands via the
   * OS shell to implement actions in Adapt.
   * @public
   */
  export declare class Command extends Action<CommandProps> {
      shouldAct(op: ChangeType, ctx: ActionContext): Promise<ShouldActDetail>;
      action(op: ChangeType, ctx: ActionContext): Promise<void>;
  }/**
   * Type guard for {@link action.ShouldActDetail}.
   * @public
   */
  export declare function isShouldActDetail(val: any): val is ShouldActDetail;/**
   * Transforms a {@link action.ShouldAct} into an {@link action.ShouldActDetail}.
   * @internal
   */
  export declare function toDetail(val: ShouldAct): {
      act: boolean;
      detail: string;
  };/**
   * Type guard for Action FinalDomElements.
   * @internal
   */
  export declare function isActionFinalElement(val: any): val is FinalDomElement;/**
   * Returns the component instance for an {@link action.Action} component.
   * @internal
   */
  export declare function getActionInstance(el: FinalDomElement): Action | null;/**
   * Detailed information on why an action should be taken.
   * @public
   */
  export declare interface ShouldActDetail {
      /**
       * True if the action should be performed.
       */
      act: boolean;
      /**
       * Explanation of why the action should be performed.
       */
      detail: string;
  }/**
   * Return type for {@link action.Action.shouldAct} that describes whether an
   * action should be taken and why.
   * @public
   */
  export declare type ShouldAct = false | ShouldActDetail;/**
   * Helper information for an {@link action.Action} component.
   * @public
   */
  export declare interface ActionContext {
      /** Various pieces of data about the current element and build cycle */
      buildData: BuildData;
      /** A location to put files that need to be persisted as state */
      dataDir: string;
      /** Interface to use for logging messages.  Prefer to using stderr or stdout */
      logger: MessageLogger;
  }/**
   * Component that can be inherited to perform actions during deploy
   *
   * @public
   */
  export declare class Action<P extends object = {}, S extends object = {}> extends PrimitiveComponent<P, S> {
      /**
       * Calculates whether or not any action is needed based on state/props/observation
       *
       * @returns false if no action needed, `{ act: true, detail: <user-facing description of action> }`.
       */
      shouldAct(_op: ChangeType, _ctx: ActionContext): ShouldAct | Promise<ShouldAct>;
      action(_op: ChangeType, _ctx: ActionContext): void | Promise<void>;
  }/**
   * Properties for the {@link action.Command | Command} component.
   * @public
   */
  export declare interface CommandProps {
      shouldRun?: string[];
      shouldDelete?: string[];
      run: string[];
      delete?: string[];
  }/**
   * Primitive component that can be used to interact with commands via the
   * OS shell to implement actions in Adapt.
   * @public
   */
  export declare class Command extends Action<CommandProps> {
      shouldAct(op: ChangeType, ctx: ActionContext): Promise<ShouldActDetail>;
      action(op: ChangeType, ctx: ActionContext): Promise<void>;
  }
}

export declare namespace aws {
/** @beta */
  export declare function isCFResourcePrimitiveElement(val: any): val is FinalDomElement<CFResourceProps>;/** @beta */
  export declare function CFResource(props: SFCDeclProps<CFResourceProps>): Adapt.JSX.Element;/** @beta */
  export declare interface AnyProperties {
      [propName: string]: any;
  }/** @beta */
  export declare interface CFResourceProps {
      Type: string;
      Properties: AnyProperties;
      cfStackHandle?: Handle;
      children?: any;
      /**
       * Set to true if CloudFormation or the underlying AWS resource does not
       * support tagging
       */
      tagsUnsupported?: boolean;
  }/** @beta */
  export declare class CFResourcePrimitive extends PrimitiveComponent<CFResourceProps> {
      deployedWhen: DeployedWhenMethod;
  }/** @beta */
  export declare function awsCredentialsContext(defaultCreds: AwsCredentialsProps): Adapt.Context<AwsCredentialsProps>;/** @beta */
  export declare function withCredentials<W extends Constructor<Component<any, any>>>(Wrapped: W, Ctx?: AwsCredentialsContext): (props: PropsType<W> & WithChildren) => Adapt.JSX.Element;/** @beta */
  export declare function loadAwsCreds(options?: AwsCredsOptions): Promise<AwsCredentials>;/** @beta */
  export declare interface AwsCredentialsProps {
      awsAccessKeyId: string;
      awsSecretAccessKey: string;
      awsRegion: string;
  }/** @beta */
  export declare interface WithCredentials {
      awsCredentials?: AwsCredentialsProps;
  }/** @beta */
  export declare type AwsCredentialsContext = Context<AwsCredentialsProps>;/** @beta */
  const awsDefaultCredentialsContext: Adapt.Context<AwsCredentialsProps>;/** @beta */
  export declare interface AwsCredentials {
      awsAccessKeyId: string;
      awsSecretAccessKey: string;
      awsRegion: string;
  }/** @beta */
  export declare interface AwsCredsOptions {
      credsFile?: string;
  }/** @beta */
  export declare interface EC2Props extends ComputeProps, WithChildren, WithCredentials {
      imageId: string;
      instanceType: string;
      sshKeyName: string;
      securityGroups: string[];
      userData?: string;
  }/** @beta */
  export declare interface EC2InstanceStatus extends Status, AWS.EC2.Instance {
  }/** @beta */
  const EC2Instance: (props: EC2Props & Adapt.WithChildren) => Adapt.JSX.Element;/** @beta */
  export declare interface EIPAssociationProps extends WithCredentials {
      AllocationId?: string;
      EIP?: string;
      InstanceId?: string | Handle;
      NetworkInterfaceId?: string;
      PrivateIpAddress?: string;
  }/** @beta */
  const EIPAssociation: (props: EIPAssociationProps & Adapt.WithChildren) => Adapt.JSX.Element;/** @beta */
  const EIPAssociation: (props: EIPAssociationProps & Adapt.WithChildren) => Adapt.JSX.Element;/** @beta */
  export declare function isCFResourcePrimitiveElement(val: any): val is FinalDomElement<CFResourceProps>;/** @beta */
  export declare function CFResource(props: SFCDeclProps<CFResourceProps>): Adapt.JSX.Element;/** @beta */
  export declare interface AnyProperties {
      [propName: string]: any;
  }/** @beta */
  export declare interface CFResourceProps {
      Type: string;
      Properties: AnyProperties;
      cfStackHandle?: Handle;
      children?: any;
      /**
       * Set to true if CloudFormation or the underlying AWS resource does not
       * support tagging
       */
      tagsUnsupported?: boolean;
  }/** @beta */
  export declare class CFResourcePrimitive extends PrimitiveComponent<CFResourceProps> {
      deployedWhen: DeployedWhenMethod;
  }/** @beta */
  export declare function awsCredentialsContext(defaultCreds: AwsCredentialsProps): Adapt.Context<AwsCredentialsProps>;/** @beta */
  export declare function withCredentials<W extends Constructor<Component<any, any>>>(Wrapped: W, Ctx?: AwsCredentialsContext): (props: PropsType<W> & WithChildren) => Adapt.JSX.Element;/** @beta */
  export declare function loadAwsCreds(options?: AwsCredsOptions): Promise<AwsCredentials>;/** @beta */
  export declare interface AwsCredentialsProps {
      awsAccessKeyId: string;
      awsSecretAccessKey: string;
      awsRegion: string;
  }/** @beta */
  export declare interface WithCredentials {
      awsCredentials?: AwsCredentialsProps;
  }/** @beta */
  export declare type AwsCredentialsContext = Context<AwsCredentialsProps>;/** @beta */
  const awsDefaultCredentialsContext: Adapt.Context<AwsCredentialsProps>;/** @beta */
  export declare interface AwsCredentials {
      awsAccessKeyId: string;
      awsSecretAccessKey: string;
      awsRegion: string;
  }/** @beta */
  export declare interface AwsCredsOptions {
      credsFile?: string;
  }/** @beta */
  export declare interface EC2Props extends ComputeProps, WithChildren, WithCredentials {
      imageId: string;
      instanceType: string;
      sshKeyName: string;
      securityGroups: string[];
      userData?: string;
  }/** @beta */
  export declare interface EC2InstanceStatus extends Status, AWS.EC2.Instance {
  }/** @beta */
  const EC2Instance: (props: EC2Props & Adapt.WithChildren) => Adapt.JSX.Element;/** @beta */
  export declare interface EIPAssociationProps extends WithCredentials {
      AllocationId?: string;
      EIP?: string;
      InstanceId?: string | Handle;
      NetworkInterfaceId?: string;
      PrivateIpAddress?: string;
  }/** @beta */
  const EIPAssociation: (props: EIPAssociationProps & Adapt.WithChildren) => Adapt.JSX.Element;/** @beta */
  const EIPAssociation: (props: EIPAssociationProps & Adapt.WithChildren) => Adapt.JSX.Element;/** @beta */
  export declare function isCFResourcePrimitiveElement(val: any): val is FinalDomElement<CFResourceProps>;/** @beta */
  export declare function CFResource(props: SFCDeclProps<CFResourceProps>): Adapt.JSX.Element;/** @beta */
  export declare interface AnyProperties {
      [propName: string]: any;
  }/** @beta */
  export declare interface CFResourceProps {
      Type: string;
      Properties: AnyProperties;
      cfStackHandle?: Handle;
      children?: any;
      /**
       * Set to true if CloudFormation or the underlying AWS resource does not
       * support tagging
       */
      tagsUnsupported?: boolean;
  }/** @beta */
  export declare class CFResourcePrimitive extends PrimitiveComponent<CFResourceProps> {
      deployedWhen: DeployedWhenMethod;
  }/** @beta */
  export declare function awsCredentialsContext(defaultCreds: AwsCredentialsProps): Adapt.Context<AwsCredentialsProps>;/** @beta */
  export declare function withCredentials<W extends Constructor<Component<any, any>>>(Wrapped: W, Ctx?: AwsCredentialsContext): (props: PropsType<W> & WithChildren) => Adapt.JSX.Element;/** @beta */
  export declare function loadAwsCreds(options?: AwsCredsOptions): Promise<AwsCredentials>;/** @beta */
  export declare interface AwsCredentialsProps {
      awsAccessKeyId: string;
      awsSecretAccessKey: string;
      awsRegion: string;
  }/** @beta */
  export declare interface WithCredentials {
      awsCredentials?: AwsCredentialsProps;
  }/** @beta */
  export declare type AwsCredentialsContext = Context<AwsCredentialsProps>;/** @beta */
  const awsDefaultCredentialsContext: Adapt.Context<AwsCredentialsProps>;/** @beta */
  export declare interface AwsCredentials {
      awsAccessKeyId: string;
      awsSecretAccessKey: string;
      awsRegion: string;
  }/** @beta */
  export declare interface AwsCredsOptions {
      credsFile?: string;
  }/** @beta */
  export declare interface EC2Props extends ComputeProps, WithChildren, WithCredentials {
      imageId: string;
      instanceType: string;
      sshKeyName: string;
      securityGroups: string[];
      userData?: string;
  }/** @beta */
  export declare interface EC2InstanceStatus extends Status, AWS.EC2.Instance {
  }/** @beta */
  const EC2Instance: (props: EC2Props & Adapt.WithChildren) => Adapt.JSX.Element;/** @beta */
  export declare interface EIPAssociationProps extends WithCredentials {
      AllocationId?: string;
      EIP?: string;
      InstanceId?: string | Handle;
      NetworkInterfaceId?: string;
      PrivateIpAddress?: string;
  }/** @beta */
  const EIPAssociation: (props: EIPAssociationProps & Adapt.WithChildren) => Adapt.JSX.Element;/** @beta */
  const EIPAssociation: (props: EIPAssociationProps & Adapt.WithChildren) => Adapt.JSX.Element;/** @beta */
  export declare function isCFResourcePrimitiveElement(val: any): val is FinalDomElement<CFResourceProps>;/** @beta */
  export declare function CFResource(props: SFCDeclProps<CFResourceProps>): Adapt.JSX.Element;/** @beta */
  export declare interface AnyProperties {
      [propName: string]: any;
  }/** @beta */
  export declare interface CFResourceProps {
      Type: string;
      Properties: AnyProperties;
      cfStackHandle?: Handle;
      children?: any;
      /**
       * Set to true if CloudFormation or the underlying AWS resource does not
       * support tagging
       */
      tagsUnsupported?: boolean;
  }/** @beta */
  export declare class CFResourcePrimitive extends PrimitiveComponent<CFResourceProps> {
      deployedWhen: DeployedWhenMethod;
  }/** @beta */
  export declare function awsCredentialsContext(defaultCreds: AwsCredentialsProps): Adapt.Context<AwsCredentialsProps>;/** @beta */
  export declare function withCredentials<W extends Constructor<Component<any, any>>>(Wrapped: W, Ctx?: AwsCredentialsContext): (props: PropsType<W> & WithChildren) => Adapt.JSX.Element;/** @beta */
  export declare function loadAwsCreds(options?: AwsCredsOptions): Promise<AwsCredentials>;/** @beta */
  export declare interface AwsCredentialsProps {
      awsAccessKeyId: string;
      awsSecretAccessKey: string;
      awsRegion: string;
  }/** @beta */
  export declare interface WithCredentials {
      awsCredentials?: AwsCredentialsProps;
  }/** @beta */
  export declare type AwsCredentialsContext = Context<AwsCredentialsProps>;/** @beta */
  const awsDefaultCredentialsContext: Adapt.Context<AwsCredentialsProps>;/** @beta */
  export declare interface AwsCredentials {
      awsAccessKeyId: string;
      awsSecretAccessKey: string;
      awsRegion: string;
  }/** @beta */
  export declare interface AwsCredsOptions {
      credsFile?: string;
  }/** @beta */
  export declare interface EC2Props extends ComputeProps, WithChildren, WithCredentials {
      imageId: string;
      instanceType: string;
      sshKeyName: string;
      securityGroups: string[];
      userData?: string;
  }/** @beta */
  export declare interface EC2InstanceStatus extends Status, AWS.EC2.Instance {
  }/** @beta */
  const EC2Instance: (props: EC2Props & Adapt.WithChildren) => Adapt.JSX.Element;/** @beta */
  export declare interface EIPAssociationProps extends WithCredentials {
      AllocationId?: string;
      EIP?: string;
      InstanceId?: string | Handle;
      NetworkInterfaceId?: string;
      PrivateIpAddress?: string;
  }/** @beta */
  const EIPAssociation: (props: EIPAssociationProps & Adapt.WithChildren) => Adapt.JSX.Element;/** @beta */
  const EIPAssociation: (props: EIPAssociationProps & Adapt.WithChildren) => Adapt.JSX.Element;/** @beta */
  export declare function isCFResourcePrimitiveElement(val: any): val is FinalDomElement<CFResourceProps>;/** @beta */
  export declare function CFResource(props: SFCDeclProps<CFResourceProps>): Adapt.JSX.Element;/** @beta */
  export declare interface AnyProperties {
      [propName: string]: any;
  }/** @beta */
  export declare interface CFResourceProps {
      Type: string;
      Properties: AnyProperties;
      cfStackHandle?: Handle;
      children?: any;
      /**
       * Set to true if CloudFormation or the underlying AWS resource does not
       * support tagging
       */
      tagsUnsupported?: boolean;
  }/** @beta */
  export declare class CFResourcePrimitive extends PrimitiveComponent<CFResourceProps> {
      deployedWhen: DeployedWhenMethod;
  }/** @beta */
  export declare function awsCredentialsContext(defaultCreds: AwsCredentialsProps): Adapt.Context<AwsCredentialsProps>;/** @beta */
  export declare function withCredentials<W extends Constructor<Component<any, any>>>(Wrapped: W, Ctx?: AwsCredentialsContext): (props: PropsType<W> & WithChildren) => Adapt.JSX.Element;/** @beta */
  export declare function loadAwsCreds(options?: AwsCredsOptions): Promise<AwsCredentials>;/** @beta */
  export declare interface AwsCredentialsProps {
      awsAccessKeyId: string;
      awsSecretAccessKey: string;
      awsRegion: string;
  }/** @beta */
  export declare interface WithCredentials {
      awsCredentials?: AwsCredentialsProps;
  }/** @beta */
  export declare type AwsCredentialsContext = Context<AwsCredentialsProps>;/** @beta */
  const awsDefaultCredentialsContext: Adapt.Context<AwsCredentialsProps>;/** @beta */
  export declare interface AwsCredentials {
      awsAccessKeyId: string;
      awsSecretAccessKey: string;
      awsRegion: string;
  }/** @beta */
  export declare interface AwsCredsOptions {
      credsFile?: string;
  }/** @beta */
  export declare interface EC2Props extends ComputeProps, WithChildren, WithCredentials {
      imageId: string;
      instanceType: string;
      sshKeyName: string;
      securityGroups: string[];
      userData?: string;
  }/** @beta */
  export declare interface EC2InstanceStatus extends Status, AWS.EC2.Instance {
  }/** @beta */
  const EC2Instance: (props: EC2Props & Adapt.WithChildren) => Adapt.JSX.Element;/** @beta */
  export declare interface EIPAssociationProps extends WithCredentials {
      AllocationId?: string;
      EIP?: string;
      InstanceId?: string | Handle;
      NetworkInterfaceId?: string;
      PrivateIpAddress?: string;
  }/** @beta */
  const EIPAssociation: (props: EIPAssociationProps & Adapt.WithChildren) => Adapt.JSX.Element;/** @beta */
  const EIPAssociation: (props: EIPAssociationProps & Adapt.WithChildren) => Adapt.JSX.Element;/** @beta */
  export declare function isCFResourcePrimitiveElement(val: any): val is FinalDomElement<CFResourceProps>;/** @beta */
  export declare function CFResource(props: SFCDeclProps<CFResourceProps>): Adapt.JSX.Element;/** @beta */
  export declare interface AnyProperties {
      [propName: string]: any;
  }/** @beta */
  export declare interface CFResourceProps {
      Type: string;
      Properties: AnyProperties;
      cfStackHandle?: Handle;
      children?: any;
      /**
       * Set to true if CloudFormation or the underlying AWS resource does not
       * support tagging
       */
      tagsUnsupported?: boolean;
  }/** @beta */
  export declare class CFResourcePrimitive extends PrimitiveComponent<CFResourceProps> {
      deployedWhen: DeployedWhenMethod;
  }/** @beta */
  export declare function awsCredentialsContext(defaultCreds: AwsCredentialsProps): Adapt.Context<AwsCredentialsProps>;/** @beta */
  export declare function withCredentials<W extends Constructor<Component<any, any>>>(Wrapped: W, Ctx?: AwsCredentialsContext): (props: PropsType<W> & WithChildren) => Adapt.JSX.Element;/** @beta */
  export declare function loadAwsCreds(options?: AwsCredsOptions): Promise<AwsCredentials>;/** @beta */
  export declare interface AwsCredentialsProps {
      awsAccessKeyId: string;
      awsSecretAccessKey: string;
      awsRegion: string;
  }/** @beta */
  export declare interface WithCredentials {
      awsCredentials?: AwsCredentialsProps;
  }/** @beta */
  export declare type AwsCredentialsContext = Context<AwsCredentialsProps>;/** @beta */
  const awsDefaultCredentialsContext: Adapt.Context<AwsCredentialsProps>;/** @beta */
  export declare interface AwsCredentials {
      awsAccessKeyId: string;
      awsSecretAccessKey: string;
      awsRegion: string;
  }/** @beta */
  export declare interface AwsCredsOptions {
      credsFile?: string;
  }/** @beta */
  export declare interface EC2Props extends ComputeProps, WithChildren, WithCredentials {
      imageId: string;
      instanceType: string;
      sshKeyName: string;
      securityGroups: string[];
      userData?: string;
  }/** @beta */
  export declare interface EC2InstanceStatus extends Status, AWS.EC2.Instance {
  }/** @beta */
  const EC2Instance: (props: EC2Props & Adapt.WithChildren) => Adapt.JSX.Element;/** @beta */
  export declare interface EIPAssociationProps extends WithCredentials {
      AllocationId?: string;
      EIP?: string;
      InstanceId?: string | Handle;
      NetworkInterfaceId?: string;
      PrivateIpAddress?: string;
  }/** @beta */
  const EIPAssociation: (props: EIPAssociationProps & Adapt.WithChildren) => Adapt.JSX.Element;/** @beta */
  const EIPAssociation: (props: EIPAssociationProps & Adapt.WithChildren) => Adapt.JSX.Element;
}

/**
 * A command to be used when creating a {@link Container}.
 *
 * @remarks
 * See the
 * {@link https://docs.docker.com/engine/api/v1.40/#operation/ContainerCreate | Docker API Reference}
 * for more information.
 * @public
 */
export declare type Command = string | string[];

/**
 * Abstract element to represent a computational resource
 *
 * @beta
 */
export declare abstract class Compute extends Component<ComputeProps, {}> {
}

/**
 * Props for a {@link Compute} element
 *
 * @beta
 */
export declare interface ComputeProps extends WithChildren {
    name?: string;
    ip?: string;
}

/**
 * Config for {@link ContainerStatus}
 * @public
 */
export declare interface Config {
    Hostname: string;
    Domainname: string;
    User: string;
    AttachStdin: boolean;
    AttachStdout: boolean;
    AttachStderr: boolean;
    Tty: boolean;
    OpenStdin: boolean;
    StdinOnce: boolean;
    Env: string[];
    Cmd: string[];
    ArgsEscaped: boolean;
    Image: string;
    Volumes: FIXME_NeedsProperType;
    WorkingDir: string;
    Entrypoint: FIXME_NeedsProperType;
    OnBuild: FIXME_NeedsProperType;
    Labels: ContainerLabels;
    StopSignal: FIXME_NeedsProperType;
    ExposedPorts: null | {
        [port: string]: {};
    };
}

/**
 * Components that provide a service, such as a database service or API
 * service, can implement this interface in order to supply all the information
 * required to connect to the service.
 *
 * @remarks
 * Currently, the only method supported for providing connection information
 * is via environment variables. However, additional formats for providing
 * connection information will be added as needs arise.
 * @public
 */
export declare interface ConnectToInstance {
    /**
     * Supplies the set of environment variables that have all the information
     * needed for a consumer of a service to connect to the provider.
     *
     * @param scope - Scope for which connection information is desired
     * @returns Environment with connection information, undefined if info not yet ready.
     *
     * @remarks
     * This may include information like network hostname(s), port(s),
     * credentials, namespace, or any other service-specific information.
     *
     * In cases where the service has not been deployed yet or the
     * connection information is not yet available for any reason, the
     * method will return `undefined`.
     *
     * If a scope for which there will never be connection information is
     * requested, this method should throw an appropriate error.  For example
     * if `NetworkScope.external` is requested for a service only reachable
     * from within a cluster, this method should throw.
     *
     * Providers are discouraged from using environment variable names
     * that are too generic or are likely to conflict with other environment
     * variables that may already be in use. For example, avoid names like
     * `HOST` and `USERNAME`. Instead, use names that are likely to be
     * unique to the type of service so that a consumer can
     * use more than one type of service without causing naming conflicts.
     *
     * Providers are encouraged to use environment variable names that are
     * typically used by consumers of the service. For example, the provider
     * of a Postgres database service should use the names `PGHOST` and
     * `PGUSER`, which are defined in the Postgres documentation and
     * are typically supported by most Postgres database clients.
     *
     * Providers should never return partial information. Return `undefined`
     * until all required connection information is available.
     */
    connectEnv(scope?: NetworkScope): Environment | undefined;
}

/**
 * Abstract component representing a container.
 * @public
 */
export declare abstract class Container extends PrimitiveComponent<ContainerProps> {
    static defaultProps: {
        autoRemove: boolean;
        ports: never[];
        stdinOpen: boolean;
        tty: boolean;
        portBindings: {};
        environment: {};
        links: {};
        imagePullPolicy: string;
    };
    static displayName: string;
}

/**
 * Labels for a {@link Container}
 * @public
 */
export declare interface ContainerLabels {
    [name: string]: string;
}

/**
 * Network for {@link ContainerStatus}
 * @public
 */
export declare interface ContainerNetwork {
    IPAMConfig: FIXME_NeedsProperType;
    Links: FIXME_NeedsProperType;
    Aliases: FIXME_NeedsProperType;
    NetworkID: string;
    EndpointID: string;
    Gateway: string;
    IPAddress: string;
    IPPrefixLen: number;
    IPv6Gateway: string;
    GlobalIPv6Address: string;
    GlobalIPv6PrefixLen: number;
    MacAddress: string;
    DriverOpts: FIXME_NeedsProperType;
}

/**
 * NetworkSettings for {@link ContainerStatus}
 * @public
 */
export declare interface ContainerNetworkSettings {
    Bridge: FIXME_NeedsProperType;
    SandboxID: string;
    HairpinMode: boolean;
    LinkLocalIPv6Address: string;
    LinkLocalIPv6PrefixLen: number;
    Ports: FIXME_NeedsProperType;
    SandboxKey: string;
    SecondaryIPAddresses: FIXME_NeedsProperType;
    SecondaryIPv6Addresses: FIXME_NeedsProperType;
    EndpointID: string;
    Gateway: string;
    GlobalIPv6Address: string;
    GlobalIPv6PrefixLen: number;
    IPAddress: string;
    IPPrefixLen: number;
    IPv6Gateway: string;
    MacAddress: string;
    Networks: {
        [name: string]: ContainerNetwork;
    };
}

/**
 * Props for the {@link Container} component.
 *
 * @remarks
 * See the
 * {@link https://docs.docker.com/engine/api/v1.40/#operation/ContainerCreate | Docker API Reference}
 * for more information.
 * @public
 */
export declare interface ContainerProps {
    name: string;
    dockerHost?: string;
    image: ImageId;
    autoRemove?: boolean;
    ports?: PortDescription[];
    stdinOpen?: boolean;
    stopSignal?: string;
    tty?: boolean;
    command?: Command;
    portBindings?: PortBinding;
    environment?: Environment;
    links?: Links;
    entrypoint?: Command;
    /**
     * The behavior to apply when the container exits.
     * @remarks
     * See {@link RestartPolicy} and {@link RestartPolicyName} for the
     * possible values and corresponding behavior.
     * @defaultValue The default is `{ name: "Never" }`, which does not
     * restart the container.
     */
    restartPolicy?: RestartPolicy;
    workingDir?: string;
    imagePullPolicy?: "Always" | "Never" | "IfNotPresent";
}

/**
 * State information for a {@link Container}.
 * @public
 */
export declare interface ContainerState {
    Status: string;
    Running: boolean;
    Paused: boolean;
    Restarting: boolean;
    OOMKilled: boolean;
    Dead: boolean;
    Pid: number;
    ExitCode: number;
    Error: string;
    StartedAt: string;
    FinishedAt: string;
}

/**
 * Status of a {@link Container}.
 * @public
 */
export declare interface ContainerStatus {
    Id: string;
    Created: string;
    Path: string;
    Args: string[];
    State: ContainerState;
    Image: string;
    ResolvConfPath: string;
    HostnamePath: string;
    HostsPath: string;
    Node: FIXME_NeedsProperType;
    Name: string;
    RestartCount: number;
    Driver: string;
    MountLabel: string;
    ProcessLabel: string;
    AppArmorProfile: string;
    ExecIDs: string;
    HostConfig: HostConfigStatus;
    GraphDriver: FIXME_NeedsProperType;
    SizeRw: number;
    SizeRootFs: number;
    Mounts: MountStatus[];
    Config: Config;
    NetworkSettings: ContainerNetworkSettings;
}

export declare namespace docker {
/**
   * Props for {@link docker.BuildKitImage}
   *
   * @public
   */
  export declare interface BuildKitImageProps {
      /** Directory for use as the build context */
      contextDir?: string;
      /**
       * Contents of the dockerfile
       *
       * @remarks
       * Should not be used if dockerfileName is set
       */
      dockerfile?: string;
      /**
       * Path to a local Dockerfile in the Adapt project.
       *
       * @remarks
       * This path is relative to the root of the Adapt project.
       * Should not be used if `dockerfile` is set.
       */
      dockerfileName?: string;
      /**
       * Extra files that should be included during the docker build
       *
       * @remarks
       * BuildKitImage uses a multi-stage build process.  It first creates
       * a temporary image that includes the files specified in this field.
       * This temporary image is then made available to the `dockerfile` with
       * stage name `files` and can then be copied into the final image, as
       * desired, using `COPY` or `ADD` commands in the `dockerfile`.
       *
       * @example
       * To create a final Docker image that contains a file that has some
       * programmatically created content, use the `dockerfile` prop along
       * with the `files` prop like this:
       * ```tsx
       * const files = [{
       *   path: '/path/to/myfile.txt',
       *   contents: 'contents for myfile\n'
       * }];
       * const dockerfile = `
       *   FROM alpine
       *   COPY --from=files /path/to/myfile.txt /app/myfile.txt
       *   ...
       * `;
       * return <BuildKitImage files={files} dockerfile={dockerfile} />
       * ```
       */
      files?: File[];
      /**
       * Options to control the behavior of docker build
       */
      options?: BuildKitBuildOptions;
      /**
       * Directs BuildKit where to store the built image.
       */
      output: BuildKitOutput;
      /**
       * Extra stages to include in a multi-stage docker build
       */
      stages?: Stage[];
  }/**
   * @internal
   */
  export declare interface BuildKitImageState {
      deployOpID?: DeployOpID;
      image?: WithId<ImageRefRegistry>;
      imagePropsJson?: string;
      prevUniqueNameTag?: string;
  }/**
   * Locally builds a docker image
   *
   * @remarks
   * See {@link docker.BuildKitImageProps}.
   *
   * @public
   */
  export declare class BuildKitImage extends Action<BuildKitImageProps, BuildKitImageState> implements DockerPushableImageInstance {
      static defaultProps: {
          options: {};
      };
      deployedWhenIsTrivial: boolean;
      private image_?;
      private imagePropsJson_?;
      private options_;
      constructor(props: BuildKitImageProps);
      buildComplete(): boolean;
      ready(): boolean;
      image(): WithId<ImageRefRegistry> | undefined;
      pushTo({ ref }: {
          ref: string;
      }): Promise<undefined | WithId<ImageRefRegistry>>;
      latestImage(): WithId<ImageRefRegistry> | undefined;
      /**
       * User-facing name to display in status messages.
       */
      displayName(): string;
      /**
       * Implementations for Action base class
       * @internal
       */
      shouldAct(op: ChangeType): Promise<ShouldAct>;
      /**
       * Implementations for Action base class
       * @internal
       */
      action(op: ChangeType, ctx: ActionContext): Promise<void>;
      /** @internal */
      initialState(): {};
      /** @internal */
      deployedWhen: (goalStatus: GoalStatus) => true | import("@adpt/core").Waiting;
      /** @internal */
      protected get imagePropsJson(): string;
  }/**
   * Components that provide a Docker image can implement this interface to
   * allow other components to get information about the Docker image.
   * @public
   */
  export declare interface DockerImageInstance {
      /**
       * Returns information about the version of the Docker image that reflects
       * the current set of props for the component.
       * @remarks
       * Returns undefined if no image has ever been built by
       * this component OR if the component props have changed and the image
       * that corresponds to the current props has not yet been built.
       */
      image(): ImageRef | undefined;
      /**
       * Returns information about the most current version of the Docker image
       * that has completed building, even if that version does not reflect the
       * current set of props for the component.
       * @remarks
       * Returns undefined if no image has ever been built by this component.
       */
      latestImage(): ImageRef | undefined;
      /**
       * Pushes the image returned by `latestImage` to a Docker registry.
       *
       * @param ref - A docker domain, path components, and tag to which this image should be pushed
       *
       * @remarks
       * If there is no latest image available (`latestImage` returns
       * undefined), then `pushTo` will return undefined. Otherwise, if the
       * push was successful, returns an {@link docker.ImageRefRegistry} that contains
       * the complete nameTag, including registry portion.
       */
      pushTo?({ ref }: {
          ref: NameTagString;
      }): MaybePromise<ImageRefRegistry | undefined>;
  }/**
   * Components that provide a Docker image can implement this interface to
   * allow other components to get information about the Docker image and
   * to be able to push the image to a registry.
   * @public
   */
  export declare interface DockerPushableImageInstance extends DockerImageInstance {
      /**
       * {@inheritdoc docker.DockerImageInstance.pushTo}
       */
      pushTo({ ref }: {
          ref: NameTagString;
      }): MaybePromise<ImageRefRegistry | undefined>;
  }/**
   * Props for {@link docker.DockerImage}.
   * @beta
   */
  export declare interface DockerImageProps {
  }/**
   * Abstract component representing a {@link https://docker.com | Docker}
   * image that can be used to create containers.
   * @remarks
   * See also {@link Container}.
   * @beta
   */
  export declare abstract class DockerImage extends Component<DockerImageProps> implements DockerImageInstance {
      /**
       * {@inheritdoc docker.DockerImageInstance.image}
       */
      image(): ImageRef | undefined;
      /**
       * {@inheritdoc docker.DockerImageInstance.latestImage}
       */
      latestImage(): ImageRef | undefined;
  }/**
   * Compute the status of a container based on a graphQL schema
   *
   * @internal
   */
  export declare function containerStatus(observe: ObserveForStatus, containerName: string, dockerHost: string): Promise<ContainerStatus | NoStatus>;/** @public */
  export declare interface DockerContainerStatus extends ContainerStatus {
  }/**
   * Compute a unique name for the container
   *
   * @internal
   */
  const computeContainerName: (elemKey: string, elemID: string, deployID: string) => string;/**
   * Component to instantiate an image container with docker
   *
   * @remarks
   * See {@link docker.DockerContainerProps}.
   *
   * @public
   */
  declare class DockerContainer extends Action<DockerContainerProps, DockerContainerState> {
      static defaultProps: {
          dockerHost: string;
          privileged: boolean;
      };
      info?: ContainerInfo;
      dependsOn: DependsOnMethod;
      /** @internal */
      shouldAct(diff: ChangeType, context: ActionContext): Promise<false | ShouldAct>;
      /** @internal */
      action(diff: ChangeType, context: ActionContext): Promise<void>;
      status(observe: ObserveForStatus, buildData: BuildData): Promise<NoStatus | ContainerStatus>;
      /**
       * Get the IP address of the container, optionally for a specific Docker
       * network.
       * @remarks
       * The IP addresses that are returned by this function are valid only
       * on the associated Docker network, which is often only associated
       * with a single host node for most Docker network types.
       *
       * @param network - Name of a Docker network. If `network` is provided
       * and the container is connected to the network with an IP address, that
       * address will be returned. If the container is not connected to the
       * network, `undefined` will be returned. If `network` is not provided,
       * the default container IP address will be returned.
       *
       * @beta
       */
      dockerIP(network?: string): string | undefined;
      /** @internal */
      initialState(): {};
      private displayName;
      private refreshContainerInfo;
  }/**
   * Component to instantiate an image container with docker
   *
   * @remarks
   * See {@link docker.DockerContainerProps}.
   *
   * @public
   */
  declare class DockerContainer extends Action<DockerContainerProps, DockerContainerState> {
      static defaultProps: {
          dockerHost: string;
          privileged: boolean;
      };
      info?: ContainerInfo;
      dependsOn: DependsOnMethod;
      /** @internal */
      shouldAct(diff: ChangeType, context: ActionContext): Promise<false | ShouldAct>;
      /** @internal */
      action(diff: ChangeType, context: ActionContext): Promise<void>;
      status(observe: ObserveForStatus, buildData: BuildData): Promise<NoStatus | ContainerStatus>;
      /**
       * Get the IP address of the container, optionally for a specific Docker
       * network.
       * @remarks
       * The IP addresses that are returned by this function are valid only
       * on the associated Docker network, which is often only associated
       * with a single host node for most Docker network types.
       *
       * @param network - Name of a Docker network. If `network` is provided
       * and the container is connected to the network with an IP address, that
       * address will be returned. If the container is not connected to the
       * network, `undefined` will be returned. If `network` is not provided,
       * the default container IP address will be returned.
       *
       * @beta
       */
      dockerIP(network?: string): string | undefined;
      /** @internal */
      initialState(): {};
      private displayName;
      private refreshContainerInfo;
  }/**
   * Type guard for determining whether a given object has a non-null `id`
   * property.
   * @public
   */
  export declare function hasId<T extends {
      id?: ImageIdString;
  }>(o: T): o is WithId<T>;/**
   * Factory function for creating a {@link docker.MutableImageRef}.
   * @remarks
   * Can also be used to clone an existing {@link docker.MutableImageRef} or
   * to create a mutable version of an existing {@link docker.ImageRef}.
   * @public
   */
  export declare function mutableImageRef(ref: ImageNameString, normalize?: boolean): MutableImageRef;/**
   * Factory function for creating a {@link docker.MutableImageRef}.
   * @remarks
   * Can also be used to clone an existing {@link docker.MutableImageRef} or
   * to create a mutable version of an existing {@link docker.ImageRef}.
   * @public
   */
  export declare function mutableImageRef(info?: ImageRefData): MutableImageRef;/**
   * Factory function for creating a {@link docker.ImageRef} or cloning an
   * existing one.
   * @public
   */
  export declare function imageRef(ref: ImageNameString, normalize?: boolean): ImageRef;/**
   * Factory function for creating a {@link docker.ImageRef} or cloning an
   * existing one.
   * @public
   */
  export declare function imageRef(info?: ImageRefData): ImageRef;/**
   * A type guard for determining whether a {@link docker.ImageRef} is a
   * {@link docker.ImageRefRegistry}.
   * @public
   */
  export declare function isImageRefRegistry(ref: ImageRef): ref is ImageRefRegistry;/**
   * A type guard for determining whether a {@link docker.ImageRef} is a
   * {@link docker.ImageRefRegistry} that has the `id` property set.
   * @public
   */
  export declare function isImageRefRegistryWithId(ref: ImageRef): ref is WithId<ImageRefRegistry>;/**
   * A type guard for determining whether a {@link docker.ImageRef} is a
   * {@link docker.ImageRefDockerHost}.
   * @public
   */
  export declare function isImageRefDockerhost(ref: ImageRef): ref is ImageRefDockerHost;/**
   * A type guard for determining whether a {@link docker.ImageRef} is a
   * {@link docker.ImageRefDockerHost} that has the `id` property set.
   * @public
   */
  export declare function isImageRefDockerhostWithId(ref: ImageRef): ref is WithId<ImageRefDockerHost>;/**
   * The most basic components that make up a {@link docker.ImageRef}.
   * All other properties of a {@link docker.ImageRef} can be computed from
   * these.
   * @remarks
   * See also {@link docker.ImageRef} for more information on references.
   * @public
   */
  export declare interface ImageRefData {
      /**
       * Image digest in the form `algorithm:hex`
       * @example
       * sha256:04696b491e0cc3c58a75bace8941c14c924b9f313b03ce5029ebbc040ed9dcd9
       */
      digest?: string;
      /**
       * Docker host string to contact the Docker daemon where this image is
       * located.
       *
       * @remarks
       * This should be in the same format that Docker expects for the `DOCKER_HOST`
       * environment variable. The special string `default` can also be used,
       * which will use the current value of the `DOCKER_HOST` environment variable,
       * if it is set and will otherwise use the default named pipe on Windows
       * (`npipe:///./pipe/docker_engine`) and the default socket on other
       * systems (`unix:///var/run/docker.sock`).
       * @example
       * tcp://localhost:2375
       */
      dockerHost?: "default" | string;
      /**
       * Hostname and optional port number of the container image registry where
       * this image is located.
       * @example
       * docker.io
       * @example
       * localhost:5000
       */
      domain?: RegistryString;
      /**
       * Image content ID in the form `algorithm:hex`
       * @example
       * sha256:199e537da3a86126cd6eb114bd0b13ab178dc291bbb6ea4a4a3aa257b2366b71
       */
      id?: ImageIdString;
      /**
       * The image repo path.
       * @example
       * google/cloud-sdk
       */
      path?: string;
      /**
       * Image tag
       * @example
       * latest
       */
      tag?: string;
  }/**
   * The type of an image reference indicates how the image can be
   * accessed, currently either through a Docker host (daemon) or directly to a
   * container registry via its API.
   *
   * @remarks
   * If not enough information is present to access and uniquely identify a
   * container image, the type is `incomplete`.
   * @public
   */
  export declare type ImageRefType = "incomplete" | "registry" | "dockerhost";/**
   * An immutable reference to a container image, including all information
   * known about the image.
   *
   * @remarks
   * This type is the base type for an image reference and is allowed to
   * contain partial or incomplete information about a container image.
   * It can include both information about how to access the image and
   * also information about the image itself.
   *
   * Many of the properties of {@link docker.ImageRef} are related to the
   * container image reference string used by Docker and other container-based
   * systems. A container image reference string is a structured string
   * containing multiple components. The most basic components are illustrated
   * below, using the example image reference string
   * `"my.registry:5000/a/repo/path:sometag@sha256:899a03e9816e5283edba63d"`.
   *
   * NOTE: The length of the `digest` has been shortened for formatting
   * purposes.
   *
   * ```
   * "my.registry:5000/a/repo/path:sometag@sha256:899a03e9816e5283edba63d"
   * |     domain     |   path    |  tag  |         digest               |
   * ```
   *
   * To aid in correct formatting, {@link docker.ImageRef} and related types and
   * classes also provide helper properties that combine these basic components
   * into combinations that are often useful, such as `name`, which is the
   * `domain` and `path` combined with a `/`.
   *
   * Many tools, such as the Docker UI, also accept a shortened form of a string
   * reference, called the `familiar` form. An example of a familiar reference is
   * `ubuntu`. In this form, only the `path` component is required. When
   * components of the reference are left out, default values are assumed. The
   * default `domain` is `docker.io` and the default `tag` is `latest`.
   * Additionally, if the `domain` is `docker.io` and there are no `/` characters
   * in the `path`, `library/` is prepended to the path. So `ubuntu` is the
   * familiar form for the complete reference `docker.io/library/ubuntu:latest`.
   *
   * An {@link docker.ImageRef} is designed to hold as much information about
   * an image as may be available and therefore some properties that are
   * not known will be `undefined`.
   *
   * See also {@link docker.MutableImageRef}, which can be used to parse
   * reference strings and construct or modify image references.
   * @public
   */
  export declare interface ImageRef extends Readonly<ImageRefData> {
      /**
       * The complete string reference for this image in familiar form, which
       * leaves out certain fields from the reference when they are set to
       * default values.
       * @remarks
       * This reference form is the form typically used in the Docker UI.
       * If the ImageRef is not complete, familiar will return `undefined`, as
       * the correct familiar representation cannot be determined.
       * @example
       * mysql
       * @example
       * gcr.io/my-project/image:1.0.1
       */
      readonly familiar?: string;
      /**
       * The image name, which is comprised of the optional domain and
       * the (non-optional) path. Will be `undefined` if there is no `path`.
       * @example
       * gcr.io/my-project/image
       */
      readonly name?: string;
      /**
       * The image name (including any registry) and image tag. Returns undefined
       * if either path or tag are not set.
       * If nameTag is set to a string that does not contain a tag (i.e. does
       * not include a ":"), the default tag of `latest` will be set.
       * To set nameTag without defaulting to `latest`, call the class method
       * `setNameTag` with the parameter `useDefaultTag` set to `false`.
       * @example
       * gcr.io/my-project/image:1.0.1
       */
      readonly nameTag?: string;
      /**
       * The image path (not including any registry) and image tag. Returns
       * undefined if either `path` or `tag` are not set.
       * @example
       * my-project/image:1.0.1
       */
      readonly pathTag?: string;
      /**
       * The best (most specific and complete) string reference for this image,
       * given the information available in this {@link docker.ImageRef}.
       */
      readonly ref: string;
      /**
       * An alias for `domain`.
       */
      readonly registry?: string;
      /**
       * The best remote reference available for this image in either
       * `domain/path@digest` format or `domain/path:tag` format.
       * @remarks
       * Returns `registryDigest` if it is set, otherwise returns `registryTag`.
       * If no remote reference is available, returns undefined.
       * @example
       * gcr.io/my-project/image\@sha256:899a03e9816e5283edba63d71ea528cd83576b28a7586cf617ce78af5526f209
       * @example
       * gcr.io/my-project/image:1.0.1
       */
      readonly registryRef?: string;
      /**
       * The remote digest reference in `domain/path@digest` form.
       * @remarks
       * Undefined if any of `domain`, `path`, or `digest` are unset.
       * @example
       * gcr.io/my-project/image\@sha256:899a03e9816e5283edba63d71ea528cd83576b28a7586cf617ce78af5526f209
       */
      readonly registryDigest?: string;
      /**
       * The remote tag reference in `domain/path:tag` form.
       * @remarks
       * Undefined if any of `domain`, `path`, or `tag` are unset.
       * @example
       * gcr.io/my-project/image:1.0.1
       */
      readonly registryTag?: string;
      /**
       * The type of an image reference indicates how the image can be
       * accessed, either through a Docker host (daemon) or directly to a
       * container registry.
       *
       * @remarks
       * A reference is a valid `dockerhost` type ref when it contains a valid
       * dockerHost string and either:
       * - A valid image id or
       * - A valid path and either a valid tag or digest.
       *
       * A reference is a valid `registry` type ref when it contains a valid
       * domain, path, and either a tag or a digest.
       *
       * If not enough information is present to access and uniquely identify a
       * container image, the type is `incomplete`.
       */
      readonly type: ImageRefType;
  }/**
   * Helper type that augments a base type to indicate that the `id` field
   * is present and has a valid image ID.
   * @public
   */
  export declare type WithId<T> = T & {
      id: ImageIdString;
  };/**
   * A mutable reference to a container image that can be used to parse,
   * construct, and modify an image reference, as well as to hold information
   * about the image and how to access it.
   *
   * @remarks
   * This class can be used to parse strings that contain complete or partial
   * container image references. It can also be used to construct an image
   * reference from scratch, from individual component parts, or from another
   * reference, then to correctly format the reference or its components for
   * use with various tools.
   *
   * To parse and normalize a "familiar" image reference, like is typically
   * seen in the Docker UI:
   * ```ts
   * const ref = mutableImageRef("redis", true);
   * console.log(ref.tag);         // => "latest"
   * console.log(ref.registryRef); // => "docker.io/library/redis:latest"
   * ```
   *
   * To construct a reference to an image present on the local Docker daemon
   * that has an image ID:
   * ```ts
   * const ref = mutableImageRef({
   *     dockerHost: "default",
   *     path: "myimage",
   *     tag: "just-built",
   *     id: "sha256:04696b491e0cc3c58a75bace8941c14c924b9f313b03ce5029ebbc040ed9dcd9",
   * });
   * ```
   *
   * To convert a `MutableImageRef` to an immutable plain object `ImageRef`,
   * use the `freeze` method.
   * @public
   */
  export declare class MutableImageRef implements ImageRef {
      _digest?: string;
      _dockerHost?: string;
      _domain?: string;
      _id?: ImageIdString;
      _path?: string;
      _tag?: string;
      constructor(ref: ImageNameString, normalize?: boolean);
      constructor(info?: ImageRefData | undefined);
      freeze(): ImageRef;
      toData(): ImageRefData;
      toJSON(): ImageRefData;
      /**
       * The digest string for this image in its associated registry and repo
       * in the form `algorithm:hex`.
       */
      get digest(): string | undefined;
      set digest(digest: string | undefined);
      get dockerHost(): string | undefined;
      set dockerHost(dockerHost: string | undefined);
      /**
       * The hostname and optional port of the image registry for this image.
       */
      get domain(): string | undefined;
      set domain(domain: string | undefined);
      /**
       * The complete string reference for this image in familiar form, which
       * leaves out certain fields from the reference when they are set to
       * default values.
       * @remarks
       * This reference form is the form typically used in the Docker UI.
       * If the ImageRef is not complete, familiar will return `undefined`, as
       * the correct familiar representation cannot be determined.
       */
      get familiar(): string | undefined;
      /**
       * The content ID of the image in `algorithm:hex` format.
       */
      get id(): ImageIdString | undefined;
      set id(id: ImageIdString | undefined);
      /**
       * The image name, which is comprised of the optional domain and
       * the (non-optional) path.
       */
      get name(): string | undefined;
      set name(name: string | undefined);
      /**
       * The image name (including any registry) and image tag. Returns undefined
       * if either path or tag are not set.
       * If nameTag is set to a string that does not contain a tag (i.e. does
       * not include a ":"), the default tag of `latest` will be set.
       * To set nameTag without defaulting to `latest`, call the class method
       * `setNameTag` with the parameter `useDefaultTag` set to `false`.
       */
      get nameTag(): NameTagString | undefined;
      set nameTag(nt: NameTagString | undefined);
      /**
       * Method to set the image name and image tag which also allows choice
       * of default behavior when `nameTag` does not contain a tag string.
       */
      setNameTag(nameTag: NameTagString | undefined, useDefaultTag?: boolean): void;
      /**
       * The image repo path.
       */
      get path(): string | undefined;
      set path(path: string | undefined);
      /**
       * The image path (not including any registry) and image tag. Returns
       * undefined if either path or tag are not set.
       * If pathTag is set to a string that does not contain a tag (i.e. does
       * not include a ":"), the default tag of `latest` will be set.
       * To set pathTag without defaulting to `latest`, call the class method
       * `setPathTag` with the parameter `useDefaultTag` set to `false`.
       */
      get pathTag(): string | undefined;
      set pathTag(pathTag: string | undefined);
      /**
       * Method to set the image path and image tag which also allows choice
       * of default behavior when `pathTag` does not contain a tag string.
       */
      setPathTag(pathTag: string | undefined, useDefaultTag?: boolean): void;
      get ref(): string;
      /**
       * Alias for domain
       */
      get registry(): string | undefined;
      /**
       * The best remote reference available for this image in either
       * `domain/path@digest` format or `domain/path:tag` format.
       * @remarks
       * Returns `registryDigest` if it is set, otherwise returns `registryTag`.
       * If no remote reference is available, returns undefined.
       */
      get registryRef(): ImageNameString | undefined;
      /**
       * The remote digest reference in `domain/path@digest` form.
       * @remarks
       * Undefined if any of `domain`, `path`, or `digest` are unset.
       */
      get registryDigest(): RepoDigestString | undefined;
      set registryDigest(rd: RepoDigestString | undefined);
      /**
       * The remote tag reference in `domain/path:tag` form.
       * @remarks
       * Undefined if any of `domain`, `path`, or `tag` are unset.
       */
      get registryTag(): NameTagString | undefined;
      set registryTag(rt: NameTagString | undefined);
      /**
       * The image tag.
       */
      get tag(): string | undefined;
      set tag(tag: string | undefined);
      /**
       * The type of an image reference indicates how the image can be
       * accessed, either through a Docker host (daemon) or directly to a
       * container registry.
       *
       * @remarks
       * A reference is a valid `dockerhost` type ref when it contains a valid
       * dockerHost string and either:
       * - A valid image id or
       * - A valid path and either a valid tag or digest.
       *
       * A reference is a valid `registry` type ref when it contains a valid
       * domain, path, and either a tag or a digest.
       *
       * If not enough information is present to access and uniquely identify a
       * container image, the type is `incomplete`.
       */
      get type(): ImageRefType;
  }/**
   * A more specific type of {@link docker.ImageRef} that contains sufficient
   * information to uniquely identify an image on a container registry.
   * @public
   */
  export declare interface ImageRefRegistry {
      readonly digest?: string;
      readonly domain: string;
      readonly familiar: string;
      readonly id?: ImageIdString;
      readonly name: string;
      readonly nameTag?: string;
      readonly path: string;
      readonly pathTag?: string;
      readonly ref: string;
      readonly registry: string;
      readonly registryRef: string;
      readonly registryDigest?: string;
      readonly registryTag?: string;
      readonly tag?: string;
      readonly type: "registry";
  }/**
   * A more specific type of {@link docker.ImageRef} that contains sufficient
   * information to uniquely identify an image on a specific Docker host
   * (daemon).
   * @public
   */
  export declare interface ImageRefDockerHost {
      readonly digest?: string;
      readonly dockerHost: string;
      readonly domain?: string;
      readonly familiar: string;
      readonly id?: ImageIdString;
      readonly name: string;
      readonly nameTag?: string;
      readonly path: string;
      readonly pathTag?: string;
      readonly ref: string;
      readonly registry?: string;
      readonly registryRef?: string;
      readonly registryDigest?: string;
      readonly registryTag?: string;
      readonly tag?: string;
      readonly type: "dockerhost";
  }/**
   * Docker network service component, compatible with the abstract
   * {@link NetworkService} component.
   *
   * @remarks
   *
   * Implements the {@link NetworkServiceInstance} interface.
   * In a Docker deployment, there is no actual network service object to deploy.
   * So this is a "virtual" component that simply implements the required
   * instance methods for a NetworkService, but renders to null.
   *
   * This component is typically used by {@link docker.ServiceContainerSet}. The
   * {@link docker.ServiceContainerSet} component can be used to ensure the proper
   * network port configuration is applied to the `props.endpoint` container.
   *
   * @public
   */
  export declare function NetworkService(props: SFCDeclProps<NetworkServiceProps, typeof defaultProps>): null;/**
   * The base string used for Adapt Docker labels.
   * @internal
   */
  const adaptDockerKey = "org.adaptjs";/**
   * Docker label for the deployID the object was created from.
   * @internal
   */
  const adaptDockerDeployIDKey: string;/**
   * Props for {@link docker.LocalDockerImage}
   *
   * @public
   */
  export declare interface LocalDockerImageProps {
      /** Directory for use as the build context in docker build */
      contextDir?: string;
      /**
       * Contents of the dockerfile
       *
       * @remarks
       * Should not be used if dockerfileName is set
       */
      dockerfile?: string;
      /**
       * Path to a local Dockerfile in the Adapt project.
       *
       * @remarks
       * This path is relative to the root of the Adapt project.
       * Should not be used if `dockerfile` is set.
       */
      dockerfileName?: string;
      /**
       * Extra files that should be included during the docker build
       *
       * @remarks
       * LocalDockerImage uses a multi-stage build process.  It first creates
       * a temporary image that includes the files specified in this field.
       * This temporary image is then made available to the `dockerfile` with
       * stage name `files` and can then be copied into the final image, as
       * desired, using `COPY` or `ADD` commands in the `dockerfile`.
       *
       * @example
       * To create a final Docker image that contains a file that has some
       * programmatically created content, use the `dockerfile` prop along
       * with the `files` prop like this:
       * ```tsx
       * const files = [{
       *   path: '/path/to/myfile.txt',
       *   contents: 'contents for myfile\n'
       * }];
       * const dockerfile = `
       *   FROM alpine
       *   COPY --from=files /path/to/myfile.txt /app/myfile.txt
       *   ...
       * `;
       * return <LocalDockerImage files={files} dockerfile={dockerfile} />
       * ```
       */
      files?: File[];
      /**
       * Options to control the behavior of docker build
       */
      options?: DockerBuildOptions;
      /**
       * Extra stages to include in a multi-stage docker build
       */
      stages?: Stage[];
  }/**
   * @internal
   */
  export declare interface LocalDockerImageState {
      deployOpID?: DeployOpID;
      image?: WithId<ImageRefDockerHost>;
      imagePropsJson?: string;
      prevUniqueNameTag?: string;
  }/**
   * Locally builds a docker image
   *
   * @remarks
   * See {@link docker.LocalDockerImageProps}.
   *
   * @public
   */
  export declare class LocalDockerImage extends Action<LocalDockerImageProps, LocalDockerImageState> implements DockerPushableImageInstance {
      static defaultProps: {
          options: {
              dockerHost: string | undefined;
              forceRm: boolean;
          };
      };
      deployedWhenIsTrivial: boolean;
      private image_?;
      private imagePropsJson_?;
      private options_;
      constructor(props: LocalDockerImageProps);
      buildComplete(): boolean;
      ready(): boolean;
      image(): WithId<ImageRefDockerHost> | undefined;
      pushTo({ ref }: {
          ref: string;
      }): Promise<undefined | WithId<ImageRefRegistry>>;
      latestImage(): WithId<ImageRefDockerHost> | undefined;
      /**
       * User-facing name to display in status messages.
       */
      displayName(): string | undefined;
      /**
       * Implementations for Action base class
       * @internal
       */
      shouldAct(op: ChangeType): Promise<ShouldAct>;
      /**
       * Implementations for Action base class
       * @internal
       */
      action(op: ChangeType, ctx: ActionContext): Promise<void>;
      /** @internal */
      initialState(): {};
      /** @internal */
      deployedWhen: (goalStatus: GoalStatus) => true | import("@adpt/core").Waiting;
      /** @internal */
      protected get imagePropsJson(): string;
  }/**
   * Runs a Docker registry in a container.
   * @remarks
   * Implements {@link docker.DockerRegistryInstance}.
   *
   * @public
   */
  export declare function LocalDockerRegistry(props: SFCDeclProps<LocalDockerRegistryProps, typeof defaultProps>): Adapt.JSX.Element;/**
   * Props for {@link docker.LocalDockerRegistry}
   * @public
   */
  export declare interface LocalDockerRegistryProps extends ExcludeKeys<DockerContainerProps, "image"> {
      /**
       * Tag to use for official Docker Hub `registry` image repo.
       */
      imageTag: NameTagString;
      /**
       * Port number to expose for the registry HTTP server.
       */
      port: number;
  }/** @public */
  export declare interface DockerRegistryInstance {
      registry(): RegistryString | undefined;
  }/**
   * Props for {@link docker.RegistryDockerImage}
   * @public
   */
  export declare interface RegistryDockerImageProps {
      /**
       * Handle for image source
       * @remarks
       * Currently, only handle to LocalDockerImage components and compatible
       * interfaces are supported.
       * @privateRemarks
       * FIXME(manishv) support string refs to other registries and handles of
       * other registry images
       */
      imageSrc: Handle<DockerPushableImageInstance>;
      /**
       * Registry and path where the image should be pushed and pulled
       *
       * @remarks
       * If this parameter is a string, registryPrefix will be used for both push and pull
       *
       * If registryPrefix is of the form `{ external: string, internal: string }`, docker images wil be
       * pushed to `external` and image strings will refer to `internal`.
       *
       * Registry prefixes can be of the form `domain/path/elements`, for example `gcr.io/myproject`.
       * However, the registryPrefix should not include the final name, use newPathTag instead.
       *
       * Note(manishv)
       * This is a bit of a hack to allow one hostname or IP address to push images from outside
       * a particular environment (say k8s) and a different URL for that environment to pull
       * images.
       *
       * A good example of this is a k3s-dind (k3s docker-in-docker) instance of kubernetes where
       * a private registry is running on a docker network attached to the k3s-dind instance, but where we
       * want to push {@link docker.LocalDockerImage} built images to that registry.  Since
       * {@link docker.LocalDockerImage | LocalDockerImage} is outside the k3s-dind environment, it must
       * use a host accessible network to push to the registry.  However, since the k3s-dind instance sees
       * the registry from within Docker, it must use a different address to pull the images for use.
       *
       * Once network scopes are fully supported, this interface will change to whatever is appropriate.  It
       * is best if you can arrange to have the same URL or registry string work for all access regardless
       * of which network the registry, Adapt host, and ultimate container running environment is uses.
       */
      registryPrefix: RegistryString | DockerSplitRegistryInfo;
      /**
       * Path and tag to be used for the image in the new registry in
       * `path:tag` or `path` format.
       * @remarks
       * The entire path and tag are blindly concatenated to the domain and path
       * in registryPrefix to form the full ref that will be used to push the
       * image.
       *
       * If omitted, the last component of the path and the tag from the source
       * image is used. The newPathTag should not include the registry
       * hostname/port prefix. If the `:tag` portion of `path:tag` is omitted,
       * the tag `latest` will be used.
       */
      newPathTag?: string;
      /**
       * Path and tag to be used for the image in the new registry in
       * `path:tag` or `path` format.
       * @deprecated This prop has been renamed to `newPathTag`. The functionality
       * for both props is the same and if both are set, `newPathTag` takes
       * priority.
       * @remarks
       * If omitted, the path and tag from the source image is used. The
       * newTag should not include the registry hostname/port prefix. If the
       * `:tag` portion of `path:tag` is omitted, the tag `latest` will be used.
       */
      newTag?: string;
  }/**
   * Represents a Docker image in a registry.
   * @remarks
   * If the image does not exist in the specified registry, it will be pushed
   * to that registry.
   * @public
   */
  export declare class RegistryDockerImage extends Action<RegistryDockerImageProps, State> implements DockerImageInstance {
      private latestImage_?;
      private latestRegistryUrl_?;
      private registry;
      constructor(props: RegistryDockerImageProps);
      /**
       * Returns information about the version of the Docker image that reflects
       * the current set of props for the component and has been pushed to the
       * registry.
       * @remarks
       * Returns undefined if the `props.imageSrc` component's `latestImage` method
       * returns undefined (depending on the component referenced by
       * `props.imageSrc`, that may indicate the source image has not been built).
       * Also returns undefined if the current image has not yet been
       * pushed to the registry.
       */
      image(): ImageRefRegistry | undefined;
      /**
       * Returns information about the most current version of the Docker image
       * that has been pushed to the registry.
       * @remarks
       * Returns undefined if no image has ever been pushed by this component.
       */
      latestImage(): ImageRefRegistry | undefined;
      /** @internal */
      initialState(): {};
      /** @internal */
      shouldAct(diff: ChangeType): false | {
          act: boolean;
          detail: string;
      };
      /** @internal */
      dependsOn: DependsOnMethod;
      /** @internal */
      action(op: ChangeType): Promise<void>;
      private currentNameTag;
      private getNewPathTag;
      private srcImageName;
  }/**
   * Props for {@link docker.ServiceContainerSet}
   *
   * @public
   */
  export declare interface ServiceContainerSetProps extends ServiceProps {
      /**
       * Props to apply to all {@link docker.DockerContainer}s within this
       * ServiceContainerSet. If a prop is specified in the source {@link Container}
       * component and in `containerProps`, `containerProps` will take
       * precedence.
       */
      containerProps?: Partial<DockerContainerProps>;
      /**
       * If set, all children of this ServiceContainerSet that support the
       * `dockerHost` prop will get this value, overriding any other value for
       * this prop.
       */
      dockerHost?: string;
  }/**
   * A component for mapping a group of abstract {@link Container}s and
   * {@link NetworkService}s to Docker {@link docker.DockerContainer | DockerContainer}s
   * and {@link docker.NetworkService}s.
   *
   * @remarks
   * This component is intended to be used to replace {@link Container} and
   * {@link NetworkService} components that are grouped together, as the
   * only children of a common parent in a pattern that looks like this:
   * ```tsx
   * <Service>
   *   <Container ... />
   *   <Container ... />
   *   <NetworkService ... />
   * </Service>
   * ```
   * `ServiceContainerSet` maps those abstract components into Docker components
   * like this:
   * ```tsx
   * <Group>
   *   <docker.DockerContainer ... >
   *   <docker.DockerContainer ... >
   *   <docker.NetworkService ... >
   * </Group>
   * ```
   * An example style rule to do this is:
   * ```tsx
   * {Service}
   * {Adapt.rule((matchedProps) => {
   *     const { handle, ...remainingProps } = matchedProps;
   *     return <ServiceContainerSet {...remainingProps} />;
   * })}
   * ```
   *
   * Currently, {@link docker.NetworkService} implements the {@link NetworkServiceInstance}
   * interface, but does not deploy a network proxy component. So the Docker
   * ServiceContainerSet component applies the network port configuration specified by
   * the {@link NetworkService}s to their target
   * {@link docker.DockerContainer | DockerContainer}s.
   *
   * @public
   */
  export declare class ServiceContainerSet extends DeferredComponent<ServiceContainerSetProps> {
      build(helpers: BuildHelpers): Adapt.JSX.Element;
  }/**
   * Options for interacting with Docker Engine that apply to all
   * operations.
   * @public
   */
  export declare interface DockerGlobalOptions {
      dockerHost?: string;
  }/**
   * Options for performing Docker image builds.
   * @public
   */
  export declare interface DockerBuildOptions extends DockerGlobalOptions {
      /**
       * Requests BuildKit as the internal Docker build engine.
       *
       * @remarks
       * This option requests the use of the BuildKit build engine when building
       * Docker images, if BuildKit is available. This is primarily useful for
       * BuildKit's performance improvements over the legacy Docker build engine.
       * However, because this option does not guarantee BuildKit will be used,
       * BuildKit-only features such as secret mounting should not be used.
       *
       * Internally, this option sets the `DOCKER_BUILDKIT` environment
       * variable when performing builds, which enables BuildKit on Docker
       * systems that support it.
       *
       * For more information, see
       * [Build images with BuildKit](https://docs.docker.com/develop/develop-images/build_enhancements/).
       *
       * @defaultValue `true`
       */
      requestBuildKit?: boolean;
      forceRm?: boolean;
      imageName?: string;
      imageTag?: string;
      prevUniqueNameTag?: string;
      stdin?: string;
      /**
       * If true and the newly built image ID does not match the image ID for
       * prevUniqueNameTag (or prevUniqueNameTag is not set), a new unique nameTag is
       * generated for this image (from imageName and imageTag).
       * If true and the newly built image ID does match the image ID for
       * prevUniqueNameTag, then prevUniqueNameTag is returned as nameTag.
       * If false, imageName and imageTag are used without modification.
       */
      uniqueTag?: boolean;
      /**
       * If set, will add a Docker LABEL with the DeployID.
       */
      deployID?: string;
      buildArgs?: Environment;
  }/**
   * A dynamically-created file that can be used during the build of a Docker
   * image.
   *
   * @remarks
   * These `File` objects are used to create a temporary "scratch" image in a
   * {@link https://docs.docker.com/develop/develop-images/multistage-build/ | multi-stage build}
   * that contains only the specified files. Then, in later stages of that build,
   * the files within the temporary image can be copied into the later stage
   * image.
   * @public
   */
  export declare interface File {
      /**
       * The path in the temporary image where the file will be created.
       */
      path: string;
      /**
       * The contents of the file.
       */
      contents: Buffer | string;
  }/**
   * A stage to be added to a
   * {@link https://docs.docker.com/develop/develop-images/multistage-build/ | multi-stage Docker build}.
   *
   * @remarks
   * The stage will be added to the generated Dockerfile for the image as:
   * ```
   * FROM image as name
   * ```
   * @public
   */
  export declare interface Stage {
      /** The image (name + tag or digest) to use for the stage. */
      image: string;
      /** Name for the stage */
      name: string;
  }/**
   * A string that contains both a Docker repo and a registry digest.
   *
   * @remarks
   * This is a string that represents a specific image on a specific registry
   * contained in a particular repo on that registry. It's of the form:
   * ```
   * [registry/]repo@digest
   * ```
   * `registry` - (optional) The hostname or hostname:port of a Docker registry
   * where the repo is located. If not provided, the official default Docker
   * registry is assumed.
   *
   * `repo` - The more precise name for what's commonly referred to as an image
   * name. It may include 0 or more slashes to denote namespaces.
   *
   * `digest` - The repo digest for the image in the form `algorithm:hex`.
   * This digest is specific to the associated registry and repo and has no
   * significance without those additional pieces of information. If this image is
   * pushed to a different registry, it will have a different digest value.
   * The digest is also known as a "distribution hash".
   *
   * Examples:
   * ```
   * alpine@sha256:04696b491e0cc3c58a75bace8941c14c924b9f313b03ce5029ebbc040ed9dcd9
   * localhost:5000/mockdeploy-htws@sha256:899a03e9816e5283edba63d71ea528cd83576b28a7586cf617ce78af5526f209
   * ```
   * @public
   */
  export declare type RepoDigestString = string;/**
   * Docker image ID, in the form `algorithm:hex`.
   *
   * @remarks
   * The Docker image ID (also known as "Content Hash") is a single value
   * that uniquely identifies a specific image on a local Docker host.
   *
   * An image ID does not require a registry or repo qualifier to be significant.
   * It is distinct from a Docker image
   * {@link docker.RepoDigestString | repo digest}.
   *
   * Example:
   * ```
   * sha256:199e537da3a86126cd6eb114bd0b13ab178dc291bbb6ea4a4a3aa257b2366b71
   * ```
   * @public
   */
  export declare type ImageIdString = string;/**
   * A string reference to a Docker image that contains a repo name, and may
   * contain an optional registry and optional tag.
   *
   * @remarks
   * This is a string that references a Docker image. It's in the form of
   * one of:
   * ```
   * [registry/]repo
   * [registry/]repo:tag
   * ```
   * `registry` - (optional) The hostname or hostname:port of a Docker registry
   * where the repo is located. If not provided, depending on context, either
   * the official default Docker registry may be assumed or the image may just
   * be present locally and not on any registry.
   *
   * `repo` - The more precise name for what's commonly referred to as an image
   * name. It may include 0 or more slashes to denote namespaces.
   *
   * `tag` - A tag string identifying a version of image within the repo.
   *
   * Examples:
   * ```
   * alpine
   * ubuntu:16.04
   * ```
   * @public
   */
  export declare type NameTagString = string;/**
   * A string reference to a Docker image that contains a repo name, and may
   * contain an optional registry and optionally either a tag or a repo digest.
   *
   * @remarks
   * This is a string that references a Docker image. It's in the form of
   * one of:
   * ```
   * [registry/]repo
   * [registry/]repo:tag
   * [registry/]repo@digest
   * ```
   * For more detail, see {@link docker.NameTagString} and
   * {@link docker.RepoDigestString}.
   *
   * Examples:
   * ```
   * alpine
   * ubuntu:16.04
   * alpine@sha256:04696b491e0cc3c58a75bace8941c14c924b9f313b03ce5029ebbc040ed9dcd9
   * localhost:5000/mockdeploy-htws@sha256:899a03e9816e5283edba63d71ea528cd83576b28a7586cf617ce78af5526f209
   * ```
   * @public
   */
  export declare type ImageNameString = NameTagString | RepoDigestString;/**
   * A string that references a Docker registry that contains a hostname and
   * may optionally contain a port and/or path.
   *
   * @remarks
   * This string is in the form of one of:
   * ```
   * hostname[:port]
   * hostname[:port]/path
   * ```
   * This form does not include the protocol, such as `http:` or `https:` in
   * the string.
   *
   * @public
   */
  export declare type RegistryString = string;/**
   * Information about a specific instance of a Docker image, as identified by
   * its image ID.
   * @deprecated Replaced with {@link docker.ImageRef}.
   * @public
   */
  export declare interface ImageInfo {
      /**
       * Docker image ID, in the form `algorithm:hex`.
       * @remarks
       * See {@link docker.ImageIdString}.
       */
      id: ImageIdString;
      /**
       * Docker image name and optional tag in the form `name` or `name:tag`.
       * @remarks
       * See {@link docker.NameTagString}
       */
      nameTag?: NameTagString;
  }/**
   * Props for {@link docker.DockerContainer}
   *
   * @public
   */
  export declare interface DockerContainerProps extends DockerGlobalOptions, Pick<ContainerProps, "autoRemove" | "command" | "environment" | "portBindings" | "ports" | "restartPolicy" | "stopSignal"> {
      /** image name as a string, or a handle to a DockerImage component */
      image: ImageNameString | Handle<DockerImageInstance>;
      /**
       * Host and port of the remote docker host to use.
       *
       * @remarks
       * Defaults to the DOCKER_HOST environment variable
       */
      dockerHost: string;
      /**
       * Labels to apply to the container.
       */
      labels?: ContainerLabels;
      /**
       * Filesystems to be mounted in the container.
       */
      mounts?: Mount[];
      /**
       * Networks to connect the container to
       *
       * @remarks
       * Accepts the same strings as docker network connect
       */
      networks?: string[];
      /**
       * Enables the container to run in privileged mode.
       */
      privileged?: boolean;
  }/**
   * Represents a split registry, with pushes going to external and pulls going to internal
   * @beta
   */
  export declare interface DockerSplitRegistryInfo {
      external: RegistryString;
      internal: RegistryString;
  }/**
   * Describes bind mount filesystems to be mounted in a container.
   * @public
   */
  export declare interface BindMount {
      type: "bind";
      source: string;
      destination: string;
      readonly?: boolean;
      propagation?: "shared" | "slave" | "private" | "rshared" | "rslave" | "rprivate";
  }/**
   * Describes filesystems to be mounted in a container.
   * @public
   */
  export declare type Mount = BindMount;/**
   * Props for {@link docker.BuildKitImage}
   *
   * @public
   */
  export declare interface BuildKitImageProps {
      /** Directory for use as the build context */
      contextDir?: string;
      /**
       * Contents of the dockerfile
       *
       * @remarks
       * Should not be used if dockerfileName is set
       */
      dockerfile?: string;
      /**
       * Path to a local Dockerfile in the Adapt project.
       *
       * @remarks
       * This path is relative to the root of the Adapt project.
       * Should not be used if `dockerfile` is set.
       */
      dockerfileName?: string;
      /**
       * Extra files that should be included during the docker build
       *
       * @remarks
       * BuildKitImage uses a multi-stage build process.  It first creates
       * a temporary image that includes the files specified in this field.
       * This temporary image is then made available to the `dockerfile` with
       * stage name `files` and can then be copied into the final image, as
       * desired, using `COPY` or `ADD` commands in the `dockerfile`.
       *
       * @example
       * To create a final Docker image that contains a file that has some
       * programmatically created content, use the `dockerfile` prop along
       * with the `files` prop like this:
       * ```tsx
       * const files = [{
       *   path: '/path/to/myfile.txt',
       *   contents: 'contents for myfile\n'
       * }];
       * const dockerfile = `
       *   FROM alpine
       *   COPY --from=files /path/to/myfile.txt /app/myfile.txt
       *   ...
       * `;
       * return <BuildKitImage files={files} dockerfile={dockerfile} />
       * ```
       */
      files?: File[];
      /**
       * Options to control the behavior of docker build
       */
      options?: BuildKitBuildOptions;
      /**
       * Directs BuildKit where to store the built image.
       */
      output: BuildKitOutput;
      /**
       * Extra stages to include in a multi-stage docker build
       */
      stages?: Stage[];
  }/**
   * @internal
   */
  export declare interface BuildKitImageState {
      deployOpID?: DeployOpID;
      image?: WithId<ImageRefRegistry>;
      imagePropsJson?: string;
      prevUniqueNameTag?: string;
  }/**
   * Locally builds a docker image
   *
   * @remarks
   * See {@link docker.BuildKitImageProps}.
   *
   * @public
   */
  export declare class BuildKitImage extends Action<BuildKitImageProps, BuildKitImageState> implements DockerPushableImageInstance {
      static defaultProps: {
          options: {};
      };
      deployedWhenIsTrivial: boolean;
      private image_?;
      private imagePropsJson_?;
      private options_;
      constructor(props: BuildKitImageProps);
      buildComplete(): boolean;
      ready(): boolean;
      image(): WithId<ImageRefRegistry> | undefined;
      pushTo({ ref }: {
          ref: string;
      }): Promise<undefined | WithId<ImageRefRegistry>>;
      latestImage(): WithId<ImageRefRegistry> | undefined;
      /**
       * User-facing name to display in status messages.
       */
      displayName(): string;
      /**
       * Implementations for Action base class
       * @internal
       */
      shouldAct(op: ChangeType): Promise<ShouldAct>;
      /**
       * Implementations for Action base class
       * @internal
       */
      action(op: ChangeType, ctx: ActionContext): Promise<void>;
      /** @internal */
      initialState(): {};
      /** @internal */
      deployedWhen: (goalStatus: GoalStatus) => true | import("@adpt/core").Waiting;
      /** @internal */
      protected get imagePropsJson(): string;
  }/**
   * Components that provide a Docker image can implement this interface to
   * allow other components to get information about the Docker image.
   * @public
   */
  export declare interface DockerImageInstance {
      /**
       * Returns information about the version of the Docker image that reflects
       * the current set of props for the component.
       * @remarks
       * Returns undefined if no image has ever been built by
       * this component OR if the component props have changed and the image
       * that corresponds to the current props has not yet been built.
       */
      image(): ImageRef | undefined;
      /**
       * Returns information about the most current version of the Docker image
       * that has completed building, even if that version does not reflect the
       * current set of props for the component.
       * @remarks
       * Returns undefined if no image has ever been built by this component.
       */
      latestImage(): ImageRef | undefined;
      /**
       * Pushes the image returned by `latestImage` to a Docker registry.
       *
       * @param ref - A docker domain, path components, and tag to which this image should be pushed
       *
       * @remarks
       * If there is no latest image available (`latestImage` returns
       * undefined), then `pushTo` will return undefined. Otherwise, if the
       * push was successful, returns an {@link docker.ImageRefRegistry} that contains
       * the complete nameTag, including registry portion.
       */
      pushTo?({ ref }: {
          ref: NameTagString;
      }): MaybePromise<ImageRefRegistry | undefined>;
  }/**
   * Components that provide a Docker image can implement this interface to
   * allow other components to get information about the Docker image and
   * to be able to push the image to a registry.
   * @public
   */
  export declare interface DockerPushableImageInstance extends DockerImageInstance {
      /**
       * {@inheritdoc docker.DockerImageInstance.pushTo}
       */
      pushTo({ ref }: {
          ref: NameTagString;
      }): MaybePromise<ImageRefRegistry | undefined>;
  }/**
   * Props for {@link docker.DockerImage}.
   * @beta
   */
  export declare interface DockerImageProps {
  }/**
   * Abstract component representing a {@link https://docker.com | Docker}
   * image that can be used to create containers.
   * @remarks
   * See also {@link Container}.
   * @beta
   */
  export declare abstract class DockerImage extends Component<DockerImageProps> implements DockerImageInstance {
      /**
       * {@inheritdoc docker.DockerImageInstance.image}
       */
      image(): ImageRef | undefined;
      /**
       * {@inheritdoc docker.DockerImageInstance.latestImage}
       */
      latestImage(): ImageRef | undefined;
  }/**
   * Compute the status of a container based on a graphQL schema
   *
   * @internal
   */
  export declare function containerStatus(observe: ObserveForStatus, containerName: string, dockerHost: string): Promise<ContainerStatus | NoStatus>;/** @public */
  export declare interface DockerContainerStatus extends ContainerStatus {
  }/**
   * Compute a unique name for the container
   *
   * @internal
   */
  const computeContainerName: (elemKey: string, elemID: string, deployID: string) => string;/**
   * Component to instantiate an image container with docker
   *
   * @remarks
   * See {@link docker.DockerContainerProps}.
   *
   * @public
   */
  declare class DockerContainer extends Action<DockerContainerProps, DockerContainerState> {
      static defaultProps: {
          dockerHost: string;
          privileged: boolean;
      };
      info?: ContainerInfo;
      dependsOn: DependsOnMethod;
      /** @internal */
      shouldAct(diff: ChangeType, context: ActionContext): Promise<false | ShouldAct>;
      /** @internal */
      action(diff: ChangeType, context: ActionContext): Promise<void>;
      status(observe: ObserveForStatus, buildData: BuildData): Promise<NoStatus | ContainerStatus>;
      /**
       * Get the IP address of the container, optionally for a specific Docker
       * network.
       * @remarks
       * The IP addresses that are returned by this function are valid only
       * on the associated Docker network, which is often only associated
       * with a single host node for most Docker network types.
       *
       * @param network - Name of a Docker network. If `network` is provided
       * and the container is connected to the network with an IP address, that
       * address will be returned. If the container is not connected to the
       * network, `undefined` will be returned. If `network` is not provided,
       * the default container IP address will be returned.
       *
       * @beta
       */
      dockerIP(network?: string): string | undefined;
      /** @internal */
      initialState(): {};
      private displayName;
      private refreshContainerInfo;
  }/**
   * Component to instantiate an image container with docker
   *
   * @remarks
   * See {@link docker.DockerContainerProps}.
   *
   * @public
   */
  declare class DockerContainer extends Action<DockerContainerProps, DockerContainerState> {
      static defaultProps: {
          dockerHost: string;
          privileged: boolean;
      };
      info?: ContainerInfo;
      dependsOn: DependsOnMethod;
      /** @internal */
      shouldAct(diff: ChangeType, context: ActionContext): Promise<false | ShouldAct>;
      /** @internal */
      action(diff: ChangeType, context: ActionContext): Promise<void>;
      status(observe: ObserveForStatus, buildData: BuildData): Promise<NoStatus | ContainerStatus>;
      /**
       * Get the IP address of the container, optionally for a specific Docker
       * network.
       * @remarks
       * The IP addresses that are returned by this function are valid only
       * on the associated Docker network, which is often only associated
       * with a single host node for most Docker network types.
       *
       * @param network - Name of a Docker network. If `network` is provided
       * and the container is connected to the network with an IP address, that
       * address will be returned. If the container is not connected to the
       * network, `undefined` will be returned. If `network` is not provided,
       * the default container IP address will be returned.
       *
       * @beta
       */
      dockerIP(network?: string): string | undefined;
      /** @internal */
      initialState(): {};
      private displayName;
      private refreshContainerInfo;
  }/**
   * Type guard for determining whether a given object has a non-null `id`
   * property.
   * @public
   */
  export declare function hasId<T extends {
      id?: ImageIdString;
  }>(o: T): o is WithId<T>;/**
   * Factory function for creating a {@link docker.MutableImageRef}.
   * @remarks
   * Can also be used to clone an existing {@link docker.MutableImageRef} or
   * to create a mutable version of an existing {@link docker.ImageRef}.
   * @public
   */
  export declare function mutableImageRef(ref: ImageNameString, normalize?: boolean): MutableImageRef;/**
   * Factory function for creating a {@link docker.MutableImageRef}.
   * @remarks
   * Can also be used to clone an existing {@link docker.MutableImageRef} or
   * to create a mutable version of an existing {@link docker.ImageRef}.
   * @public
   */
  export declare function mutableImageRef(info?: ImageRefData): MutableImageRef;/**
   * Factory function for creating a {@link docker.ImageRef} or cloning an
   * existing one.
   * @public
   */
  export declare function imageRef(ref: ImageNameString, normalize?: boolean): ImageRef;/**
   * Factory function for creating a {@link docker.ImageRef} or cloning an
   * existing one.
   * @public
   */
  export declare function imageRef(info?: ImageRefData): ImageRef;/**
   * A type guard for determining whether a {@link docker.ImageRef} is a
   * {@link docker.ImageRefRegistry}.
   * @public
   */
  export declare function isImageRefRegistry(ref: ImageRef): ref is ImageRefRegistry;/**
   * A type guard for determining whether a {@link docker.ImageRef} is a
   * {@link docker.ImageRefRegistry} that has the `id` property set.
   * @public
   */
  export declare function isImageRefRegistryWithId(ref: ImageRef): ref is WithId<ImageRefRegistry>;/**
   * A type guard for determining whether a {@link docker.ImageRef} is a
   * {@link docker.ImageRefDockerHost}.
   * @public
   */
  export declare function isImageRefDockerhost(ref: ImageRef): ref is ImageRefDockerHost;/**
   * A type guard for determining whether a {@link docker.ImageRef} is a
   * {@link docker.ImageRefDockerHost} that has the `id` property set.
   * @public
   */
  export declare function isImageRefDockerhostWithId(ref: ImageRef): ref is WithId<ImageRefDockerHost>;/**
   * The most basic components that make up a {@link docker.ImageRef}.
   * All other properties of a {@link docker.ImageRef} can be computed from
   * these.
   * @remarks
   * See also {@link docker.ImageRef} for more information on references.
   * @public
   */
  export declare interface ImageRefData {
      /**
       * Image digest in the form `algorithm:hex`
       * @example
       * sha256:04696b491e0cc3c58a75bace8941c14c924b9f313b03ce5029ebbc040ed9dcd9
       */
      digest?: string;
      /**
       * Docker host string to contact the Docker daemon where this image is
       * located.
       *
       * @remarks
       * This should be in the same format that Docker expects for the `DOCKER_HOST`
       * environment variable. The special string `default` can also be used,
       * which will use the current value of the `DOCKER_HOST` environment variable,
       * if it is set and will otherwise use the default named pipe on Windows
       * (`npipe:///./pipe/docker_engine`) and the default socket on other
       * systems (`unix:///var/run/docker.sock`).
       * @example
       * tcp://localhost:2375
       */
      dockerHost?: "default" | string;
      /**
       * Hostname and optional port number of the container image registry where
       * this image is located.
       * @example
       * docker.io
       * @example
       * localhost:5000
       */
      domain?: RegistryString;
      /**
       * Image content ID in the form `algorithm:hex`
       * @example
       * sha256:199e537da3a86126cd6eb114bd0b13ab178dc291bbb6ea4a4a3aa257b2366b71
       */
      id?: ImageIdString;
      /**
       * The image repo path.
       * @example
       * google/cloud-sdk
       */
      path?: string;
      /**
       * Image tag
       * @example
       * latest
       */
      tag?: string;
  }/**
   * The type of an image reference indicates how the image can be
   * accessed, currently either through a Docker host (daemon) or directly to a
   * container registry via its API.
   *
   * @remarks
   * If not enough information is present to access and uniquely identify a
   * container image, the type is `incomplete`.
   * @public
   */
  export declare type ImageRefType = "incomplete" | "registry" | "dockerhost";/**
   * An immutable reference to a container image, including all information
   * known about the image.
   *
   * @remarks
   * This type is the base type for an image reference and is allowed to
   * contain partial or incomplete information about a container image.
   * It can include both information about how to access the image and
   * also information about the image itself.
   *
   * Many of the properties of {@link docker.ImageRef} are related to the
   * container image reference string used by Docker and other container-based
   * systems. A container image reference string is a structured string
   * containing multiple components. The most basic components are illustrated
   * below, using the example image reference string
   * `"my.registry:5000/a/repo/path:sometag@sha256:899a03e9816e5283edba63d"`.
   *
   * NOTE: The length of the `digest` has been shortened for formatting
   * purposes.
   *
   * ```
   * "my.registry:5000/a/repo/path:sometag@sha256:899a03e9816e5283edba63d"
   * |     domain     |   path    |  tag  |         digest               |
   * ```
   *
   * To aid in correct formatting, {@link docker.ImageRef} and related types and
   * classes also provide helper properties that combine these basic components
   * into combinations that are often useful, such as `name`, which is the
   * `domain` and `path` combined with a `/`.
   *
   * Many tools, such as the Docker UI, also accept a shortened form of a string
   * reference, called the `familiar` form. An example of a familiar reference is
   * `ubuntu`. In this form, only the `path` component is required. When
   * components of the reference are left out, default values are assumed. The
   * default `domain` is `docker.io` and the default `tag` is `latest`.
   * Additionally, if the `domain` is `docker.io` and there are no `/` characters
   * in the `path`, `library/` is prepended to the path. So `ubuntu` is the
   * familiar form for the complete reference `docker.io/library/ubuntu:latest`.
   *
   * An {@link docker.ImageRef} is designed to hold as much information about
   * an image as may be available and therefore some properties that are
   * not known will be `undefined`.
   *
   * See also {@link docker.MutableImageRef}, which can be used to parse
   * reference strings and construct or modify image references.
   * @public
   */
  export declare interface ImageRef extends Readonly<ImageRefData> {
      /**
       * The complete string reference for this image in familiar form, which
       * leaves out certain fields from the reference when they are set to
       * default values.
       * @remarks
       * This reference form is the form typically used in the Docker UI.
       * If the ImageRef is not complete, familiar will return `undefined`, as
       * the correct familiar representation cannot be determined.
       * @example
       * mysql
       * @example
       * gcr.io/my-project/image:1.0.1
       */
      readonly familiar?: string;
      /**
       * The image name, which is comprised of the optional domain and
       * the (non-optional) path. Will be `undefined` if there is no `path`.
       * @example
       * gcr.io/my-project/image
       */
      readonly name?: string;
      /**
       * The image name (including any registry) and image tag. Returns undefined
       * if either path or tag are not set.
       * If nameTag is set to a string that does not contain a tag (i.e. does
       * not include a ":"), the default tag of `latest` will be set.
       * To set nameTag without defaulting to `latest`, call the class method
       * `setNameTag` with the parameter `useDefaultTag` set to `false`.
       * @example
       * gcr.io/my-project/image:1.0.1
       */
      readonly nameTag?: string;
      /**
       * The image path (not including any registry) and image tag. Returns
       * undefined if either `path` or `tag` are not set.
       * @example
       * my-project/image:1.0.1
       */
      readonly pathTag?: string;
      /**
       * The best (most specific and complete) string reference for this image,
       * given the information available in this {@link docker.ImageRef}.
       */
      readonly ref: string;
      /**
       * An alias for `domain`.
       */
      readonly registry?: string;
      /**
       * The best remote reference available for this image in either
       * `domain/path@digest` format or `domain/path:tag` format.
       * @remarks
       * Returns `registryDigest` if it is set, otherwise returns `registryTag`.
       * If no remote reference is available, returns undefined.
       * @example
       * gcr.io/my-project/image\@sha256:899a03e9816e5283edba63d71ea528cd83576b28a7586cf617ce78af5526f209
       * @example
       * gcr.io/my-project/image:1.0.1
       */
      readonly registryRef?: string;
      /**
       * The remote digest reference in `domain/path@digest` form.
       * @remarks
       * Undefined if any of `domain`, `path`, or `digest` are unset.
       * @example
       * gcr.io/my-project/image\@sha256:899a03e9816e5283edba63d71ea528cd83576b28a7586cf617ce78af5526f209
       */
      readonly registryDigest?: string;
      /**
       * The remote tag reference in `domain/path:tag` form.
       * @remarks
       * Undefined if any of `domain`, `path`, or `tag` are unset.
       * @example
       * gcr.io/my-project/image:1.0.1
       */
      readonly registryTag?: string;
      /**
       * The type of an image reference indicates how the image can be
       * accessed, either through a Docker host (daemon) or directly to a
       * container registry.
       *
       * @remarks
       * A reference is a valid `dockerhost` type ref when it contains a valid
       * dockerHost string and either:
       * - A valid image id or
       * - A valid path and either a valid tag or digest.
       *
       * A reference is a valid `registry` type ref when it contains a valid
       * domain, path, and either a tag or a digest.
       *
       * If not enough information is present to access and uniquely identify a
       * container image, the type is `incomplete`.
       */
      readonly type: ImageRefType;
  }/**
   * Helper type that augments a base type to indicate that the `id` field
   * is present and has a valid image ID.
   * @public
   */
  export declare type WithId<T> = T & {
      id: ImageIdString;
  };/**
   * A mutable reference to a container image that can be used to parse,
   * construct, and modify an image reference, as well as to hold information
   * about the image and how to access it.
   *
   * @remarks
   * This class can be used to parse strings that contain complete or partial
   * container image references. It can also be used to construct an image
   * reference from scratch, from individual component parts, or from another
   * reference, then to correctly format the reference or its components for
   * use with various tools.
   *
   * To parse and normalize a "familiar" image reference, like is typically
   * seen in the Docker UI:
   * ```ts
   * const ref = mutableImageRef("redis", true);
   * console.log(ref.tag);         // => "latest"
   * console.log(ref.registryRef); // => "docker.io/library/redis:latest"
   * ```
   *
   * To construct a reference to an image present on the local Docker daemon
   * that has an image ID:
   * ```ts
   * const ref = mutableImageRef({
   *     dockerHost: "default",
   *     path: "myimage",
   *     tag: "just-built",
   *     id: "sha256:04696b491e0cc3c58a75bace8941c14c924b9f313b03ce5029ebbc040ed9dcd9",
   * });
   * ```
   *
   * To convert a `MutableImageRef` to an immutable plain object `ImageRef`,
   * use the `freeze` method.
   * @public
   */
  export declare class MutableImageRef implements ImageRef {
      _digest?: string;
      _dockerHost?: string;
      _domain?: string;
      _id?: ImageIdString;
      _path?: string;
      _tag?: string;
      constructor(ref: ImageNameString, normalize?: boolean);
      constructor(info?: ImageRefData | undefined);
      freeze(): ImageRef;
      toData(): ImageRefData;
      toJSON(): ImageRefData;
      /**
       * The digest string for this image in its associated registry and repo
       * in the form `algorithm:hex`.
       */
      get digest(): string | undefined;
      set digest(digest: string | undefined);
      get dockerHost(): string | undefined;
      set dockerHost(dockerHost: string | undefined);
      /**
       * The hostname and optional port of the image registry for this image.
       */
      get domain(): string | undefined;
      set domain(domain: string | undefined);
      /**
       * The complete string reference for this image in familiar form, which
       * leaves out certain fields from the reference when they are set to
       * default values.
       * @remarks
       * This reference form is the form typically used in the Docker UI.
       * If the ImageRef is not complete, familiar will return `undefined`, as
       * the correct familiar representation cannot be determined.
       */
      get familiar(): string | undefined;
      /**
       * The content ID of the image in `algorithm:hex` format.
       */
      get id(): ImageIdString | undefined;
      set id(id: ImageIdString | undefined);
      /**
       * The image name, which is comprised of the optional domain and
       * the (non-optional) path.
       */
      get name(): string | undefined;
      set name(name: string | undefined);
      /**
       * The image name (including any registry) and image tag. Returns undefined
       * if either path or tag are not set.
       * If nameTag is set to a string that does not contain a tag (i.e. does
       * not include a ":"), the default tag of `latest` will be set.
       * To set nameTag without defaulting to `latest`, call the class method
       * `setNameTag` with the parameter `useDefaultTag` set to `false`.
       */
      get nameTag(): NameTagString | undefined;
      set nameTag(nt: NameTagString | undefined);
      /**
       * Method to set the image name and image tag which also allows choice
       * of default behavior when `nameTag` does not contain a tag string.
       */
      setNameTag(nameTag: NameTagString | undefined, useDefaultTag?: boolean): void;
      /**
       * The image repo path.
       */
      get path(): string | undefined;
      set path(path: string | undefined);
      /**
       * The image path (not including any registry) and image tag. Returns
       * undefined if either path or tag are not set.
       * If pathTag is set to a string that does not contain a tag (i.e. does
       * not include a ":"), the default tag of `latest` will be set.
       * To set pathTag without defaulting to `latest`, call the class method
       * `setPathTag` with the parameter `useDefaultTag` set to `false`.
       */
      get pathTag(): string | undefined;
      set pathTag(pathTag: string | undefined);
      /**
       * Method to set the image path and image tag which also allows choice
       * of default behavior when `pathTag` does not contain a tag string.
       */
      setPathTag(pathTag: string | undefined, useDefaultTag?: boolean): void;
      get ref(): string;
      /**
       * Alias for domain
       */
      get registry(): string | undefined;
      /**
       * The best remote reference available for this image in either
       * `domain/path@digest` format or `domain/path:tag` format.
       * @remarks
       * Returns `registryDigest` if it is set, otherwise returns `registryTag`.
       * If no remote reference is available, returns undefined.
       */
      get registryRef(): ImageNameString | undefined;
      /**
       * The remote digest reference in `domain/path@digest` form.
       * @remarks
       * Undefined if any of `domain`, `path`, or `digest` are unset.
       */
      get registryDigest(): RepoDigestString | undefined;
      set registryDigest(rd: RepoDigestString | undefined);
      /**
       * The remote tag reference in `domain/path:tag` form.
       * @remarks
       * Undefined if any of `domain`, `path`, or `tag` are unset.
       */
      get registryTag(): NameTagString | undefined;
      set registryTag(rt: NameTagString | undefined);
      /**
       * The image tag.
       */
      get tag(): string | undefined;
      set tag(tag: string | undefined);
      /**
       * The type of an image reference indicates how the image can be
       * accessed, either through a Docker host (daemon) or directly to a
       * container registry.
       *
       * @remarks
       * A reference is a valid `dockerhost` type ref when it contains a valid
       * dockerHost string and either:
       * - A valid image id or
       * - A valid path and either a valid tag or digest.
       *
       * A reference is a valid `registry` type ref when it contains a valid
       * domain, path, and either a tag or a digest.
       *
       * If not enough information is present to access and uniquely identify a
       * container image, the type is `incomplete`.
       */
      get type(): ImageRefType;
  }/**
   * A more specific type of {@link docker.ImageRef} that contains sufficient
   * information to uniquely identify an image on a container registry.
   * @public
   */
  export declare interface ImageRefRegistry {
      readonly digest?: string;
      readonly domain: string;
      readonly familiar: string;
      readonly id?: ImageIdString;
      readonly name: string;
      readonly nameTag?: string;
      readonly path: string;
      readonly pathTag?: string;
      readonly ref: string;
      readonly registry: string;
      readonly registryRef: string;
      readonly registryDigest?: string;
      readonly registryTag?: string;
      readonly tag?: string;
      readonly type: "registry";
  }/**
   * A more specific type of {@link docker.ImageRef} that contains sufficient
   * information to uniquely identify an image on a specific Docker host
   * (daemon).
   * @public
   */
  export declare interface ImageRefDockerHost {
      readonly digest?: string;
      readonly dockerHost: string;
      readonly domain?: string;
      readonly familiar: string;
      readonly id?: ImageIdString;
      readonly name: string;
      readonly nameTag?: string;
      readonly path: string;
      readonly pathTag?: string;
      readonly ref: string;
      readonly registry?: string;
      readonly registryRef?: string;
      readonly registryDigest?: string;
      readonly registryTag?: string;
      readonly tag?: string;
      readonly type: "dockerhost";
  }/**
   * Docker network service component, compatible with the abstract
   * {@link NetworkService} component.
   *
   * @remarks
   *
   * Implements the {@link NetworkServiceInstance} interface.
   * In a Docker deployment, there is no actual network service object to deploy.
   * So this is a "virtual" component that simply implements the required
   * instance methods for a NetworkService, but renders to null.
   *
   * This component is typically used by {@link docker.ServiceContainerSet}. The
   * {@link docker.ServiceContainerSet} component can be used to ensure the proper
   * network port configuration is applied to the `props.endpoint` container.
   *
   * @public
   */
  export declare function NetworkService(props: SFCDeclProps<NetworkServiceProps, typeof defaultProps>): null;/**
   * The base string used for Adapt Docker labels.
   * @internal
   */
  const adaptDockerKey = "org.adaptjs";/**
   * Docker label for the deployID the object was created from.
   * @internal
   */
  const adaptDockerDeployIDKey: string;/**
   * Props for {@link docker.LocalDockerImage}
   *
   * @public
   */
  export declare interface LocalDockerImageProps {
      /** Directory for use as the build context in docker build */
      contextDir?: string;
      /**
       * Contents of the dockerfile
       *
       * @remarks
       * Should not be used if dockerfileName is set
       */
      dockerfile?: string;
      /**
       * Path to a local Dockerfile in the Adapt project.
       *
       * @remarks
       * This path is relative to the root of the Adapt project.
       * Should not be used if `dockerfile` is set.
       */
      dockerfileName?: string;
      /**
       * Extra files that should be included during the docker build
       *
       * @remarks
       * LocalDockerImage uses a multi-stage build process.  It first creates
       * a temporary image that includes the files specified in this field.
       * This temporary image is then made available to the `dockerfile` with
       * stage name `files` and can then be copied into the final image, as
       * desired, using `COPY` or `ADD` commands in the `dockerfile`.
       *
       * @example
       * To create a final Docker image that contains a file that has some
       * programmatically created content, use the `dockerfile` prop along
       * with the `files` prop like this:
       * ```tsx
       * const files = [{
       *   path: '/path/to/myfile.txt',
       *   contents: 'contents for myfile\n'
       * }];
       * const dockerfile = `
       *   FROM alpine
       *   COPY --from=files /path/to/myfile.txt /app/myfile.txt
       *   ...
       * `;
       * return <LocalDockerImage files={files} dockerfile={dockerfile} />
       * ```
       */
      files?: File[];
      /**
       * Options to control the behavior of docker build
       */
      options?: DockerBuildOptions;
      /**
       * Extra stages to include in a multi-stage docker build
       */
      stages?: Stage[];
  }/**
   * @internal
   */
  export declare interface LocalDockerImageState {
      deployOpID?: DeployOpID;
      image?: WithId<ImageRefDockerHost>;
      imagePropsJson?: string;
      prevUniqueNameTag?: string;
  }/**
   * Locally builds a docker image
   *
   * @remarks
   * See {@link docker.LocalDockerImageProps}.
   *
   * @public
   */
  export declare class LocalDockerImage extends Action<LocalDockerImageProps, LocalDockerImageState> implements DockerPushableImageInstance {
      static defaultProps: {
          options: {
              dockerHost: string | undefined;
              forceRm: boolean;
          };
      };
      deployedWhenIsTrivial: boolean;
      private image_?;
      private imagePropsJson_?;
      private options_;
      constructor(props: LocalDockerImageProps);
      buildComplete(): boolean;
      ready(): boolean;
      image(): WithId<ImageRefDockerHost> | undefined;
      pushTo({ ref }: {
          ref: string;
      }): Promise<undefined | WithId<ImageRefRegistry>>;
      latestImage(): WithId<ImageRefDockerHost> | undefined;
      /**
       * User-facing name to display in status messages.
       */
      displayName(): string | undefined;
      /**
       * Implementations for Action base class
       * @internal
       */
      shouldAct(op: ChangeType): Promise<ShouldAct>;
      /**
       * Implementations for Action base class
       * @internal
       */
      action(op: ChangeType, ctx: ActionContext): Promise<void>;
      /** @internal */
      initialState(): {};
      /** @internal */
      deployedWhen: (goalStatus: GoalStatus) => true | import("@adpt/core").Waiting;
      /** @internal */
      protected get imagePropsJson(): string;
  }/**
   * Runs a Docker registry in a container.
   * @remarks
   * Implements {@link docker.DockerRegistryInstance}.
   *
   * @public
   */
  export declare function LocalDockerRegistry(props: SFCDeclProps<LocalDockerRegistryProps, typeof defaultProps>): Adapt.JSX.Element;/**
   * Props for {@link docker.LocalDockerRegistry}
   * @public
   */
  export declare interface LocalDockerRegistryProps extends ExcludeKeys<DockerContainerProps, "image"> {
      /**
       * Tag to use for official Docker Hub `registry` image repo.
       */
      imageTag: NameTagString;
      /**
       * Port number to expose for the registry HTTP server.
       */
      port: number;
  }/** @public */
  export declare interface DockerRegistryInstance {
      registry(): RegistryString | undefined;
  }/**
   * Props for {@link docker.RegistryDockerImage}
   * @public
   */
  export declare interface RegistryDockerImageProps {
      /**
       * Handle for image source
       * @remarks
       * Currently, only handle to LocalDockerImage components and compatible
       * interfaces are supported.
       * @privateRemarks
       * FIXME(manishv) support string refs to other registries and handles of
       * other registry images
       */
      imageSrc: Handle<DockerPushableImageInstance>;
      /**
       * Registry and path where the image should be pushed and pulled
       *
       * @remarks
       * If this parameter is a string, registryPrefix will be used for both push and pull
       *
       * If registryPrefix is of the form `{ external: string, internal: string }`, docker images wil be
       * pushed to `external` and image strings will refer to `internal`.
       *
       * Registry prefixes can be of the form `domain/path/elements`, for example `gcr.io/myproject`.
       * However, the registryPrefix should not include the final name, use newPathTag instead.
       *
       * Note(manishv)
       * This is a bit of a hack to allow one hostname or IP address to push images from outside
       * a particular environment (say k8s) and a different URL for that environment to pull
       * images.
       *
       * A good example of this is a k3s-dind (k3s docker-in-docker) instance of kubernetes where
       * a private registry is running on a docker network attached to the k3s-dind instance, but where we
       * want to push {@link docker.LocalDockerImage} built images to that registry.  Since
       * {@link docker.LocalDockerImage | LocalDockerImage} is outside the k3s-dind environment, it must
       * use a host accessible network to push to the registry.  However, since the k3s-dind instance sees
       * the registry from within Docker, it must use a different address to pull the images for use.
       *
       * Once network scopes are fully supported, this interface will change to whatever is appropriate.  It
       * is best if you can arrange to have the same URL or registry string work for all access regardless
       * of which network the registry, Adapt host, and ultimate container running environment is uses.
       */
      registryPrefix: RegistryString | DockerSplitRegistryInfo;
      /**
       * Path and tag to be used for the image in the new registry in
       * `path:tag` or `path` format.
       * @remarks
       * The entire path and tag are blindly concatenated to the domain and path
       * in registryPrefix to form the full ref that will be used to push the
       * image.
       *
       * If omitted, the last component of the path and the tag from the source
       * image is used. The newPathTag should not include the registry
       * hostname/port prefix. If the `:tag` portion of `path:tag` is omitted,
       * the tag `latest` will be used.
       */
      newPathTag?: string;
      /**
       * Path and tag to be used for the image in the new registry in
       * `path:tag` or `path` format.
       * @deprecated This prop has been renamed to `newPathTag`. The functionality
       * for both props is the same and if both are set, `newPathTag` takes
       * priority.
       * @remarks
       * If omitted, the path and tag from the source image is used. The
       * newTag should not include the registry hostname/port prefix. If the
       * `:tag` portion of `path:tag` is omitted, the tag `latest` will be used.
       */
      newTag?: string;
  }/**
   * Represents a Docker image in a registry.
   * @remarks
   * If the image does not exist in the specified registry, it will be pushed
   * to that registry.
   * @public
   */
  export declare class RegistryDockerImage extends Action<RegistryDockerImageProps, State> implements DockerImageInstance {
      private latestImage_?;
      private latestRegistryUrl_?;
      private registry;
      constructor(props: RegistryDockerImageProps);
      /**
       * Returns information about the version of the Docker image that reflects
       * the current set of props for the component and has been pushed to the
       * registry.
       * @remarks
       * Returns undefined if the `props.imageSrc` component's `latestImage` method
       * returns undefined (depending on the component referenced by
       * `props.imageSrc`, that may indicate the source image has not been built).
       * Also returns undefined if the current image has not yet been
       * pushed to the registry.
       */
      image(): ImageRefRegistry | undefined;
      /**
       * Returns information about the most current version of the Docker image
       * that has been pushed to the registry.
       * @remarks
       * Returns undefined if no image has ever been pushed by this component.
       */
      latestImage(): ImageRefRegistry | undefined;
      /** @internal */
      initialState(): {};
      /** @internal */
      shouldAct(diff: ChangeType): false | {
          act: boolean;
          detail: string;
      };
      /** @internal */
      dependsOn: DependsOnMethod;
      /** @internal */
      action(op: ChangeType): Promise<void>;
      private currentNameTag;
      private getNewPathTag;
      private srcImageName;
  }/**
   * Props for {@link docker.ServiceContainerSet}
   *
   * @public
   */
  export declare interface ServiceContainerSetProps extends ServiceProps {
      /**
       * Props to apply to all {@link docker.DockerContainer}s within this
       * ServiceContainerSet. If a prop is specified in the source {@link Container}
       * component and in `containerProps`, `containerProps` will take
       * precedence.
       */
      containerProps?: Partial<DockerContainerProps>;
      /**
       * If set, all children of this ServiceContainerSet that support the
       * `dockerHost` prop will get this value, overriding any other value for
       * this prop.
       */
      dockerHost?: string;
  }/**
   * A component for mapping a group of abstract {@link Container}s and
   * {@link NetworkService}s to Docker {@link docker.DockerContainer | DockerContainer}s
   * and {@link docker.NetworkService}s.
   *
   * @remarks
   * This component is intended to be used to replace {@link Container} and
   * {@link NetworkService} components that are grouped together, as the
   * only children of a common parent in a pattern that looks like this:
   * ```tsx
   * <Service>
   *   <Container ... />
   *   <Container ... />
   *   <NetworkService ... />
   * </Service>
   * ```
   * `ServiceContainerSet` maps those abstract components into Docker components
   * like this:
   * ```tsx
   * <Group>
   *   <docker.DockerContainer ... >
   *   <docker.DockerContainer ... >
   *   <docker.NetworkService ... >
   * </Group>
   * ```
   * An example style rule to do this is:
   * ```tsx
   * {Service}
   * {Adapt.rule((matchedProps) => {
   *     const { handle, ...remainingProps } = matchedProps;
   *     return <ServiceContainerSet {...remainingProps} />;
   * })}
   * ```
   *
   * Currently, {@link docker.NetworkService} implements the {@link NetworkServiceInstance}
   * interface, but does not deploy a network proxy component. So the Docker
   * ServiceContainerSet component applies the network port configuration specified by
   * the {@link NetworkService}s to their target
   * {@link docker.DockerContainer | DockerContainer}s.
   *
   * @public
   */
  export declare class ServiceContainerSet extends DeferredComponent<ServiceContainerSetProps> {
      build(helpers: BuildHelpers): Adapt.JSX.Element;
  }/**
   * Options for interacting with Docker Engine that apply to all
   * operations.
   * @public
   */
  export declare interface DockerGlobalOptions {
      dockerHost?: string;
  }/**
   * Options for performing Docker image builds.
   * @public
   */
  export declare interface DockerBuildOptions extends DockerGlobalOptions {
      /**
       * Requests BuildKit as the internal Docker build engine.
       *
       * @remarks
       * This option requests the use of the BuildKit build engine when building
       * Docker images, if BuildKit is available. This is primarily useful for
       * BuildKit's performance improvements over the legacy Docker build engine.
       * However, because this option does not guarantee BuildKit will be used,
       * BuildKit-only features such as secret mounting should not be used.
       *
       * Internally, this option sets the `DOCKER_BUILDKIT` environment
       * variable when performing builds, which enables BuildKit on Docker
       * systems that support it.
       *
       * For more information, see
       * [Build images with BuildKit](https://docs.docker.com/develop/develop-images/build_enhancements/).
       *
       * @defaultValue `true`
       */
      requestBuildKit?: boolean;
      forceRm?: boolean;
      imageName?: string;
      imageTag?: string;
      prevUniqueNameTag?: string;
      stdin?: string;
      /**
       * If true and the newly built image ID does not match the image ID for
       * prevUniqueNameTag (or prevUniqueNameTag is not set), a new unique nameTag is
       * generated for this image (from imageName and imageTag).
       * If true and the newly built image ID does match the image ID for
       * prevUniqueNameTag, then prevUniqueNameTag is returned as nameTag.
       * If false, imageName and imageTag are used without modification.
       */
      uniqueTag?: boolean;
      /**
       * If set, will add a Docker LABEL with the DeployID.
       */
      deployID?: string;
      buildArgs?: Environment;
  }/**
   * A dynamically-created file that can be used during the build of a Docker
   * image.
   *
   * @remarks
   * These `File` objects are used to create a temporary "scratch" image in a
   * {@link https://docs.docker.com/develop/develop-images/multistage-build/ | multi-stage build}
   * that contains only the specified files. Then, in later stages of that build,
   * the files within the temporary image can be copied into the later stage
   * image.
   * @public
   */
  export declare interface File {
      /**
       * The path in the temporary image where the file will be created.
       */
      path: string;
      /**
       * The contents of the file.
       */
      contents: Buffer | string;
  }/**
   * A stage to be added to a
   * {@link https://docs.docker.com/develop/develop-images/multistage-build/ | multi-stage Docker build}.
   *
   * @remarks
   * The stage will be added to the generated Dockerfile for the image as:
   * ```
   * FROM image as name
   * ```
   * @public
   */
  export declare interface Stage {
      /** The image (name + tag or digest) to use for the stage. */
      image: string;
      /** Name for the stage */
      name: string;
  }/**
   * A string that contains both a Docker repo and a registry digest.
   *
   * @remarks
   * This is a string that represents a specific image on a specific registry
   * contained in a particular repo on that registry. It's of the form:
   * ```
   * [registry/]repo@digest
   * ```
   * `registry` - (optional) The hostname or hostname:port of a Docker registry
   * where the repo is located. If not provided, the official default Docker
   * registry is assumed.
   *
   * `repo` - The more precise name for what's commonly referred to as an image
   * name. It may include 0 or more slashes to denote namespaces.
   *
   * `digest` - The repo digest for the image in the form `algorithm:hex`.
   * This digest is specific to the associated registry and repo and has no
   * significance without those additional pieces of information. If this image is
   * pushed to a different registry, it will have a different digest value.
   * The digest is also known as a "distribution hash".
   *
   * Examples:
   * ```
   * alpine@sha256:04696b491e0cc3c58a75bace8941c14c924b9f313b03ce5029ebbc040ed9dcd9
   * localhost:5000/mockdeploy-htws@sha256:899a03e9816e5283edba63d71ea528cd83576b28a7586cf617ce78af5526f209
   * ```
   * @public
   */
  export declare type RepoDigestString = string;/**
   * Docker image ID, in the form `algorithm:hex`.
   *
   * @remarks
   * The Docker image ID (also known as "Content Hash") is a single value
   * that uniquely identifies a specific image on a local Docker host.
   *
   * An image ID does not require a registry or repo qualifier to be significant.
   * It is distinct from a Docker image
   * {@link docker.RepoDigestString | repo digest}.
   *
   * Example:
   * ```
   * sha256:199e537da3a86126cd6eb114bd0b13ab178dc291bbb6ea4a4a3aa257b2366b71
   * ```
   * @public
   */
  export declare type ImageIdString = string;/**
   * A string reference to a Docker image that contains a repo name, and may
   * contain an optional registry and optional tag.
   *
   * @remarks
   * This is a string that references a Docker image. It's in the form of
   * one of:
   * ```
   * [registry/]repo
   * [registry/]repo:tag
   * ```
   * `registry` - (optional) The hostname or hostname:port of a Docker registry
   * where the repo is located. If not provided, depending on context, either
   * the official default Docker registry may be assumed or the image may just
   * be present locally and not on any registry.
   *
   * `repo` - The more precise name for what's commonly referred to as an image
   * name. It may include 0 or more slashes to denote namespaces.
   *
   * `tag` - A tag string identifying a version of image within the repo.
   *
   * Examples:
   * ```
   * alpine
   * ubuntu:16.04
   * ```
   * @public
   */
  export declare type NameTagString = string;/**
   * A string reference to a Docker image that contains a repo name, and may
   * contain an optional registry and optionally either a tag or a repo digest.
   *
   * @remarks
   * This is a string that references a Docker image. It's in the form of
   * one of:
   * ```
   * [registry/]repo
   * [registry/]repo:tag
   * [registry/]repo@digest
   * ```
   * For more detail, see {@link docker.NameTagString} and
   * {@link docker.RepoDigestString}.
   *
   * Examples:
   * ```
   * alpine
   * ubuntu:16.04
   * alpine@sha256:04696b491e0cc3c58a75bace8941c14c924b9f313b03ce5029ebbc040ed9dcd9
   * localhost:5000/mockdeploy-htws@sha256:899a03e9816e5283edba63d71ea528cd83576b28a7586cf617ce78af5526f209
   * ```
   * @public
   */
  export declare type ImageNameString = NameTagString | RepoDigestString;/**
   * A string that references a Docker registry that contains a hostname and
   * may optionally contain a port and/or path.
   *
   * @remarks
   * This string is in the form of one of:
   * ```
   * hostname[:port]
   * hostname[:port]/path
   * ```
   * This form does not include the protocol, such as `http:` or `https:` in
   * the string.
   *
   * @public
   */
  export declare type RegistryString = string;/**
   * Information about a specific instance of a Docker image, as identified by
   * its image ID.
   * @deprecated Replaced with {@link docker.ImageRef}.
   * @public
   */
  export declare interface ImageInfo {
      /**
       * Docker image ID, in the form `algorithm:hex`.
       * @remarks
       * See {@link docker.ImageIdString}.
       */
      id: ImageIdString;
      /**
       * Docker image name and optional tag in the form `name` or `name:tag`.
       * @remarks
       * See {@link docker.NameTagString}
       */
      nameTag?: NameTagString;
  }/**
   * Props for {@link docker.DockerContainer}
   *
   * @public
   */
  export declare interface DockerContainerProps extends DockerGlobalOptions, Pick<ContainerProps, "autoRemove" | "command" | "environment" | "portBindings" | "ports" | "restartPolicy" | "stopSignal"> {
      /** image name as a string, or a handle to a DockerImage component */
      image: ImageNameString | Handle<DockerImageInstance>;
      /**
       * Host and port of the remote docker host to use.
       *
       * @remarks
       * Defaults to the DOCKER_HOST environment variable
       */
      dockerHost: string;
      /**
       * Labels to apply to the container.
       */
      labels?: ContainerLabels;
      /**
       * Filesystems to be mounted in the container.
       */
      mounts?: Mount[];
      /**
       * Networks to connect the container to
       *
       * @remarks
       * Accepts the same strings as docker network connect
       */
      networks?: string[];
      /**
       * Enables the container to run in privileged mode.
       */
      privileged?: boolean;
  }/**
   * Represents a split registry, with pushes going to external and pulls going to internal
   * @beta
   */
  export declare interface DockerSplitRegistryInfo {
      external: RegistryString;
      internal: RegistryString;
  }/**
   * Describes bind mount filesystems to be mounted in a container.
   * @public
   */
  export declare interface BindMount {
      type: "bind";
      source: string;
      destination: string;
      readonly?: boolean;
      propagation?: "shared" | "slave" | "private" | "rshared" | "rslave" | "rprivate";
  }/**
   * Describes filesystems to be mounted in a container.
   * @public
   */
  export declare type Mount = BindMount;/**
   * Props for {@link docker.BuildKitImage}
   *
   * @public
   */
  export declare interface BuildKitImageProps {
      /** Directory for use as the build context */
      contextDir?: string;
      /**
       * Contents of the dockerfile
       *
       * @remarks
       * Should not be used if dockerfileName is set
       */
      dockerfile?: string;
      /**
       * Path to a local Dockerfile in the Adapt project.
       *
       * @remarks
       * This path is relative to the root of the Adapt project.
       * Should not be used if `dockerfile` is set.
       */
      dockerfileName?: string;
      /**
       * Extra files that should be included during the docker build
       *
       * @remarks
       * BuildKitImage uses a multi-stage build process.  It first creates
       * a temporary image that includes the files specified in this field.
       * This temporary image is then made available to the `dockerfile` with
       * stage name `files` and can then be copied into the final image, as
       * desired, using `COPY` or `ADD` commands in the `dockerfile`.
       *
       * @example
       * To create a final Docker image that contains a file that has some
       * programmatically created content, use the `dockerfile` prop along
       * with the `files` prop like this:
       * ```tsx
       * const files = [{
       *   path: '/path/to/myfile.txt',
       *   contents: 'contents for myfile\n'
       * }];
       * const dockerfile = `
       *   FROM alpine
       *   COPY --from=files /path/to/myfile.txt /app/myfile.txt
       *   ...
       * `;
       * return <BuildKitImage files={files} dockerfile={dockerfile} />
       * ```
       */
      files?: File[];
      /**
       * Options to control the behavior of docker build
       */
      options?: BuildKitBuildOptions;
      /**
       * Directs BuildKit where to store the built image.
       */
      output: BuildKitOutput;
      /**
       * Extra stages to include in a multi-stage docker build
       */
      stages?: Stage[];
  }/**
   * @internal
   */
  export declare interface BuildKitImageState {
      deployOpID?: DeployOpID;
      image?: WithId<ImageRefRegistry>;
      imagePropsJson?: string;
      prevUniqueNameTag?: string;
  }/**
   * Locally builds a docker image
   *
   * @remarks
   * See {@link docker.BuildKitImageProps}.
   *
   * @public
   */
  export declare class BuildKitImage extends Action<BuildKitImageProps, BuildKitImageState> implements DockerPushableImageInstance {
      static defaultProps: {
          options: {};
      };
      deployedWhenIsTrivial: boolean;
      private image_?;
      private imagePropsJson_?;
      private options_;
      constructor(props: BuildKitImageProps);
      buildComplete(): boolean;
      ready(): boolean;
      image(): WithId<ImageRefRegistry> | undefined;
      pushTo({ ref }: {
          ref: string;
      }): Promise<undefined | WithId<ImageRefRegistry>>;
      latestImage(): WithId<ImageRefRegistry> | undefined;
      /**
       * User-facing name to display in status messages.
       */
      displayName(): string;
      /**
       * Implementations for Action base class
       * @internal
       */
      shouldAct(op: ChangeType): Promise<ShouldAct>;
      /**
       * Implementations for Action base class
       * @internal
       */
      action(op: ChangeType, ctx: ActionContext): Promise<void>;
      /** @internal */
      initialState(): {};
      /** @internal */
      deployedWhen: (goalStatus: GoalStatus) => true | import("@adpt/core").Waiting;
      /** @internal */
      protected get imagePropsJson(): string;
  }/**
   * Components that provide a Docker image can implement this interface to
   * allow other components to get information about the Docker image.
   * @public
   */
  export declare interface DockerImageInstance {
      /**
       * Returns information about the version of the Docker image that reflects
       * the current set of props for the component.
       * @remarks
       * Returns undefined if no image has ever been built by
       * this component OR if the component props have changed and the image
       * that corresponds to the current props has not yet been built.
       */
      image(): ImageRef | undefined;
      /**
       * Returns information about the most current version of the Docker image
       * that has completed building, even if that version does not reflect the
       * current set of props for the component.
       * @remarks
       * Returns undefined if no image has ever been built by this component.
       */
      latestImage(): ImageRef | undefined;
      /**
       * Pushes the image returned by `latestImage` to a Docker registry.
       *
       * @param ref - A docker domain, path components, and tag to which this image should be pushed
       *
       * @remarks
       * If there is no latest image available (`latestImage` returns
       * undefined), then `pushTo` will return undefined. Otherwise, if the
       * push was successful, returns an {@link docker.ImageRefRegistry} that contains
       * the complete nameTag, including registry portion.
       */
      pushTo?({ ref }: {
          ref: NameTagString;
      }): MaybePromise<ImageRefRegistry | undefined>;
  }/**
   * Components that provide a Docker image can implement this interface to
   * allow other components to get information about the Docker image and
   * to be able to push the image to a registry.
   * @public
   */
  export declare interface DockerPushableImageInstance extends DockerImageInstance {
      /**
       * {@inheritdoc docker.DockerImageInstance.pushTo}
       */
      pushTo({ ref }: {
          ref: NameTagString;
      }): MaybePromise<ImageRefRegistry | undefined>;
  }/**
   * Props for {@link docker.DockerImage}.
   * @beta
   */
  export declare interface DockerImageProps {
  }/**
   * Abstract component representing a {@link https://docker.com | Docker}
   * image that can be used to create containers.
   * @remarks
   * See also {@link Container}.
   * @beta
   */
  export declare abstract class DockerImage extends Component<DockerImageProps> implements DockerImageInstance {
      /**
       * {@inheritdoc docker.DockerImageInstance.image}
       */
      image(): ImageRef | undefined;
      /**
       * {@inheritdoc docker.DockerImageInstance.latestImage}
       */
      latestImage(): ImageRef | undefined;
  }/**
   * Compute the status of a container based on a graphQL schema
   *
   * @internal
   */
  export declare function containerStatus(observe: ObserveForStatus, containerName: string, dockerHost: string): Promise<ContainerStatus | NoStatus>;/** @public */
  export declare interface DockerContainerStatus extends ContainerStatus {
  }/**
   * Compute a unique name for the container
   *
   * @internal
   */
  const computeContainerName: (elemKey: string, elemID: string, deployID: string) => string;/**
   * Component to instantiate an image container with docker
   *
   * @remarks
   * See {@link docker.DockerContainerProps}.
   *
   * @public
   */
  declare class DockerContainer extends Action<DockerContainerProps, DockerContainerState> {
      static defaultProps: {
          dockerHost: string;
          privileged: boolean;
      };
      info?: ContainerInfo;
      dependsOn: DependsOnMethod;
      /** @internal */
      shouldAct(diff: ChangeType, context: ActionContext): Promise<false | ShouldAct>;
      /** @internal */
      action(diff: ChangeType, context: ActionContext): Promise<void>;
      status(observe: ObserveForStatus, buildData: BuildData): Promise<NoStatus | ContainerStatus>;
      /**
       * Get the IP address of the container, optionally for a specific Docker
       * network.
       * @remarks
       * The IP addresses that are returned by this function are valid only
       * on the associated Docker network, which is often only associated
       * with a single host node for most Docker network types.
       *
       * @param network - Name of a Docker network. If `network` is provided
       * and the container is connected to the network with an IP address, that
       * address will be returned. If the container is not connected to the
       * network, `undefined` will be returned. If `network` is not provided,
       * the default container IP address will be returned.
       *
       * @beta
       */
      dockerIP(network?: string): string | undefined;
      /** @internal */
      initialState(): {};
      private displayName;
      private refreshContainerInfo;
  }/**
   * Component to instantiate an image container with docker
   *
   * @remarks
   * See {@link docker.DockerContainerProps}.
   *
   * @public
   */
  declare class DockerContainer extends Action<DockerContainerProps, DockerContainerState> {
      static defaultProps: {
          dockerHost: string;
          privileged: boolean;
      };
      info?: ContainerInfo;
      dependsOn: DependsOnMethod;
      /** @internal */
      shouldAct(diff: ChangeType, context: ActionContext): Promise<false | ShouldAct>;
      /** @internal */
      action(diff: ChangeType, context: ActionContext): Promise<void>;
      status(observe: ObserveForStatus, buildData: BuildData): Promise<NoStatus | ContainerStatus>;
      /**
       * Get the IP address of the container, optionally for a specific Docker
       * network.
       * @remarks
       * The IP addresses that are returned by this function are valid only
       * on the associated Docker network, which is often only associated
       * with a single host node for most Docker network types.
       *
       * @param network - Name of a Docker network. If `network` is provided
       * and the container is connected to the network with an IP address, that
       * address will be returned. If the container is not connected to the
       * network, `undefined` will be returned. If `network` is not provided,
       * the default container IP address will be returned.
       *
       * @beta
       */
      dockerIP(network?: string): string | undefined;
      /** @internal */
      initialState(): {};
      private displayName;
      private refreshContainerInfo;
  }/**
   * Type guard for determining whether a given object has a non-null `id`
   * property.
   * @public
   */
  export declare function hasId<T extends {
      id?: ImageIdString;
  }>(o: T): o is WithId<T>;/**
   * Factory function for creating a {@link docker.MutableImageRef}.
   * @remarks
   * Can also be used to clone an existing {@link docker.MutableImageRef} or
   * to create a mutable version of an existing {@link docker.ImageRef}.
   * @public
   */
  export declare function mutableImageRef(ref: ImageNameString, normalize?: boolean): MutableImageRef;/**
   * Factory function for creating a {@link docker.MutableImageRef}.
   * @remarks
   * Can also be used to clone an existing {@link docker.MutableImageRef} or
   * to create a mutable version of an existing {@link docker.ImageRef}.
   * @public
   */
  export declare function mutableImageRef(info?: ImageRefData): MutableImageRef;/**
   * Factory function for creating a {@link docker.ImageRef} or cloning an
   * existing one.
   * @public
   */
  export declare function imageRef(ref: ImageNameString, normalize?: boolean): ImageRef;/**
   * Factory function for creating a {@link docker.ImageRef} or cloning an
   * existing one.
   * @public
   */
  export declare function imageRef(info?: ImageRefData): ImageRef;/**
   * A type guard for determining whether a {@link docker.ImageRef} is a
   * {@link docker.ImageRefRegistry}.
   * @public
   */
  export declare function isImageRefRegistry(ref: ImageRef): ref is ImageRefRegistry;/**
   * A type guard for determining whether a {@link docker.ImageRef} is a
   * {@link docker.ImageRefRegistry} that has the `id` property set.
   * @public
   */
  export declare function isImageRefRegistryWithId(ref: ImageRef): ref is WithId<ImageRefRegistry>;/**
   * A type guard for determining whether a {@link docker.ImageRef} is a
   * {@link docker.ImageRefDockerHost}.
   * @public
   */
  export declare function isImageRefDockerhost(ref: ImageRef): ref is ImageRefDockerHost;/**
   * A type guard for determining whether a {@link docker.ImageRef} is a
   * {@link docker.ImageRefDockerHost} that has the `id` property set.
   * @public
   */
  export declare function isImageRefDockerhostWithId(ref: ImageRef): ref is WithId<ImageRefDockerHost>;/**
   * The most basic components that make up a {@link docker.ImageRef}.
   * All other properties of a {@link docker.ImageRef} can be computed from
   * these.
   * @remarks
   * See also {@link docker.ImageRef} for more information on references.
   * @public
   */
  export declare interface ImageRefData {
      /**
       * Image digest in the form `algorithm:hex`
       * @example
       * sha256:04696b491e0cc3c58a75bace8941c14c924b9f313b03ce5029ebbc040ed9dcd9
       */
      digest?: string;
      /**
       * Docker host string to contact the Docker daemon where this image is
       * located.
       *
       * @remarks
       * This should be in the same format that Docker expects for the `DOCKER_HOST`
       * environment variable. The special string `default` can also be used,
       * which will use the current value of the `DOCKER_HOST` environment variable,
       * if it is set and will otherwise use the default named pipe on Windows
       * (`npipe:///./pipe/docker_engine`) and the default socket on other
       * systems (`unix:///var/run/docker.sock`).
       * @example
       * tcp://localhost:2375
       */
      dockerHost?: "default" | string;
      /**
       * Hostname and optional port number of the container image registry where
       * this image is located.
       * @example
       * docker.io
       * @example
       * localhost:5000
       */
      domain?: RegistryString;
      /**
       * Image content ID in the form `algorithm:hex`
       * @example
       * sha256:199e537da3a86126cd6eb114bd0b13ab178dc291bbb6ea4a4a3aa257b2366b71
       */
      id?: ImageIdString;
      /**
       * The image repo path.
       * @example
       * google/cloud-sdk
       */
      path?: string;
      /**
       * Image tag
       * @example
       * latest
       */
      tag?: string;
  }/**
   * The type of an image reference indicates how the image can be
   * accessed, currently either through a Docker host (daemon) or directly to a
   * container registry via its API.
   *
   * @remarks
   * If not enough information is present to access and uniquely identify a
   * container image, the type is `incomplete`.
   * @public
   */
  export declare type ImageRefType = "incomplete" | "registry" | "dockerhost";/**
   * An immutable reference to a container image, including all information
   * known about the image.
   *
   * @remarks
   * This type is the base type for an image reference and is allowed to
   * contain partial or incomplete information about a container image.
   * It can include both information about how to access the image and
   * also information about the image itself.
   *
   * Many of the properties of {@link docker.ImageRef} are related to the
   * container image reference string used by Docker and other container-based
   * systems. A container image reference string is a structured string
   * containing multiple components. The most basic components are illustrated
   * below, using the example image reference string
   * `"my.registry:5000/a/repo/path:sometag@sha256:899a03e9816e5283edba63d"`.
   *
   * NOTE: The length of the `digest` has been shortened for formatting
   * purposes.
   *
   * ```
   * "my.registry:5000/a/repo/path:sometag@sha256:899a03e9816e5283edba63d"
   * |     domain     |   path    |  tag  |         digest               |
   * ```
   *
   * To aid in correct formatting, {@link docker.ImageRef} and related types and
   * classes also provide helper properties that combine these basic components
   * into combinations that are often useful, such as `name`, which is the
   * `domain` and `path` combined with a `/`.
   *
   * Many tools, such as the Docker UI, also accept a shortened form of a string
   * reference, called the `familiar` form. An example of a familiar reference is
   * `ubuntu`. In this form, only the `path` component is required. When
   * components of the reference are left out, default values are assumed. The
   * default `domain` is `docker.io` and the default `tag` is `latest`.
   * Additionally, if the `domain` is `docker.io` and there are no `/` characters
   * in the `path`, `library/` is prepended to the path. So `ubuntu` is the
   * familiar form for the complete reference `docker.io/library/ubuntu:latest`.
   *
   * An {@link docker.ImageRef} is designed to hold as much information about
   * an image as may be available and therefore some properties that are
   * not known will be `undefined`.
   *
   * See also {@link docker.MutableImageRef}, which can be used to parse
   * reference strings and construct or modify image references.
   * @public
   */
  export declare interface ImageRef extends Readonly<ImageRefData> {
      /**
       * The complete string reference for this image in familiar form, which
       * leaves out certain fields from the reference when they are set to
       * default values.
       * @remarks
       * This reference form is the form typically used in the Docker UI.
       * If the ImageRef is not complete, familiar will return `undefined`, as
       * the correct familiar representation cannot be determined.
       * @example
       * mysql
       * @example
       * gcr.io/my-project/image:1.0.1
       */
      readonly familiar?: string;
      /**
       * The image name, which is comprised of the optional domain and
       * the (non-optional) path. Will be `undefined` if there is no `path`.
       * @example
       * gcr.io/my-project/image
       */
      readonly name?: string;
      /**
       * The image name (including any registry) and image tag. Returns undefined
       * if either path or tag are not set.
       * If nameTag is set to a string that does not contain a tag (i.e. does
       * not include a ":"), the default tag of `latest` will be set.
       * To set nameTag without defaulting to `latest`, call the class method
       * `setNameTag` with the parameter `useDefaultTag` set to `false`.
       * @example
       * gcr.io/my-project/image:1.0.1
       */
      readonly nameTag?: string;
      /**
       * The image path (not including any registry) and image tag. Returns
       * undefined if either `path` or `tag` are not set.
       * @example
       * my-project/image:1.0.1
       */
      readonly pathTag?: string;
      /**
       * The best (most specific and complete) string reference for this image,
       * given the information available in this {@link docker.ImageRef}.
       */
      readonly ref: string;
      /**
       * An alias for `domain`.
       */
      readonly registry?: string;
      /**
       * The best remote reference available for this image in either
       * `domain/path@digest` format or `domain/path:tag` format.
       * @remarks
       * Returns `registryDigest` if it is set, otherwise returns `registryTag`.
       * If no remote reference is available, returns undefined.
       * @example
       * gcr.io/my-project/image\@sha256:899a03e9816e5283edba63d71ea528cd83576b28a7586cf617ce78af5526f209
       * @example
       * gcr.io/my-project/image:1.0.1
       */
      readonly registryRef?: string;
      /**
       * The remote digest reference in `domain/path@digest` form.
       * @remarks
       * Undefined if any of `domain`, `path`, or `digest` are unset.
       * @example
       * gcr.io/my-project/image\@sha256:899a03e9816e5283edba63d71ea528cd83576b28a7586cf617ce78af5526f209
       */
      readonly registryDigest?: string;
      /**
       * The remote tag reference in `domain/path:tag` form.
       * @remarks
       * Undefined if any of `domain`, `path`, or `tag` are unset.
       * @example
       * gcr.io/my-project/image:1.0.1
       */
      readonly registryTag?: string;
      /**
       * The type of an image reference indicates how the image can be
       * accessed, either through a Docker host (daemon) or directly to a
       * container registry.
       *
       * @remarks
       * A reference is a valid `dockerhost` type ref when it contains a valid
       * dockerHost string and either:
       * - A valid image id or
       * - A valid path and either a valid tag or digest.
       *
       * A reference is a valid `registry` type ref when it contains a valid
       * domain, path, and either a tag or a digest.
       *
       * If not enough information is present to access and uniquely identify a
       * container image, the type is `incomplete`.
       */
      readonly type: ImageRefType;
  }/**
   * Helper type that augments a base type to indicate that the `id` field
   * is present and has a valid image ID.
   * @public
   */
  export declare type WithId<T> = T & {
      id: ImageIdString;
  };/**
   * A mutable reference to a container image that can be used to parse,
   * construct, and modify an image reference, as well as to hold information
   * about the image and how to access it.
   *
   * @remarks
   * This class can be used to parse strings that contain complete or partial
   * container image references. It can also be used to construct an image
   * reference from scratch, from individual component parts, or from another
   * reference, then to correctly format the reference or its components for
   * use with various tools.
   *
   * To parse and normalize a "familiar" image reference, like is typically
   * seen in the Docker UI:
   * ```ts
   * const ref = mutableImageRef("redis", true);
   * console.log(ref.tag);         // => "latest"
   * console.log(ref.registryRef); // => "docker.io/library/redis:latest"
   * ```
   *
   * To construct a reference to an image present on the local Docker daemon
   * that has an image ID:
   * ```ts
   * const ref = mutableImageRef({
   *     dockerHost: "default",
   *     path: "myimage",
   *     tag: "just-built",
   *     id: "sha256:04696b491e0cc3c58a75bace8941c14c924b9f313b03ce5029ebbc040ed9dcd9",
   * });
   * ```
   *
   * To convert a `MutableImageRef` to an immutable plain object `ImageRef`,
   * use the `freeze` method.
   * @public
   */
  export declare class MutableImageRef implements ImageRef {
      _digest?: string;
      _dockerHost?: string;
      _domain?: string;
      _id?: ImageIdString;
      _path?: string;
      _tag?: string;
      constructor(ref: ImageNameString, normalize?: boolean);
      constructor(info?: ImageRefData | undefined);
      freeze(): ImageRef;
      toData(): ImageRefData;
      toJSON(): ImageRefData;
      /**
       * The digest string for this image in its associated registry and repo
       * in the form `algorithm:hex`.
       */
      get digest(): string | undefined;
      set digest(digest: string | undefined);
      get dockerHost(): string | undefined;
      set dockerHost(dockerHost: string | undefined);
      /**
       * The hostname and optional port of the image registry for this image.
       */
      get domain(): string | undefined;
      set domain(domain: string | undefined);
      /**
       * The complete string reference for this image in familiar form, which
       * leaves out certain fields from the reference when they are set to
       * default values.
       * @remarks
       * This reference form is the form typically used in the Docker UI.
       * If the ImageRef is not complete, familiar will return `undefined`, as
       * the correct familiar representation cannot be determined.
       */
      get familiar(): string | undefined;
      /**
       * The content ID of the image in `algorithm:hex` format.
       */
      get id(): ImageIdString | undefined;
      set id(id: ImageIdString | undefined);
      /**
       * The image name, which is comprised of the optional domain and
       * the (non-optional) path.
       */
      get name(): string | undefined;
      set name(name: string | undefined);
      /**
       * The image name (including any registry) and image tag. Returns undefined
       * if either path or tag are not set.
       * If nameTag is set to a string that does not contain a tag (i.e. does
       * not include a ":"), the default tag of `latest` will be set.
       * To set nameTag without defaulting to `latest`, call the class method
       * `setNameTag` with the parameter `useDefaultTag` set to `false`.
       */
      get nameTag(): NameTagString | undefined;
      set nameTag(nt: NameTagString | undefined);
      /**
       * Method to set the image name and image tag which also allows choice
       * of default behavior when `nameTag` does not contain a tag string.
       */
      setNameTag(nameTag: NameTagString | undefined, useDefaultTag?: boolean): void;
      /**
       * The image repo path.
       */
      get path(): string | undefined;
      set path(path: string | undefined);
      /**
       * The image path (not including any registry) and image tag. Returns
       * undefined if either path or tag are not set.
       * If pathTag is set to a string that does not contain a tag (i.e. does
       * not include a ":"), the default tag of `latest` will be set.
       * To set pathTag without defaulting to `latest`, call the class method
       * `setPathTag` with the parameter `useDefaultTag` set to `false`.
       */
      get pathTag(): string | undefined;
      set pathTag(pathTag: string | undefined);
      /**
       * Method to set the image path and image tag which also allows choice
       * of default behavior when `pathTag` does not contain a tag string.
       */
      setPathTag(pathTag: string | undefined, useDefaultTag?: boolean): void;
      get ref(): string;
      /**
       * Alias for domain
       */
      get registry(): string | undefined;
      /**
       * The best remote reference available for this image in either
       * `domain/path@digest` format or `domain/path:tag` format.
       * @remarks
       * Returns `registryDigest` if it is set, otherwise returns `registryTag`.
       * If no remote reference is available, returns undefined.
       */
      get registryRef(): ImageNameString | undefined;
      /**
       * The remote digest reference in `domain/path@digest` form.
       * @remarks
       * Undefined if any of `domain`, `path`, or `digest` are unset.
       */
      get registryDigest(): RepoDigestString | undefined;
      set registryDigest(rd: RepoDigestString | undefined);
      /**
       * The remote tag reference in `domain/path:tag` form.
       * @remarks
       * Undefined if any of `domain`, `path`, or `tag` are unset.
       */
      get registryTag(): NameTagString | undefined;
      set registryTag(rt: NameTagString | undefined);
      /**
       * The image tag.
       */
      get tag(): string | undefined;
      set tag(tag: string | undefined);
      /**
       * The type of an image reference indicates how the image can be
       * accessed, either through a Docker host (daemon) or directly to a
       * container registry.
       *
       * @remarks
       * A reference is a valid `dockerhost` type ref when it contains a valid
       * dockerHost string and either:
       * - A valid image id or
       * - A valid path and either a valid tag or digest.
       *
       * A reference is a valid `registry` type ref when it contains a valid
       * domain, path, and either a tag or a digest.
       *
       * If not enough information is present to access and uniquely identify a
       * container image, the type is `incomplete`.
       */
      get type(): ImageRefType;
  }/**
   * A more specific type of {@link docker.ImageRef} that contains sufficient
   * information to uniquely identify an image on a container registry.
   * @public
   */
  export declare interface ImageRefRegistry {
      readonly digest?: string;
      readonly domain: string;
      readonly familiar: string;
      readonly id?: ImageIdString;
      readonly name: string;
      readonly nameTag?: string;
      readonly path: string;
      readonly pathTag?: string;
      readonly ref: string;
      readonly registry: string;
      readonly registryRef: string;
      readonly registryDigest?: string;
      readonly registryTag?: string;
      readonly tag?: string;
      readonly type: "registry";
  }/**
   * A more specific type of {@link docker.ImageRef} that contains sufficient
   * information to uniquely identify an image on a specific Docker host
   * (daemon).
   * @public
   */
  export declare interface ImageRefDockerHost {
      readonly digest?: string;
      readonly dockerHost: string;
      readonly domain?: string;
      readonly familiar: string;
      readonly id?: ImageIdString;
      readonly name: string;
      readonly nameTag?: string;
      readonly path: string;
      readonly pathTag?: string;
      readonly ref: string;
      readonly registry?: string;
      readonly registryRef?: string;
      readonly registryDigest?: string;
      readonly registryTag?: string;
      readonly tag?: string;
      readonly type: "dockerhost";
  }/**
   * Docker network service component, compatible with the abstract
   * {@link NetworkService} component.
   *
   * @remarks
   *
   * Implements the {@link NetworkServiceInstance} interface.
   * In a Docker deployment, there is no actual network service object to deploy.
   * So this is a "virtual" component that simply implements the required
   * instance methods for a NetworkService, but renders to null.
   *
   * This component is typically used by {@link docker.ServiceContainerSet}. The
   * {@link docker.ServiceContainerSet} component can be used to ensure the proper
   * network port configuration is applied to the `props.endpoint` container.
   *
   * @public
   */
  export declare function NetworkService(props: SFCDeclProps<NetworkServiceProps, typeof defaultProps>): null;/**
   * The base string used for Adapt Docker labels.
   * @internal
   */
  const adaptDockerKey = "org.adaptjs";/**
   * Docker label for the deployID the object was created from.
   * @internal
   */
  const adaptDockerDeployIDKey: string;/**
   * Props for {@link docker.LocalDockerImage}
   *
   * @public
   */
  export declare interface LocalDockerImageProps {
      /** Directory for use as the build context in docker build */
      contextDir?: string;
      /**
       * Contents of the dockerfile
       *
       * @remarks
       * Should not be used if dockerfileName is set
       */
      dockerfile?: string;
      /**
       * Path to a local Dockerfile in the Adapt project.
       *
       * @remarks
       * This path is relative to the root of the Adapt project.
       * Should not be used if `dockerfile` is set.
       */
      dockerfileName?: string;
      /**
       * Extra files that should be included during the docker build
       *
       * @remarks
       * LocalDockerImage uses a multi-stage build process.  It first creates
       * a temporary image that includes the files specified in this field.
       * This temporary image is then made available to the `dockerfile` with
       * stage name `files` and can then be copied into the final image, as
       * desired, using `COPY` or `ADD` commands in the `dockerfile`.
       *
       * @example
       * To create a final Docker image that contains a file that has some
       * programmatically created content, use the `dockerfile` prop along
       * with the `files` prop like this:
       * ```tsx
       * const files = [{
       *   path: '/path/to/myfile.txt',
       *   contents: 'contents for myfile\n'
       * }];
       * const dockerfile = `
       *   FROM alpine
       *   COPY --from=files /path/to/myfile.txt /app/myfile.txt
       *   ...
       * `;
       * return <LocalDockerImage files={files} dockerfile={dockerfile} />
       * ```
       */
      files?: File[];
      /**
       * Options to control the behavior of docker build
       */
      options?: DockerBuildOptions;
      /**
       * Extra stages to include in a multi-stage docker build
       */
      stages?: Stage[];
  }/**
   * @internal
   */
  export declare interface LocalDockerImageState {
      deployOpID?: DeployOpID;
      image?: WithId<ImageRefDockerHost>;
      imagePropsJson?: string;
      prevUniqueNameTag?: string;
  }/**
   * Locally builds a docker image
   *
   * @remarks
   * See {@link docker.LocalDockerImageProps}.
   *
   * @public
   */
  export declare class LocalDockerImage extends Action<LocalDockerImageProps, LocalDockerImageState> implements DockerPushableImageInstance {
      static defaultProps: {
          options: {
              dockerHost: string | undefined;
              forceRm: boolean;
          };
      };
      deployedWhenIsTrivial: boolean;
      private image_?;
      private imagePropsJson_?;
      private options_;
      constructor(props: LocalDockerImageProps);
      buildComplete(): boolean;
      ready(): boolean;
      image(): WithId<ImageRefDockerHost> | undefined;
      pushTo({ ref }: {
          ref: string;
      }): Promise<undefined | WithId<ImageRefRegistry>>;
      latestImage(): WithId<ImageRefDockerHost> | undefined;
      /**
       * User-facing name to display in status messages.
       */
      displayName(): string | undefined;
      /**
       * Implementations for Action base class
       * @internal
       */
      shouldAct(op: ChangeType): Promise<ShouldAct>;
      /**
       * Implementations for Action base class
       * @internal
       */
      action(op: ChangeType, ctx: ActionContext): Promise<void>;
      /** @internal */
      initialState(): {};
      /** @internal */
      deployedWhen: (goalStatus: GoalStatus) => true | import("@adpt/core").Waiting;
      /** @internal */
      protected get imagePropsJson(): string;
  }/**
   * Runs a Docker registry in a container.
   * @remarks
   * Implements {@link docker.DockerRegistryInstance}.
   *
   * @public
   */
  export declare function LocalDockerRegistry(props: SFCDeclProps<LocalDockerRegistryProps, typeof defaultProps>): Adapt.JSX.Element;/**
   * Props for {@link docker.LocalDockerRegistry}
   * @public
   */
  export declare interface LocalDockerRegistryProps extends ExcludeKeys<DockerContainerProps, "image"> {
      /**
       * Tag to use for official Docker Hub `registry` image repo.
       */
      imageTag: NameTagString;
      /**
       * Port number to expose for the registry HTTP server.
       */
      port: number;
  }/** @public */
  export declare interface DockerRegistryInstance {
      registry(): RegistryString | undefined;
  }/**
   * Props for {@link docker.RegistryDockerImage}
   * @public
   */
  export declare interface RegistryDockerImageProps {
      /**
       * Handle for image source
       * @remarks
       * Currently, only handle to LocalDockerImage components and compatible
       * interfaces are supported.
       * @privateRemarks
       * FIXME(manishv) support string refs to other registries and handles of
       * other registry images
       */
      imageSrc: Handle<DockerPushableImageInstance>;
      /**
       * Registry and path where the image should be pushed and pulled
       *
       * @remarks
       * If this parameter is a string, registryPrefix will be used for both push and pull
       *
       * If registryPrefix is of the form `{ external: string, internal: string }`, docker images wil be
       * pushed to `external` and image strings will refer to `internal`.
       *
       * Registry prefixes can be of the form `domain/path/elements`, for example `gcr.io/myproject`.
       * However, the registryPrefix should not include the final name, use newPathTag instead.
       *
       * Note(manishv)
       * This is a bit of a hack to allow one hostname or IP address to push images from outside
       * a particular environment (say k8s) and a different URL for that environment to pull
       * images.
       *
       * A good example of this is a k3s-dind (k3s docker-in-docker) instance of kubernetes where
       * a private registry is running on a docker network attached to the k3s-dind instance, but where we
       * want to push {@link docker.LocalDockerImage} built images to that registry.  Since
       * {@link docker.LocalDockerImage | LocalDockerImage} is outside the k3s-dind environment, it must
       * use a host accessible network to push to the registry.  However, since the k3s-dind instance sees
       * the registry from within Docker, it must use a different address to pull the images for use.
       *
       * Once network scopes are fully supported, this interface will change to whatever is appropriate.  It
       * is best if you can arrange to have the same URL or registry string work for all access regardless
       * of which network the registry, Adapt host, and ultimate container running environment is uses.
       */
      registryPrefix: RegistryString | DockerSplitRegistryInfo;
      /**
       * Path and tag to be used for the image in the new registry in
       * `path:tag` or `path` format.
       * @remarks
       * The entire path and tag are blindly concatenated to the domain and path
       * in registryPrefix to form the full ref that will be used to push the
       * image.
       *
       * If omitted, the last component of the path and the tag from the source
       * image is used. The newPathTag should not include the registry
       * hostname/port prefix. If the `:tag` portion of `path:tag` is omitted,
       * the tag `latest` will be used.
       */
      newPathTag?: string;
      /**
       * Path and tag to be used for the image in the new registry in
       * `path:tag` or `path` format.
       * @deprecated This prop has been renamed to `newPathTag`. The functionality
       * for both props is the same and if both are set, `newPathTag` takes
       * priority.
       * @remarks
       * If omitted, the path and tag from the source image is used. The
       * newTag should not include the registry hostname/port prefix. If the
       * `:tag` portion of `path:tag` is omitted, the tag `latest` will be used.
       */
      newTag?: string;
  }/**
   * Represents a Docker image in a registry.
   * @remarks
   * If the image does not exist in the specified registry, it will be pushed
   * to that registry.
   * @public
   */
  export declare class RegistryDockerImage extends Action<RegistryDockerImageProps, State> implements DockerImageInstance {
      private latestImage_?;
      private latestRegistryUrl_?;
      private registry;
      constructor(props: RegistryDockerImageProps);
      /**
       * Returns information about the version of the Docker image that reflects
       * the current set of props for the component and has been pushed to the
       * registry.
       * @remarks
       * Returns undefined if the `props.imageSrc` component's `latestImage` method
       * returns undefined (depending on the component referenced by
       * `props.imageSrc`, that may indicate the source image has not been built).
       * Also returns undefined if the current image has not yet been
       * pushed to the registry.
       */
      image(): ImageRefRegistry | undefined;
      /**
       * Returns information about the most current version of the Docker image
       * that has been pushed to the registry.
       * @remarks
       * Returns undefined if no image has ever been pushed by this component.
       */
      latestImage(): ImageRefRegistry | undefined;
      /** @internal */
      initialState(): {};
      /** @internal */
      shouldAct(diff: ChangeType): false | {
          act: boolean;
          detail: string;
      };
      /** @internal */
      dependsOn: DependsOnMethod;
      /** @internal */
      action(op: ChangeType): Promise<void>;
      private currentNameTag;
      private getNewPathTag;
      private srcImageName;
  }/**
   * Props for {@link docker.ServiceContainerSet}
   *
   * @public
   */
  export declare interface ServiceContainerSetProps extends ServiceProps {
      /**
       * Props to apply to all {@link docker.DockerContainer}s within this
       * ServiceContainerSet. If a prop is specified in the source {@link Container}
       * component and in `containerProps`, `containerProps` will take
       * precedence.
       */
      containerProps?: Partial<DockerContainerProps>;
      /**
       * If set, all children of this ServiceContainerSet that support the
       * `dockerHost` prop will get this value, overriding any other value for
       * this prop.
       */
      dockerHost?: string;
  }/**
   * A component for mapping a group of abstract {@link Container}s and
   * {@link NetworkService}s to Docker {@link docker.DockerContainer | DockerContainer}s
   * and {@link docker.NetworkService}s.
   *
   * @remarks
   * This component is intended to be used to replace {@link Container} and
   * {@link NetworkService} components that are grouped together, as the
   * only children of a common parent in a pattern that looks like this:
   * ```tsx
   * <Service>
   *   <Container ... />
   *   <Container ... />
   *   <NetworkService ... />
   * </Service>
   * ```
   * `ServiceContainerSet` maps those abstract components into Docker components
   * like this:
   * ```tsx
   * <Group>
   *   <docker.DockerContainer ... >
   *   <docker.DockerContainer ... >
   *   <docker.NetworkService ... >
   * </Group>
   * ```
   * An example style rule to do this is:
   * ```tsx
   * {Service}
   * {Adapt.rule((matchedProps) => {
   *     const { handle, ...remainingProps } = matchedProps;
   *     return <ServiceContainerSet {...remainingProps} />;
   * })}
   * ```
   *
   * Currently, {@link docker.NetworkService} implements the {@link NetworkServiceInstance}
   * interface, but does not deploy a network proxy component. So the Docker
   * ServiceContainerSet component applies the network port configuration specified by
   * the {@link NetworkService}s to their target
   * {@link docker.DockerContainer | DockerContainer}s.
   *
   * @public
   */
  export declare class ServiceContainerSet extends DeferredComponent<ServiceContainerSetProps> {
      build(helpers: BuildHelpers): Adapt.JSX.Element;
  }/**
   * Options for interacting with Docker Engine that apply to all
   * operations.
   * @public
   */
  export declare interface DockerGlobalOptions {
      dockerHost?: string;
  }/**
   * Options for performing Docker image builds.
   * @public
   */
  export declare interface DockerBuildOptions extends DockerGlobalOptions {
      /**
       * Requests BuildKit as the internal Docker build engine.
       *
       * @remarks
       * This option requests the use of the BuildKit build engine when building
       * Docker images, if BuildKit is available. This is primarily useful for
       * BuildKit's performance improvements over the legacy Docker build engine.
       * However, because this option does not guarantee BuildKit will be used,
       * BuildKit-only features such as secret mounting should not be used.
       *
       * Internally, this option sets the `DOCKER_BUILDKIT` environment
       * variable when performing builds, which enables BuildKit on Docker
       * systems that support it.
       *
       * For more information, see
       * [Build images with BuildKit](https://docs.docker.com/develop/develop-images/build_enhancements/).
       *
       * @defaultValue `true`
       */
      requestBuildKit?: boolean;
      forceRm?: boolean;
      imageName?: string;
      imageTag?: string;
      prevUniqueNameTag?: string;
      stdin?: string;
      /**
       * If true and the newly built image ID does not match the image ID for
       * prevUniqueNameTag (or prevUniqueNameTag is not set), a new unique nameTag is
       * generated for this image (from imageName and imageTag).
       * If true and the newly built image ID does match the image ID for
       * prevUniqueNameTag, then prevUniqueNameTag is returned as nameTag.
       * If false, imageName and imageTag are used without modification.
       */
      uniqueTag?: boolean;
      /**
       * If set, will add a Docker LABEL with the DeployID.
       */
      deployID?: string;
      buildArgs?: Environment;
  }/**
   * A dynamically-created file that can be used during the build of a Docker
   * image.
   *
   * @remarks
   * These `File` objects are used to create a temporary "scratch" image in a
   * {@link https://docs.docker.com/develop/develop-images/multistage-build/ | multi-stage build}
   * that contains only the specified files. Then, in later stages of that build,
   * the files within the temporary image can be copied into the later stage
   * image.
   * @public
   */
  export declare interface File {
      /**
       * The path in the temporary image where the file will be created.
       */
      path: string;
      /**
       * The contents of the file.
       */
      contents: Buffer | string;
  }/**
   * A stage to be added to a
   * {@link https://docs.docker.com/develop/develop-images/multistage-build/ | multi-stage Docker build}.
   *
   * @remarks
   * The stage will be added to the generated Dockerfile for the image as:
   * ```
   * FROM image as name
   * ```
   * @public
   */
  export declare interface Stage {
      /** The image (name + tag or digest) to use for the stage. */
      image: string;
      /** Name for the stage */
      name: string;
  }/**
   * A string that contains both a Docker repo and a registry digest.
   *
   * @remarks
   * This is a string that represents a specific image on a specific registry
   * contained in a particular repo on that registry. It's of the form:
   * ```
   * [registry/]repo@digest
   * ```
   * `registry` - (optional) The hostname or hostname:port of a Docker registry
   * where the repo is located. If not provided, the official default Docker
   * registry is assumed.
   *
   * `repo` - The more precise name for what's commonly referred to as an image
   * name. It may include 0 or more slashes to denote namespaces.
   *
   * `digest` - The repo digest for the image in the form `algorithm:hex`.
   * This digest is specific to the associated registry and repo and has no
   * significance without those additional pieces of information. If this image is
   * pushed to a different registry, it will have a different digest value.
   * The digest is also known as a "distribution hash".
   *
   * Examples:
   * ```
   * alpine@sha256:04696b491e0cc3c58a75bace8941c14c924b9f313b03ce5029ebbc040ed9dcd9
   * localhost:5000/mockdeploy-htws@sha256:899a03e9816e5283edba63d71ea528cd83576b28a7586cf617ce78af5526f209
   * ```
   * @public
   */
  export declare type RepoDigestString = string;/**
   * Docker image ID, in the form `algorithm:hex`.
   *
   * @remarks
   * The Docker image ID (also known as "Content Hash") is a single value
   * that uniquely identifies a specific image on a local Docker host.
   *
   * An image ID does not require a registry or repo qualifier to be significant.
   * It is distinct from a Docker image
   * {@link docker.RepoDigestString | repo digest}.
   *
   * Example:
   * ```
   * sha256:199e537da3a86126cd6eb114bd0b13ab178dc291bbb6ea4a4a3aa257b2366b71
   * ```
   * @public
   */
  export declare type ImageIdString = string;/**
   * A string reference to a Docker image that contains a repo name, and may
   * contain an optional registry and optional tag.
   *
   * @remarks
   * This is a string that references a Docker image. It's in the form of
   * one of:
   * ```
   * [registry/]repo
   * [registry/]repo:tag
   * ```
   * `registry` - (optional) The hostname or hostname:port of a Docker registry
   * where the repo is located. If not provided, depending on context, either
   * the official default Docker registry may be assumed or the image may just
   * be present locally and not on any registry.
   *
   * `repo` - The more precise name for what's commonly referred to as an image
   * name. It may include 0 or more slashes to denote namespaces.
   *
   * `tag` - A tag string identifying a version of image within the repo.
   *
   * Examples:
   * ```
   * alpine
   * ubuntu:16.04
   * ```
   * @public
   */
  export declare type NameTagString = string;/**
   * A string reference to a Docker image that contains a repo name, and may
   * contain an optional registry and optionally either a tag or a repo digest.
   *
   * @remarks
   * This is a string that references a Docker image. It's in the form of
   * one of:
   * ```
   * [registry/]repo
   * [registry/]repo:tag
   * [registry/]repo@digest
   * ```
   * For more detail, see {@link docker.NameTagString} and
   * {@link docker.RepoDigestString}.
   *
   * Examples:
   * ```
   * alpine
   * ubuntu:16.04
   * alpine@sha256:04696b491e0cc3c58a75bace8941c14c924b9f313b03ce5029ebbc040ed9dcd9
   * localhost:5000/mockdeploy-htws@sha256:899a03e9816e5283edba63d71ea528cd83576b28a7586cf617ce78af5526f209
   * ```
   * @public
   */
  export declare type ImageNameString = NameTagString | RepoDigestString;/**
   * A string that references a Docker registry that contains a hostname and
   * may optionally contain a port and/or path.
   *
   * @remarks
   * This string is in the form of one of:
   * ```
   * hostname[:port]
   * hostname[:port]/path
   * ```
   * This form does not include the protocol, such as `http:` or `https:` in
   * the string.
   *
   * @public
   */
  export declare type RegistryString = string;/**
   * Information about a specific instance of a Docker image, as identified by
   * its image ID.
   * @deprecated Replaced with {@link docker.ImageRef}.
   * @public
   */
  export declare interface ImageInfo {
      /**
       * Docker image ID, in the form `algorithm:hex`.
       * @remarks
       * See {@link docker.ImageIdString}.
       */
      id: ImageIdString;
      /**
       * Docker image name and optional tag in the form `name` or `name:tag`.
       * @remarks
       * See {@link docker.NameTagString}
       */
      nameTag?: NameTagString;
  }/**
   * Props for {@link docker.DockerContainer}
   *
   * @public
   */
  export declare interface DockerContainerProps extends DockerGlobalOptions, Pick<ContainerProps, "autoRemove" | "command" | "environment" | "portBindings" | "ports" | "restartPolicy" | "stopSignal"> {
      /** image name as a string, or a handle to a DockerImage component */
      image: ImageNameString | Handle<DockerImageInstance>;
      /**
       * Host and port of the remote docker host to use.
       *
       * @remarks
       * Defaults to the DOCKER_HOST environment variable
       */
      dockerHost: string;
      /**
       * Labels to apply to the container.
       */
      labels?: ContainerLabels;
      /**
       * Filesystems to be mounted in the container.
       */
      mounts?: Mount[];
      /**
       * Networks to connect the container to
       *
       * @remarks
       * Accepts the same strings as docker network connect
       */
      networks?: string[];
      /**
       * Enables the container to run in privileged mode.
       */
      privileged?: boolean;
  }/**
   * Represents a split registry, with pushes going to external and pulls going to internal
   * @beta
   */
  export declare interface DockerSplitRegistryInfo {
      external: RegistryString;
      internal: RegistryString;
  }/**
   * Describes bind mount filesystems to be mounted in a container.
   * @public
   */
  export declare interface BindMount {
      type: "bind";
      source: string;
      destination: string;
      readonly?: boolean;
      propagation?: "shared" | "slave" | "private" | "rshared" | "rslave" | "rprivate";
  }/**
   * Describes filesystems to be mounted in a container.
   * @public
   */
  export declare type Mount = BindMount;/**
   * Props for {@link docker.BuildKitImage}
   *
   * @public
   */
  export declare interface BuildKitImageProps {
      /** Directory for use as the build context */
      contextDir?: string;
      /**
       * Contents of the dockerfile
       *
       * @remarks
       * Should not be used if dockerfileName is set
       */
      dockerfile?: string;
      /**
       * Path to a local Dockerfile in the Adapt project.
       *
       * @remarks
       * This path is relative to the root of the Adapt project.
       * Should not be used if `dockerfile` is set.
       */
      dockerfileName?: string;
      /**
       * Extra files that should be included during the docker build
       *
       * @remarks
       * BuildKitImage uses a multi-stage build process.  It first creates
       * a temporary image that includes the files specified in this field.
       * This temporary image is then made available to the `dockerfile` with
       * stage name `files` and can then be copied into the final image, as
       * desired, using `COPY` or `ADD` commands in the `dockerfile`.
       *
       * @example
       * To create a final Docker image that contains a file that has some
       * programmatically created content, use the `dockerfile` prop along
       * with the `files` prop like this:
       * ```tsx
       * const files = [{
       *   path: '/path/to/myfile.txt',
       *   contents: 'contents for myfile\n'
       * }];
       * const dockerfile = `
       *   FROM alpine
       *   COPY --from=files /path/to/myfile.txt /app/myfile.txt
       *   ...
       * `;
       * return <BuildKitImage files={files} dockerfile={dockerfile} />
       * ```
       */
      files?: File[];
      /**
       * Options to control the behavior of docker build
       */
      options?: BuildKitBuildOptions;
      /**
       * Directs BuildKit where to store the built image.
       */
      output: BuildKitOutput;
      /**
       * Extra stages to include in a multi-stage docker build
       */
      stages?: Stage[];
  }/**
   * @internal
   */
  export declare interface BuildKitImageState {
      deployOpID?: DeployOpID;
      image?: WithId<ImageRefRegistry>;
      imagePropsJson?: string;
      prevUniqueNameTag?: string;
  }/**
   * Locally builds a docker image
   *
   * @remarks
   * See {@link docker.BuildKitImageProps}.
   *
   * @public
   */
  export declare class BuildKitImage extends Action<BuildKitImageProps, BuildKitImageState> implements DockerPushableImageInstance {
      static defaultProps: {
          options: {};
      };
      deployedWhenIsTrivial: boolean;
      private image_?;
      private imagePropsJson_?;
      private options_;
      constructor(props: BuildKitImageProps);
      buildComplete(): boolean;
      ready(): boolean;
      image(): WithId<ImageRefRegistry> | undefined;
      pushTo({ ref }: {
          ref: string;
      }): Promise<undefined | WithId<ImageRefRegistry>>;
      latestImage(): WithId<ImageRefRegistry> | undefined;
      /**
       * User-facing name to display in status messages.
       */
      displayName(): string;
      /**
       * Implementations for Action base class
       * @internal
       */
      shouldAct(op: ChangeType): Promise<ShouldAct>;
      /**
       * Implementations for Action base class
       * @internal
       */
      action(op: ChangeType, ctx: ActionContext): Promise<void>;
      /** @internal */
      initialState(): {};
      /** @internal */
      deployedWhen: (goalStatus: GoalStatus) => true | import("@adpt/core").Waiting;
      /** @internal */
      protected get imagePropsJson(): string;
  }/**
   * Components that provide a Docker image can implement this interface to
   * allow other components to get information about the Docker image.
   * @public
   */
  export declare interface DockerImageInstance {
      /**
       * Returns information about the version of the Docker image that reflects
       * the current set of props for the component.
       * @remarks
       * Returns undefined if no image has ever been built by
       * this component OR if the component props have changed and the image
       * that corresponds to the current props has not yet been built.
       */
      image(): ImageRef | undefined;
      /**
       * Returns information about the most current version of the Docker image
       * that has completed building, even if that version does not reflect the
       * current set of props for the component.
       * @remarks
       * Returns undefined if no image has ever been built by this component.
       */
      latestImage(): ImageRef | undefined;
      /**
       * Pushes the image returned by `latestImage` to a Docker registry.
       *
       * @param ref - A docker domain, path components, and tag to which this image should be pushed
       *
       * @remarks
       * If there is no latest image available (`latestImage` returns
       * undefined), then `pushTo` will return undefined. Otherwise, if the
       * push was successful, returns an {@link docker.ImageRefRegistry} that contains
       * the complete nameTag, including registry portion.
       */
      pushTo?({ ref }: {
          ref: NameTagString;
      }): MaybePromise<ImageRefRegistry | undefined>;
  }/**
   * Components that provide a Docker image can implement this interface to
   * allow other components to get information about the Docker image and
   * to be able to push the image to a registry.
   * @public
   */
  export declare interface DockerPushableImageInstance extends DockerImageInstance {
      /**
       * {@inheritdoc docker.DockerImageInstance.pushTo}
       */
      pushTo({ ref }: {
          ref: NameTagString;
      }): MaybePromise<ImageRefRegistry | undefined>;
  }/**
   * Props for {@link docker.DockerImage}.
   * @beta
   */
  export declare interface DockerImageProps {
  }/**
   * Abstract component representing a {@link https://docker.com | Docker}
   * image that can be used to create containers.
   * @remarks
   * See also {@link Container}.
   * @beta
   */
  export declare abstract class DockerImage extends Component<DockerImageProps> implements DockerImageInstance {
      /**
       * {@inheritdoc docker.DockerImageInstance.image}
       */
      image(): ImageRef | undefined;
      /**
       * {@inheritdoc docker.DockerImageInstance.latestImage}
       */
      latestImage(): ImageRef | undefined;
  }/**
   * Compute the status of a container based on a graphQL schema
   *
   * @internal
   */
  export declare function containerStatus(observe: ObserveForStatus, containerName: string, dockerHost: string): Promise<ContainerStatus | NoStatus>;/** @public */
  export declare interface DockerContainerStatus extends ContainerStatus {
  }/**
   * Compute a unique name for the container
   *
   * @internal
   */
  const computeContainerName: (elemKey: string, elemID: string, deployID: string) => string;/**
   * Component to instantiate an image container with docker
   *
   * @remarks
   * See {@link docker.DockerContainerProps}.
   *
   * @public
   */
  declare class DockerContainer extends Action<DockerContainerProps, DockerContainerState> {
      static defaultProps: {
          dockerHost: string;
          privileged: boolean;
      };
      info?: ContainerInfo;
      dependsOn: DependsOnMethod;
      /** @internal */
      shouldAct(diff: ChangeType, context: ActionContext): Promise<false | ShouldAct>;
      /** @internal */
      action(diff: ChangeType, context: ActionContext): Promise<void>;
      status(observe: ObserveForStatus, buildData: BuildData): Promise<NoStatus | ContainerStatus>;
      /**
       * Get the IP address of the container, optionally for a specific Docker
       * network.
       * @remarks
       * The IP addresses that are returned by this function are valid only
       * on the associated Docker network, which is often only associated
       * with a single host node for most Docker network types.
       *
       * @param network - Name of a Docker network. If `network` is provided
       * and the container is connected to the network with an IP address, that
       * address will be returned. If the container is not connected to the
       * network, `undefined` will be returned. If `network` is not provided,
       * the default container IP address will be returned.
       *
       * @beta
       */
      dockerIP(network?: string): string | undefined;
      /** @internal */
      initialState(): {};
      private displayName;
      private refreshContainerInfo;
  }/**
   * Component to instantiate an image container with docker
   *
   * @remarks
   * See {@link docker.DockerContainerProps}.
   *
   * @public
   */
  declare class DockerContainer extends Action<DockerContainerProps, DockerContainerState> {
      static defaultProps: {
          dockerHost: string;
          privileged: boolean;
      };
      info?: ContainerInfo;
      dependsOn: DependsOnMethod;
      /** @internal */
      shouldAct(diff: ChangeType, context: ActionContext): Promise<false | ShouldAct>;
      /** @internal */
      action(diff: ChangeType, context: ActionContext): Promise<void>;
      status(observe: ObserveForStatus, buildData: BuildData): Promise<NoStatus | ContainerStatus>;
      /**
       * Get the IP address of the container, optionally for a specific Docker
       * network.
       * @remarks
       * The IP addresses that are returned by this function are valid only
       * on the associated Docker network, which is often only associated
       * with a single host node for most Docker network types.
       *
       * @param network - Name of a Docker network. If `network` is provided
       * and the container is connected to the network with an IP address, that
       * address will be returned. If the container is not connected to the
       * network, `undefined` will be returned. If `network` is not provided,
       * the default container IP address will be returned.
       *
       * @beta
       */
      dockerIP(network?: string): string | undefined;
      /** @internal */
      initialState(): {};
      private displayName;
      private refreshContainerInfo;
  }/**
   * Type guard for determining whether a given object has a non-null `id`
   * property.
   * @public
   */
  export declare function hasId<T extends {
      id?: ImageIdString;
  }>(o: T): o is WithId<T>;/**
   * Factory function for creating a {@link docker.MutableImageRef}.
   * @remarks
   * Can also be used to clone an existing {@link docker.MutableImageRef} or
   * to create a mutable version of an existing {@link docker.ImageRef}.
   * @public
   */
  export declare function mutableImageRef(ref: ImageNameString, normalize?: boolean): MutableImageRef;/**
   * Factory function for creating a {@link docker.MutableImageRef}.
   * @remarks
   * Can also be used to clone an existing {@link docker.MutableImageRef} or
   * to create a mutable version of an existing {@link docker.ImageRef}.
   * @public
   */
  export declare function mutableImageRef(info?: ImageRefData): MutableImageRef;/**
   * Factory function for creating a {@link docker.ImageRef} or cloning an
   * existing one.
   * @public
   */
  export declare function imageRef(ref: ImageNameString, normalize?: boolean): ImageRef;/**
   * Factory function for creating a {@link docker.ImageRef} or cloning an
   * existing one.
   * @public
   */
  export declare function imageRef(info?: ImageRefData): ImageRef;/**
   * A type guard for determining whether a {@link docker.ImageRef} is a
   * {@link docker.ImageRefRegistry}.
   * @public
   */
  export declare function isImageRefRegistry(ref: ImageRef): ref is ImageRefRegistry;/**
   * A type guard for determining whether a {@link docker.ImageRef} is a
   * {@link docker.ImageRefRegistry} that has the `id` property set.
   * @public
   */
  export declare function isImageRefRegistryWithId(ref: ImageRef): ref is WithId<ImageRefRegistry>;/**
   * A type guard for determining whether a {@link docker.ImageRef} is a
   * {@link docker.ImageRefDockerHost}.
   * @public
   */
  export declare function isImageRefDockerhost(ref: ImageRef): ref is ImageRefDockerHost;/**
   * A type guard for determining whether a {@link docker.ImageRef} is a
   * {@link docker.ImageRefDockerHost} that has the `id` property set.
   * @public
   */
  export declare function isImageRefDockerhostWithId(ref: ImageRef): ref is WithId<ImageRefDockerHost>;/**
   * The most basic components that make up a {@link docker.ImageRef}.
   * All other properties of a {@link docker.ImageRef} can be computed from
   * these.
   * @remarks
   * See also {@link docker.ImageRef} for more information on references.
   * @public
   */
  export declare interface ImageRefData {
      /**
       * Image digest in the form `algorithm:hex`
       * @example
       * sha256:04696b491e0cc3c58a75bace8941c14c924b9f313b03ce5029ebbc040ed9dcd9
       */
      digest?: string;
      /**
       * Docker host string to contact the Docker daemon where this image is
       * located.
       *
       * @remarks
       * This should be in the same format that Docker expects for the `DOCKER_HOST`
       * environment variable. The special string `default` can also be used,
       * which will use the current value of the `DOCKER_HOST` environment variable,
       * if it is set and will otherwise use the default named pipe on Windows
       * (`npipe:///./pipe/docker_engine`) and the default socket on other
       * systems (`unix:///var/run/docker.sock`).
       * @example
       * tcp://localhost:2375
       */
      dockerHost?: "default" | string;
      /**
       * Hostname and optional port number of the container image registry where
       * this image is located.
       * @example
       * docker.io
       * @example
       * localhost:5000
       */
      domain?: RegistryString;
      /**
       * Image content ID in the form `algorithm:hex`
       * @example
       * sha256:199e537da3a86126cd6eb114bd0b13ab178dc291bbb6ea4a4a3aa257b2366b71
       */
      id?: ImageIdString;
      /**
       * The image repo path.
       * @example
       * google/cloud-sdk
       */
      path?: string;
      /**
       * Image tag
       * @example
       * latest
       */
      tag?: string;
  }/**
   * The type of an image reference indicates how the image can be
   * accessed, currently either through a Docker host (daemon) or directly to a
   * container registry via its API.
   *
   * @remarks
   * If not enough information is present to access and uniquely identify a
   * container image, the type is `incomplete`.
   * @public
   */
  export declare type ImageRefType = "incomplete" | "registry" | "dockerhost";/**
   * An immutable reference to a container image, including all information
   * known about the image.
   *
   * @remarks
   * This type is the base type for an image reference and is allowed to
   * contain partial or incomplete information about a container image.
   * It can include both information about how to access the image and
   * also information about the image itself.
   *
   * Many of the properties of {@link docker.ImageRef} are related to the
   * container image reference string used by Docker and other container-based
   * systems. A container image reference string is a structured string
   * containing multiple components. The most basic components are illustrated
   * below, using the example image reference string
   * `"my.registry:5000/a/repo/path:sometag@sha256:899a03e9816e5283edba63d"`.
   *
   * NOTE: The length of the `digest` has been shortened for formatting
   * purposes.
   *
   * ```
   * "my.registry:5000/a/repo/path:sometag@sha256:899a03e9816e5283edba63d"
   * |     domain     |   path    |  tag  |         digest               |
   * ```
   *
   * To aid in correct formatting, {@link docker.ImageRef} and related types and
   * classes also provide helper properties that combine these basic components
   * into combinations that are often useful, such as `name`, which is the
   * `domain` and `path` combined with a `/`.
   *
   * Many tools, such as the Docker UI, also accept a shortened form of a string
   * reference, called the `familiar` form. An example of a familiar reference is
   * `ubuntu`. In this form, only the `path` component is required. When
   * components of the reference are left out, default values are assumed. The
   * default `domain` is `docker.io` and the default `tag` is `latest`.
   * Additionally, if the `domain` is `docker.io` and there are no `/` characters
   * in the `path`, `library/` is prepended to the path. So `ubuntu` is the
   * familiar form for the complete reference `docker.io/library/ubuntu:latest`.
   *
   * An {@link docker.ImageRef} is designed to hold as much information about
   * an image as may be available and therefore some properties that are
   * not known will be `undefined`.
   *
   * See also {@link docker.MutableImageRef}, which can be used to parse
   * reference strings and construct or modify image references.
   * @public
   */
  export declare interface ImageRef extends Readonly<ImageRefData> {
      /**
       * The complete string reference for this image in familiar form, which
       * leaves out certain fields from the reference when they are set to
       * default values.
       * @remarks
       * This reference form is the form typically used in the Docker UI.
       * If the ImageRef is not complete, familiar will return `undefined`, as
       * the correct familiar representation cannot be determined.
       * @example
       * mysql
       * @example
       * gcr.io/my-project/image:1.0.1
       */
      readonly familiar?: string;
      /**
       * The image name, which is comprised of the optional domain and
       * the (non-optional) path. Will be `undefined` if there is no `path`.
       * @example
       * gcr.io/my-project/image
       */
      readonly name?: string;
      /**
       * The image name (including any registry) and image tag. Returns undefined
       * if either path or tag are not set.
       * If nameTag is set to a string that does not contain a tag (i.e. does
       * not include a ":"), the default tag of `latest` will be set.
       * To set nameTag without defaulting to `latest`, call the class method
       * `setNameTag` with the parameter `useDefaultTag` set to `false`.
       * @example
       * gcr.io/my-project/image:1.0.1
       */
      readonly nameTag?: string;
      /**
       * The image path (not including any registry) and image tag. Returns
       * undefined if either `path` or `tag` are not set.
       * @example
       * my-project/image:1.0.1
       */
      readonly pathTag?: string;
      /**
       * The best (most specific and complete) string reference for this image,
       * given the information available in this {@link docker.ImageRef}.
       */
      readonly ref: string;
      /**
       * An alias for `domain`.
       */
      readonly registry?: string;
      /**
       * The best remote reference available for this image in either
       * `domain/path@digest` format or `domain/path:tag` format.
       * @remarks
       * Returns `registryDigest` if it is set, otherwise returns `registryTag`.
       * If no remote reference is available, returns undefined.
       * @example
       * gcr.io/my-project/image\@sha256:899a03e9816e5283edba63d71ea528cd83576b28a7586cf617ce78af5526f209
       * @example
       * gcr.io/my-project/image:1.0.1
       */
      readonly registryRef?: string;
      /**
       * The remote digest reference in `domain/path@digest` form.
       * @remarks
       * Undefined if any of `domain`, `path`, or `digest` are unset.
       * @example
       * gcr.io/my-project/image\@sha256:899a03e9816e5283edba63d71ea528cd83576b28a7586cf617ce78af5526f209
       */
      readonly registryDigest?: string;
      /**
       * The remote tag reference in `domain/path:tag` form.
       * @remarks
       * Undefined if any of `domain`, `path`, or `tag` are unset.
       * @example
       * gcr.io/my-project/image:1.0.1
       */
      readonly registryTag?: string;
      /**
       * The type of an image reference indicates how the image can be
       * accessed, either through a Docker host (daemon) or directly to a
       * container registry.
       *
       * @remarks
       * A reference is a valid `dockerhost` type ref when it contains a valid
       * dockerHost string and either:
       * - A valid image id or
       * - A valid path and either a valid tag or digest.
       *
       * A reference is a valid `registry` type ref when it contains a valid
       * domain, path, and either a tag or a digest.
       *
       * If not enough information is present to access and uniquely identify a
       * container image, the type is `incomplete`.
       */
      readonly type: ImageRefType;
  }/**
   * Helper type that augments a base type to indicate that the `id` field
   * is present and has a valid image ID.
   * @public
   */
  export declare type WithId<T> = T & {
      id: ImageIdString;
  };/**
   * A mutable reference to a container image that can be used to parse,
   * construct, and modify an image reference, as well as to hold information
   * about the image and how to access it.
   *
   * @remarks
   * This class can be used to parse strings that contain complete or partial
   * container image references. It can also be used to construct an image
   * reference from scratch, from individual component parts, or from another
   * reference, then to correctly format the reference or its components for
   * use with various tools.
   *
   * To parse and normalize a "familiar" image reference, like is typically
   * seen in the Docker UI:
   * ```ts
   * const ref = mutableImageRef("redis", true);
   * console.log(ref.tag);         // => "latest"
   * console.log(ref.registryRef); // => "docker.io/library/redis:latest"
   * ```
   *
   * To construct a reference to an image present on the local Docker daemon
   * that has an image ID:
   * ```ts
   * const ref = mutableImageRef({
   *     dockerHost: "default",
   *     path: "myimage",
   *     tag: "just-built",
   *     id: "sha256:04696b491e0cc3c58a75bace8941c14c924b9f313b03ce5029ebbc040ed9dcd9",
   * });
   * ```
   *
   * To convert a `MutableImageRef` to an immutable plain object `ImageRef`,
   * use the `freeze` method.
   * @public
   */
  export declare class MutableImageRef implements ImageRef {
      _digest?: string;
      _dockerHost?: string;
      _domain?: string;
      _id?: ImageIdString;
      _path?: string;
      _tag?: string;
      constructor(ref: ImageNameString, normalize?: boolean);
      constructor(info?: ImageRefData | undefined);
      freeze(): ImageRef;
      toData(): ImageRefData;
      toJSON(): ImageRefData;
      /**
       * The digest string for this image in its associated registry and repo
       * in the form `algorithm:hex`.
       */
      get digest(): string | undefined;
      set digest(digest: string | undefined);
      get dockerHost(): string | undefined;
      set dockerHost(dockerHost: string | undefined);
      /**
       * The hostname and optional port of the image registry for this image.
       */
      get domain(): string | undefined;
      set domain(domain: string | undefined);
      /**
       * The complete string reference for this image in familiar form, which
       * leaves out certain fields from the reference when they are set to
       * default values.
       * @remarks
       * This reference form is the form typically used in the Docker UI.
       * If the ImageRef is not complete, familiar will return `undefined`, as
       * the correct familiar representation cannot be determined.
       */
      get familiar(): string | undefined;
      /**
       * The content ID of the image in `algorithm:hex` format.
       */
      get id(): ImageIdString | undefined;
      set id(id: ImageIdString | undefined);
      /**
       * The image name, which is comprised of the optional domain and
       * the (non-optional) path.
       */
      get name(): string | undefined;
      set name(name: string | undefined);
      /**
       * The image name (including any registry) and image tag. Returns undefined
       * if either path or tag are not set.
       * If nameTag is set to a string that does not contain a tag (i.e. does
       * not include a ":"), the default tag of `latest` will be set.
       * To set nameTag without defaulting to `latest`, call the class method
       * `setNameTag` with the parameter `useDefaultTag` set to `false`.
       */
      get nameTag(): NameTagString | undefined;
      set nameTag(nt: NameTagString | undefined);
      /**
       * Method to set the image name and image tag which also allows choice
       * of default behavior when `nameTag` does not contain a tag string.
       */
      setNameTag(nameTag: NameTagString | undefined, useDefaultTag?: boolean): void;
      /**
       * The image repo path.
       */
      get path(): string | undefined;
      set path(path: string | undefined);
      /**
       * The image path (not including any registry) and image tag. Returns
       * undefined if either path or tag are not set.
       * If pathTag is set to a string that does not contain a tag (i.e. does
       * not include a ":"), the default tag of `latest` will be set.
       * To set pathTag without defaulting to `latest`, call the class method
       * `setPathTag` with the parameter `useDefaultTag` set to `false`.
       */
      get pathTag(): string | undefined;
      set pathTag(pathTag: string | undefined);
      /**
       * Method to set the image path and image tag which also allows choice
       * of default behavior when `pathTag` does not contain a tag string.
       */
      setPathTag(pathTag: string | undefined, useDefaultTag?: boolean): void;
      get ref(): string;
      /**
       * Alias for domain
       */
      get registry(): string | undefined;
      /**
       * The best remote reference available for this image in either
       * `domain/path@digest` format or `domain/path:tag` format.
       * @remarks
       * Returns `registryDigest` if it is set, otherwise returns `registryTag`.
       * If no remote reference is available, returns undefined.
       */
      get registryRef(): ImageNameString | undefined;
      /**
       * The remote digest reference in `domain/path@digest` form.
       * @remarks
       * Undefined if any of `domain`, `path`, or `digest` are unset.
       */
      get registryDigest(): RepoDigestString | undefined;
      set registryDigest(rd: RepoDigestString | undefined);
      /**
       * The remote tag reference in `domain/path:tag` form.
       * @remarks
       * Undefined if any of `domain`, `path`, or `tag` are unset.
       */
      get registryTag(): NameTagString | undefined;
      set registryTag(rt: NameTagString | undefined);
      /**
       * The image tag.
       */
      get tag(): string | undefined;
      set tag(tag: string | undefined);
      /**
       * The type of an image reference indicates how the image can be
       * accessed, either through a Docker host (daemon) or directly to a
       * container registry.
       *
       * @remarks
       * A reference is a valid `dockerhost` type ref when it contains a valid
       * dockerHost string and either:
       * - A valid image id or
       * - A valid path and either a valid tag or digest.
       *
       * A reference is a valid `registry` type ref when it contains a valid
       * domain, path, and either a tag or a digest.
       *
       * If not enough information is present to access and uniquely identify a
       * container image, the type is `incomplete`.
       */
      get type(): ImageRefType;
  }/**
   * A more specific type of {@link docker.ImageRef} that contains sufficient
   * information to uniquely identify an image on a container registry.
   * @public
   */
  export declare interface ImageRefRegistry {
      readonly digest?: string;
      readonly domain: string;
      readonly familiar: string;
      readonly id?: ImageIdString;
      readonly name: string;
      readonly nameTag?: string;
      readonly path: string;
      readonly pathTag?: string;
      readonly ref: string;
      readonly registry: string;
      readonly registryRef: string;
      readonly registryDigest?: string;
      readonly registryTag?: string;
      readonly tag?: string;
      readonly type: "registry";
  }/**
   * A more specific type of {@link docker.ImageRef} that contains sufficient
   * information to uniquely identify an image on a specific Docker host
   * (daemon).
   * @public
   */
  export declare interface ImageRefDockerHost {
      readonly digest?: string;
      readonly dockerHost: string;
      readonly domain?: string;
      readonly familiar: string;
      readonly id?: ImageIdString;
      readonly name: string;
      readonly nameTag?: string;
      readonly path: string;
      readonly pathTag?: string;
      readonly ref: string;
      readonly registry?: string;
      readonly registryRef?: string;
      readonly registryDigest?: string;
      readonly registryTag?: string;
      readonly tag?: string;
      readonly type: "dockerhost";
  }/**
   * Docker network service component, compatible with the abstract
   * {@link NetworkService} component.
   *
   * @remarks
   *
   * Implements the {@link NetworkServiceInstance} interface.
   * In a Docker deployment, there is no actual network service object to deploy.
   * So this is a "virtual" component that simply implements the required
   * instance methods for a NetworkService, but renders to null.
   *
   * This component is typically used by {@link docker.ServiceContainerSet}. The
   * {@link docker.ServiceContainerSet} component can be used to ensure the proper
   * network port configuration is applied to the `props.endpoint` container.
   *
   * @public
   */
  export declare function NetworkService(props: SFCDeclProps<NetworkServiceProps, typeof defaultProps>): null;/**
   * The base string used for Adapt Docker labels.
   * @internal
   */
  const adaptDockerKey = "org.adaptjs";/**
   * Docker label for the deployID the object was created from.
   * @internal
   */
  const adaptDockerDeployIDKey: string;/**
   * Props for {@link docker.LocalDockerImage}
   *
   * @public
   */
  export declare interface LocalDockerImageProps {
      /** Directory for use as the build context in docker build */
      contextDir?: string;
      /**
       * Contents of the dockerfile
       *
       * @remarks
       * Should not be used if dockerfileName is set
       */
      dockerfile?: string;
      /**
       * Path to a local Dockerfile in the Adapt project.
       *
       * @remarks
       * This path is relative to the root of the Adapt project.
       * Should not be used if `dockerfile` is set.
       */
      dockerfileName?: string;
      /**
       * Extra files that should be included during the docker build
       *
       * @remarks
       * LocalDockerImage uses a multi-stage build process.  It first creates
       * a temporary image that includes the files specified in this field.
       * This temporary image is then made available to the `dockerfile` with
       * stage name `files` and can then be copied into the final image, as
       * desired, using `COPY` or `ADD` commands in the `dockerfile`.
       *
       * @example
       * To create a final Docker image that contains a file that has some
       * programmatically created content, use the `dockerfile` prop along
       * with the `files` prop like this:
       * ```tsx
       * const files = [{
       *   path: '/path/to/myfile.txt',
       *   contents: 'contents for myfile\n'
       * }];
       * const dockerfile = `
       *   FROM alpine
       *   COPY --from=files /path/to/myfile.txt /app/myfile.txt
       *   ...
       * `;
       * return <LocalDockerImage files={files} dockerfile={dockerfile} />
       * ```
       */
      files?: File[];
      /**
       * Options to control the behavior of docker build
       */
      options?: DockerBuildOptions;
      /**
       * Extra stages to include in a multi-stage docker build
       */
      stages?: Stage[];
  }/**
   * @internal
   */
  export declare interface LocalDockerImageState {
      deployOpID?: DeployOpID;
      image?: WithId<ImageRefDockerHost>;
      imagePropsJson?: string;
      prevUniqueNameTag?: string;
  }/**
   * Locally builds a docker image
   *
   * @remarks
   * See {@link docker.LocalDockerImageProps}.
   *
   * @public
   */
  export declare class LocalDockerImage extends Action<LocalDockerImageProps, LocalDockerImageState> implements DockerPushableImageInstance {
      static defaultProps: {
          options: {
              dockerHost: string | undefined;
              forceRm: boolean;
          };
      };
      deployedWhenIsTrivial: boolean;
      private image_?;
      private imagePropsJson_?;
      private options_;
      constructor(props: LocalDockerImageProps);
      buildComplete(): boolean;
      ready(): boolean;
      image(): WithId<ImageRefDockerHost> | undefined;
      pushTo({ ref }: {
          ref: string;
      }): Promise<undefined | WithId<ImageRefRegistry>>;
      latestImage(): WithId<ImageRefDockerHost> | undefined;
      /**
       * User-facing name to display in status messages.
       */
      displayName(): string | undefined;
      /**
       * Implementations for Action base class
       * @internal
       */
      shouldAct(op: ChangeType): Promise<ShouldAct>;
      /**
       * Implementations for Action base class
       * @internal
       */
      action(op: ChangeType, ctx: ActionContext): Promise<void>;
      /** @internal */
      initialState(): {};
      /** @internal */
      deployedWhen: (goalStatus: GoalStatus) => true | import("@adpt/core").Waiting;
      /** @internal */
      protected get imagePropsJson(): string;
  }/**
   * Runs a Docker registry in a container.
   * @remarks
   * Implements {@link docker.DockerRegistryInstance}.
   *
   * @public
   */
  export declare function LocalDockerRegistry(props: SFCDeclProps<LocalDockerRegistryProps, typeof defaultProps>): Adapt.JSX.Element;/**
   * Props for {@link docker.LocalDockerRegistry}
   * @public
   */
  export declare interface LocalDockerRegistryProps extends ExcludeKeys<DockerContainerProps, "image"> {
      /**
       * Tag to use for official Docker Hub `registry` image repo.
       */
      imageTag: NameTagString;
      /**
       * Port number to expose for the registry HTTP server.
       */
      port: number;
  }/** @public */
  export declare interface DockerRegistryInstance {
      registry(): RegistryString | undefined;
  }/**
   * Props for {@link docker.RegistryDockerImage}
   * @public
   */
  export declare interface RegistryDockerImageProps {
      /**
       * Handle for image source
       * @remarks
       * Currently, only handle to LocalDockerImage components and compatible
       * interfaces are supported.
       * @privateRemarks
       * FIXME(manishv) support string refs to other registries and handles of
       * other registry images
       */
      imageSrc: Handle<DockerPushableImageInstance>;
      /**
       * Registry and path where the image should be pushed and pulled
       *
       * @remarks
       * If this parameter is a string, registryPrefix will be used for both push and pull
       *
       * If registryPrefix is of the form `{ external: string, internal: string }`, docker images wil be
       * pushed to `external` and image strings will refer to `internal`.
       *
       * Registry prefixes can be of the form `domain/path/elements`, for example `gcr.io/myproject`.
       * However, the registryPrefix should not include the final name, use newPathTag instead.
       *
       * Note(manishv)
       * This is a bit of a hack to allow one hostname or IP address to push images from outside
       * a particular environment (say k8s) and a different URL for that environment to pull
       * images.
       *
       * A good example of this is a k3s-dind (k3s docker-in-docker) instance of kubernetes where
       * a private registry is running on a docker network attached to the k3s-dind instance, but where we
       * want to push {@link docker.LocalDockerImage} built images to that registry.  Since
       * {@link docker.LocalDockerImage | LocalDockerImage} is outside the k3s-dind environment, it must
       * use a host accessible network to push to the registry.  However, since the k3s-dind instance sees
       * the registry from within Docker, it must use a different address to pull the images for use.
       *
       * Once network scopes are fully supported, this interface will change to whatever is appropriate.  It
       * is best if you can arrange to have the same URL or registry string work for all access regardless
       * of which network the registry, Adapt host, and ultimate container running environment is uses.
       */
      registryPrefix: RegistryString | DockerSplitRegistryInfo;
      /**
       * Path and tag to be used for the image in the new registry in
       * `path:tag` or `path` format.
       * @remarks
       * The entire path and tag are blindly concatenated to the domain and path
       * in registryPrefix to form the full ref that will be used to push the
       * image.
       *
       * If omitted, the last component of the path and the tag from the source
       * image is used. The newPathTag should not include the registry
       * hostname/port prefix. If the `:tag` portion of `path:tag` is omitted,
       * the tag `latest` will be used.
       */
      newPathTag?: string;
      /**
       * Path and tag to be used for the image in the new registry in
       * `path:tag` or `path` format.
       * @deprecated This prop has been renamed to `newPathTag`. The functionality
       * for both props is the same and if both are set, `newPathTag` takes
       * priority.
       * @remarks
       * If omitted, the path and tag from the source image is used. The
       * newTag should not include the registry hostname/port prefix. If the
       * `:tag` portion of `path:tag` is omitted, the tag `latest` will be used.
       */
      newTag?: string;
  }/**
   * Represents a Docker image in a registry.
   * @remarks
   * If the image does not exist in the specified registry, it will be pushed
   * to that registry.
   * @public
   */
  export declare class RegistryDockerImage extends Action<RegistryDockerImageProps, State> implements DockerImageInstance {
      private latestImage_?;
      private latestRegistryUrl_?;
      private registry;
      constructor(props: RegistryDockerImageProps);
      /**
       * Returns information about the version of the Docker image that reflects
       * the current set of props for the component and has been pushed to the
       * registry.
       * @remarks
       * Returns undefined if the `props.imageSrc` component's `latestImage` method
       * returns undefined (depending on the component referenced by
       * `props.imageSrc`, that may indicate the source image has not been built).
       * Also returns undefined if the current image has not yet been
       * pushed to the registry.
       */
      image(): ImageRefRegistry | undefined;
      /**
       * Returns information about the most current version of the Docker image
       * that has been pushed to the registry.
       * @remarks
       * Returns undefined if no image has ever been pushed by this component.
       */
      latestImage(): ImageRefRegistry | undefined;
      /** @internal */
      initialState(): {};
      /** @internal */
      shouldAct(diff: ChangeType): false | {
          act: boolean;
          detail: string;
      };
      /** @internal */
      dependsOn: DependsOnMethod;
      /** @internal */
      action(op: ChangeType): Promise<void>;
      private currentNameTag;
      private getNewPathTag;
      private srcImageName;
  }/**
   * Props for {@link docker.ServiceContainerSet}
   *
   * @public
   */
  export declare interface ServiceContainerSetProps extends ServiceProps {
      /**
       * Props to apply to all {@link docker.DockerContainer}s within this
       * ServiceContainerSet. If a prop is specified in the source {@link Container}
       * component and in `containerProps`, `containerProps` will take
       * precedence.
       */
      containerProps?: Partial<DockerContainerProps>;
      /**
       * If set, all children of this ServiceContainerSet that support the
       * `dockerHost` prop will get this value, overriding any other value for
       * this prop.
       */
      dockerHost?: string;
  }/**
   * A component for mapping a group of abstract {@link Container}s and
   * {@link NetworkService}s to Docker {@link docker.DockerContainer | DockerContainer}s
   * and {@link docker.NetworkService}s.
   *
   * @remarks
   * This component is intended to be used to replace {@link Container} and
   * {@link NetworkService} components that are grouped together, as the
   * only children of a common parent in a pattern that looks like this:
   * ```tsx
   * <Service>
   *   <Container ... />
   *   <Container ... />
   *   <NetworkService ... />
   * </Service>
   * ```
   * `ServiceContainerSet` maps those abstract components into Docker components
   * like this:
   * ```tsx
   * <Group>
   *   <docker.DockerContainer ... >
   *   <docker.DockerContainer ... >
   *   <docker.NetworkService ... >
   * </Group>
   * ```
   * An example style rule to do this is:
   * ```tsx
   * {Service}
   * {Adapt.rule((matchedProps) => {
   *     const { handle, ...remainingProps } = matchedProps;
   *     return <ServiceContainerSet {...remainingProps} />;
   * })}
   * ```
   *
   * Currently, {@link docker.NetworkService} implements the {@link NetworkServiceInstance}
   * interface, but does not deploy a network proxy component. So the Docker
   * ServiceContainerSet component applies the network port configuration specified by
   * the {@link NetworkService}s to their target
   * {@link docker.DockerContainer | DockerContainer}s.
   *
   * @public
   */
  export declare class ServiceContainerSet extends DeferredComponent<ServiceContainerSetProps> {
      build(helpers: BuildHelpers): Adapt.JSX.Element;
  }/**
   * Options for interacting with Docker Engine that apply to all
   * operations.
   * @public
   */
  export declare interface DockerGlobalOptions {
      dockerHost?: string;
  }/**
   * Options for performing Docker image builds.
   * @public
   */
  export declare interface DockerBuildOptions extends DockerGlobalOptions {
      /**
       * Requests BuildKit as the internal Docker build engine.
       *
       * @remarks
       * This option requests the use of the BuildKit build engine when building
       * Docker images, if BuildKit is available. This is primarily useful for
       * BuildKit's performance improvements over the legacy Docker build engine.
       * However, because this option does not guarantee BuildKit will be used,
       * BuildKit-only features such as secret mounting should not be used.
       *
       * Internally, this option sets the `DOCKER_BUILDKIT` environment
       * variable when performing builds, which enables BuildKit on Docker
       * systems that support it.
       *
       * For more information, see
       * [Build images with BuildKit](https://docs.docker.com/develop/develop-images/build_enhancements/).
       *
       * @defaultValue `true`
       */
      requestBuildKit?: boolean;
      forceRm?: boolean;
      imageName?: string;
      imageTag?: string;
      prevUniqueNameTag?: string;
      stdin?: string;
      /**
       * If true and the newly built image ID does not match the image ID for
       * prevUniqueNameTag (or prevUniqueNameTag is not set), a new unique nameTag is
       * generated for this image (from imageName and imageTag).
       * If true and the newly built image ID does match the image ID for
       * prevUniqueNameTag, then prevUniqueNameTag is returned as nameTag.
       * If false, imageName and imageTag are used without modification.
       */
      uniqueTag?: boolean;
      /**
       * If set, will add a Docker LABEL with the DeployID.
       */
      deployID?: string;
      buildArgs?: Environment;
  }/**
   * A dynamically-created file that can be used during the build of a Docker
   * image.
   *
   * @remarks
   * These `File` objects are used to create a temporary "scratch" image in a
   * {@link https://docs.docker.com/develop/develop-images/multistage-build/ | multi-stage build}
   * that contains only the specified files. Then, in later stages of that build,
   * the files within the temporary image can be copied into the later stage
   * image.
   * @public
   */
  export declare interface File {
      /**
       * The path in the temporary image where the file will be created.
       */
      path: string;
      /**
       * The contents of the file.
       */
      contents: Buffer | string;
  }/**
   * A stage to be added to a
   * {@link https://docs.docker.com/develop/develop-images/multistage-build/ | multi-stage Docker build}.
   *
   * @remarks
   * The stage will be added to the generated Dockerfile for the image as:
   * ```
   * FROM image as name
   * ```
   * @public
   */
  export declare interface Stage {
      /** The image (name + tag or digest) to use for the stage. */
      image: string;
      /** Name for the stage */
      name: string;
  }/**
   * A string that contains both a Docker repo and a registry digest.
   *
   * @remarks
   * This is a string that represents a specific image on a specific registry
   * contained in a particular repo on that registry. It's of the form:
   * ```
   * [registry/]repo@digest
   * ```
   * `registry` - (optional) The hostname or hostname:port of a Docker registry
   * where the repo is located. If not provided, the official default Docker
   * registry is assumed.
   *
   * `repo` - The more precise name for what's commonly referred to as an image
   * name. It may include 0 or more slashes to denote namespaces.
   *
   * `digest` - The repo digest for the image in the form `algorithm:hex`.
   * This digest is specific to the associated registry and repo and has no
   * significance without those additional pieces of information. If this image is
   * pushed to a different registry, it will have a different digest value.
   * The digest is also known as a "distribution hash".
   *
   * Examples:
   * ```
   * alpine@sha256:04696b491e0cc3c58a75bace8941c14c924b9f313b03ce5029ebbc040ed9dcd9
   * localhost:5000/mockdeploy-htws@sha256:899a03e9816e5283edba63d71ea528cd83576b28a7586cf617ce78af5526f209
   * ```
   * @public
   */
  export declare type RepoDigestString = string;/**
   * Docker image ID, in the form `algorithm:hex`.
   *
   * @remarks
   * The Docker image ID (also known as "Content Hash") is a single value
   * that uniquely identifies a specific image on a local Docker host.
   *
   * An image ID does not require a registry or repo qualifier to be significant.
   * It is distinct from a Docker image
   * {@link docker.RepoDigestString | repo digest}.
   *
   * Example:
   * ```
   * sha256:199e537da3a86126cd6eb114bd0b13ab178dc291bbb6ea4a4a3aa257b2366b71
   * ```
   * @public
   */
  export declare type ImageIdString = string;/**
   * A string reference to a Docker image that contains a repo name, and may
   * contain an optional registry and optional tag.
   *
   * @remarks
   * This is a string that references a Docker image. It's in the form of
   * one of:
   * ```
   * [registry/]repo
   * [registry/]repo:tag
   * ```
   * `registry` - (optional) The hostname or hostname:port of a Docker registry
   * where the repo is located. If not provided, depending on context, either
   * the official default Docker registry may be assumed or the image may just
   * be present locally and not on any registry.
   *
   * `repo` - The more precise name for what's commonly referred to as an image
   * name. It may include 0 or more slashes to denote namespaces.
   *
   * `tag` - A tag string identifying a version of image within the repo.
   *
   * Examples:
   * ```
   * alpine
   * ubuntu:16.04
   * ```
   * @public
   */
  export declare type NameTagString = string;/**
   * A string reference to a Docker image that contains a repo name, and may
   * contain an optional registry and optionally either a tag or a repo digest.
   *
   * @remarks
   * This is a string that references a Docker image. It's in the form of
   * one of:
   * ```
   * [registry/]repo
   * [registry/]repo:tag
   * [registry/]repo@digest
   * ```
   * For more detail, see {@link docker.NameTagString} and
   * {@link docker.RepoDigestString}.
   *
   * Examples:
   * ```
   * alpine
   * ubuntu:16.04
   * alpine@sha256:04696b491e0cc3c58a75bace8941c14c924b9f313b03ce5029ebbc040ed9dcd9
   * localhost:5000/mockdeploy-htws@sha256:899a03e9816e5283edba63d71ea528cd83576b28a7586cf617ce78af5526f209
   * ```
   * @public
   */
  export declare type ImageNameString = NameTagString | RepoDigestString;/**
   * A string that references a Docker registry that contains a hostname and
   * may optionally contain a port and/or path.
   *
   * @remarks
   * This string is in the form of one of:
   * ```
   * hostname[:port]
   * hostname[:port]/path
   * ```
   * This form does not include the protocol, such as `http:` or `https:` in
   * the string.
   *
   * @public
   */
  export declare type RegistryString = string;/**
   * Information about a specific instance of a Docker image, as identified by
   * its image ID.
   * @deprecated Replaced with {@link docker.ImageRef}.
   * @public
   */
  export declare interface ImageInfo {
      /**
       * Docker image ID, in the form `algorithm:hex`.
       * @remarks
       * See {@link docker.ImageIdString}.
       */
      id: ImageIdString;
      /**
       * Docker image name and optional tag in the form `name` or `name:tag`.
       * @remarks
       * See {@link docker.NameTagString}
       */
      nameTag?: NameTagString;
  }/**
   * Props for {@link docker.DockerContainer}
   *
   * @public
   */
  export declare interface DockerContainerProps extends DockerGlobalOptions, Pick<ContainerProps, "autoRemove" | "command" | "environment" | "portBindings" | "ports" | "restartPolicy" | "stopSignal"> {
      /** image name as a string, or a handle to a DockerImage component */
      image: ImageNameString | Handle<DockerImageInstance>;
      /**
       * Host and port of the remote docker host to use.
       *
       * @remarks
       * Defaults to the DOCKER_HOST environment variable
       */
      dockerHost: string;
      /**
       * Labels to apply to the container.
       */
      labels?: ContainerLabels;
      /**
       * Filesystems to be mounted in the container.
       */
      mounts?: Mount[];
      /**
       * Networks to connect the container to
       *
       * @remarks
       * Accepts the same strings as docker network connect
       */
      networks?: string[];
      /**
       * Enables the container to run in privileged mode.
       */
      privileged?: boolean;
  }/**
   * Represents a split registry, with pushes going to external and pulls going to internal
   * @beta
   */
  export declare interface DockerSplitRegistryInfo {
      external: RegistryString;
      internal: RegistryString;
  }/**
   * Describes bind mount filesystems to be mounted in a container.
   * @public
   */
  export declare interface BindMount {
      type: "bind";
      source: string;
      destination: string;
      readonly?: boolean;
      propagation?: "shared" | "slave" | "private" | "rshared" | "rslave" | "rprivate";
  }/**
   * Describes filesystems to be mounted in a container.
   * @public
   */
  export declare type Mount = BindMount;/**
   * Props for {@link docker.BuildKitImage}
   *
   * @public
   */
  export declare interface BuildKitImageProps {
      /** Directory for use as the build context */
      contextDir?: string;
      /**
       * Contents of the dockerfile
       *
       * @remarks
       * Should not be used if dockerfileName is set
       */
      dockerfile?: string;
      /**
       * Path to a local Dockerfile in the Adapt project.
       *
       * @remarks
       * This path is relative to the root of the Adapt project.
       * Should not be used if `dockerfile` is set.
       */
      dockerfileName?: string;
      /**
       * Extra files that should be included during the docker build
       *
       * @remarks
       * BuildKitImage uses a multi-stage build process.  It first creates
       * a temporary image that includes the files specified in this field.
       * This temporary image is then made available to the `dockerfile` with
       * stage name `files` and can then be copied into the final image, as
       * desired, using `COPY` or `ADD` commands in the `dockerfile`.
       *
       * @example
       * To create a final Docker image that contains a file that has some
       * programmatically created content, use the `dockerfile` prop along
       * with the `files` prop like this:
       * ```tsx
       * const files = [{
       *   path: '/path/to/myfile.txt',
       *   contents: 'contents for myfile\n'
       * }];
       * const dockerfile = `
       *   FROM alpine
       *   COPY --from=files /path/to/myfile.txt /app/myfile.txt
       *   ...
       * `;
       * return <BuildKitImage files={files} dockerfile={dockerfile} />
       * ```
       */
      files?: File[];
      /**
       * Options to control the behavior of docker build
       */
      options?: BuildKitBuildOptions;
      /**
       * Directs BuildKit where to store the built image.
       */
      output: BuildKitOutput;
      /**
       * Extra stages to include in a multi-stage docker build
       */
      stages?: Stage[];
  }/**
   * @internal
   */
  export declare interface BuildKitImageState {
      deployOpID?: DeployOpID;
      image?: WithId<ImageRefRegistry>;
      imagePropsJson?: string;
      prevUniqueNameTag?: string;
  }/**
   * Locally builds a docker image
   *
   * @remarks
   * See {@link docker.BuildKitImageProps}.
   *
   * @public
   */
  export declare class BuildKitImage extends Action<BuildKitImageProps, BuildKitImageState> implements DockerPushableImageInstance {
      static defaultProps: {
          options: {};
      };
      deployedWhenIsTrivial: boolean;
      private image_?;
      private imagePropsJson_?;
      private options_;
      constructor(props: BuildKitImageProps);
      buildComplete(): boolean;
      ready(): boolean;
      image(): WithId<ImageRefRegistry> | undefined;
      pushTo({ ref }: {
          ref: string;
      }): Promise<undefined | WithId<ImageRefRegistry>>;
      latestImage(): WithId<ImageRefRegistry> | undefined;
      /**
       * User-facing name to display in status messages.
       */
      displayName(): string;
      /**
       * Implementations for Action base class
       * @internal
       */
      shouldAct(op: ChangeType): Promise<ShouldAct>;
      /**
       * Implementations for Action base class
       * @internal
       */
      action(op: ChangeType, ctx: ActionContext): Promise<void>;
      /** @internal */
      initialState(): {};
      /** @internal */
      deployedWhen: (goalStatus: GoalStatus) => true | import("@adpt/core").Waiting;
      /** @internal */
      protected get imagePropsJson(): string;
  }/**
   * Components that provide a Docker image can implement this interface to
   * allow other components to get information about the Docker image.
   * @public
   */
  export declare interface DockerImageInstance {
      /**
       * Returns information about the version of the Docker image that reflects
       * the current set of props for the component.
       * @remarks
       * Returns undefined if no image has ever been built by
       * this component OR if the component props have changed and the image
       * that corresponds to the current props has not yet been built.
       */
      image(): ImageRef | undefined;
      /**
       * Returns information about the most current version of the Docker image
       * that has completed building, even if that version does not reflect the
       * current set of props for the component.
       * @remarks
       * Returns undefined if no image has ever been built by this component.
       */
      latestImage(): ImageRef | undefined;
      /**
       * Pushes the image returned by `latestImage` to a Docker registry.
       *
       * @param ref - A docker domain, path components, and tag to which this image should be pushed
       *
       * @remarks
       * If there is no latest image available (`latestImage` returns
       * undefined), then `pushTo` will return undefined. Otherwise, if the
       * push was successful, returns an {@link docker.ImageRefRegistry} that contains
       * the complete nameTag, including registry portion.
       */
      pushTo?({ ref }: {
          ref: NameTagString;
      }): MaybePromise<ImageRefRegistry | undefined>;
  }/**
   * Components that provide a Docker image can implement this interface to
   * allow other components to get information about the Docker image and
   * to be able to push the image to a registry.
   * @public
   */
  export declare interface DockerPushableImageInstance extends DockerImageInstance {
      /**
       * {@inheritdoc docker.DockerImageInstance.pushTo}
       */
      pushTo({ ref }: {
          ref: NameTagString;
      }): MaybePromise<ImageRefRegistry | undefined>;
  }/**
   * Props for {@link docker.DockerImage}.
   * @beta
   */
  export declare interface DockerImageProps {
  }/**
   * Abstract component representing a {@link https://docker.com | Docker}
   * image that can be used to create containers.
   * @remarks
   * See also {@link Container}.
   * @beta
   */
  export declare abstract class DockerImage extends Component<DockerImageProps> implements DockerImageInstance {
      /**
       * {@inheritdoc docker.DockerImageInstance.image}
       */
      image(): ImageRef | undefined;
      /**
       * {@inheritdoc docker.DockerImageInstance.latestImage}
       */
      latestImage(): ImageRef | undefined;
  }/**
   * Compute the status of a container based on a graphQL schema
   *
   * @internal
   */
  export declare function containerStatus(observe: ObserveForStatus, containerName: string, dockerHost: string): Promise<ContainerStatus | NoStatus>;/** @public */
  export declare interface DockerContainerStatus extends ContainerStatus {
  }/**
   * Compute a unique name for the container
   *
   * @internal
   */
  const computeContainerName: (elemKey: string, elemID: string, deployID: string) => string;/**
   * Component to instantiate an image container with docker
   *
   * @remarks
   * See {@link docker.DockerContainerProps}.
   *
   * @public
   */
  declare class DockerContainer extends Action<DockerContainerProps, DockerContainerState> {
      static defaultProps: {
          dockerHost: string;
          privileged: boolean;
      };
      info?: ContainerInfo;
      dependsOn: DependsOnMethod;
      /** @internal */
      shouldAct(diff: ChangeType, context: ActionContext): Promise<false | ShouldAct>;
      /** @internal */
      action(diff: ChangeType, context: ActionContext): Promise<void>;
      status(observe: ObserveForStatus, buildData: BuildData): Promise<NoStatus | ContainerStatus>;
      /**
       * Get the IP address of the container, optionally for a specific Docker
       * network.
       * @remarks
       * The IP addresses that are returned by this function are valid only
       * on the associated Docker network, which is often only associated
       * with a single host node for most Docker network types.
       *
       * @param network - Name of a Docker network. If `network` is provided
       * and the container is connected to the network with an IP address, that
       * address will be returned. If the container is not connected to the
       * network, `undefined` will be returned. If `network` is not provided,
       * the default container IP address will be returned.
       *
       * @beta
       */
      dockerIP(network?: string): string | undefined;
      /** @internal */
      initialState(): {};
      private displayName;
      private refreshContainerInfo;
  }/**
   * Component to instantiate an image container with docker
   *
   * @remarks
   * See {@link docker.DockerContainerProps}.
   *
   * @public
   */
  declare class DockerContainer extends Action<DockerContainerProps, DockerContainerState> {
      static defaultProps: {
          dockerHost: string;
          privileged: boolean;
      };
      info?: ContainerInfo;
      dependsOn: DependsOnMethod;
      /** @internal */
      shouldAct(diff: ChangeType, context: ActionContext): Promise<false | ShouldAct>;
      /** @internal */
      action(diff: ChangeType, context: ActionContext): Promise<void>;
      status(observe: ObserveForStatus, buildData: BuildData): Promise<NoStatus | ContainerStatus>;
      /**
       * Get the IP address of the container, optionally for a specific Docker
       * network.
       * @remarks
       * The IP addresses that are returned by this function are valid only
       * on the associated Docker network, which is often only associated
       * with a single host node for most Docker network types.
       *
       * @param network - Name of a Docker network. If `network` is provided
       * and the container is connected to the network with an IP address, that
       * address will be returned. If the container is not connected to the
       * network, `undefined` will be returned. If `network` is not provided,
       * the default container IP address will be returned.
       *
       * @beta
       */
      dockerIP(network?: string): string | undefined;
      /** @internal */
      initialState(): {};
      private displayName;
      private refreshContainerInfo;
  }/**
   * Type guard for determining whether a given object has a non-null `id`
   * property.
   * @public
   */
  export declare function hasId<T extends {
      id?: ImageIdString;
  }>(o: T): o is WithId<T>;/**
   * Factory function for creating a {@link docker.MutableImageRef}.
   * @remarks
   * Can also be used to clone an existing {@link docker.MutableImageRef} or
   * to create a mutable version of an existing {@link docker.ImageRef}.
   * @public
   */
  export declare function mutableImageRef(ref: ImageNameString, normalize?: boolean): MutableImageRef;/**
   * Factory function for creating a {@link docker.MutableImageRef}.
   * @remarks
   * Can also be used to clone an existing {@link docker.MutableImageRef} or
   * to create a mutable version of an existing {@link docker.ImageRef}.
   * @public
   */
  export declare function mutableImageRef(info?: ImageRefData): MutableImageRef;/**
   * Factory function for creating a {@link docker.ImageRef} or cloning an
   * existing one.
   * @public
   */
  export declare function imageRef(ref: ImageNameString, normalize?: boolean): ImageRef;/**
   * Factory function for creating a {@link docker.ImageRef} or cloning an
   * existing one.
   * @public
   */
  export declare function imageRef(info?: ImageRefData): ImageRef;/**
   * A type guard for determining whether a {@link docker.ImageRef} is a
   * {@link docker.ImageRefRegistry}.
   * @public
   */
  export declare function isImageRefRegistry(ref: ImageRef): ref is ImageRefRegistry;/**
   * A type guard for determining whether a {@link docker.ImageRef} is a
   * {@link docker.ImageRefRegistry} that has the `id` property set.
   * @public
   */
  export declare function isImageRefRegistryWithId(ref: ImageRef): ref is WithId<ImageRefRegistry>;/**
   * A type guard for determining whether a {@link docker.ImageRef} is a
   * {@link docker.ImageRefDockerHost}.
   * @public
   */
  export declare function isImageRefDockerhost(ref: ImageRef): ref is ImageRefDockerHost;/**
   * A type guard for determining whether a {@link docker.ImageRef} is a
   * {@link docker.ImageRefDockerHost} that has the `id` property set.
   * @public
   */
  export declare function isImageRefDockerhostWithId(ref: ImageRef): ref is WithId<ImageRefDockerHost>;/**
   * The most basic components that make up a {@link docker.ImageRef}.
   * All other properties of a {@link docker.ImageRef} can be computed from
   * these.
   * @remarks
   * See also {@link docker.ImageRef} for more information on references.
   * @public
   */
  export declare interface ImageRefData {
      /**
       * Image digest in the form `algorithm:hex`
       * @example
       * sha256:04696b491e0cc3c58a75bace8941c14c924b9f313b03ce5029ebbc040ed9dcd9
       */
      digest?: string;
      /**
       * Docker host string to contact the Docker daemon where this image is
       * located.
       *
       * @remarks
       * This should be in the same format that Docker expects for the `DOCKER_HOST`
       * environment variable. The special string `default` can also be used,
       * which will use the current value of the `DOCKER_HOST` environment variable,
       * if it is set and will otherwise use the default named pipe on Windows
       * (`npipe:///./pipe/docker_engine`) and the default socket on other
       * systems (`unix:///var/run/docker.sock`).
       * @example
       * tcp://localhost:2375
       */
      dockerHost?: "default" | string;
      /**
       * Hostname and optional port number of the container image registry where
       * this image is located.
       * @example
       * docker.io
       * @example
       * localhost:5000
       */
      domain?: RegistryString;
      /**
       * Image content ID in the form `algorithm:hex`
       * @example
       * sha256:199e537da3a86126cd6eb114bd0b13ab178dc291bbb6ea4a4a3aa257b2366b71
       */
      id?: ImageIdString;
      /**
       * The image repo path.
       * @example
       * google/cloud-sdk
       */
      path?: string;
      /**
       * Image tag
       * @example
       * latest
       */
      tag?: string;
  }/**
   * The type of an image reference indicates how the image can be
   * accessed, currently either through a Docker host (daemon) or directly to a
   * container registry via its API.
   *
   * @remarks
   * If not enough information is present to access and uniquely identify a
   * container image, the type is `incomplete`.
   * @public
   */
  export declare type ImageRefType = "incomplete" | "registry" | "dockerhost";/**
   * An immutable reference to a container image, including all information
   * known about the image.
   *
   * @remarks
   * This type is the base type for an image reference and is allowed to
   * contain partial or incomplete information about a container image.
   * It can include both information about how to access the image and
   * also information about the image itself.
   *
   * Many of the properties of {@link docker.ImageRef} are related to the
   * container image reference string used by Docker and other container-based
   * systems. A container image reference string is a structured string
   * containing multiple components. The most basic components are illustrated
   * below, using the example image reference string
   * `"my.registry:5000/a/repo/path:sometag@sha256:899a03e9816e5283edba63d"`.
   *
   * NOTE: The length of the `digest` has been shortened for formatting
   * purposes.
   *
   * ```
   * "my.registry:5000/a/repo/path:sometag@sha256:899a03e9816e5283edba63d"
   * |     domain     |   path    |  tag  |         digest               |
   * ```
   *
   * To aid in correct formatting, {@link docker.ImageRef} and related types and
   * classes also provide helper properties that combine these basic components
   * into combinations that are often useful, such as `name`, which is the
   * `domain` and `path` combined with a `/`.
   *
   * Many tools, such as the Docker UI, also accept a shortened form of a string
   * reference, called the `familiar` form. An example of a familiar reference is
   * `ubuntu`. In this form, only the `path` component is required. When
   * components of the reference are left out, default values are assumed. The
   * default `domain` is `docker.io` and the default `tag` is `latest`.
   * Additionally, if the `domain` is `docker.io` and there are no `/` characters
   * in the `path`, `library/` is prepended to the path. So `ubuntu` is the
   * familiar form for the complete reference `docker.io/library/ubuntu:latest`.
   *
   * An {@link docker.ImageRef} is designed to hold as much information about
   * an image as may be available and therefore some properties that are
   * not known will be `undefined`.
   *
   * See also {@link docker.MutableImageRef}, which can be used to parse
   * reference strings and construct or modify image references.
   * @public
   */
  export declare interface ImageRef extends Readonly<ImageRefData> {
      /**
       * The complete string reference for this image in familiar form, which
       * leaves out certain fields from the reference when they are set to
       * default values.
       * @remarks
       * This reference form is the form typically used in the Docker UI.
       * If the ImageRef is not complete, familiar will return `undefined`, as
       * the correct familiar representation cannot be determined.
       * @example
       * mysql
       * @example
       * gcr.io/my-project/image:1.0.1
       */
      readonly familiar?: string;
      /**
       * The image name, which is comprised of the optional domain and
       * the (non-optional) path. Will be `undefined` if there is no `path`.
       * @example
       * gcr.io/my-project/image
       */
      readonly name?: string;
      /**
       * The image name (including any registry) and image tag. Returns undefined
       * if either path or tag are not set.
       * If nameTag is set to a string that does not contain a tag (i.e. does
       * not include a ":"), the default tag of `latest` will be set.
       * To set nameTag without defaulting to `latest`, call the class method
       * `setNameTag` with the parameter `useDefaultTag` set to `false`.
       * @example
       * gcr.io/my-project/image:1.0.1
       */
      readonly nameTag?: string;
      /**
       * The image path (not including any registry) and image tag. Returns
       * undefined if either `path` or `tag` are not set.
       * @example
       * my-project/image:1.0.1
       */
      readonly pathTag?: string;
      /**
       * The best (most specific and complete) string reference for this image,
       * given the information available in this {@link docker.ImageRef}.
       */
      readonly ref: string;
      /**
       * An alias for `domain`.
       */
      readonly registry?: string;
      /**
       * The best remote reference available for this image in either
       * `domain/path@digest` format or `domain/path:tag` format.
       * @remarks
       * Returns `registryDigest` if it is set, otherwise returns `registryTag`.
       * If no remote reference is available, returns undefined.
       * @example
       * gcr.io/my-project/image\@sha256:899a03e9816e5283edba63d71ea528cd83576b28a7586cf617ce78af5526f209
       * @example
       * gcr.io/my-project/image:1.0.1
       */
      readonly registryRef?: string;
      /**
       * The remote digest reference in `domain/path@digest` form.
       * @remarks
       * Undefined if any of `domain`, `path`, or `digest` are unset.
       * @example
       * gcr.io/my-project/image\@sha256:899a03e9816e5283edba63d71ea528cd83576b28a7586cf617ce78af5526f209
       */
      readonly registryDigest?: string;
      /**
       * The remote tag reference in `domain/path:tag` form.
       * @remarks
       * Undefined if any of `domain`, `path`, or `tag` are unset.
       * @example
       * gcr.io/my-project/image:1.0.1
       */
      readonly registryTag?: string;
      /**
       * The type of an image reference indicates how the image can be
       * accessed, either through a Docker host (daemon) or directly to a
       * container registry.
       *
       * @remarks
       * A reference is a valid `dockerhost` type ref when it contains a valid
       * dockerHost string and either:
       * - A valid image id or
       * - A valid path and either a valid tag or digest.
       *
       * A reference is a valid `registry` type ref when it contains a valid
       * domain, path, and either a tag or a digest.
       *
       * If not enough information is present to access and uniquely identify a
       * container image, the type is `incomplete`.
       */
      readonly type: ImageRefType;
  }/**
   * Helper type that augments a base type to indicate that the `id` field
   * is present and has a valid image ID.
   * @public
   */
  export declare type WithId<T> = T & {
      id: ImageIdString;
  };/**
   * A mutable reference to a container image that can be used to parse,
   * construct, and modify an image reference, as well as to hold information
   * about the image and how to access it.
   *
   * @remarks
   * This class can be used to parse strings that contain complete or partial
   * container image references. It can also be used to construct an image
   * reference from scratch, from individual component parts, or from another
   * reference, then to correctly format the reference or its components for
   * use with various tools.
   *
   * To parse and normalize a "familiar" image reference, like is typically
   * seen in the Docker UI:
   * ```ts
   * const ref = mutableImageRef("redis", true);
   * console.log(ref.tag);         // => "latest"
   * console.log(ref.registryRef); // => "docker.io/library/redis:latest"
   * ```
   *
   * To construct a reference to an image present on the local Docker daemon
   * that has an image ID:
   * ```ts
   * const ref = mutableImageRef({
   *     dockerHost: "default",
   *     path: "myimage",
   *     tag: "just-built",
   *     id: "sha256:04696b491e0cc3c58a75bace8941c14c924b9f313b03ce5029ebbc040ed9dcd9",
   * });
   * ```
   *
   * To convert a `MutableImageRef` to an immutable plain object `ImageRef`,
   * use the `freeze` method.
   * @public
   */
  export declare class MutableImageRef implements ImageRef {
      _digest?: string;
      _dockerHost?: string;
      _domain?: string;
      _id?: ImageIdString;
      _path?: string;
      _tag?: string;
      constructor(ref: ImageNameString, normalize?: boolean);
      constructor(info?: ImageRefData | undefined);
      freeze(): ImageRef;
      toData(): ImageRefData;
      toJSON(): ImageRefData;
      /**
       * The digest string for this image in its associated registry and repo
       * in the form `algorithm:hex`.
       */
      get digest(): string | undefined;
      set digest(digest: string | undefined);
      get dockerHost(): string | undefined;
      set dockerHost(dockerHost: string | undefined);
      /**
       * The hostname and optional port of the image registry for this image.
       */
      get domain(): string | undefined;
      set domain(domain: string | undefined);
      /**
       * The complete string reference for this image in familiar form, which
       * leaves out certain fields from the reference when they are set to
       * default values.
       * @remarks
       * This reference form is the form typically used in the Docker UI.
       * If the ImageRef is not complete, familiar will return `undefined`, as
       * the correct familiar representation cannot be determined.
       */
      get familiar(): string | undefined;
      /**
       * The content ID of the image in `algorithm:hex` format.
       */
      get id(): ImageIdString | undefined;
      set id(id: ImageIdString | undefined);
      /**
       * The image name, which is comprised of the optional domain and
       * the (non-optional) path.
       */
      get name(): string | undefined;
      set name(name: string | undefined);
      /**
       * The image name (including any registry) and image tag. Returns undefined
       * if either path or tag are not set.
       * If nameTag is set to a string that does not contain a tag (i.e. does
       * not include a ":"), the default tag of `latest` will be set.
       * To set nameTag without defaulting to `latest`, call the class method
       * `setNameTag` with the parameter `useDefaultTag` set to `false`.
       */
      get nameTag(): NameTagString | undefined;
      set nameTag(nt: NameTagString | undefined);
      /**
       * Method to set the image name and image tag which also allows choice
       * of default behavior when `nameTag` does not contain a tag string.
       */
      setNameTag(nameTag: NameTagString | undefined, useDefaultTag?: boolean): void;
      /**
       * The image repo path.
       */
      get path(): string | undefined;
      set path(path: string | undefined);
      /**
       * The image path (not including any registry) and image tag. Returns
       * undefined if either path or tag are not set.
       * If pathTag is set to a string that does not contain a tag (i.e. does
       * not include a ":"), the default tag of `latest` will be set.
       * To set pathTag without defaulting to `latest`, call the class method
       * `setPathTag` with the parameter `useDefaultTag` set to `false`.
       */
      get pathTag(): string | undefined;
      set pathTag(pathTag: string | undefined);
      /**
       * Method to set the image path and image tag which also allows choice
       * of default behavior when `pathTag` does not contain a tag string.
       */
      setPathTag(pathTag: string | undefined, useDefaultTag?: boolean): void;
      get ref(): string;
      /**
       * Alias for domain
       */
      get registry(): string | undefined;
      /**
       * The best remote reference available for this image in either
       * `domain/path@digest` format or `domain/path:tag` format.
       * @remarks
       * Returns `registryDigest` if it is set, otherwise returns `registryTag`.
       * If no remote reference is available, returns undefined.
       */
      get registryRef(): ImageNameString | undefined;
      /**
       * The remote digest reference in `domain/path@digest` form.
       * @remarks
       * Undefined if any of `domain`, `path`, or `digest` are unset.
       */
      get registryDigest(): RepoDigestString | undefined;
      set registryDigest(rd: RepoDigestString | undefined);
      /**
       * The remote tag reference in `domain/path:tag` form.
       * @remarks
       * Undefined if any of `domain`, `path`, or `tag` are unset.
       */
      get registryTag(): NameTagString | undefined;
      set registryTag(rt: NameTagString | undefined);
      /**
       * The image tag.
       */
      get tag(): string | undefined;
      set tag(tag: string | undefined);
      /**
       * The type of an image reference indicates how the image can be
       * accessed, either through a Docker host (daemon) or directly to a
       * container registry.
       *
       * @remarks
       * A reference is a valid `dockerhost` type ref when it contains a valid
       * dockerHost string and either:
       * - A valid image id or
       * - A valid path and either a valid tag or digest.
       *
       * A reference is a valid `registry` type ref when it contains a valid
       * domain, path, and either a tag or a digest.
       *
       * If not enough information is present to access and uniquely identify a
       * container image, the type is `incomplete`.
       */
      get type(): ImageRefType;
  }/**
   * A more specific type of {@link docker.ImageRef} that contains sufficient
   * information to uniquely identify an image on a container registry.
   * @public
   */
  export declare interface ImageRefRegistry {
      readonly digest?: string;
      readonly domain: string;
      readonly familiar: string;
      readonly id?: ImageIdString;
      readonly name: string;
      readonly nameTag?: string;
      readonly path: string;
      readonly pathTag?: string;
      readonly ref: string;
      readonly registry: string;
      readonly registryRef: string;
      readonly registryDigest?: string;
      readonly registryTag?: string;
      readonly tag?: string;
      readonly type: "registry";
  }/**
   * A more specific type of {@link docker.ImageRef} that contains sufficient
   * information to uniquely identify an image on a specific Docker host
   * (daemon).
   * @public
   */
  export declare interface ImageRefDockerHost {
      readonly digest?: string;
      readonly dockerHost: string;
      readonly domain?: string;
      readonly familiar: string;
      readonly id?: ImageIdString;
      readonly name: string;
      readonly nameTag?: string;
      readonly path: string;
      readonly pathTag?: string;
      readonly ref: string;
      readonly registry?: string;
      readonly registryRef?: string;
      readonly registryDigest?: string;
      readonly registryTag?: string;
      readonly tag?: string;
      readonly type: "dockerhost";
  }/**
   * Docker network service component, compatible with the abstract
   * {@link NetworkService} component.
   *
   * @remarks
   *
   * Implements the {@link NetworkServiceInstance} interface.
   * In a Docker deployment, there is no actual network service object to deploy.
   * So this is a "virtual" component that simply implements the required
   * instance methods for a NetworkService, but renders to null.
   *
   * This component is typically used by {@link docker.ServiceContainerSet}. The
   * {@link docker.ServiceContainerSet} component can be used to ensure the proper
   * network port configuration is applied to the `props.endpoint` container.
   *
   * @public
   */
  export declare function NetworkService(props: SFCDeclProps<NetworkServiceProps, typeof defaultProps>): null;/**
   * The base string used for Adapt Docker labels.
   * @internal
   */
  const adaptDockerKey = "org.adaptjs";/**
   * Docker label for the deployID the object was created from.
   * @internal
   */
  const adaptDockerDeployIDKey: string;/**
   * Props for {@link docker.LocalDockerImage}
   *
   * @public
   */
  export declare interface LocalDockerImageProps {
      /** Directory for use as the build context in docker build */
      contextDir?: string;
      /**
       * Contents of the dockerfile
       *
       * @remarks
       * Should not be used if dockerfileName is set
       */
      dockerfile?: string;
      /**
       * Path to a local Dockerfile in the Adapt project.
       *
       * @remarks
       * This path is relative to the root of the Adapt project.
       * Should not be used if `dockerfile` is set.
       */
      dockerfileName?: string;
      /**
       * Extra files that should be included during the docker build
       *
       * @remarks
       * LocalDockerImage uses a multi-stage build process.  It first creates
       * a temporary image that includes the files specified in this field.
       * This temporary image is then made available to the `dockerfile` with
       * stage name `files` and can then be copied into the final image, as
       * desired, using `COPY` or `ADD` commands in the `dockerfile`.
       *
       * @example
       * To create a final Docker image that contains a file that has some
       * programmatically created content, use the `dockerfile` prop along
       * with the `files` prop like this:
       * ```tsx
       * const files = [{
       *   path: '/path/to/myfile.txt',
       *   contents: 'contents for myfile\n'
       * }];
       * const dockerfile = `
       *   FROM alpine
       *   COPY --from=files /path/to/myfile.txt /app/myfile.txt
       *   ...
       * `;
       * return <LocalDockerImage files={files} dockerfile={dockerfile} />
       * ```
       */
      files?: File[];
      /**
       * Options to control the behavior of docker build
       */
      options?: DockerBuildOptions;
      /**
       * Extra stages to include in a multi-stage docker build
       */
      stages?: Stage[];
  }/**
   * @internal
   */
  export declare interface LocalDockerImageState {
      deployOpID?: DeployOpID;
      image?: WithId<ImageRefDockerHost>;
      imagePropsJson?: string;
      prevUniqueNameTag?: string;
  }/**
   * Locally builds a docker image
   *
   * @remarks
   * See {@link docker.LocalDockerImageProps}.
   *
   * @public
   */
  export declare class LocalDockerImage extends Action<LocalDockerImageProps, LocalDockerImageState> implements DockerPushableImageInstance {
      static defaultProps: {
          options: {
              dockerHost: string | undefined;
              forceRm: boolean;
          };
      };
      deployedWhenIsTrivial: boolean;
      private image_?;
      private imagePropsJson_?;
      private options_;
      constructor(props: LocalDockerImageProps);
      buildComplete(): boolean;
      ready(): boolean;
      image(): WithId<ImageRefDockerHost> | undefined;
      pushTo({ ref }: {
          ref: string;
      }): Promise<undefined | WithId<ImageRefRegistry>>;
      latestImage(): WithId<ImageRefDockerHost> | undefined;
      /**
       * User-facing name to display in status messages.
       */
      displayName(): string | undefined;
      /**
       * Implementations for Action base class
       * @internal
       */
      shouldAct(op: ChangeType): Promise<ShouldAct>;
      /**
       * Implementations for Action base class
       * @internal
       */
      action(op: ChangeType, ctx: ActionContext): Promise<void>;
      /** @internal */
      initialState(): {};
      /** @internal */
      deployedWhen: (goalStatus: GoalStatus) => true | import("@adpt/core").Waiting;
      /** @internal */
      protected get imagePropsJson(): string;
  }/**
   * Runs a Docker registry in a container.
   * @remarks
   * Implements {@link docker.DockerRegistryInstance}.
   *
   * @public
   */
  export declare function LocalDockerRegistry(props: SFCDeclProps<LocalDockerRegistryProps, typeof defaultProps>): Adapt.JSX.Element;/**
   * Props for {@link docker.LocalDockerRegistry}
   * @public
   */
  export declare interface LocalDockerRegistryProps extends ExcludeKeys<DockerContainerProps, "image"> {
      /**
       * Tag to use for official Docker Hub `registry` image repo.
       */
      imageTag: NameTagString;
      /**
       * Port number to expose for the registry HTTP server.
       */
      port: number;
  }/** @public */
  export declare interface DockerRegistryInstance {
      registry(): RegistryString | undefined;
  }/**
   * Props for {@link docker.RegistryDockerImage}
   * @public
   */
  export declare interface RegistryDockerImageProps {
      /**
       * Handle for image source
       * @remarks
       * Currently, only handle to LocalDockerImage components and compatible
       * interfaces are supported.
       * @privateRemarks
       * FIXME(manishv) support string refs to other registries and handles of
       * other registry images
       */
      imageSrc: Handle<DockerPushableImageInstance>;
      /**
       * Registry and path where the image should be pushed and pulled
       *
       * @remarks
       * If this parameter is a string, registryPrefix will be used for both push and pull
       *
       * If registryPrefix is of the form `{ external: string, internal: string }`, docker images wil be
       * pushed to `external` and image strings will refer to `internal`.
       *
       * Registry prefixes can be of the form `domain/path/elements`, for example `gcr.io/myproject`.
       * However, the registryPrefix should not include the final name, use newPathTag instead.
       *
       * Note(manishv)
       * This is a bit of a hack to allow one hostname or IP address to push images from outside
       * a particular environment (say k8s) and a different URL for that environment to pull
       * images.
       *
       * A good example of this is a k3s-dind (k3s docker-in-docker) instance of kubernetes where
       * a private registry is running on a docker network attached to the k3s-dind instance, but where we
       * want to push {@link docker.LocalDockerImage} built images to that registry.  Since
       * {@link docker.LocalDockerImage | LocalDockerImage} is outside the k3s-dind environment, it must
       * use a host accessible network to push to the registry.  However, since the k3s-dind instance sees
       * the registry from within Docker, it must use a different address to pull the images for use.
       *
       * Once network scopes are fully supported, this interface will change to whatever is appropriate.  It
       * is best if you can arrange to have the same URL or registry string work for all access regardless
       * of which network the registry, Adapt host, and ultimate container running environment is uses.
       */
      registryPrefix: RegistryString | DockerSplitRegistryInfo;
      /**
       * Path and tag to be used for the image in the new registry in
       * `path:tag` or `path` format.
       * @remarks
       * The entire path and tag are blindly concatenated to the domain and path
       * in registryPrefix to form the full ref that will be used to push the
       * image.
       *
       * If omitted, the last component of the path and the tag from the source
       * image is used. The newPathTag should not include the registry
       * hostname/port prefix. If the `:tag` portion of `path:tag` is omitted,
       * the tag `latest` will be used.
       */
      newPathTag?: string;
      /**
       * Path and tag to be used for the image in the new registry in
       * `path:tag` or `path` format.
       * @deprecated This prop has been renamed to `newPathTag`. The functionality
       * for both props is the same and if both are set, `newPathTag` takes
       * priority.
       * @remarks
       * If omitted, the path and tag from the source image is used. The
       * newTag should not include the registry hostname/port prefix. If the
       * `:tag` portion of `path:tag` is omitted, the tag `latest` will be used.
       */
      newTag?: string;
  }/**
   * Represents a Docker image in a registry.
   * @remarks
   * If the image does not exist in the specified registry, it will be pushed
   * to that registry.
   * @public
   */
  export declare class RegistryDockerImage extends Action<RegistryDockerImageProps, State> implements DockerImageInstance {
      private latestImage_?;
      private latestRegistryUrl_?;
      private registry;
      constructor(props: RegistryDockerImageProps);
      /**
       * Returns information about the version of the Docker image that reflects
       * the current set of props for the component and has been pushed to the
       * registry.
       * @remarks
       * Returns undefined if the `props.imageSrc` component's `latestImage` method
       * returns undefined (depending on the component referenced by
       * `props.imageSrc`, that may indicate the source image has not been built).
       * Also returns undefined if the current image has not yet been
       * pushed to the registry.
       */
      image(): ImageRefRegistry | undefined;
      /**
       * Returns information about the most current version of the Docker image
       * that has been pushed to the registry.
       * @remarks
       * Returns undefined if no image has ever been pushed by this component.
       */
      latestImage(): ImageRefRegistry | undefined;
      /** @internal */
      initialState(): {};
      /** @internal */
      shouldAct(diff: ChangeType): false | {
          act: boolean;
          detail: string;
      };
      /** @internal */
      dependsOn: DependsOnMethod;
      /** @internal */
      action(op: ChangeType): Promise<void>;
      private currentNameTag;
      private getNewPathTag;
      private srcImageName;
  }/**
   * Props for {@link docker.ServiceContainerSet}
   *
   * @public
   */
  export declare interface ServiceContainerSetProps extends ServiceProps {
      /**
       * Props to apply to all {@link docker.DockerContainer}s within this
       * ServiceContainerSet. If a prop is specified in the source {@link Container}
       * component and in `containerProps`, `containerProps` will take
       * precedence.
       */
      containerProps?: Partial<DockerContainerProps>;
      /**
       * If set, all children of this ServiceContainerSet that support the
       * `dockerHost` prop will get this value, overriding any other value for
       * this prop.
       */
      dockerHost?: string;
  }/**
   * A component for mapping a group of abstract {@link Container}s and
   * {@link NetworkService}s to Docker {@link docker.DockerContainer | DockerContainer}s
   * and {@link docker.NetworkService}s.
   *
   * @remarks
   * This component is intended to be used to replace {@link Container} and
   * {@link NetworkService} components that are grouped together, as the
   * only children of a common parent in a pattern that looks like this:
   * ```tsx
   * <Service>
   *   <Container ... />
   *   <Container ... />
   *   <NetworkService ... />
   * </Service>
   * ```
   * `ServiceContainerSet` maps those abstract components into Docker components
   * like this:
   * ```tsx
   * <Group>
   *   <docker.DockerContainer ... >
   *   <docker.DockerContainer ... >
   *   <docker.NetworkService ... >
   * </Group>
   * ```
   * An example style rule to do this is:
   * ```tsx
   * {Service}
   * {Adapt.rule((matchedProps) => {
   *     const { handle, ...remainingProps } = matchedProps;
   *     return <ServiceContainerSet {...remainingProps} />;
   * })}
   * ```
   *
   * Currently, {@link docker.NetworkService} implements the {@link NetworkServiceInstance}
   * interface, but does not deploy a network proxy component. So the Docker
   * ServiceContainerSet component applies the network port configuration specified by
   * the {@link NetworkService}s to their target
   * {@link docker.DockerContainer | DockerContainer}s.
   *
   * @public
   */
  export declare class ServiceContainerSet extends DeferredComponent<ServiceContainerSetProps> {
      build(helpers: BuildHelpers): Adapt.JSX.Element;
  }/**
   * Options for interacting with Docker Engine that apply to all
   * operations.
   * @public
   */
  export declare interface DockerGlobalOptions {
      dockerHost?: string;
  }/**
   * Options for performing Docker image builds.
   * @public
   */
  export declare interface DockerBuildOptions extends DockerGlobalOptions {
      /**
       * Requests BuildKit as the internal Docker build engine.
       *
       * @remarks
       * This option requests the use of the BuildKit build engine when building
       * Docker images, if BuildKit is available. This is primarily useful for
       * BuildKit's performance improvements over the legacy Docker build engine.
       * However, because this option does not guarantee BuildKit will be used,
       * BuildKit-only features such as secret mounting should not be used.
       *
       * Internally, this option sets the `DOCKER_BUILDKIT` environment
       * variable when performing builds, which enables BuildKit on Docker
       * systems that support it.
       *
       * For more information, see
       * [Build images with BuildKit](https://docs.docker.com/develop/develop-images/build_enhancements/).
       *
       * @defaultValue `true`
       */
      requestBuildKit?: boolean;
      forceRm?: boolean;
      imageName?: string;
      imageTag?: string;
      prevUniqueNameTag?: string;
      stdin?: string;
      /**
       * If true and the newly built image ID does not match the image ID for
       * prevUniqueNameTag (or prevUniqueNameTag is not set), a new unique nameTag is
       * generated for this image (from imageName and imageTag).
       * If true and the newly built image ID does match the image ID for
       * prevUniqueNameTag, then prevUniqueNameTag is returned as nameTag.
       * If false, imageName and imageTag are used without modification.
       */
      uniqueTag?: boolean;
      /**
       * If set, will add a Docker LABEL with the DeployID.
       */
      deployID?: string;
      buildArgs?: Environment;
  }/**
   * A dynamically-created file that can be used during the build of a Docker
   * image.
   *
   * @remarks
   * These `File` objects are used to create a temporary "scratch" image in a
   * {@link https://docs.docker.com/develop/develop-images/multistage-build/ | multi-stage build}
   * that contains only the specified files. Then, in later stages of that build,
   * the files within the temporary image can be copied into the later stage
   * image.
   * @public
   */
  export declare interface File {
      /**
       * The path in the temporary image where the file will be created.
       */
      path: string;
      /**
       * The contents of the file.
       */
      contents: Buffer | string;
  }/**
   * A stage to be added to a
   * {@link https://docs.docker.com/develop/develop-images/multistage-build/ | multi-stage Docker build}.
   *
   * @remarks
   * The stage will be added to the generated Dockerfile for the image as:
   * ```
   * FROM image as name
   * ```
   * @public
   */
  export declare interface Stage {
      /** The image (name + tag or digest) to use for the stage. */
      image: string;
      /** Name for the stage */
      name: string;
  }/**
   * A string that contains both a Docker repo and a registry digest.
   *
   * @remarks
   * This is a string that represents a specific image on a specific registry
   * contained in a particular repo on that registry. It's of the form:
   * ```
   * [registry/]repo@digest
   * ```
   * `registry` - (optional) The hostname or hostname:port of a Docker registry
   * where the repo is located. If not provided, the official default Docker
   * registry is assumed.
   *
   * `repo` - The more precise name for what's commonly referred to as an image
   * name. It may include 0 or more slashes to denote namespaces.
   *
   * `digest` - The repo digest for the image in the form `algorithm:hex`.
   * This digest is specific to the associated registry and repo and has no
   * significance without those additional pieces of information. If this image is
   * pushed to a different registry, it will have a different digest value.
   * The digest is also known as a "distribution hash".
   *
   * Examples:
   * ```
   * alpine@sha256:04696b491e0cc3c58a75bace8941c14c924b9f313b03ce5029ebbc040ed9dcd9
   * localhost:5000/mockdeploy-htws@sha256:899a03e9816e5283edba63d71ea528cd83576b28a7586cf617ce78af5526f209
   * ```
   * @public
   */
  export declare type RepoDigestString = string;/**
   * Docker image ID, in the form `algorithm:hex`.
   *
   * @remarks
   * The Docker image ID (also known as "Content Hash") is a single value
   * that uniquely identifies a specific image on a local Docker host.
   *
   * An image ID does not require a registry or repo qualifier to be significant.
   * It is distinct from a Docker image
   * {@link docker.RepoDigestString | repo digest}.
   *
   * Example:
   * ```
   * sha256:199e537da3a86126cd6eb114bd0b13ab178dc291bbb6ea4a4a3aa257b2366b71
   * ```
   * @public
   */
  export declare type ImageIdString = string;/**
   * A string reference to a Docker image that contains a repo name, and may
   * contain an optional registry and optional tag.
   *
   * @remarks
   * This is a string that references a Docker image. It's in the form of
   * one of:
   * ```
   * [registry/]repo
   * [registry/]repo:tag
   * ```
   * `registry` - (optional) The hostname or hostname:port of a Docker registry
   * where the repo is located. If not provided, depending on context, either
   * the official default Docker registry may be assumed or the image may just
   * be present locally and not on any registry.
   *
   * `repo` - The more precise name for what's commonly referred to as an image
   * name. It may include 0 or more slashes to denote namespaces.
   *
   * `tag` - A tag string identifying a version of image within the repo.
   *
   * Examples:
   * ```
   * alpine
   * ubuntu:16.04
   * ```
   * @public
   */
  export declare type NameTagString = string;/**
   * A string reference to a Docker image that contains a repo name, and may
   * contain an optional registry and optionally either a tag or a repo digest.
   *
   * @remarks
   * This is a string that references a Docker image. It's in the form of
   * one of:
   * ```
   * [registry/]repo
   * [registry/]repo:tag
   * [registry/]repo@digest
   * ```
   * For more detail, see {@link docker.NameTagString} and
   * {@link docker.RepoDigestString}.
   *
   * Examples:
   * ```
   * alpine
   * ubuntu:16.04
   * alpine@sha256:04696b491e0cc3c58a75bace8941c14c924b9f313b03ce5029ebbc040ed9dcd9
   * localhost:5000/mockdeploy-htws@sha256:899a03e9816e5283edba63d71ea528cd83576b28a7586cf617ce78af5526f209
   * ```
   * @public
   */
  export declare type ImageNameString = NameTagString | RepoDigestString;/**
   * A string that references a Docker registry that contains a hostname and
   * may optionally contain a port and/or path.
   *
   * @remarks
   * This string is in the form of one of:
   * ```
   * hostname[:port]
   * hostname[:port]/path
   * ```
   * This form does not include the protocol, such as `http:` or `https:` in
   * the string.
   *
   * @public
   */
  export declare type RegistryString = string;/**
   * Information about a specific instance of a Docker image, as identified by
   * its image ID.
   * @deprecated Replaced with {@link docker.ImageRef}.
   * @public
   */
  export declare interface ImageInfo {
      /**
       * Docker image ID, in the form `algorithm:hex`.
       * @remarks
       * See {@link docker.ImageIdString}.
       */
      id: ImageIdString;
      /**
       * Docker image name and optional tag in the form `name` or `name:tag`.
       * @remarks
       * See {@link docker.NameTagString}
       */
      nameTag?: NameTagString;
  }/**
   * Props for {@link docker.DockerContainer}
   *
   * @public
   */
  export declare interface DockerContainerProps extends DockerGlobalOptions, Pick<ContainerProps, "autoRemove" | "command" | "environment" | "portBindings" | "ports" | "restartPolicy" | "stopSignal"> {
      /** image name as a string, or a handle to a DockerImage component */
      image: ImageNameString | Handle<DockerImageInstance>;
      /**
       * Host and port of the remote docker host to use.
       *
       * @remarks
       * Defaults to the DOCKER_HOST environment variable
       */
      dockerHost: string;
      /**
       * Labels to apply to the container.
       */
      labels?: ContainerLabels;
      /**
       * Filesystems to be mounted in the container.
       */
      mounts?: Mount[];
      /**
       * Networks to connect the container to
       *
       * @remarks
       * Accepts the same strings as docker network connect
       */
      networks?: string[];
      /**
       * Enables the container to run in privileged mode.
       */
      privileged?: boolean;
  }/**
   * Represents a split registry, with pushes going to external and pulls going to internal
   * @beta
   */
  export declare interface DockerSplitRegistryInfo {
      external: RegistryString;
      internal: RegistryString;
  }/**
   * Describes bind mount filesystems to be mounted in a container.
   * @public
   */
  export declare interface BindMount {
      type: "bind";
      source: string;
      destination: string;
      readonly?: boolean;
      propagation?: "shared" | "slave" | "private" | "rshared" | "rslave" | "rprivate";
  }/**
   * Describes filesystems to be mounted in a container.
   * @public
   */
  export declare type Mount = BindMount;/**
   * Props for {@link docker.BuildKitImage}
   *
   * @public
   */
  export declare interface BuildKitImageProps {
      /** Directory for use as the build context */
      contextDir?: string;
      /**
       * Contents of the dockerfile
       *
       * @remarks
       * Should not be used if dockerfileName is set
       */
      dockerfile?: string;
      /**
       * Path to a local Dockerfile in the Adapt project.
       *
       * @remarks
       * This path is relative to the root of the Adapt project.
       * Should not be used if `dockerfile` is set.
       */
      dockerfileName?: string;
      /**
       * Extra files that should be included during the docker build
       *
       * @remarks
       * BuildKitImage uses a multi-stage build process.  It first creates
       * a temporary image that includes the files specified in this field.
       * This temporary image is then made available to the `dockerfile` with
       * stage name `files` and can then be copied into the final image, as
       * desired, using `COPY` or `ADD` commands in the `dockerfile`.
       *
       * @example
       * To create a final Docker image that contains a file that has some
       * programmatically created content, use the `dockerfile` prop along
       * with the `files` prop like this:
       * ```tsx
       * const files = [{
       *   path: '/path/to/myfile.txt',
       *   contents: 'contents for myfile\n'
       * }];
       * const dockerfile = `
       *   FROM alpine
       *   COPY --from=files /path/to/myfile.txt /app/myfile.txt
       *   ...
       * `;
       * return <BuildKitImage files={files} dockerfile={dockerfile} />
       * ```
       */
      files?: File[];
      /**
       * Options to control the behavior of docker build
       */
      options?: BuildKitBuildOptions;
      /**
       * Directs BuildKit where to store the built image.
       */
      output: BuildKitOutput;
      /**
       * Extra stages to include in a multi-stage docker build
       */
      stages?: Stage[];
  }/**
   * @internal
   */
  export declare interface BuildKitImageState {
      deployOpID?: DeployOpID;
      image?: WithId<ImageRefRegistry>;
      imagePropsJson?: string;
      prevUniqueNameTag?: string;
  }/**
   * Locally builds a docker image
   *
   * @remarks
   * See {@link docker.BuildKitImageProps}.
   *
   * @public
   */
  export declare class BuildKitImage extends Action<BuildKitImageProps, BuildKitImageState> implements DockerPushableImageInstance {
      static defaultProps: {
          options: {};
      };
      deployedWhenIsTrivial: boolean;
      private image_?;
      private imagePropsJson_?;
      private options_;
      constructor(props: BuildKitImageProps);
      buildComplete(): boolean;
      ready(): boolean;
      image(): WithId<ImageRefRegistry> | undefined;
      pushTo({ ref }: {
          ref: string;
      }): Promise<undefined | WithId<ImageRefRegistry>>;
      latestImage(): WithId<ImageRefRegistry> | undefined;
      /**
       * User-facing name to display in status messages.
       */
      displayName(): string;
      /**
       * Implementations for Action base class
       * @internal
       */
      shouldAct(op: ChangeType): Promise<ShouldAct>;
      /**
       * Implementations for Action base class
       * @internal
       */
      action(op: ChangeType, ctx: ActionContext): Promise<void>;
      /** @internal */
      initialState(): {};
      /** @internal */
      deployedWhen: (goalStatus: GoalStatus) => true | import("@adpt/core").Waiting;
      /** @internal */
      protected get imagePropsJson(): string;
  }/**
   * Components that provide a Docker image can implement this interface to
   * allow other components to get information about the Docker image.
   * @public
   */
  export declare interface DockerImageInstance {
      /**
       * Returns information about the version of the Docker image that reflects
       * the current set of props for the component.
       * @remarks
       * Returns undefined if no image has ever been built by
       * this component OR if the component props have changed and the image
       * that corresponds to the current props has not yet been built.
       */
      image(): ImageRef | undefined;
      /**
       * Returns information about the most current version of the Docker image
       * that has completed building, even if that version does not reflect the
       * current set of props for the component.
       * @remarks
       * Returns undefined if no image has ever been built by this component.
       */
      latestImage(): ImageRef | undefined;
      /**
       * Pushes the image returned by `latestImage` to a Docker registry.
       *
       * @param ref - A docker domain, path components, and tag to which this image should be pushed
       *
       * @remarks
       * If there is no latest image available (`latestImage` returns
       * undefined), then `pushTo` will return undefined. Otherwise, if the
       * push was successful, returns an {@link docker.ImageRefRegistry} that contains
       * the complete nameTag, including registry portion.
       */
      pushTo?({ ref }: {
          ref: NameTagString;
      }): MaybePromise<ImageRefRegistry | undefined>;
  }/**
   * Components that provide a Docker image can implement this interface to
   * allow other components to get information about the Docker image and
   * to be able to push the image to a registry.
   * @public
   */
  export declare interface DockerPushableImageInstance extends DockerImageInstance {
      /**
       * {@inheritdoc docker.DockerImageInstance.pushTo}
       */
      pushTo({ ref }: {
          ref: NameTagString;
      }): MaybePromise<ImageRefRegistry | undefined>;
  }/**
   * Props for {@link docker.DockerImage}.
   * @beta
   */
  export declare interface DockerImageProps {
  }/**
   * Abstract component representing a {@link https://docker.com | Docker}
   * image that can be used to create containers.
   * @remarks
   * See also {@link Container}.
   * @beta
   */
  export declare abstract class DockerImage extends Component<DockerImageProps> implements DockerImageInstance {
      /**
       * {@inheritdoc docker.DockerImageInstance.image}
       */
      image(): ImageRef | undefined;
      /**
       * {@inheritdoc docker.DockerImageInstance.latestImage}
       */
      latestImage(): ImageRef | undefined;
  }/**
   * Compute the status of a container based on a graphQL schema
   *
   * @internal
   */
  export declare function containerStatus(observe: ObserveForStatus, containerName: string, dockerHost: string): Promise<ContainerStatus | NoStatus>;/** @public */
  export declare interface DockerContainerStatus extends ContainerStatus {
  }/**
   * Compute a unique name for the container
   *
   * @internal
   */
  const computeContainerName: (elemKey: string, elemID: string, deployID: string) => string;/**
   * Component to instantiate an image container with docker
   *
   * @remarks
   * See {@link docker.DockerContainerProps}.
   *
   * @public
   */
  declare class DockerContainer extends Action<DockerContainerProps, DockerContainerState> {
      static defaultProps: {
          dockerHost: string;
          privileged: boolean;
      };
      info?: ContainerInfo;
      dependsOn: DependsOnMethod;
      /** @internal */
      shouldAct(diff: ChangeType, context: ActionContext): Promise<false | ShouldAct>;
      /** @internal */
      action(diff: ChangeType, context: ActionContext): Promise<void>;
      status(observe: ObserveForStatus, buildData: BuildData): Promise<NoStatus | ContainerStatus>;
      /**
       * Get the IP address of the container, optionally for a specific Docker
       * network.
       * @remarks
       * The IP addresses that are returned by this function are valid only
       * on the associated Docker network, which is often only associated
       * with a single host node for most Docker network types.
       *
       * @param network - Name of a Docker network. If `network` is provided
       * and the container is connected to the network with an IP address, that
       * address will be returned. If the container is not connected to the
       * network, `undefined` will be returned. If `network` is not provided,
       * the default container IP address will be returned.
       *
       * @beta
       */
      dockerIP(network?: string): string | undefined;
      /** @internal */
      initialState(): {};
      private displayName;
      private refreshContainerInfo;
  }/**
   * Component to instantiate an image container with docker
   *
   * @remarks
   * See {@link docker.DockerContainerProps}.
   *
   * @public
   */
  declare class DockerContainer extends Action<DockerContainerProps, DockerContainerState> {
      static defaultProps: {
          dockerHost: string;
          privileged: boolean;
      };
      info?: ContainerInfo;
      dependsOn: DependsOnMethod;
      /** @internal */
      shouldAct(diff: ChangeType, context: ActionContext): Promise<false | ShouldAct>;
      /** @internal */
      action(diff: ChangeType, context: ActionContext): Promise<void>;
      status(observe: ObserveForStatus, buildData: BuildData): Promise<NoStatus | ContainerStatus>;
      /**
       * Get the IP address of the container, optionally for a specific Docker
       * network.
       * @remarks
       * The IP addresses that are returned by this function are valid only
       * on the associated Docker network, which is often only associated
       * with a single host node for most Docker network types.
       *
       * @param network - Name of a Docker network. If `network` is provided
       * and the container is connected to the network with an IP address, that
       * address will be returned. If the container is not connected to the
       * network, `undefined` will be returned. If `network` is not provided,
       * the default container IP address will be returned.
       *
       * @beta
       */
      dockerIP(network?: string): string | undefined;
      /** @internal */
      initialState(): {};
      private displayName;
      private refreshContainerInfo;
  }/**
   * Type guard for determining whether a given object has a non-null `id`
   * property.
   * @public
   */
  export declare function hasId<T extends {
      id?: ImageIdString;
  }>(o: T): o is WithId<T>;/**
   * Factory function for creating a {@link docker.MutableImageRef}.
   * @remarks
   * Can also be used to clone an existing {@link docker.MutableImageRef} or
   * to create a mutable version of an existing {@link docker.ImageRef}.
   * @public
   */
  export declare function mutableImageRef(ref: ImageNameString, normalize?: boolean): MutableImageRef;/**
   * Factory function for creating a {@link docker.MutableImageRef}.
   * @remarks
   * Can also be used to clone an existing {@link docker.MutableImageRef} or
   * to create a mutable version of an existing {@link docker.ImageRef}.
   * @public
   */
  export declare function mutableImageRef(info?: ImageRefData): MutableImageRef;/**
   * Factory function for creating a {@link docker.ImageRef} or cloning an
   * existing one.
   * @public
   */
  export declare function imageRef(ref: ImageNameString, normalize?: boolean): ImageRef;/**
   * Factory function for creating a {@link docker.ImageRef} or cloning an
   * existing one.
   * @public
   */
  export declare function imageRef(info?: ImageRefData): ImageRef;/**
   * A type guard for determining whether a {@link docker.ImageRef} is a
   * {@link docker.ImageRefRegistry}.
   * @public
   */
  export declare function isImageRefRegistry(ref: ImageRef): ref is ImageRefRegistry;/**
   * A type guard for determining whether a {@link docker.ImageRef} is a
   * {@link docker.ImageRefRegistry} that has the `id` property set.
   * @public
   */
  export declare function isImageRefRegistryWithId(ref: ImageRef): ref is WithId<ImageRefRegistry>;/**
   * A type guard for determining whether a {@link docker.ImageRef} is a
   * {@link docker.ImageRefDockerHost}.
   * @public
   */
  export declare function isImageRefDockerhost(ref: ImageRef): ref is ImageRefDockerHost;/**
   * A type guard for determining whether a {@link docker.ImageRef} is a
   * {@link docker.ImageRefDockerHost} that has the `id` property set.
   * @public
   */
  export declare function isImageRefDockerhostWithId(ref: ImageRef): ref is WithId<ImageRefDockerHost>;/**
   * The most basic components that make up a {@link docker.ImageRef}.
   * All other properties of a {@link docker.ImageRef} can be computed from
   * these.
   * @remarks
   * See also {@link docker.ImageRef} for more information on references.
   * @public
   */
  export declare interface ImageRefData {
      /**
       * Image digest in the form `algorithm:hex`
       * @example
       * sha256:04696b491e0cc3c58a75bace8941c14c924b9f313b03ce5029ebbc040ed9dcd9
       */
      digest?: string;
      /**
       * Docker host string to contact the Docker daemon where this image is
       * located.
       *
       * @remarks
       * This should be in the same format that Docker expects for the `DOCKER_HOST`
       * environment variable. The special string `default` can also be used,
       * which will use the current value of the `DOCKER_HOST` environment variable,
       * if it is set and will otherwise use the default named pipe on Windows
       * (`npipe:///./pipe/docker_engine`) and the default socket on other
       * systems (`unix:///var/run/docker.sock`).
       * @example
       * tcp://localhost:2375
       */
      dockerHost?: "default" | string;
      /**
       * Hostname and optional port number of the container image registry where
       * this image is located.
       * @example
       * docker.io
       * @example
       * localhost:5000
       */
      domain?: RegistryString;
      /**
       * Image content ID in the form `algorithm:hex`
       * @example
       * sha256:199e537da3a86126cd6eb114bd0b13ab178dc291bbb6ea4a4a3aa257b2366b71
       */
      id?: ImageIdString;
      /**
       * The image repo path.
       * @example
       * google/cloud-sdk
       */
      path?: string;
      /**
       * Image tag
       * @example
       * latest
       */
      tag?: string;
  }/**
   * The type of an image reference indicates how the image can be
   * accessed, currently either through a Docker host (daemon) or directly to a
   * container registry via its API.
   *
   * @remarks
   * If not enough information is present to access and uniquely identify a
   * container image, the type is `incomplete`.
   * @public
   */
  export declare type ImageRefType = "incomplete" | "registry" | "dockerhost";/**
   * An immutable reference to a container image, including all information
   * known about the image.
   *
   * @remarks
   * This type is the base type for an image reference and is allowed to
   * contain partial or incomplete information about a container image.
   * It can include both information about how to access the image and
   * also information about the image itself.
   *
   * Many of the properties of {@link docker.ImageRef} are related to the
   * container image reference string used by Docker and other container-based
   * systems. A container image reference string is a structured string
   * containing multiple components. The most basic components are illustrated
   * below, using the example image reference string
   * `"my.registry:5000/a/repo/path:sometag@sha256:899a03e9816e5283edba63d"`.
   *
   * NOTE: The length of the `digest` has been shortened for formatting
   * purposes.
   *
   * ```
   * "my.registry:5000/a/repo/path:sometag@sha256:899a03e9816e5283edba63d"
   * |     domain     |   path    |  tag  |         digest               |
   * ```
   *
   * To aid in correct formatting, {@link docker.ImageRef} and related types and
   * classes also provide helper properties that combine these basic components
   * into combinations that are often useful, such as `name`, which is the
   * `domain` and `path` combined with a `/`.
   *
   * Many tools, such as the Docker UI, also accept a shortened form of a string
   * reference, called the `familiar` form. An example of a familiar reference is
   * `ubuntu`. In this form, only the `path` component is required. When
   * components of the reference are left out, default values are assumed. The
   * default `domain` is `docker.io` and the default `tag` is `latest`.
   * Additionally, if the `domain` is `docker.io` and there are no `/` characters
   * in the `path`, `library/` is prepended to the path. So `ubuntu` is the
   * familiar form for the complete reference `docker.io/library/ubuntu:latest`.
   *
   * An {@link docker.ImageRef} is designed to hold as much information about
   * an image as may be available and therefore some properties that are
   * not known will be `undefined`.
   *
   * See also {@link docker.MutableImageRef}, which can be used to parse
   * reference strings and construct or modify image references.
   * @public
   */
  export declare interface ImageRef extends Readonly<ImageRefData> {
      /**
       * The complete string reference for this image in familiar form, which
       * leaves out certain fields from the reference when they are set to
       * default values.
       * @remarks
       * This reference form is the form typically used in the Docker UI.
       * If the ImageRef is not complete, familiar will return `undefined`, as
       * the correct familiar representation cannot be determined.
       * @example
       * mysql
       * @example
       * gcr.io/my-project/image:1.0.1
       */
      readonly familiar?: string;
      /**
       * The image name, which is comprised of the optional domain and
       * the (non-optional) path. Will be `undefined` if there is no `path`.
       * @example
       * gcr.io/my-project/image
       */
      readonly name?: string;
      /**
       * The image name (including any registry) and image tag. Returns undefined
       * if either path or tag are not set.
       * If nameTag is set to a string that does not contain a tag (i.e. does
       * not include a ":"), the default tag of `latest` will be set.
       * To set nameTag without defaulting to `latest`, call the class method
       * `setNameTag` with the parameter `useDefaultTag` set to `false`.
       * @example
       * gcr.io/my-project/image:1.0.1
       */
      readonly nameTag?: string;
      /**
       * The image path (not including any registry) and image tag. Returns
       * undefined if either `path` or `tag` are not set.
       * @example
       * my-project/image:1.0.1
       */
      readonly pathTag?: string;
      /**
       * The best (most specific and complete) string reference for this image,
       * given the information available in this {@link docker.ImageRef}.
       */
      readonly ref: string;
      /**
       * An alias for `domain`.
       */
      readonly registry?: string;
      /**
       * The best remote reference available for this image in either
       * `domain/path@digest` format or `domain/path:tag` format.
       * @remarks
       * Returns `registryDigest` if it is set, otherwise returns `registryTag`.
       * If no remote reference is available, returns undefined.
       * @example
       * gcr.io/my-project/image\@sha256:899a03e9816e5283edba63d71ea528cd83576b28a7586cf617ce78af5526f209
       * @example
       * gcr.io/my-project/image:1.0.1
       */
      readonly registryRef?: string;
      /**
       * The remote digest reference in `domain/path@digest` form.
       * @remarks
       * Undefined if any of `domain`, `path`, or `digest` are unset.
       * @example
       * gcr.io/my-project/image\@sha256:899a03e9816e5283edba63d71ea528cd83576b28a7586cf617ce78af5526f209
       */
      readonly registryDigest?: string;
      /**
       * The remote tag reference in `domain/path:tag` form.
       * @remarks
       * Undefined if any of `domain`, `path`, or `tag` are unset.
       * @example
       * gcr.io/my-project/image:1.0.1
       */
      readonly registryTag?: string;
      /**
       * The type of an image reference indicates how the image can be
       * accessed, either through a Docker host (daemon) or directly to a
       * container registry.
       *
       * @remarks
       * A reference is a valid `dockerhost` type ref when it contains a valid
       * dockerHost string and either:
       * - A valid image id or
       * - A valid path and either a valid tag or digest.
       *
       * A reference is a valid `registry` type ref when it contains a valid
       * domain, path, and either a tag or a digest.
       *
       * If not enough information is present to access and uniquely identify a
       * container image, the type is `incomplete`.
       */
      readonly type: ImageRefType;
  }/**
   * Helper type that augments a base type to indicate that the `id` field
   * is present and has a valid image ID.
   * @public
   */
  export declare type WithId<T> = T & {
      id: ImageIdString;
  };/**
   * A mutable reference to a container image that can be used to parse,
   * construct, and modify an image reference, as well as to hold information
   * about the image and how to access it.
   *
   * @remarks
   * This class can be used to parse strings that contain complete or partial
   * container image references. It can also be used to construct an image
   * reference from scratch, from individual component parts, or from another
   * reference, then to correctly format the reference or its components for
   * use with various tools.
   *
   * To parse and normalize a "familiar" image reference, like is typically
   * seen in the Docker UI:
   * ```ts
   * const ref = mutableImageRef("redis", true);
   * console.log(ref.tag);         // => "latest"
   * console.log(ref.registryRef); // => "docker.io/library/redis:latest"
   * ```
   *
   * To construct a reference to an image present on the local Docker daemon
   * that has an image ID:
   * ```ts
   * const ref = mutableImageRef({
   *     dockerHost: "default",
   *     path: "myimage",
   *     tag: "just-built",
   *     id: "sha256:04696b491e0cc3c58a75bace8941c14c924b9f313b03ce5029ebbc040ed9dcd9",
   * });
   * ```
   *
   * To convert a `MutableImageRef` to an immutable plain object `ImageRef`,
   * use the `freeze` method.
   * @public
   */
  export declare class MutableImageRef implements ImageRef {
      _digest?: string;
      _dockerHost?: string;
      _domain?: string;
      _id?: ImageIdString;
      _path?: string;
      _tag?: string;
      constructor(ref: ImageNameString, normalize?: boolean);
      constructor(info?: ImageRefData | undefined);
      freeze(): ImageRef;
      toData(): ImageRefData;
      toJSON(): ImageRefData;
      /**
       * The digest string for this image in its associated registry and repo
       * in the form `algorithm:hex`.
       */
      get digest(): string | undefined;
      set digest(digest: string | undefined);
      get dockerHost(): string | undefined;
      set dockerHost(dockerHost: string | undefined);
      /**
       * The hostname and optional port of the image registry for this image.
       */
      get domain(): string | undefined;
      set domain(domain: string | undefined);
      /**
       * The complete string reference for this image in familiar form, which
       * leaves out certain fields from the reference when they are set to
       * default values.
       * @remarks
       * This reference form is the form typically used in the Docker UI.
       * If the ImageRef is not complete, familiar will return `undefined`, as
       * the correct familiar representation cannot be determined.
       */
      get familiar(): string | undefined;
      /**
       * The content ID of the image in `algorithm:hex` format.
       */
      get id(): ImageIdString | undefined;
      set id(id: ImageIdString | undefined);
      /**
       * The image name, which is comprised of the optional domain and
       * the (non-optional) path.
       */
      get name(): string | undefined;
      set name(name: string | undefined);
      /**
       * The image name (including any registry) and image tag. Returns undefined
       * if either path or tag are not set.
       * If nameTag is set to a string that does not contain a tag (i.e. does
       * not include a ":"), the default tag of `latest` will be set.
       * To set nameTag without defaulting to `latest`, call the class method
       * `setNameTag` with the parameter `useDefaultTag` set to `false`.
       */
      get nameTag(): NameTagString | undefined;
      set nameTag(nt: NameTagString | undefined);
      /**
       * Method to set the image name and image tag which also allows choice
       * of default behavior when `nameTag` does not contain a tag string.
       */
      setNameTag(nameTag: NameTagString | undefined, useDefaultTag?: boolean): void;
      /**
       * The image repo path.
       */
      get path(): string | undefined;
      set path(path: string | undefined);
      /**
       * The image path (not including any registry) and image tag. Returns
       * undefined if either path or tag are not set.
       * If pathTag is set to a string that does not contain a tag (i.e. does
       * not include a ":"), the default tag of `latest` will be set.
       * To set pathTag without defaulting to `latest`, call the class method
       * `setPathTag` with the parameter `useDefaultTag` set to `false`.
       */
      get pathTag(): string | undefined;
      set pathTag(pathTag: string | undefined);
      /**
       * Method to set the image path and image tag which also allows choice
       * of default behavior when `pathTag` does not contain a tag string.
       */
      setPathTag(pathTag: string | undefined, useDefaultTag?: boolean): void;
      get ref(): string;
      /**
       * Alias for domain
       */
      get registry(): string | undefined;
      /**
       * The best remote reference available for this image in either
       * `domain/path@digest` format or `domain/path:tag` format.
       * @remarks
       * Returns `registryDigest` if it is set, otherwise returns `registryTag`.
       * If no remote reference is available, returns undefined.
       */
      get registryRef(): ImageNameString | undefined;
      /**
       * The remote digest reference in `domain/path@digest` form.
       * @remarks
       * Undefined if any of `domain`, `path`, or `digest` are unset.
       */
      get registryDigest(): RepoDigestString | undefined;
      set registryDigest(rd: RepoDigestString | undefined);
      /**
       * The remote tag reference in `domain/path:tag` form.
       * @remarks
       * Undefined if any of `domain`, `path`, or `tag` are unset.
       */
      get registryTag(): NameTagString | undefined;
      set registryTag(rt: NameTagString | undefined);
      /**
       * The image tag.
       */
      get tag(): string | undefined;
      set tag(tag: string | undefined);
      /**
       * The type of an image reference indicates how the image can be
       * accessed, either through a Docker host (daemon) or directly to a
       * container registry.
       *
       * @remarks
       * A reference is a valid `dockerhost` type ref when it contains a valid
       * dockerHost string and either:
       * - A valid image id or
       * - A valid path and either a valid tag or digest.
       *
       * A reference is a valid `registry` type ref when it contains a valid
       * domain, path, and either a tag or a digest.
       *
       * If not enough information is present to access and uniquely identify a
       * container image, the type is `incomplete`.
       */
      get type(): ImageRefType;
  }/**
   * A more specific type of {@link docker.ImageRef} that contains sufficient
   * information to uniquely identify an image on a container registry.
   * @public
   */
  export declare interface ImageRefRegistry {
      readonly digest?: string;
      readonly domain: string;
      readonly familiar: string;
      readonly id?: ImageIdString;
      readonly name: string;
      readonly nameTag?: string;
      readonly path: string;
      readonly pathTag?: string;
      readonly ref: string;
      readonly registry: string;
      readonly registryRef: string;
      readonly registryDigest?: string;
      readonly registryTag?: string;
      readonly tag?: string;
      readonly type: "registry";
  }/**
   * A more specific type of {@link docker.ImageRef} that contains sufficient
   * information to uniquely identify an image on a specific Docker host
   * (daemon).
   * @public
   */
  export declare interface ImageRefDockerHost {
      readonly digest?: string;
      readonly dockerHost: string;
      readonly domain?: string;
      readonly familiar: string;
      readonly id?: ImageIdString;
      readonly name: string;
      readonly nameTag?: string;
      readonly path: string;
      readonly pathTag?: string;
      readonly ref: string;
      readonly registry?: string;
      readonly registryRef?: string;
      readonly registryDigest?: string;
      readonly registryTag?: string;
      readonly tag?: string;
      readonly type: "dockerhost";
  }/**
   * Docker network service component, compatible with the abstract
   * {@link NetworkService} component.
   *
   * @remarks
   *
   * Implements the {@link NetworkServiceInstance} interface.
   * In a Docker deployment, there is no actual network service object to deploy.
   * So this is a "virtual" component that simply implements the required
   * instance methods for a NetworkService, but renders to null.
   *
   * This component is typically used by {@link docker.ServiceContainerSet}. The
   * {@link docker.ServiceContainerSet} component can be used to ensure the proper
   * network port configuration is applied to the `props.endpoint` container.
   *
   * @public
   */
  export declare function NetworkService(props: SFCDeclProps<NetworkServiceProps, typeof defaultProps>): null;/**
   * The base string used for Adapt Docker labels.
   * @internal
   */
  const adaptDockerKey = "org.adaptjs";/**
   * Docker label for the deployID the object was created from.
   * @internal
   */
  const adaptDockerDeployIDKey: string;/**
   * Props for {@link docker.LocalDockerImage}
   *
   * @public
   */
  export declare interface LocalDockerImageProps {
      /** Directory for use as the build context in docker build */
      contextDir?: string;
      /**
       * Contents of the dockerfile
       *
       * @remarks
       * Should not be used if dockerfileName is set
       */
      dockerfile?: string;
      /**
       * Path to a local Dockerfile in the Adapt project.
       *
       * @remarks
       * This path is relative to the root of the Adapt project.
       * Should not be used if `dockerfile` is set.
       */
      dockerfileName?: string;
      /**
       * Extra files that should be included during the docker build
       *
       * @remarks
       * LocalDockerImage uses a multi-stage build process.  It first creates
       * a temporary image that includes the files specified in this field.
       * This temporary image is then made available to the `dockerfile` with
       * stage name `files` and can then be copied into the final image, as
       * desired, using `COPY` or `ADD` commands in the `dockerfile`.
       *
       * @example
       * To create a final Docker image that contains a file that has some
       * programmatically created content, use the `dockerfile` prop along
       * with the `files` prop like this:
       * ```tsx
       * const files = [{
       *   path: '/path/to/myfile.txt',
       *   contents: 'contents for myfile\n'
       * }];
       * const dockerfile = `
       *   FROM alpine
       *   COPY --from=files /path/to/myfile.txt /app/myfile.txt
       *   ...
       * `;
       * return <LocalDockerImage files={files} dockerfile={dockerfile} />
       * ```
       */
      files?: File[];
      /**
       * Options to control the behavior of docker build
       */
      options?: DockerBuildOptions;
      /**
       * Extra stages to include in a multi-stage docker build
       */
      stages?: Stage[];
  }/**
   * @internal
   */
  export declare interface LocalDockerImageState {
      deployOpID?: DeployOpID;
      image?: WithId<ImageRefDockerHost>;
      imagePropsJson?: string;
      prevUniqueNameTag?: string;
  }/**
   * Locally builds a docker image
   *
   * @remarks
   * See {@link docker.LocalDockerImageProps}.
   *
   * @public
   */
  export declare class LocalDockerImage extends Action<LocalDockerImageProps, LocalDockerImageState> implements DockerPushableImageInstance {
      static defaultProps: {
          options: {
              dockerHost: string | undefined;
              forceRm: boolean;
          };
      };
      deployedWhenIsTrivial: boolean;
      private image_?;
      private imagePropsJson_?;
      private options_;
      constructor(props: LocalDockerImageProps);
      buildComplete(): boolean;
      ready(): boolean;
      image(): WithId<ImageRefDockerHost> | undefined;
      pushTo({ ref }: {
          ref: string;
      }): Promise<undefined | WithId<ImageRefRegistry>>;
      latestImage(): WithId<ImageRefDockerHost> | undefined;
      /**
       * User-facing name to display in status messages.
       */
      displayName(): string | undefined;
      /**
       * Implementations for Action base class
       * @internal
       */
      shouldAct(op: ChangeType): Promise<ShouldAct>;
      /**
       * Implementations for Action base class
       * @internal
       */
      action(op: ChangeType, ctx: ActionContext): Promise<void>;
      /** @internal */
      initialState(): {};
      /** @internal */
      deployedWhen: (goalStatus: GoalStatus) => true | import("@adpt/core").Waiting;
      /** @internal */
      protected get imagePropsJson(): string;
  }/**
   * Runs a Docker registry in a container.
   * @remarks
   * Implements {@link docker.DockerRegistryInstance}.
   *
   * @public
   */
  export declare function LocalDockerRegistry(props: SFCDeclProps<LocalDockerRegistryProps, typeof defaultProps>): Adapt.JSX.Element;/**
   * Props for {@link docker.LocalDockerRegistry}
   * @public
   */
  export declare interface LocalDockerRegistryProps extends ExcludeKeys<DockerContainerProps, "image"> {
      /**
       * Tag to use for official Docker Hub `registry` image repo.
       */
      imageTag: NameTagString;
      /**
       * Port number to expose for the registry HTTP server.
       */
      port: number;
  }/** @public */
  export declare interface DockerRegistryInstance {
      registry(): RegistryString | undefined;
  }/**
   * Props for {@link docker.RegistryDockerImage}
   * @public
   */
  export declare interface RegistryDockerImageProps {
      /**
       * Handle for image source
       * @remarks
       * Currently, only handle to LocalDockerImage components and compatible
       * interfaces are supported.
       * @privateRemarks
       * FIXME(manishv) support string refs to other registries and handles of
       * other registry images
       */
      imageSrc: Handle<DockerPushableImageInstance>;
      /**
       * Registry and path where the image should be pushed and pulled
       *
       * @remarks
       * If this parameter is a string, registryPrefix will be used for both push and pull
       *
       * If registryPrefix is of the form `{ external: string, internal: string }`, docker images wil be
       * pushed to `external` and image strings will refer to `internal`.
       *
       * Registry prefixes can be of the form `domain/path/elements`, for example `gcr.io/myproject`.
       * However, the registryPrefix should not include the final name, use newPathTag instead.
       *
       * Note(manishv)
       * This is a bit of a hack to allow one hostname or IP address to push images from outside
       * a particular environment (say k8s) and a different URL for that environment to pull
       * images.
       *
       * A good example of this is a k3s-dind (k3s docker-in-docker) instance of kubernetes where
       * a private registry is running on a docker network attached to the k3s-dind instance, but where we
       * want to push {@link docker.LocalDockerImage} built images to that registry.  Since
       * {@link docker.LocalDockerImage | LocalDockerImage} is outside the k3s-dind environment, it must
       * use a host accessible network to push to the registry.  However, since the k3s-dind instance sees
       * the registry from within Docker, it must use a different address to pull the images for use.
       *
       * Once network scopes are fully supported, this interface will change to whatever is appropriate.  It
       * is best if you can arrange to have the same URL or registry string work for all access regardless
       * of which network the registry, Adapt host, and ultimate container running environment is uses.
       */
      registryPrefix: RegistryString | DockerSplitRegistryInfo;
      /**
       * Path and tag to be used for the image in the new registry in
       * `path:tag` or `path` format.
       * @remarks
       * The entire path and tag are blindly concatenated to the domain and path
       * in registryPrefix to form the full ref that will be used to push the
       * image.
       *
       * If omitted, the last component of the path and the tag from the source
       * image is used. The newPathTag should not include the registry
       * hostname/port prefix. If the `:tag` portion of `path:tag` is omitted,
       * the tag `latest` will be used.
       */
      newPathTag?: string;
      /**
       * Path and tag to be used for the image in the new registry in
       * `path:tag` or `path` format.
       * @deprecated This prop has been renamed to `newPathTag`. The functionality
       * for both props is the same and if both are set, `newPathTag` takes
       * priority.
       * @remarks
       * If omitted, the path and tag from the source image is used. The
       * newTag should not include the registry hostname/port prefix. If the
       * `:tag` portion of `path:tag` is omitted, the tag `latest` will be used.
       */
      newTag?: string;
  }/**
   * Represents a Docker image in a registry.
   * @remarks
   * If the image does not exist in the specified registry, it will be pushed
   * to that registry.
   * @public
   */
  export declare class RegistryDockerImage extends Action<RegistryDockerImageProps, State> implements DockerImageInstance {
      private latestImage_?;
      private latestRegistryUrl_?;
      private registry;
      constructor(props: RegistryDockerImageProps);
      /**
       * Returns information about the version of the Docker image that reflects
       * the current set of props for the component and has been pushed to the
       * registry.
       * @remarks
       * Returns undefined if the `props.imageSrc` component's `latestImage` method
       * returns undefined (depending on the component referenced by
       * `props.imageSrc`, that may indicate the source image has not been built).
       * Also returns undefined if the current image has not yet been
       * pushed to the registry.
       */
      image(): ImageRefRegistry | undefined;
      /**
       * Returns information about the most current version of the Docker image
       * that has been pushed to the registry.
       * @remarks
       * Returns undefined if no image has ever been pushed by this component.
       */
      latestImage(): ImageRefRegistry | undefined;
      /** @internal */
      initialState(): {};
      /** @internal */
      shouldAct(diff: ChangeType): false | {
          act: boolean;
          detail: string;
      };
      /** @internal */
      dependsOn: DependsOnMethod;
      /** @internal */
      action(op: ChangeType): Promise<void>;
      private currentNameTag;
      private getNewPathTag;
      private srcImageName;
  }/**
   * Props for {@link docker.ServiceContainerSet}
   *
   * @public
   */
  export declare interface ServiceContainerSetProps extends ServiceProps {
      /**
       * Props to apply to all {@link docker.DockerContainer}s within this
       * ServiceContainerSet. If a prop is specified in the source {@link Container}
       * component and in `containerProps`, `containerProps` will take
       * precedence.
       */
      containerProps?: Partial<DockerContainerProps>;
      /**
       * If set, all children of this ServiceContainerSet that support the
       * `dockerHost` prop will get this value, overriding any other value for
       * this prop.
       */
      dockerHost?: string;
  }/**
   * A component for mapping a group of abstract {@link Container}s and
   * {@link NetworkService}s to Docker {@link docker.DockerContainer | DockerContainer}s
   * and {@link docker.NetworkService}s.
   *
   * @remarks
   * This component is intended to be used to replace {@link Container} and
   * {@link NetworkService} components that are grouped together, as the
   * only children of a common parent in a pattern that looks like this:
   * ```tsx
   * <Service>
   *   <Container ... />
   *   <Container ... />
   *   <NetworkService ... />
   * </Service>
   * ```
   * `ServiceContainerSet` maps those abstract components into Docker components
   * like this:
   * ```tsx
   * <Group>
   *   <docker.DockerContainer ... >
   *   <docker.DockerContainer ... >
   *   <docker.NetworkService ... >
   * </Group>
   * ```
   * An example style rule to do this is:
   * ```tsx
   * {Service}
   * {Adapt.rule((matchedProps) => {
   *     const { handle, ...remainingProps } = matchedProps;
   *     return <ServiceContainerSet {...remainingProps} />;
   * })}
   * ```
   *
   * Currently, {@link docker.NetworkService} implements the {@link NetworkServiceInstance}
   * interface, but does not deploy a network proxy component. So the Docker
   * ServiceContainerSet component applies the network port configuration specified by
   * the {@link NetworkService}s to their target
   * {@link docker.DockerContainer | DockerContainer}s.
   *
   * @public
   */
  export declare class ServiceContainerSet extends DeferredComponent<ServiceContainerSetProps> {
      build(helpers: BuildHelpers): Adapt.JSX.Element;
  }/**
   * Options for interacting with Docker Engine that apply to all
   * operations.
   * @public
   */
  export declare interface DockerGlobalOptions {
      dockerHost?: string;
  }/**
   * Options for performing Docker image builds.
   * @public
   */
  export declare interface DockerBuildOptions extends DockerGlobalOptions {
      /**
       * Requests BuildKit as the internal Docker build engine.
       *
       * @remarks
       * This option requests the use of the BuildKit build engine when building
       * Docker images, if BuildKit is available. This is primarily useful for
       * BuildKit's performance improvements over the legacy Docker build engine.
       * However, because this option does not guarantee BuildKit will be used,
       * BuildKit-only features such as secret mounting should not be used.
       *
       * Internally, this option sets the `DOCKER_BUILDKIT` environment
       * variable when performing builds, which enables BuildKit on Docker
       * systems that support it.
       *
       * For more information, see
       * [Build images with BuildKit](https://docs.docker.com/develop/develop-images/build_enhancements/).
       *
       * @defaultValue `true`
       */
      requestBuildKit?: boolean;
      forceRm?: boolean;
      imageName?: string;
      imageTag?: string;
      prevUniqueNameTag?: string;
      stdin?: string;
      /**
       * If true and the newly built image ID does not match the image ID for
       * prevUniqueNameTag (or prevUniqueNameTag is not set), a new unique nameTag is
       * generated for this image (from imageName and imageTag).
       * If true and the newly built image ID does match the image ID for
       * prevUniqueNameTag, then prevUniqueNameTag is returned as nameTag.
       * If false, imageName and imageTag are used without modification.
       */
      uniqueTag?: boolean;
      /**
       * If set, will add a Docker LABEL with the DeployID.
       */
      deployID?: string;
      buildArgs?: Environment;
  }/**
   * A dynamically-created file that can be used during the build of a Docker
   * image.
   *
   * @remarks
   * These `File` objects are used to create a temporary "scratch" image in a
   * {@link https://docs.docker.com/develop/develop-images/multistage-build/ | multi-stage build}
   * that contains only the specified files. Then, in later stages of that build,
   * the files within the temporary image can be copied into the later stage
   * image.
   * @public
   */
  export declare interface File {
      /**
       * The path in the temporary image where the file will be created.
       */
      path: string;
      /**
       * The contents of the file.
       */
      contents: Buffer | string;
  }/**
   * A stage to be added to a
   * {@link https://docs.docker.com/develop/develop-images/multistage-build/ | multi-stage Docker build}.
   *
   * @remarks
   * The stage will be added to the generated Dockerfile for the image as:
   * ```
   * FROM image as name
   * ```
   * @public
   */
  export declare interface Stage {
      /** The image (name + tag or digest) to use for the stage. */
      image: string;
      /** Name for the stage */
      name: string;
  }/**
   * A string that contains both a Docker repo and a registry digest.
   *
   * @remarks
   * This is a string that represents a specific image on a specific registry
   * contained in a particular repo on that registry. It's of the form:
   * ```
   * [registry/]repo@digest
   * ```
   * `registry` - (optional) The hostname or hostname:port of a Docker registry
   * where the repo is located. If not provided, the official default Docker
   * registry is assumed.
   *
   * `repo` - The more precise name for what's commonly referred to as an image
   * name. It may include 0 or more slashes to denote namespaces.
   *
   * `digest` - The repo digest for the image in the form `algorithm:hex`.
   * This digest is specific to the associated registry and repo and has no
   * significance without those additional pieces of information. If this image is
   * pushed to a different registry, it will have a different digest value.
   * The digest is also known as a "distribution hash".
   *
   * Examples:
   * ```
   * alpine@sha256:04696b491e0cc3c58a75bace8941c14c924b9f313b03ce5029ebbc040ed9dcd9
   * localhost:5000/mockdeploy-htws@sha256:899a03e9816e5283edba63d71ea528cd83576b28a7586cf617ce78af5526f209
   * ```
   * @public
   */
  export declare type RepoDigestString = string;/**
   * Docker image ID, in the form `algorithm:hex`.
   *
   * @remarks
   * The Docker image ID (also known as "Content Hash") is a single value
   * that uniquely identifies a specific image on a local Docker host.
   *
   * An image ID does not require a registry or repo qualifier to be significant.
   * It is distinct from a Docker image
   * {@link docker.RepoDigestString | repo digest}.
   *
   * Example:
   * ```
   * sha256:199e537da3a86126cd6eb114bd0b13ab178dc291bbb6ea4a4a3aa257b2366b71
   * ```
   * @public
   */
  export declare type ImageIdString = string;/**
   * A string reference to a Docker image that contains a repo name, and may
   * contain an optional registry and optional tag.
   *
   * @remarks
   * This is a string that references a Docker image. It's in the form of
   * one of:
   * ```
   * [registry/]repo
   * [registry/]repo:tag
   * ```
   * `registry` - (optional) The hostname or hostname:port of a Docker registry
   * where the repo is located. If not provided, depending on context, either
   * the official default Docker registry may be assumed or the image may just
   * be present locally and not on any registry.
   *
   * `repo` - The more precise name for what's commonly referred to as an image
   * name. It may include 0 or more slashes to denote namespaces.
   *
   * `tag` - A tag string identifying a version of image within the repo.
   *
   * Examples:
   * ```
   * alpine
   * ubuntu:16.04
   * ```
   * @public
   */
  export declare type NameTagString = string;/**
   * A string reference to a Docker image that contains a repo name, and may
   * contain an optional registry and optionally either a tag or a repo digest.
   *
   * @remarks
   * This is a string that references a Docker image. It's in the form of
   * one of:
   * ```
   * [registry/]repo
   * [registry/]repo:tag
   * [registry/]repo@digest
   * ```
   * For more detail, see {@link docker.NameTagString} and
   * {@link docker.RepoDigestString}.
   *
   * Examples:
   * ```
   * alpine
   * ubuntu:16.04
   * alpine@sha256:04696b491e0cc3c58a75bace8941c14c924b9f313b03ce5029ebbc040ed9dcd9
   * localhost:5000/mockdeploy-htws@sha256:899a03e9816e5283edba63d71ea528cd83576b28a7586cf617ce78af5526f209
   * ```
   * @public
   */
  export declare type ImageNameString = NameTagString | RepoDigestString;/**
   * A string that references a Docker registry that contains a hostname and
   * may optionally contain a port and/or path.
   *
   * @remarks
   * This string is in the form of one of:
   * ```
   * hostname[:port]
   * hostname[:port]/path
   * ```
   * This form does not include the protocol, such as `http:` or `https:` in
   * the string.
   *
   * @public
   */
  export declare type RegistryString = string;/**
   * Information about a specific instance of a Docker image, as identified by
   * its image ID.
   * @deprecated Replaced with {@link docker.ImageRef}.
   * @public
   */
  export declare interface ImageInfo {
      /**
       * Docker image ID, in the form `algorithm:hex`.
       * @remarks
       * See {@link docker.ImageIdString}.
       */
      id: ImageIdString;
      /**
       * Docker image name and optional tag in the form `name` or `name:tag`.
       * @remarks
       * See {@link docker.NameTagString}
       */
      nameTag?: NameTagString;
  }/**
   * Props for {@link docker.DockerContainer}
   *
   * @public
   */
  export declare interface DockerContainerProps extends DockerGlobalOptions, Pick<ContainerProps, "autoRemove" | "command" | "environment" | "portBindings" | "ports" | "restartPolicy" | "stopSignal"> {
      /** image name as a string, or a handle to a DockerImage component */
      image: ImageNameString | Handle<DockerImageInstance>;
      /**
       * Host and port of the remote docker host to use.
       *
       * @remarks
       * Defaults to the DOCKER_HOST environment variable
       */
      dockerHost: string;
      /**
       * Labels to apply to the container.
       */
      labels?: ContainerLabels;
      /**
       * Filesystems to be mounted in the container.
       */
      mounts?: Mount[];
      /**
       * Networks to connect the container to
       *
       * @remarks
       * Accepts the same strings as docker network connect
       */
      networks?: string[];
      /**
       * Enables the container to run in privileged mode.
       */
      privileged?: boolean;
  }/**
   * Represents a split registry, with pushes going to external and pulls going to internal
   * @beta
   */
  export declare interface DockerSplitRegistryInfo {
      external: RegistryString;
      internal: RegistryString;
  }/**
   * Describes bind mount filesystems to be mounted in a container.
   * @public
   */
  export declare interface BindMount {
      type: "bind";
      source: string;
      destination: string;
      readonly?: boolean;
      propagation?: "shared" | "slave" | "private" | "rshared" | "rslave" | "rprivate";
  }/**
   * Describes filesystems to be mounted in a container.
   * @public
   */
  export declare type Mount = BindMount;/**
   * Props for {@link docker.BuildKitImage}
   *
   * @public
   */
  export declare interface BuildKitImageProps {
      /** Directory for use as the build context */
      contextDir?: string;
      /**
       * Contents of the dockerfile
       *
       * @remarks
       * Should not be used if dockerfileName is set
       */
      dockerfile?: string;
      /**
       * Path to a local Dockerfile in the Adapt project.
       *
       * @remarks
       * This path is relative to the root of the Adapt project.
       * Should not be used if `dockerfile` is set.
       */
      dockerfileName?: string;
      /**
       * Extra files that should be included during the docker build
       *
       * @remarks
       * BuildKitImage uses a multi-stage build process.  It first creates
       * a temporary image that includes the files specified in this field.
       * This temporary image is then made available to the `dockerfile` with
       * stage name `files` and can then be copied into the final image, as
       * desired, using `COPY` or `ADD` commands in the `dockerfile`.
       *
       * @example
       * To create a final Docker image that contains a file that has some
       * programmatically created content, use the `dockerfile` prop along
       * with the `files` prop like this:
       * ```tsx
       * const files = [{
       *   path: '/path/to/myfile.txt',
       *   contents: 'contents for myfile\n'
       * }];
       * const dockerfile = `
       *   FROM alpine
       *   COPY --from=files /path/to/myfile.txt /app/myfile.txt
       *   ...
       * `;
       * return <BuildKitImage files={files} dockerfile={dockerfile} />
       * ```
       */
      files?: File[];
      /**
       * Options to control the behavior of docker build
       */
      options?: BuildKitBuildOptions;
      /**
       * Directs BuildKit where to store the built image.
       */
      output: BuildKitOutput;
      /**
       * Extra stages to include in a multi-stage docker build
       */
      stages?: Stage[];
  }/**
   * @internal
   */
  export declare interface BuildKitImageState {
      deployOpID?: DeployOpID;
      image?: WithId<ImageRefRegistry>;
      imagePropsJson?: string;
      prevUniqueNameTag?: string;
  }/**
   * Locally builds a docker image
   *
   * @remarks
   * See {@link docker.BuildKitImageProps}.
   *
   * @public
   */
  export declare class BuildKitImage extends Action<BuildKitImageProps, BuildKitImageState> implements DockerPushableImageInstance {
      static defaultProps: {
          options: {};
      };
      deployedWhenIsTrivial: boolean;
      private image_?;
      private imagePropsJson_?;
      private options_;
      constructor(props: BuildKitImageProps);
      buildComplete(): boolean;
      ready(): boolean;
      image(): WithId<ImageRefRegistry> | undefined;
      pushTo({ ref }: {
          ref: string;
      }): Promise<undefined | WithId<ImageRefRegistry>>;
      latestImage(): WithId<ImageRefRegistry> | undefined;
      /**
       * User-facing name to display in status messages.
       */
      displayName(): string;
      /**
       * Implementations for Action base class
       * @internal
       */
      shouldAct(op: ChangeType): Promise<ShouldAct>;
      /**
       * Implementations for Action base class
       * @internal
       */
      action(op: ChangeType, ctx: ActionContext): Promise<void>;
      /** @internal */
      initialState(): {};
      /** @internal */
      deployedWhen: (goalStatus: GoalStatus) => true | import("@adpt/core").Waiting;
      /** @internal */
      protected get imagePropsJson(): string;
  }/**
   * Components that provide a Docker image can implement this interface to
   * allow other components to get information about the Docker image.
   * @public
   */
  export declare interface DockerImageInstance {
      /**
       * Returns information about the version of the Docker image that reflects
       * the current set of props for the component.
       * @remarks
       * Returns undefined if no image has ever been built by
       * this component OR if the component props have changed and the image
       * that corresponds to the current props has not yet been built.
       */
      image(): ImageRef | undefined;
      /**
       * Returns information about the most current version of the Docker image
       * that has completed building, even if that version does not reflect the
       * current set of props for the component.
       * @remarks
       * Returns undefined if no image has ever been built by this component.
       */
      latestImage(): ImageRef | undefined;
      /**
       * Pushes the image returned by `latestImage` to a Docker registry.
       *
       * @param ref - A docker domain, path components, and tag to which this image should be pushed
       *
       * @remarks
       * If there is no latest image available (`latestImage` returns
       * undefined), then `pushTo` will return undefined. Otherwise, if the
       * push was successful, returns an {@link docker.ImageRefRegistry} that contains
       * the complete nameTag, including registry portion.
       */
      pushTo?({ ref }: {
          ref: NameTagString;
      }): MaybePromise<ImageRefRegistry | undefined>;
  }/**
   * Components that provide a Docker image can implement this interface to
   * allow other components to get information about the Docker image and
   * to be able to push the image to a registry.
   * @public
   */
  export declare interface DockerPushableImageInstance extends DockerImageInstance {
      /**
       * {@inheritdoc docker.DockerImageInstance.pushTo}
       */
      pushTo({ ref }: {
          ref: NameTagString;
      }): MaybePromise<ImageRefRegistry | undefined>;
  }/**
   * Props for {@link docker.DockerImage}.
   * @beta
   */
  export declare interface DockerImageProps {
  }/**
   * Abstract component representing a {@link https://docker.com | Docker}
   * image that can be used to create containers.
   * @remarks
   * See also {@link Container}.
   * @beta
   */
  export declare abstract class DockerImage extends Component<DockerImageProps> implements DockerImageInstance {
      /**
       * {@inheritdoc docker.DockerImageInstance.image}
       */
      image(): ImageRef | undefined;
      /**
       * {@inheritdoc docker.DockerImageInstance.latestImage}
       */
      latestImage(): ImageRef | undefined;
  }/**
   * Compute the status of a container based on a graphQL schema
   *
   * @internal
   */
  export declare function containerStatus(observe: ObserveForStatus, containerName: string, dockerHost: string): Promise<ContainerStatus | NoStatus>;/** @public */
  export declare interface DockerContainerStatus extends ContainerStatus {
  }/**
   * Compute a unique name for the container
   *
   * @internal
   */
  const computeContainerName: (elemKey: string, elemID: string, deployID: string) => string;/**
   * Component to instantiate an image container with docker
   *
   * @remarks
   * See {@link docker.DockerContainerProps}.
   *
   * @public
   */
  declare class DockerContainer extends Action<DockerContainerProps, DockerContainerState> {
      static defaultProps: {
          dockerHost: string;
          privileged: boolean;
      };
      info?: ContainerInfo;
      dependsOn: DependsOnMethod;
      /** @internal */
      shouldAct(diff: ChangeType, context: ActionContext): Promise<false | ShouldAct>;
      /** @internal */
      action(diff: ChangeType, context: ActionContext): Promise<void>;
      status(observe: ObserveForStatus, buildData: BuildData): Promise<NoStatus | ContainerStatus>;
      /**
       * Get the IP address of the container, optionally for a specific Docker
       * network.
       * @remarks
       * The IP addresses that are returned by this function are valid only
       * on the associated Docker network, which is often only associated
       * with a single host node for most Docker network types.
       *
       * @param network - Name of a Docker network. If `network` is provided
       * and the container is connected to the network with an IP address, that
       * address will be returned. If the container is not connected to the
       * network, `undefined` will be returned. If `network` is not provided,
       * the default container IP address will be returned.
       *
       * @beta
       */
      dockerIP(network?: string): string | undefined;
      /** @internal */
      initialState(): {};
      private displayName;
      private refreshContainerInfo;
  }/**
   * Component to instantiate an image container with docker
   *
   * @remarks
   * See {@link docker.DockerContainerProps}.
   *
   * @public
   */
  declare class DockerContainer extends Action<DockerContainerProps, DockerContainerState> {
      static defaultProps: {
          dockerHost: string;
          privileged: boolean;
      };
      info?: ContainerInfo;
      dependsOn: DependsOnMethod;
      /** @internal */
      shouldAct(diff: ChangeType, context: ActionContext): Promise<false | ShouldAct>;
      /** @internal */
      action(diff: ChangeType, context: ActionContext): Promise<void>;
      status(observe: ObserveForStatus, buildData: BuildData): Promise<NoStatus | ContainerStatus>;
      /**
       * Get the IP address of the container, optionally for a specific Docker
       * network.
       * @remarks
       * The IP addresses that are returned by this function are valid only
       * on the associated Docker network, which is often only associated
       * with a single host node for most Docker network types.
       *
       * @param network - Name of a Docker network. If `network` is provided
       * and the container is connected to the network with an IP address, that
       * address will be returned. If the container is not connected to the
       * network, `undefined` will be returned. If `network` is not provided,
       * the default container IP address will be returned.
       *
       * @beta
       */
      dockerIP(network?: string): string | undefined;
      /** @internal */
      initialState(): {};
      private displayName;
      private refreshContainerInfo;
  }/**
   * Type guard for determining whether a given object has a non-null `id`
   * property.
   * @public
   */
  export declare function hasId<T extends {
      id?: ImageIdString;
  }>(o: T): o is WithId<T>;/**
   * Factory function for creating a {@link docker.MutableImageRef}.
   * @remarks
   * Can also be used to clone an existing {@link docker.MutableImageRef} or
   * to create a mutable version of an existing {@link docker.ImageRef}.
   * @public
   */
  export declare function mutableImageRef(ref: ImageNameString, normalize?: boolean): MutableImageRef;/**
   * Factory function for creating a {@link docker.MutableImageRef}.
   * @remarks
   * Can also be used to clone an existing {@link docker.MutableImageRef} or
   * to create a mutable version of an existing {@link docker.ImageRef}.
   * @public
   */
  export declare function mutableImageRef(info?: ImageRefData): MutableImageRef;/**
   * Factory function for creating a {@link docker.ImageRef} or cloning an
   * existing one.
   * @public
   */
  export declare function imageRef(ref: ImageNameString, normalize?: boolean): ImageRef;/**
   * Factory function for creating a {@link docker.ImageRef} or cloning an
   * existing one.
   * @public
   */
  export declare function imageRef(info?: ImageRefData): ImageRef;/**
   * A type guard for determining whether a {@link docker.ImageRef} is a
   * {@link docker.ImageRefRegistry}.
   * @public
   */
  export declare function isImageRefRegistry(ref: ImageRef): ref is ImageRefRegistry;/**
   * A type guard for determining whether a {@link docker.ImageRef} is a
   * {@link docker.ImageRefRegistry} that has the `id` property set.
   * @public
   */
  export declare function isImageRefRegistryWithId(ref: ImageRef): ref is WithId<ImageRefRegistry>;/**
   * A type guard for determining whether a {@link docker.ImageRef} is a
   * {@link docker.ImageRefDockerHost}.
   * @public
   */
  export declare function isImageRefDockerhost(ref: ImageRef): ref is ImageRefDockerHost;/**
   * A type guard for determining whether a {@link docker.ImageRef} is a
   * {@link docker.ImageRefDockerHost} that has the `id` property set.
   * @public
   */
  export declare function isImageRefDockerhostWithId(ref: ImageRef): ref is WithId<ImageRefDockerHost>;/**
   * The most basic components that make up a {@link docker.ImageRef}.
   * All other properties of a {@link docker.ImageRef} can be computed from
   * these.
   * @remarks
   * See also {@link docker.ImageRef} for more information on references.
   * @public
   */
  export declare interface ImageRefData {
      /**
       * Image digest in the form `algorithm:hex`
       * @example
       * sha256:04696b491e0cc3c58a75bace8941c14c924b9f313b03ce5029ebbc040ed9dcd9
       */
      digest?: string;
      /**
       * Docker host string to contact the Docker daemon where this image is
       * located.
       *
       * @remarks
       * This should be in the same format that Docker expects for the `DOCKER_HOST`
       * environment variable. The special string `default` can also be used,
       * which will use the current value of the `DOCKER_HOST` environment variable,
       * if it is set and will otherwise use the default named pipe on Windows
       * (`npipe:///./pipe/docker_engine`) and the default socket on other
       * systems (`unix:///var/run/docker.sock`).
       * @example
       * tcp://localhost:2375
       */
      dockerHost?: "default" | string;
      /**
       * Hostname and optional port number of the container image registry where
       * this image is located.
       * @example
       * docker.io
       * @example
       * localhost:5000
       */
      domain?: RegistryString;
      /**
       * Image content ID in the form `algorithm:hex`
       * @example
       * sha256:199e537da3a86126cd6eb114bd0b13ab178dc291bbb6ea4a4a3aa257b2366b71
       */
      id?: ImageIdString;
      /**
       * The image repo path.
       * @example
       * google/cloud-sdk
       */
      path?: string;
      /**
       * Image tag
       * @example
       * latest
       */
      tag?: string;
  }/**
   * The type of an image reference indicates how the image can be
   * accessed, currently either through a Docker host (daemon) or directly to a
   * container registry via its API.
   *
   * @remarks
   * If not enough information is present to access and uniquely identify a
   * container image, the type is `incomplete`.
   * @public
   */
  export declare type ImageRefType = "incomplete" | "registry" | "dockerhost";/**
   * An immutable reference to a container image, including all information
   * known about the image.
   *
   * @remarks
   * This type is the base type for an image reference and is allowed to
   * contain partial or incomplete information about a container image.
   * It can include both information about how to access the image and
   * also information about the image itself.
   *
   * Many of the properties of {@link docker.ImageRef} are related to the
   * container image reference string used by Docker and other container-based
   * systems. A container image reference string is a structured string
   * containing multiple components. The most basic components are illustrated
   * below, using the example image reference string
   * `"my.registry:5000/a/repo/path:sometag@sha256:899a03e9816e5283edba63d"`.
   *
   * NOTE: The length of the `digest` has been shortened for formatting
   * purposes.
   *
   * ```
   * "my.registry:5000/a/repo/path:sometag@sha256:899a03e9816e5283edba63d"
   * |     domain     |   path    |  tag  |         digest               |
   * ```
   *
   * To aid in correct formatting, {@link docker.ImageRef} and related types and
   * classes also provide helper properties that combine these basic components
   * into combinations that are often useful, such as `name`, which is the
   * `domain` and `path` combined with a `/`.
   *
   * Many tools, such as the Docker UI, also accept a shortened form of a string
   * reference, called the `familiar` form. An example of a familiar reference is
   * `ubuntu`. In this form, only the `path` component is required. When
   * components of the reference are left out, default values are assumed. The
   * default `domain` is `docker.io` and the default `tag` is `latest`.
   * Additionally, if the `domain` is `docker.io` and there are no `/` characters
   * in the `path`, `library/` is prepended to the path. So `ubuntu` is the
   * familiar form for the complete reference `docker.io/library/ubuntu:latest`.
   *
   * An {@link docker.ImageRef} is designed to hold as much information about
   * an image as may be available and therefore some properties that are
   * not known will be `undefined`.
   *
   * See also {@link docker.MutableImageRef}, which can be used to parse
   * reference strings and construct or modify image references.
   * @public
   */
  export declare interface ImageRef extends Readonly<ImageRefData> {
      /**
       * The complete string reference for this image in familiar form, which
       * leaves out certain fields from the reference when they are set to
       * default values.
       * @remarks
       * This reference form is the form typically used in the Docker UI.
       * If the ImageRef is not complete, familiar will return `undefined`, as
       * the correct familiar representation cannot be determined.
       * @example
       * mysql
       * @example
       * gcr.io/my-project/image:1.0.1
       */
      readonly familiar?: string;
      /**
       * The image name, which is comprised of the optional domain and
       * the (non-optional) path. Will be `undefined` if there is no `path`.
       * @example
       * gcr.io/my-project/image
       */
      readonly name?: string;
      /**
       * The image name (including any registry) and image tag. Returns undefined
       * if either path or tag are not set.
       * If nameTag is set to a string that does not contain a tag (i.e. does
       * not include a ":"), the default tag of `latest` will be set.
       * To set nameTag without defaulting to `latest`, call the class method
       * `setNameTag` with the parameter `useDefaultTag` set to `false`.
       * @example
       * gcr.io/my-project/image:1.0.1
       */
      readonly nameTag?: string;
      /**
       * The image path (not including any registry) and image tag. Returns
       * undefined if either `path` or `tag` are not set.
       * @example
       * my-project/image:1.0.1
       */
      readonly pathTag?: string;
      /**
       * The best (most specific and complete) string reference for this image,
       * given the information available in this {@link docker.ImageRef}.
       */
      readonly ref: string;
      /**
       * An alias for `domain`.
       */
      readonly registry?: string;
      /**
       * The best remote reference available for this image in either
       * `domain/path@digest` format or `domain/path:tag` format.
       * @remarks
       * Returns `registryDigest` if it is set, otherwise returns `registryTag`.
       * If no remote reference is available, returns undefined.
       * @example
       * gcr.io/my-project/image\@sha256:899a03e9816e5283edba63d71ea528cd83576b28a7586cf617ce78af5526f209
       * @example
       * gcr.io/my-project/image:1.0.1
       */
      readonly registryRef?: string;
      /**
       * The remote digest reference in `domain/path@digest` form.
       * @remarks
       * Undefined if any of `domain`, `path`, or `digest` are unset.
       * @example
       * gcr.io/my-project/image\@sha256:899a03e9816e5283edba63d71ea528cd83576b28a7586cf617ce78af5526f209
       */
      readonly registryDigest?: string;
      /**
       * The remote tag reference in `domain/path:tag` form.
       * @remarks
       * Undefined if any of `domain`, `path`, or `tag` are unset.
       * @example
       * gcr.io/my-project/image:1.0.1
       */
      readonly registryTag?: string;
      /**
       * The type of an image reference indicates how the image can be
       * accessed, either through a Docker host (daemon) or directly to a
       * container registry.
       *
       * @remarks
       * A reference is a valid `dockerhost` type ref when it contains a valid
       * dockerHost string and either:
       * - A valid image id or
       * - A valid path and either a valid tag or digest.
       *
       * A reference is a valid `registry` type ref when it contains a valid
       * domain, path, and either a tag or a digest.
       *
       * If not enough information is present to access and uniquely identify a
       * container image, the type is `incomplete`.
       */
      readonly type: ImageRefType;
  }/**
   * Helper type that augments a base type to indicate that the `id` field
   * is present and has a valid image ID.
   * @public
   */
  export declare type WithId<T> = T & {
      id: ImageIdString;
  };/**
   * A mutable reference to a container image that can be used to parse,
   * construct, and modify an image reference, as well as to hold information
   * about the image and how to access it.
   *
   * @remarks
   * This class can be used to parse strings that contain complete or partial
   * container image references. It can also be used to construct an image
   * reference from scratch, from individual component parts, or from another
   * reference, then to correctly format the reference or its components for
   * use with various tools.
   *
   * To parse and normalize a "familiar" image reference, like is typically
   * seen in the Docker UI:
   * ```ts
   * const ref = mutableImageRef("redis", true);
   * console.log(ref.tag);         // => "latest"
   * console.log(ref.registryRef); // => "docker.io/library/redis:latest"
   * ```
   *
   * To construct a reference to an image present on the local Docker daemon
   * that has an image ID:
   * ```ts
   * const ref = mutableImageRef({
   *     dockerHost: "default",
   *     path: "myimage",
   *     tag: "just-built",
   *     id: "sha256:04696b491e0cc3c58a75bace8941c14c924b9f313b03ce5029ebbc040ed9dcd9",
   * });
   * ```
   *
   * To convert a `MutableImageRef` to an immutable plain object `ImageRef`,
   * use the `freeze` method.
   * @public
   */
  export declare class MutableImageRef implements ImageRef {
      _digest?: string;
      _dockerHost?: string;
      _domain?: string;
      _id?: ImageIdString;
      _path?: string;
      _tag?: string;
      constructor(ref: ImageNameString, normalize?: boolean);
      constructor(info?: ImageRefData | undefined);
      freeze(): ImageRef;
      toData(): ImageRefData;
      toJSON(): ImageRefData;
      /**
       * The digest string for this image in its associated registry and repo
       * in the form `algorithm:hex`.
       */
      get digest(): string | undefined;
      set digest(digest: string | undefined);
      get dockerHost(): string | undefined;
      set dockerHost(dockerHost: string | undefined);
      /**
       * The hostname and optional port of the image registry for this image.
       */
      get domain(): string | undefined;
      set domain(domain: string | undefined);
      /**
       * The complete string reference for this image in familiar form, which
       * leaves out certain fields from the reference when they are set to
       * default values.
       * @remarks
       * This reference form is the form typically used in the Docker UI.
       * If the ImageRef is not complete, familiar will return `undefined`, as
       * the correct familiar representation cannot be determined.
       */
      get familiar(): string | undefined;
      /**
       * The content ID of the image in `algorithm:hex` format.
       */
      get id(): ImageIdString | undefined;
      set id(id: ImageIdString | undefined);
      /**
       * The image name, which is comprised of the optional domain and
       * the (non-optional) path.
       */
      get name(): string | undefined;
      set name(name: string | undefined);
      /**
       * The image name (including any registry) and image tag. Returns undefined
       * if either path or tag are not set.
       * If nameTag is set to a string that does not contain a tag (i.e. does
       * not include a ":"), the default tag of `latest` will be set.
       * To set nameTag without defaulting to `latest`, call the class method
       * `setNameTag` with the parameter `useDefaultTag` set to `false`.
       */
      get nameTag(): NameTagString | undefined;
      set nameTag(nt: NameTagString | undefined);
      /**
       * Method to set the image name and image tag which also allows choice
       * of default behavior when `nameTag` does not contain a tag string.
       */
      setNameTag(nameTag: NameTagString | undefined, useDefaultTag?: boolean): void;
      /**
       * The image repo path.
       */
      get path(): string | undefined;
      set path(path: string | undefined);
      /**
       * The image path (not including any registry) and image tag. Returns
       * undefined if either path or tag are not set.
       * If pathTag is set to a string that does not contain a tag (i.e. does
       * not include a ":"), the default tag of `latest` will be set.
       * To set pathTag without defaulting to `latest`, call the class method
       * `setPathTag` with the parameter `useDefaultTag` set to `false`.
       */
      get pathTag(): string | undefined;
      set pathTag(pathTag: string | undefined);
      /**
       * Method to set the image path and image tag which also allows choice
       * of default behavior when `pathTag` does not contain a tag string.
       */
      setPathTag(pathTag: string | undefined, useDefaultTag?: boolean): void;
      get ref(): string;
      /**
       * Alias for domain
       */
      get registry(): string | undefined;
      /**
       * The best remote reference available for this image in either
       * `domain/path@digest` format or `domain/path:tag` format.
       * @remarks
       * Returns `registryDigest` if it is set, otherwise returns `registryTag`.
       * If no remote reference is available, returns undefined.
       */
      get registryRef(): ImageNameString | undefined;
      /**
       * The remote digest reference in `domain/path@digest` form.
       * @remarks
       * Undefined if any of `domain`, `path`, or `digest` are unset.
       */
      get registryDigest(): RepoDigestString | undefined;
      set registryDigest(rd: RepoDigestString | undefined);
      /**
       * The remote tag reference in `domain/path:tag` form.
       * @remarks
       * Undefined if any of `domain`, `path`, or `tag` are unset.
       */
      get registryTag(): NameTagString | undefined;
      set registryTag(rt: NameTagString | undefined);
      /**
       * The image tag.
       */
      get tag(): string | undefined;
      set tag(tag: string | undefined);
      /**
       * The type of an image reference indicates how the image can be
       * accessed, either through a Docker host (daemon) or directly to a
       * container registry.
       *
       * @remarks
       * A reference is a valid `dockerhost` type ref when it contains a valid
       * dockerHost string and either:
       * - A valid image id or
       * - A valid path and either a valid tag or digest.
       *
       * A reference is a valid `registry` type ref when it contains a valid
       * domain, path, and either a tag or a digest.
       *
       * If not enough information is present to access and uniquely identify a
       * container image, the type is `incomplete`.
       */
      get type(): ImageRefType;
  }/**
   * A more specific type of {@link docker.ImageRef} that contains sufficient
   * information to uniquely identify an image on a container registry.
   * @public
   */
  export declare interface ImageRefRegistry {
      readonly digest?: string;
      readonly domain: string;
      readonly familiar: string;
      readonly id?: ImageIdString;
      readonly name: string;
      readonly nameTag?: string;
      readonly path: string;
      readonly pathTag?: string;
      readonly ref: string;
      readonly registry: string;
      readonly registryRef: string;
      readonly registryDigest?: string;
      readonly registryTag?: string;
      readonly tag?: string;
      readonly type: "registry";
  }/**
   * A more specific type of {@link docker.ImageRef} that contains sufficient
   * information to uniquely identify an image on a specific Docker host
   * (daemon).
   * @public
   */
  export declare interface ImageRefDockerHost {
      readonly digest?: string;
      readonly dockerHost: string;
      readonly domain?: string;
      readonly familiar: string;
      readonly id?: ImageIdString;
      readonly name: string;
      readonly nameTag?: string;
      readonly path: string;
      readonly pathTag?: string;
      readonly ref: string;
      readonly registry?: string;
      readonly registryRef?: string;
      readonly registryDigest?: string;
      readonly registryTag?: string;
      readonly tag?: string;
      readonly type: "dockerhost";
  }/**
   * Docker network service component, compatible with the abstract
   * {@link NetworkService} component.
   *
   * @remarks
   *
   * Implements the {@link NetworkServiceInstance} interface.
   * In a Docker deployment, there is no actual network service object to deploy.
   * So this is a "virtual" component that simply implements the required
   * instance methods for a NetworkService, but renders to null.
   *
   * This component is typically used by {@link docker.ServiceContainerSet}. The
   * {@link docker.ServiceContainerSet} component can be used to ensure the proper
   * network port configuration is applied to the `props.endpoint` container.
   *
   * @public
   */
  export declare function NetworkService(props: SFCDeclProps<NetworkServiceProps, typeof defaultProps>): null;/**
   * The base string used for Adapt Docker labels.
   * @internal
   */
  const adaptDockerKey = "org.adaptjs";/**
   * Docker label for the deployID the object was created from.
   * @internal
   */
  const adaptDockerDeployIDKey: string;/**
   * Props for {@link docker.LocalDockerImage}
   *
   * @public
   */
  export declare interface LocalDockerImageProps {
      /** Directory for use as the build context in docker build */
      contextDir?: string;
      /**
       * Contents of the dockerfile
       *
       * @remarks
       * Should not be used if dockerfileName is set
       */
      dockerfile?: string;
      /**
       * Path to a local Dockerfile in the Adapt project.
       *
       * @remarks
       * This path is relative to the root of the Adapt project.
       * Should not be used if `dockerfile` is set.
       */
      dockerfileName?: string;
      /**
       * Extra files that should be included during the docker build
       *
       * @remarks
       * LocalDockerImage uses a multi-stage build process.  It first creates
       * a temporary image that includes the files specified in this field.
       * This temporary image is then made available to the `dockerfile` with
       * stage name `files` and can then be copied into the final image, as
       * desired, using `COPY` or `ADD` commands in the `dockerfile`.
       *
       * @example
       * To create a final Docker image that contains a file that has some
       * programmatically created content, use the `dockerfile` prop along
       * with the `files` prop like this:
       * ```tsx
       * const files = [{
       *   path: '/path/to/myfile.txt',
       *   contents: 'contents for myfile\n'
       * }];
       * const dockerfile = `
       *   FROM alpine
       *   COPY --from=files /path/to/myfile.txt /app/myfile.txt
       *   ...
       * `;
       * return <LocalDockerImage files={files} dockerfile={dockerfile} />
       * ```
       */
      files?: File[];
      /**
       * Options to control the behavior of docker build
       */
      options?: DockerBuildOptions;
      /**
       * Extra stages to include in a multi-stage docker build
       */
      stages?: Stage[];
  }/**
   * @internal
   */
  export declare interface LocalDockerImageState {
      deployOpID?: DeployOpID;
      image?: WithId<ImageRefDockerHost>;
      imagePropsJson?: string;
      prevUniqueNameTag?: string;
  }/**
   * Locally builds a docker image
   *
   * @remarks
   * See {@link docker.LocalDockerImageProps}.
   *
   * @public
   */
  export declare class LocalDockerImage extends Action<LocalDockerImageProps, LocalDockerImageState> implements DockerPushableImageInstance {
      static defaultProps: {
          options: {
              dockerHost: string | undefined;
              forceRm: boolean;
          };
      };
      deployedWhenIsTrivial: boolean;
      private image_?;
      private imagePropsJson_?;
      private options_;
      constructor(props: LocalDockerImageProps);
      buildComplete(): boolean;
      ready(): boolean;
      image(): WithId<ImageRefDockerHost> | undefined;
      pushTo({ ref }: {
          ref: string;
      }): Promise<undefined | WithId<ImageRefRegistry>>;
      latestImage(): WithId<ImageRefDockerHost> | undefined;
      /**
       * User-facing name to display in status messages.
       */
      displayName(): string | undefined;
      /**
       * Implementations for Action base class
       * @internal
       */
      shouldAct(op: ChangeType): Promise<ShouldAct>;
      /**
       * Implementations for Action base class
       * @internal
       */
      action(op: ChangeType, ctx: ActionContext): Promise<void>;
      /** @internal */
      initialState(): {};
      /** @internal */
      deployedWhen: (goalStatus: GoalStatus) => true | import("@adpt/core").Waiting;
      /** @internal */
      protected get imagePropsJson(): string;
  }/**
   * Runs a Docker registry in a container.
   * @remarks
   * Implements {@link docker.DockerRegistryInstance}.
   *
   * @public
   */
  export declare function LocalDockerRegistry(props: SFCDeclProps<LocalDockerRegistryProps, typeof defaultProps>): Adapt.JSX.Element;/**
   * Props for {@link docker.LocalDockerRegistry}
   * @public
   */
  export declare interface LocalDockerRegistryProps extends ExcludeKeys<DockerContainerProps, "image"> {
      /**
       * Tag to use for official Docker Hub `registry` image repo.
       */
      imageTag: NameTagString;
      /**
       * Port number to expose for the registry HTTP server.
       */
      port: number;
  }/** @public */
  export declare interface DockerRegistryInstance {
      registry(): RegistryString | undefined;
  }/**
   * Props for {@link docker.RegistryDockerImage}
   * @public
   */
  export declare interface RegistryDockerImageProps {
      /**
       * Handle for image source
       * @remarks
       * Currently, only handle to LocalDockerImage components and compatible
       * interfaces are supported.
       * @privateRemarks
       * FIXME(manishv) support string refs to other registries and handles of
       * other registry images
       */
      imageSrc: Handle<DockerPushableImageInstance>;
      /**
       * Registry and path where the image should be pushed and pulled
       *
       * @remarks
       * If this parameter is a string, registryPrefix will be used for both push and pull
       *
       * If registryPrefix is of the form `{ external: string, internal: string }`, docker images wil be
       * pushed to `external` and image strings will refer to `internal`.
       *
       * Registry prefixes can be of the form `domain/path/elements`, for example `gcr.io/myproject`.
       * However, the registryPrefix should not include the final name, use newPathTag instead.
       *
       * Note(manishv)
       * This is a bit of a hack to allow one hostname or IP address to push images from outside
       * a particular environment (say k8s) and a different URL for that environment to pull
       * images.
       *
       * A good example of this is a k3s-dind (k3s docker-in-docker) instance of kubernetes where
       * a private registry is running on a docker network attached to the k3s-dind instance, but where we
       * want to push {@link docker.LocalDockerImage} built images to that registry.  Since
       * {@link docker.LocalDockerImage | LocalDockerImage} is outside the k3s-dind environment, it must
       * use a host accessible network to push to the registry.  However, since the k3s-dind instance sees
       * the registry from within Docker, it must use a different address to pull the images for use.
       *
       * Once network scopes are fully supported, this interface will change to whatever is appropriate.  It
       * is best if you can arrange to have the same URL or registry string work for all access regardless
       * of which network the registry, Adapt host, and ultimate container running environment is uses.
       */
      registryPrefix: RegistryString | DockerSplitRegistryInfo;
      /**
       * Path and tag to be used for the image in the new registry in
       * `path:tag` or `path` format.
       * @remarks
       * The entire path and tag are blindly concatenated to the domain and path
       * in registryPrefix to form the full ref that will be used to push the
       * image.
       *
       * If omitted, the last component of the path and the tag from the source
       * image is used. The newPathTag should not include the registry
       * hostname/port prefix. If the `:tag` portion of `path:tag` is omitted,
       * the tag `latest` will be used.
       */
      newPathTag?: string;
      /**
       * Path and tag to be used for the image in the new registry in
       * `path:tag` or `path` format.
       * @deprecated This prop has been renamed to `newPathTag`. The functionality
       * for both props is the same and if both are set, `newPathTag` takes
       * priority.
       * @remarks
       * If omitted, the path and tag from the source image is used. The
       * newTag should not include the registry hostname/port prefix. If the
       * `:tag` portion of `path:tag` is omitted, the tag `latest` will be used.
       */
      newTag?: string;
  }/**
   * Represents a Docker image in a registry.
   * @remarks
   * If the image does not exist in the specified registry, it will be pushed
   * to that registry.
   * @public
   */
  export declare class RegistryDockerImage extends Action<RegistryDockerImageProps, State> implements DockerImageInstance {
      private latestImage_?;
      private latestRegistryUrl_?;
      private registry;
      constructor(props: RegistryDockerImageProps);
      /**
       * Returns information about the version of the Docker image that reflects
       * the current set of props for the component and has been pushed to the
       * registry.
       * @remarks
       * Returns undefined if the `props.imageSrc` component's `latestImage` method
       * returns undefined (depending on the component referenced by
       * `props.imageSrc`, that may indicate the source image has not been built).
       * Also returns undefined if the current image has not yet been
       * pushed to the registry.
       */
      image(): ImageRefRegistry | undefined;
      /**
       * Returns information about the most current version of the Docker image
       * that has been pushed to the registry.
       * @remarks
       * Returns undefined if no image has ever been pushed by this component.
       */
      latestImage(): ImageRefRegistry | undefined;
      /** @internal */
      initialState(): {};
      /** @internal */
      shouldAct(diff: ChangeType): false | {
          act: boolean;
          detail: string;
      };
      /** @internal */
      dependsOn: DependsOnMethod;
      /** @internal */
      action(op: ChangeType): Promise<void>;
      private currentNameTag;
      private getNewPathTag;
      private srcImageName;
  }/**
   * Props for {@link docker.ServiceContainerSet}
   *
   * @public
   */
  export declare interface ServiceContainerSetProps extends ServiceProps {
      /**
       * Props to apply to all {@link docker.DockerContainer}s within this
       * ServiceContainerSet. If a prop is specified in the source {@link Container}
       * component and in `containerProps`, `containerProps` will take
       * precedence.
       */
      containerProps?: Partial<DockerContainerProps>;
      /**
       * If set, all children of this ServiceContainerSet that support the
       * `dockerHost` prop will get this value, overriding any other value for
       * this prop.
       */
      dockerHost?: string;
  }/**
   * A component for mapping a group of abstract {@link Container}s and
   * {@link NetworkService}s to Docker {@link docker.DockerContainer | DockerContainer}s
   * and {@link docker.NetworkService}s.
   *
   * @remarks
   * This component is intended to be used to replace {@link Container} and
   * {@link NetworkService} components that are grouped together, as the
   * only children of a common parent in a pattern that looks like this:
   * ```tsx
   * <Service>
   *   <Container ... />
   *   <Container ... />
   *   <NetworkService ... />
   * </Service>
   * ```
   * `ServiceContainerSet` maps those abstract components into Docker components
   * like this:
   * ```tsx
   * <Group>
   *   <docker.DockerContainer ... >
   *   <docker.DockerContainer ... >
   *   <docker.NetworkService ... >
   * </Group>
   * ```
   * An example style rule to do this is:
   * ```tsx
   * {Service}
   * {Adapt.rule((matchedProps) => {
   *     const { handle, ...remainingProps } = matchedProps;
   *     return <ServiceContainerSet {...remainingProps} />;
   * })}
   * ```
   *
   * Currently, {@link docker.NetworkService} implements the {@link NetworkServiceInstance}
   * interface, but does not deploy a network proxy component. So the Docker
   * ServiceContainerSet component applies the network port configuration specified by
   * the {@link NetworkService}s to their target
   * {@link docker.DockerContainer | DockerContainer}s.
   *
   * @public
   */
  export declare class ServiceContainerSet extends DeferredComponent<ServiceContainerSetProps> {
      build(helpers: BuildHelpers): Adapt.JSX.Element;
  }/**
   * Options for interacting with Docker Engine that apply to all
   * operations.
   * @public
   */
  export declare interface DockerGlobalOptions {
      dockerHost?: string;
  }/**
   * Options for performing Docker image builds.
   * @public
   */
  export declare interface DockerBuildOptions extends DockerGlobalOptions {
      /**
       * Requests BuildKit as the internal Docker build engine.
       *
       * @remarks
       * This option requests the use of the BuildKit build engine when building
       * Docker images, if BuildKit is available. This is primarily useful for
       * BuildKit's performance improvements over the legacy Docker build engine.
       * However, because this option does not guarantee BuildKit will be used,
       * BuildKit-only features such as secret mounting should not be used.
       *
       * Internally, this option sets the `DOCKER_BUILDKIT` environment
       * variable when performing builds, which enables BuildKit on Docker
       * systems that support it.
       *
       * For more information, see
       * [Build images with BuildKit](https://docs.docker.com/develop/develop-images/build_enhancements/).
       *
       * @defaultValue `true`
       */
      requestBuildKit?: boolean;
      forceRm?: boolean;
      imageName?: string;
      imageTag?: string;
      prevUniqueNameTag?: string;
      stdin?: string;
      /**
       * If true and the newly built image ID does not match the image ID for
       * prevUniqueNameTag (or prevUniqueNameTag is not set), a new unique nameTag is
       * generated for this image (from imageName and imageTag).
       * If true and the newly built image ID does match the image ID for
       * prevUniqueNameTag, then prevUniqueNameTag is returned as nameTag.
       * If false, imageName and imageTag are used without modification.
       */
      uniqueTag?: boolean;
      /**
       * If set, will add a Docker LABEL with the DeployID.
       */
      deployID?: string;
      buildArgs?: Environment;
  }/**
   * A dynamically-created file that can be used during the build of a Docker
   * image.
   *
   * @remarks
   * These `File` objects are used to create a temporary "scratch" image in a
   * {@link https://docs.docker.com/develop/develop-images/multistage-build/ | multi-stage build}
   * that contains only the specified files. Then, in later stages of that build,
   * the files within the temporary image can be copied into the later stage
   * image.
   * @public
   */
  export declare interface File {
      /**
       * The path in the temporary image where the file will be created.
       */
      path: string;
      /**
       * The contents of the file.
       */
      contents: Buffer | string;
  }/**
   * A stage to be added to a
   * {@link https://docs.docker.com/develop/develop-images/multistage-build/ | multi-stage Docker build}.
   *
   * @remarks
   * The stage will be added to the generated Dockerfile for the image as:
   * ```
   * FROM image as name
   * ```
   * @public
   */
  export declare interface Stage {
      /** The image (name + tag or digest) to use for the stage. */
      image: string;
      /** Name for the stage */
      name: string;
  }/**
   * A string that contains both a Docker repo and a registry digest.
   *
   * @remarks
   * This is a string that represents a specific image on a specific registry
   * contained in a particular repo on that registry. It's of the form:
   * ```
   * [registry/]repo@digest
   * ```
   * `registry` - (optional) The hostname or hostname:port of a Docker registry
   * where the repo is located. If not provided, the official default Docker
   * registry is assumed.
   *
   * `repo` - The more precise name for what's commonly referred to as an image
   * name. It may include 0 or more slashes to denote namespaces.
   *
   * `digest` - The repo digest for the image in the form `algorithm:hex`.
   * This digest is specific to the associated registry and repo and has no
   * significance without those additional pieces of information. If this image is
   * pushed to a different registry, it will have a different digest value.
   * The digest is also known as a "distribution hash".
   *
   * Examples:
   * ```
   * alpine@sha256:04696b491e0cc3c58a75bace8941c14c924b9f313b03ce5029ebbc040ed9dcd9
   * localhost:5000/mockdeploy-htws@sha256:899a03e9816e5283edba63d71ea528cd83576b28a7586cf617ce78af5526f209
   * ```
   * @public
   */
  export declare type RepoDigestString = string;/**
   * Docker image ID, in the form `algorithm:hex`.
   *
   * @remarks
   * The Docker image ID (also known as "Content Hash") is a single value
   * that uniquely identifies a specific image on a local Docker host.
   *
   * An image ID does not require a registry or repo qualifier to be significant.
   * It is distinct from a Docker image
   * {@link docker.RepoDigestString | repo digest}.
   *
   * Example:
   * ```
   * sha256:199e537da3a86126cd6eb114bd0b13ab178dc291bbb6ea4a4a3aa257b2366b71
   * ```
   * @public
   */
  export declare type ImageIdString = string;/**
   * A string reference to a Docker image that contains a repo name, and may
   * contain an optional registry and optional tag.
   *
   * @remarks
   * This is a string that references a Docker image. It's in the form of
   * one of:
   * ```
   * [registry/]repo
   * [registry/]repo:tag
   * ```
   * `registry` - (optional) The hostname or hostname:port of a Docker registry
   * where the repo is located. If not provided, depending on context, either
   * the official default Docker registry may be assumed or the image may just
   * be present locally and not on any registry.
   *
   * `repo` - The more precise name for what's commonly referred to as an image
   * name. It may include 0 or more slashes to denote namespaces.
   *
   * `tag` - A tag string identifying a version of image within the repo.
   *
   * Examples:
   * ```
   * alpine
   * ubuntu:16.04
   * ```
   * @public
   */
  export declare type NameTagString = string;/**
   * A string reference to a Docker image that contains a repo name, and may
   * contain an optional registry and optionally either a tag or a repo digest.
   *
   * @remarks
   * This is a string that references a Docker image. It's in the form of
   * one of:
   * ```
   * [registry/]repo
   * [registry/]repo:tag
   * [registry/]repo@digest
   * ```
   * For more detail, see {@link docker.NameTagString} and
   * {@link docker.RepoDigestString}.
   *
   * Examples:
   * ```
   * alpine
   * ubuntu:16.04
   * alpine@sha256:04696b491e0cc3c58a75bace8941c14c924b9f313b03ce5029ebbc040ed9dcd9
   * localhost:5000/mockdeploy-htws@sha256:899a03e9816e5283edba63d71ea528cd83576b28a7586cf617ce78af5526f209
   * ```
   * @public
   */
  export declare type ImageNameString = NameTagString | RepoDigestString;/**
   * A string that references a Docker registry that contains a hostname and
   * may optionally contain a port and/or path.
   *
   * @remarks
   * This string is in the form of one of:
   * ```
   * hostname[:port]
   * hostname[:port]/path
   * ```
   * This form does not include the protocol, such as `http:` or `https:` in
   * the string.
   *
   * @public
   */
  export declare type RegistryString = string;/**
   * Information about a specific instance of a Docker image, as identified by
   * its image ID.
   * @deprecated Replaced with {@link docker.ImageRef}.
   * @public
   */
  export declare interface ImageInfo {
      /**
       * Docker image ID, in the form `algorithm:hex`.
       * @remarks
       * See {@link docker.ImageIdString}.
       */
      id: ImageIdString;
      /**
       * Docker image name and optional tag in the form `name` or `name:tag`.
       * @remarks
       * See {@link docker.NameTagString}
       */
      nameTag?: NameTagString;
  }/**
   * Props for {@link docker.DockerContainer}
   *
   * @public
   */
  export declare interface DockerContainerProps extends DockerGlobalOptions, Pick<ContainerProps, "autoRemove" | "command" | "environment" | "portBindings" | "ports" | "restartPolicy" | "stopSignal"> {
      /** image name as a string, or a handle to a DockerImage component */
      image: ImageNameString | Handle<DockerImageInstance>;
      /**
       * Host and port of the remote docker host to use.
       *
       * @remarks
       * Defaults to the DOCKER_HOST environment variable
       */
      dockerHost: string;
      /**
       * Labels to apply to the container.
       */
      labels?: ContainerLabels;
      /**
       * Filesystems to be mounted in the container.
       */
      mounts?: Mount[];
      /**
       * Networks to connect the container to
       *
       * @remarks
       * Accepts the same strings as docker network connect
       */
      networks?: string[];
      /**
       * Enables the container to run in privileged mode.
       */
      privileged?: boolean;
  }/**
   * Represents a split registry, with pushes going to external and pulls going to internal
   * @beta
   */
  export declare interface DockerSplitRegistryInfo {
      external: RegistryString;
      internal: RegistryString;
  }/**
   * Describes bind mount filesystems to be mounted in a container.
   * @public
   */
  export declare interface BindMount {
      type: "bind";
      source: string;
      destination: string;
      readonly?: boolean;
      propagation?: "shared" | "slave" | "private" | "rshared" | "rslave" | "rprivate";
  }/**
   * Describes filesystems to be mounted in a container.
   * @public
   */
  export declare type Mount = BindMount;/**
   * Props for {@link docker.BuildKitImage}
   *
   * @public
   */
  export declare interface BuildKitImageProps {
      /** Directory for use as the build context */
      contextDir?: string;
      /**
       * Contents of the dockerfile
       *
       * @remarks
       * Should not be used if dockerfileName is set
       */
      dockerfile?: string;
      /**
       * Path to a local Dockerfile in the Adapt project.
       *
       * @remarks
       * This path is relative to the root of the Adapt project.
       * Should not be used if `dockerfile` is set.
       */
      dockerfileName?: string;
      /**
       * Extra files that should be included during the docker build
       *
       * @remarks
       * BuildKitImage uses a multi-stage build process.  It first creates
       * a temporary image that includes the files specified in this field.
       * This temporary image is then made available to the `dockerfile` with
       * stage name `files` and can then be copied into the final image, as
       * desired, using `COPY` or `ADD` commands in the `dockerfile`.
       *
       * @example
       * To create a final Docker image that contains a file that has some
       * programmatically created content, use the `dockerfile` prop along
       * with the `files` prop like this:
       * ```tsx
       * const files = [{
       *   path: '/path/to/myfile.txt',
       *   contents: 'contents for myfile\n'
       * }];
       * const dockerfile = `
       *   FROM alpine
       *   COPY --from=files /path/to/myfile.txt /app/myfile.txt
       *   ...
       * `;
       * return <BuildKitImage files={files} dockerfile={dockerfile} />
       * ```
       */
      files?: File[];
      /**
       * Options to control the behavior of docker build
       */
      options?: BuildKitBuildOptions;
      /**
       * Directs BuildKit where to store the built image.
       */
      output: BuildKitOutput;
      /**
       * Extra stages to include in a multi-stage docker build
       */
      stages?: Stage[];
  }/**
   * @internal
   */
  export declare interface BuildKitImageState {
      deployOpID?: DeployOpID;
      image?: WithId<ImageRefRegistry>;
      imagePropsJson?: string;
      prevUniqueNameTag?: string;
  }/**
   * Locally builds a docker image
   *
   * @remarks
   * See {@link docker.BuildKitImageProps}.
   *
   * @public
   */
  export declare class BuildKitImage extends Action<BuildKitImageProps, BuildKitImageState> implements DockerPushableImageInstance {
      static defaultProps: {
          options: {};
      };
      deployedWhenIsTrivial: boolean;
      private image_?;
      private imagePropsJson_?;
      private options_;
      constructor(props: BuildKitImageProps);
      buildComplete(): boolean;
      ready(): boolean;
      image(): WithId<ImageRefRegistry> | undefined;
      pushTo({ ref }: {
          ref: string;
      }): Promise<undefined | WithId<ImageRefRegistry>>;
      latestImage(): WithId<ImageRefRegistry> | undefined;
      /**
       * User-facing name to display in status messages.
       */
      displayName(): string;
      /**
       * Implementations for Action base class
       * @internal
       */
      shouldAct(op: ChangeType): Promise<ShouldAct>;
      /**
       * Implementations for Action base class
       * @internal
       */
      action(op: ChangeType, ctx: ActionContext): Promise<void>;
      /** @internal */
      initialState(): {};
      /** @internal */
      deployedWhen: (goalStatus: GoalStatus) => true | import("@adpt/core").Waiting;
      /** @internal */
      protected get imagePropsJson(): string;
  }/**
   * Components that provide a Docker image can implement this interface to
   * allow other components to get information about the Docker image.
   * @public
   */
  export declare interface DockerImageInstance {
      /**
       * Returns information about the version of the Docker image that reflects
       * the current set of props for the component.
       * @remarks
       * Returns undefined if no image has ever been built by
       * this component OR if the component props have changed and the image
       * that corresponds to the current props has not yet been built.
       */
      image(): ImageRef | undefined;
      /**
       * Returns information about the most current version of the Docker image
       * that has completed building, even if that version does not reflect the
       * current set of props for the component.
       * @remarks
       * Returns undefined if no image has ever been built by this component.
       */
      latestImage(): ImageRef | undefined;
      /**
       * Pushes the image returned by `latestImage` to a Docker registry.
       *
       * @param ref - A docker domain, path components, and tag to which this image should be pushed
       *
       * @remarks
       * If there is no latest image available (`latestImage` returns
       * undefined), then `pushTo` will return undefined. Otherwise, if the
       * push was successful, returns an {@link docker.ImageRefRegistry} that contains
       * the complete nameTag, including registry portion.
       */
      pushTo?({ ref }: {
          ref: NameTagString;
      }): MaybePromise<ImageRefRegistry | undefined>;
  }/**
   * Components that provide a Docker image can implement this interface to
   * allow other components to get information about the Docker image and
   * to be able to push the image to a registry.
   * @public
   */
  export declare interface DockerPushableImageInstance extends DockerImageInstance {
      /**
       * {@inheritdoc docker.DockerImageInstance.pushTo}
       */
      pushTo({ ref }: {
          ref: NameTagString;
      }): MaybePromise<ImageRefRegistry | undefined>;
  }/**
   * Props for {@link docker.DockerImage}.
   * @beta
   */
  export declare interface DockerImageProps {
  }/**
   * Abstract component representing a {@link https://docker.com | Docker}
   * image that can be used to create containers.
   * @remarks
   * See also {@link Container}.
   * @beta
   */
  export declare abstract class DockerImage extends Component<DockerImageProps> implements DockerImageInstance {
      /**
       * {@inheritdoc docker.DockerImageInstance.image}
       */
      image(): ImageRef | undefined;
      /**
       * {@inheritdoc docker.DockerImageInstance.latestImage}
       */
      latestImage(): ImageRef | undefined;
  }/**
   * Compute the status of a container based on a graphQL schema
   *
   * @internal
   */
  export declare function containerStatus(observe: ObserveForStatus, containerName: string, dockerHost: string): Promise<ContainerStatus | NoStatus>;/** @public */
  export declare interface DockerContainerStatus extends ContainerStatus {
  }/**
   * Compute a unique name for the container
   *
   * @internal
   */
  const computeContainerName: (elemKey: string, elemID: string, deployID: string) => string;/**
   * Component to instantiate an image container with docker
   *
   * @remarks
   * See {@link docker.DockerContainerProps}.
   *
   * @public
   */
  declare class DockerContainer extends Action<DockerContainerProps, DockerContainerState> {
      static defaultProps: {
          dockerHost: string;
          privileged: boolean;
      };
      info?: ContainerInfo;
      dependsOn: DependsOnMethod;
      /** @internal */
      shouldAct(diff: ChangeType, context: ActionContext): Promise<false | ShouldAct>;
      /** @internal */
      action(diff: ChangeType, context: ActionContext): Promise<void>;
      status(observe: ObserveForStatus, buildData: BuildData): Promise<NoStatus | ContainerStatus>;
      /**
       * Get the IP address of the container, optionally for a specific Docker
       * network.
       * @remarks
       * The IP addresses that are returned by this function are valid only
       * on the associated Docker network, which is often only associated
       * with a single host node for most Docker network types.
       *
       * @param network - Name of a Docker network. If `network` is provided
       * and the container is connected to the network with an IP address, that
       * address will be returned. If the container is not connected to the
       * network, `undefined` will be returned. If `network` is not provided,
       * the default container IP address will be returned.
       *
       * @beta
       */
      dockerIP(network?: string): string | undefined;
      /** @internal */
      initialState(): {};
      private displayName;
      private refreshContainerInfo;
  }/**
   * Component to instantiate an image container with docker
   *
   * @remarks
   * See {@link docker.DockerContainerProps}.
   *
   * @public
   */
  declare class DockerContainer extends Action<DockerContainerProps, DockerContainerState> {
      static defaultProps: {
          dockerHost: string;
          privileged: boolean;
      };
      info?: ContainerInfo;
      dependsOn: DependsOnMethod;
      /** @internal */
      shouldAct(diff: ChangeType, context: ActionContext): Promise<false | ShouldAct>;
      /** @internal */
      action(diff: ChangeType, context: ActionContext): Promise<void>;
      status(observe: ObserveForStatus, buildData: BuildData): Promise<NoStatus | ContainerStatus>;
      /**
       * Get the IP address of the container, optionally for a specific Docker
       * network.
       * @remarks
       * The IP addresses that are returned by this function are valid only
       * on the associated Docker network, which is often only associated
       * with a single host node for most Docker network types.
       *
       * @param network - Name of a Docker network. If `network` is provided
       * and the container is connected to the network with an IP address, that
       * address will be returned. If the container is not connected to the
       * network, `undefined` will be returned. If `network` is not provided,
       * the default container IP address will be returned.
       *
       * @beta
       */
      dockerIP(network?: string): string | undefined;
      /** @internal */
      initialState(): {};
      private displayName;
      private refreshContainerInfo;
  }/**
   * Type guard for determining whether a given object has a non-null `id`
   * property.
   * @public
   */
  export declare function hasId<T extends {
      id?: ImageIdString;
  }>(o: T): o is WithId<T>;/**
   * Factory function for creating a {@link docker.MutableImageRef}.
   * @remarks
   * Can also be used to clone an existing {@link docker.MutableImageRef} or
   * to create a mutable version of an existing {@link docker.ImageRef}.
   * @public
   */
  export declare function mutableImageRef(ref: ImageNameString, normalize?: boolean): MutableImageRef;/**
   * Factory function for creating a {@link docker.MutableImageRef}.
   * @remarks
   * Can also be used to clone an existing {@link docker.MutableImageRef} or
   * to create a mutable version of an existing {@link docker.ImageRef}.
   * @public
   */
  export declare function mutableImageRef(info?: ImageRefData): MutableImageRef;/**
   * Factory function for creating a {@link docker.ImageRef} or cloning an
   * existing one.
   * @public
   */
  export declare function imageRef(ref: ImageNameString, normalize?: boolean): ImageRef;/**
   * Factory function for creating a {@link docker.ImageRef} or cloning an
   * existing one.
   * @public
   */
  export declare function imageRef(info?: ImageRefData): ImageRef;/**
   * A type guard for determining whether a {@link docker.ImageRef} is a
   * {@link docker.ImageRefRegistry}.
   * @public
   */
  export declare function isImageRefRegistry(ref: ImageRef): ref is ImageRefRegistry;/**
   * A type guard for determining whether a {@link docker.ImageRef} is a
   * {@link docker.ImageRefRegistry} that has the `id` property set.
   * @public
   */
  export declare function isImageRefRegistryWithId(ref: ImageRef): ref is WithId<ImageRefRegistry>;/**
   * A type guard for determining whether a {@link docker.ImageRef} is a
   * {@link docker.ImageRefDockerHost}.
   * @public
   */
  export declare function isImageRefDockerhost(ref: ImageRef): ref is ImageRefDockerHost;/**
   * A type guard for determining whether a {@link docker.ImageRef} is a
   * {@link docker.ImageRefDockerHost} that has the `id` property set.
   * @public
   */
  export declare function isImageRefDockerhostWithId(ref: ImageRef): ref is WithId<ImageRefDockerHost>;/**
   * The most basic components that make up a {@link docker.ImageRef}.
   * All other properties of a {@link docker.ImageRef} can be computed from
   * these.
   * @remarks
   * See also {@link docker.ImageRef} for more information on references.
   * @public
   */
  export declare interface ImageRefData {
      /**
       * Image digest in the form `algorithm:hex`
       * @example
       * sha256:04696b491e0cc3c58a75bace8941c14c924b9f313b03ce5029ebbc040ed9dcd9
       */
      digest?: string;
      /**
       * Docker host string to contact the Docker daemon where this image is
       * located.
       *
       * @remarks
       * This should be in the same format that Docker expects for the `DOCKER_HOST`
       * environment variable. The special string `default` can also be used,
       * which will use the current value of the `DOCKER_HOST` environment variable,
       * if it is set and will otherwise use the default named pipe on Windows
       * (`npipe:///./pipe/docker_engine`) and the default socket on other
       * systems (`unix:///var/run/docker.sock`).
       * @example
       * tcp://localhost:2375
       */
      dockerHost?: "default" | string;
      /**
       * Hostname and optional port number of the container image registry where
       * this image is located.
       * @example
       * docker.io
       * @example
       * localhost:5000
       */
      domain?: RegistryString;
      /**
       * Image content ID in the form `algorithm:hex`
       * @example
       * sha256:199e537da3a86126cd6eb114bd0b13ab178dc291bbb6ea4a4a3aa257b2366b71
       */
      id?: ImageIdString;
      /**
       * The image repo path.
       * @example
       * google/cloud-sdk
       */
      path?: string;
      /**
       * Image tag
       * @example
       * latest
       */
      tag?: string;
  }/**
   * The type of an image reference indicates how the image can be
   * accessed, currently either through a Docker host (daemon) or directly to a
   * container registry via its API.
   *
   * @remarks
   * If not enough information is present to access and uniquely identify a
   * container image, the type is `incomplete`.
   * @public
   */
  export declare type ImageRefType = "incomplete" | "registry" | "dockerhost";/**
   * An immutable reference to a container image, including all information
   * known about the image.
   *
   * @remarks
   * This type is the base type for an image reference and is allowed to
   * contain partial or incomplete information about a container image.
   * It can include both information about how to access the image and
   * also information about the image itself.
   *
   * Many of the properties of {@link docker.ImageRef} are related to the
   * container image reference string used by Docker and other container-based
   * systems. A container image reference string is a structured string
   * containing multiple components. The most basic components are illustrated
   * below, using the example image reference string
   * `"my.registry:5000/a/repo/path:sometag@sha256:899a03e9816e5283edba63d"`.
   *
   * NOTE: The length of the `digest` has been shortened for formatting
   * purposes.
   *
   * ```
   * "my.registry:5000/a/repo/path:sometag@sha256:899a03e9816e5283edba63d"
   * |     domain     |   path    |  tag  |         digest               |
   * ```
   *
   * To aid in correct formatting, {@link docker.ImageRef} and related types and
   * classes also provide helper properties that combine these basic components
   * into combinations that are often useful, such as `name`, which is the
   * `domain` and `path` combined with a `/`.
   *
   * Many tools, such as the Docker UI, also accept a shortened form of a string
   * reference, called the `familiar` form. An example of a familiar reference is
   * `ubuntu`. In this form, only the `path` component is required. When
   * components of the reference are left out, default values are assumed. The
   * default `domain` is `docker.io` and the default `tag` is `latest`.
   * Additionally, if the `domain` is `docker.io` and there are no `/` characters
   * in the `path`, `library/` is prepended to the path. So `ubuntu` is the
   * familiar form for the complete reference `docker.io/library/ubuntu:latest`.
   *
   * An {@link docker.ImageRef} is designed to hold as much information about
   * an image as may be available and therefore some properties that are
   * not known will be `undefined`.
   *
   * See also {@link docker.MutableImageRef}, which can be used to parse
   * reference strings and construct or modify image references.
   * @public
   */
  export declare interface ImageRef extends Readonly<ImageRefData> {
      /**
       * The complete string reference for this image in familiar form, which
       * leaves out certain fields from the reference when they are set to
       * default values.
       * @remarks
       * This reference form is the form typically used in the Docker UI.
       * If the ImageRef is not complete, familiar will return `undefined`, as
       * the correct familiar representation cannot be determined.
       * @example
       * mysql
       * @example
       * gcr.io/my-project/image:1.0.1
       */
      readonly familiar?: string;
      /**
       * The image name, which is comprised of the optional domain and
       * the (non-optional) path. Will be `undefined` if there is no `path`.
       * @example
       * gcr.io/my-project/image
       */
      readonly name?: string;
      /**
       * The image name (including any registry) and image tag. Returns undefined
       * if either path or tag are not set.
       * If nameTag is set to a string that does not contain a tag (i.e. does
       * not include a ":"), the default tag of `latest` will be set.
       * To set nameTag without defaulting to `latest`, call the class method
       * `setNameTag` with the parameter `useDefaultTag` set to `false`.
       * @example
       * gcr.io/my-project/image:1.0.1
       */
      readonly nameTag?: string;
      /**
       * The image path (not including any registry) and image tag. Returns
       * undefined if either `path` or `tag` are not set.
       * @example
       * my-project/image:1.0.1
       */
      readonly pathTag?: string;
      /**
       * The best (most specific and complete) string reference for this image,
       * given the information available in this {@link docker.ImageRef}.
       */
      readonly ref: string;
      /**
       * An alias for `domain`.
       */
      readonly registry?: string;
      /**
       * The best remote reference available for this image in either
       * `domain/path@digest` format or `domain/path:tag` format.
       * @remarks
       * Returns `registryDigest` if it is set, otherwise returns `registryTag`.
       * If no remote reference is available, returns undefined.
       * @example
       * gcr.io/my-project/image\@sha256:899a03e9816e5283edba63d71ea528cd83576b28a7586cf617ce78af5526f209
       * @example
       * gcr.io/my-project/image:1.0.1
       */
      readonly registryRef?: string;
      /**
       * The remote digest reference in `domain/path@digest` form.
       * @remarks
       * Undefined if any of `domain`, `path`, or `digest` are unset.
       * @example
       * gcr.io/my-project/image\@sha256:899a03e9816e5283edba63d71ea528cd83576b28a7586cf617ce78af5526f209
       */
      readonly registryDigest?: string;
      /**
       * The remote tag reference in `domain/path:tag` form.
       * @remarks
       * Undefined if any of `domain`, `path`, or `tag` are unset.
       * @example
       * gcr.io/my-project/image:1.0.1
       */
      readonly registryTag?: string;
      /**
       * The type of an image reference indicates how the image can be
       * accessed, either through a Docker host (daemon) or directly to a
       * container registry.
       *
       * @remarks
       * A reference is a valid `dockerhost` type ref when it contains a valid
       * dockerHost string and either:
       * - A valid image id or
       * - A valid path and either a valid tag or digest.
       *
       * A reference is a valid `registry` type ref when it contains a valid
       * domain, path, and either a tag or a digest.
       *
       * If not enough information is present to access and uniquely identify a
       * container image, the type is `incomplete`.
       */
      readonly type: ImageRefType;
  }/**
   * Helper type that augments a base type to indicate that the `id` field
   * is present and has a valid image ID.
   * @public
   */
  export declare type WithId<T> = T & {
      id: ImageIdString;
  };/**
   * A mutable reference to a container image that can be used to parse,
   * construct, and modify an image reference, as well as to hold information
   * about the image and how to access it.
   *
   * @remarks
   * This class can be used to parse strings that contain complete or partial
   * container image references. It can also be used to construct an image
   * reference from scratch, from individual component parts, or from another
   * reference, then to correctly format the reference or its components for
   * use with various tools.
   *
   * To parse and normalize a "familiar" image reference, like is typically
   * seen in the Docker UI:
   * ```ts
   * const ref = mutableImageRef("redis", true);
   * console.log(ref.tag);         // => "latest"
   * console.log(ref.registryRef); // => "docker.io/library/redis:latest"
   * ```
   *
   * To construct a reference to an image present on the local Docker daemon
   * that has an image ID:
   * ```ts
   * const ref = mutableImageRef({
   *     dockerHost: "default",
   *     path: "myimage",
   *     tag: "just-built",
   *     id: "sha256:04696b491e0cc3c58a75bace8941c14c924b9f313b03ce5029ebbc040ed9dcd9",
   * });
   * ```
   *
   * To convert a `MutableImageRef` to an immutable plain object `ImageRef`,
   * use the `freeze` method.
   * @public
   */
  export declare class MutableImageRef implements ImageRef {
      _digest?: string;
      _dockerHost?: string;
      _domain?: string;
      _id?: ImageIdString;
      _path?: string;
      _tag?: string;
      constructor(ref: ImageNameString, normalize?: boolean);
      constructor(info?: ImageRefData | undefined);
      freeze(): ImageRef;
      toData(): ImageRefData;
      toJSON(): ImageRefData;
      /**
       * The digest string for this image in its associated registry and repo
       * in the form `algorithm:hex`.
       */
      get digest(): string | undefined;
      set digest(digest: string | undefined);
      get dockerHost(): string | undefined;
      set dockerHost(dockerHost: string | undefined);
      /**
       * The hostname and optional port of the image registry for this image.
       */
      get domain(): string | undefined;
      set domain(domain: string | undefined);
      /**
       * The complete string reference for this image in familiar form, which
       * leaves out certain fields from the reference when they are set to
       * default values.
       * @remarks
       * This reference form is the form typically used in the Docker UI.
       * If the ImageRef is not complete, familiar will return `undefined`, as
       * the correct familiar representation cannot be determined.
       */
      get familiar(): string | undefined;
      /**
       * The content ID of the image in `algorithm:hex` format.
       */
      get id(): ImageIdString | undefined;
      set id(id: ImageIdString | undefined);
      /**
       * The image name, which is comprised of the optional domain and
       * the (non-optional) path.
       */
      get name(): string | undefined;
      set name(name: string | undefined);
      /**
       * The image name (including any registry) and image tag. Returns undefined
       * if either path or tag are not set.
       * If nameTag is set to a string that does not contain a tag (i.e. does
       * not include a ":"), the default tag of `latest` will be set.
       * To set nameTag without defaulting to `latest`, call the class method
       * `setNameTag` with the parameter `useDefaultTag` set to `false`.
       */
      get nameTag(): NameTagString | undefined;
      set nameTag(nt: NameTagString | undefined);
      /**
       * Method to set the image name and image tag which also allows choice
       * of default behavior when `nameTag` does not contain a tag string.
       */
      setNameTag(nameTag: NameTagString | undefined, useDefaultTag?: boolean): void;
      /**
       * The image repo path.
       */
      get path(): string | undefined;
      set path(path: string | undefined);
      /**
       * The image path (not including any registry) and image tag. Returns
       * undefined if either path or tag are not set.
       * If pathTag is set to a string that does not contain a tag (i.e. does
       * not include a ":"), the default tag of `latest` will be set.
       * To set pathTag without defaulting to `latest`, call the class method
       * `setPathTag` with the parameter `useDefaultTag` set to `false`.
       */
      get pathTag(): string | undefined;
      set pathTag(pathTag: string | undefined);
      /**
       * Method to set the image path and image tag which also allows choice
       * of default behavior when `pathTag` does not contain a tag string.
       */
      setPathTag(pathTag: string | undefined, useDefaultTag?: boolean): void;
      get ref(): string;
      /**
       * Alias for domain
       */
      get registry(): string | undefined;
      /**
       * The best remote reference available for this image in either
       * `domain/path@digest` format or `domain/path:tag` format.
       * @remarks
       * Returns `registryDigest` if it is set, otherwise returns `registryTag`.
       * If no remote reference is available, returns undefined.
       */
      get registryRef(): ImageNameString | undefined;
      /**
       * The remote digest reference in `domain/path@digest` form.
       * @remarks
       * Undefined if any of `domain`, `path`, or `digest` are unset.
       */
      get registryDigest(): RepoDigestString | undefined;
      set registryDigest(rd: RepoDigestString | undefined);
      /**
       * The remote tag reference in `domain/path:tag` form.
       * @remarks
       * Undefined if any of `domain`, `path`, or `tag` are unset.
       */
      get registryTag(): NameTagString | undefined;
      set registryTag(rt: NameTagString | undefined);
      /**
       * The image tag.
       */
      get tag(): string | undefined;
      set tag(tag: string | undefined);
      /**
       * The type of an image reference indicates how the image can be
       * accessed, either through a Docker host (daemon) or directly to a
       * container registry.
       *
       * @remarks
       * A reference is a valid `dockerhost` type ref when it contains a valid
       * dockerHost string and either:
       * - A valid image id or
       * - A valid path and either a valid tag or digest.
       *
       * A reference is a valid `registry` type ref when it contains a valid
       * domain, path, and either a tag or a digest.
       *
       * If not enough information is present to access and uniquely identify a
       * container image, the type is `incomplete`.
       */
      get type(): ImageRefType;
  }/**
   * A more specific type of {@link docker.ImageRef} that contains sufficient
   * information to uniquely identify an image on a container registry.
   * @public
   */
  export declare interface ImageRefRegistry {
      readonly digest?: string;
      readonly domain: string;
      readonly familiar: string;
      readonly id?: ImageIdString;
      readonly name: string;
      readonly nameTag?: string;
      readonly path: string;
      readonly pathTag?: string;
      readonly ref: string;
      readonly registry: string;
      readonly registryRef: string;
      readonly registryDigest?: string;
      readonly registryTag?: string;
      readonly tag?: string;
      readonly type: "registry";
  }/**
   * A more specific type of {@link docker.ImageRef} that contains sufficient
   * information to uniquely identify an image on a specific Docker host
   * (daemon).
   * @public
   */
  export declare interface ImageRefDockerHost {
      readonly digest?: string;
      readonly dockerHost: string;
      readonly domain?: string;
      readonly familiar: string;
      readonly id?: ImageIdString;
      readonly name: string;
      readonly nameTag?: string;
      readonly path: string;
      readonly pathTag?: string;
      readonly ref: string;
      readonly registry?: string;
      readonly registryRef?: string;
      readonly registryDigest?: string;
      readonly registryTag?: string;
      readonly tag?: string;
      readonly type: "dockerhost";
  }/**
   * Docker network service component, compatible with the abstract
   * {@link NetworkService} component.
   *
   * @remarks
   *
   * Implements the {@link NetworkServiceInstance} interface.
   * In a Docker deployment, there is no actual network service object to deploy.
   * So this is a "virtual" component that simply implements the required
   * instance methods for a NetworkService, but renders to null.
   *
   * This component is typically used by {@link docker.ServiceContainerSet}. The
   * {@link docker.ServiceContainerSet} component can be used to ensure the proper
   * network port configuration is applied to the `props.endpoint` container.
   *
   * @public
   */
  export declare function NetworkService(props: SFCDeclProps<NetworkServiceProps, typeof defaultProps>): null;/**
   * The base string used for Adapt Docker labels.
   * @internal
   */
  const adaptDockerKey = "org.adaptjs";/**
   * Docker label for the deployID the object was created from.
   * @internal
   */
  const adaptDockerDeployIDKey: string;/**
   * Props for {@link docker.LocalDockerImage}
   *
   * @public
   */
  export declare interface LocalDockerImageProps {
      /** Directory for use as the build context in docker build */
      contextDir?: string;
      /**
       * Contents of the dockerfile
       *
       * @remarks
       * Should not be used if dockerfileName is set
       */
      dockerfile?: string;
      /**
       * Path to a local Dockerfile in the Adapt project.
       *
       * @remarks
       * This path is relative to the root of the Adapt project.
       * Should not be used if `dockerfile` is set.
       */
      dockerfileName?: string;
      /**
       * Extra files that should be included during the docker build
       *
       * @remarks
       * LocalDockerImage uses a multi-stage build process.  It first creates
       * a temporary image that includes the files specified in this field.
       * This temporary image is then made available to the `dockerfile` with
       * stage name `files` and can then be copied into the final image, as
       * desired, using `COPY` or `ADD` commands in the `dockerfile`.
       *
       * @example
       * To create a final Docker image that contains a file that has some
       * programmatically created content, use the `dockerfile` prop along
       * with the `files` prop like this:
       * ```tsx
       * const files = [{
       *   path: '/path/to/myfile.txt',
       *   contents: 'contents for myfile\n'
       * }];
       * const dockerfile = `
       *   FROM alpine
       *   COPY --from=files /path/to/myfile.txt /app/myfile.txt
       *   ...
       * `;
       * return <LocalDockerImage files={files} dockerfile={dockerfile} />
       * ```
       */
      files?: File[];
      /**
       * Options to control the behavior of docker build
       */
      options?: DockerBuildOptions;
      /**
       * Extra stages to include in a multi-stage docker build
       */
      stages?: Stage[];
  }/**
   * @internal
   */
  export declare interface LocalDockerImageState {
      deployOpID?: DeployOpID;
      image?: WithId<ImageRefDockerHost>;
      imagePropsJson?: string;
      prevUniqueNameTag?: string;
  }/**
   * Locally builds a docker image
   *
   * @remarks
   * See {@link docker.LocalDockerImageProps}.
   *
   * @public
   */
  export declare class LocalDockerImage extends Action<LocalDockerImageProps, LocalDockerImageState> implements DockerPushableImageInstance {
      static defaultProps: {
          options: {
              dockerHost: string | undefined;
              forceRm: boolean;
          };
      };
      deployedWhenIsTrivial: boolean;
      private image_?;
      private imagePropsJson_?;
      private options_;
      constructor(props: LocalDockerImageProps);
      buildComplete(): boolean;
      ready(): boolean;
      image(): WithId<ImageRefDockerHost> | undefined;
      pushTo({ ref }: {
          ref: string;
      }): Promise<undefined | WithId<ImageRefRegistry>>;
      latestImage(): WithId<ImageRefDockerHost> | undefined;
      /**
       * User-facing name to display in status messages.
       */
      displayName(): string | undefined;
      /**
       * Implementations for Action base class
       * @internal
       */
      shouldAct(op: ChangeType): Promise<ShouldAct>;
      /**
       * Implementations for Action base class
       * @internal
       */
      action(op: ChangeType, ctx: ActionContext): Promise<void>;
      /** @internal */
      initialState(): {};
      /** @internal */
      deployedWhen: (goalStatus: GoalStatus) => true | import("@adpt/core").Waiting;
      /** @internal */
      protected get imagePropsJson(): string;
  }/**
   * Runs a Docker registry in a container.
   * @remarks
   * Implements {@link docker.DockerRegistryInstance}.
   *
   * @public
   */
  export declare function LocalDockerRegistry(props: SFCDeclProps<LocalDockerRegistryProps, typeof defaultProps>): Adapt.JSX.Element;/**
   * Props for {@link docker.LocalDockerRegistry}
   * @public
   */
  export declare interface LocalDockerRegistryProps extends ExcludeKeys<DockerContainerProps, "image"> {
      /**
       * Tag to use for official Docker Hub `registry` image repo.
       */
      imageTag: NameTagString;
      /**
       * Port number to expose for the registry HTTP server.
       */
      port: number;
  }/** @public */
  export declare interface DockerRegistryInstance {
      registry(): RegistryString | undefined;
  }/**
   * Props for {@link docker.RegistryDockerImage}
   * @public
   */
  export declare interface RegistryDockerImageProps {
      /**
       * Handle for image source
       * @remarks
       * Currently, only handle to LocalDockerImage components and compatible
       * interfaces are supported.
       * @privateRemarks
       * FIXME(manishv) support string refs to other registries and handles of
       * other registry images
       */
      imageSrc: Handle<DockerPushableImageInstance>;
      /**
       * Registry and path where the image should be pushed and pulled
       *
       * @remarks
       * If this parameter is a string, registryPrefix will be used for both push and pull
       *
       * If registryPrefix is of the form `{ external: string, internal: string }`, docker images wil be
       * pushed to `external` and image strings will refer to `internal`.
       *
       * Registry prefixes can be of the form `domain/path/elements`, for example `gcr.io/myproject`.
       * However, the registryPrefix should not include the final name, use newPathTag instead.
       *
       * Note(manishv)
       * This is a bit of a hack to allow one hostname or IP address to push images from outside
       * a particular environment (say k8s) and a different URL for that environment to pull
       * images.
       *
       * A good example of this is a k3s-dind (k3s docker-in-docker) instance of kubernetes where
       * a private registry is running on a docker network attached to the k3s-dind instance, but where we
       * want to push {@link docker.LocalDockerImage} built images to that registry.  Since
       * {@link docker.LocalDockerImage | LocalDockerImage} is outside the k3s-dind environment, it must
       * use a host accessible network to push to the registry.  However, since the k3s-dind instance sees
       * the registry from within Docker, it must use a different address to pull the images for use.
       *
       * Once network scopes are fully supported, this interface will change to whatever is appropriate.  It
       * is best if you can arrange to have the same URL or registry string work for all access regardless
       * of which network the registry, Adapt host, and ultimate container running environment is uses.
       */
      registryPrefix: RegistryString | DockerSplitRegistryInfo;
      /**
       * Path and tag to be used for the image in the new registry in
       * `path:tag` or `path` format.
       * @remarks
       * The entire path and tag are blindly concatenated to the domain and path
       * in registryPrefix to form the full ref that will be used to push the
       * image.
       *
       * If omitted, the last component of the path and the tag from the source
       * image is used. The newPathTag should not include the registry
       * hostname/port prefix. If the `:tag` portion of `path:tag` is omitted,
       * the tag `latest` will be used.
       */
      newPathTag?: string;
      /**
       * Path and tag to be used for the image in the new registry in
       * `path:tag` or `path` format.
       * @deprecated This prop has been renamed to `newPathTag`. The functionality
       * for both props is the same and if both are set, `newPathTag` takes
       * priority.
       * @remarks
       * If omitted, the path and tag from the source image is used. The
       * newTag should not include the registry hostname/port prefix. If the
       * `:tag` portion of `path:tag` is omitted, the tag `latest` will be used.
       */
      newTag?: string;
  }/**
   * Represents a Docker image in a registry.
   * @remarks
   * If the image does not exist in the specified registry, it will be pushed
   * to that registry.
   * @public
   */
  export declare class RegistryDockerImage extends Action<RegistryDockerImageProps, State> implements DockerImageInstance {
      private latestImage_?;
      private latestRegistryUrl_?;
      private registry;
      constructor(props: RegistryDockerImageProps);
      /**
       * Returns information about the version of the Docker image that reflects
       * the current set of props for the component and has been pushed to the
       * registry.
       * @remarks
       * Returns undefined if the `props.imageSrc` component's `latestImage` method
       * returns undefined (depending on the component referenced by
       * `props.imageSrc`, that may indicate the source image has not been built).
       * Also returns undefined if the current image has not yet been
       * pushed to the registry.
       */
      image(): ImageRefRegistry | undefined;
      /**
       * Returns information about the most current version of the Docker image
       * that has been pushed to the registry.
       * @remarks
       * Returns undefined if no image has ever been pushed by this component.
       */
      latestImage(): ImageRefRegistry | undefined;
      /** @internal */
      initialState(): {};
      /** @internal */
      shouldAct(diff: ChangeType): false | {
          act: boolean;
          detail: string;
      };
      /** @internal */
      dependsOn: DependsOnMethod;
      /** @internal */
      action(op: ChangeType): Promise<void>;
      private currentNameTag;
      private getNewPathTag;
      private srcImageName;
  }/**
   * Props for {@link docker.ServiceContainerSet}
   *
   * @public
   */
  export declare interface ServiceContainerSetProps extends ServiceProps {
      /**
       * Props to apply to all {@link docker.DockerContainer}s within this
       * ServiceContainerSet. If a prop is specified in the source {@link Container}
       * component and in `containerProps`, `containerProps` will take
       * precedence.
       */
      containerProps?: Partial<DockerContainerProps>;
      /**
       * If set, all children of this ServiceContainerSet that support the
       * `dockerHost` prop will get this value, overriding any other value for
       * this prop.
       */
      dockerHost?: string;
  }/**
   * A component for mapping a group of abstract {@link Container}s and
   * {@link NetworkService}s to Docker {@link docker.DockerContainer | DockerContainer}s
   * and {@link docker.NetworkService}s.
   *
   * @remarks
   * This component is intended to be used to replace {@link Container} and
   * {@link NetworkService} components that are grouped together, as the
   * only children of a common parent in a pattern that looks like this:
   * ```tsx
   * <Service>
   *   <Container ... />
   *   <Container ... />
   *   <NetworkService ... />
   * </Service>
   * ```
   * `ServiceContainerSet` maps those abstract components into Docker components
   * like this:
   * ```tsx
   * <Group>
   *   <docker.DockerContainer ... >
   *   <docker.DockerContainer ... >
   *   <docker.NetworkService ... >
   * </Group>
   * ```
   * An example style rule to do this is:
   * ```tsx
   * {Service}
   * {Adapt.rule((matchedProps) => {
   *     const { handle, ...remainingProps } = matchedProps;
   *     return <ServiceContainerSet {...remainingProps} />;
   * })}
   * ```
   *
   * Currently, {@link docker.NetworkService} implements the {@link NetworkServiceInstance}
   * interface, but does not deploy a network proxy component. So the Docker
   * ServiceContainerSet component applies the network port configuration specified by
   * the {@link NetworkService}s to their target
   * {@link docker.DockerContainer | DockerContainer}s.
   *
   * @public
   */
  export declare class ServiceContainerSet extends DeferredComponent<ServiceContainerSetProps> {
      build(helpers: BuildHelpers): Adapt.JSX.Element;
  }/**
   * Options for interacting with Docker Engine that apply to all
   * operations.
   * @public
   */
  export declare interface DockerGlobalOptions {
      dockerHost?: string;
  }/**
   * Options for performing Docker image builds.
   * @public
   */
  export declare interface DockerBuildOptions extends DockerGlobalOptions {
      /**
       * Requests BuildKit as the internal Docker build engine.
       *
       * @remarks
       * This option requests the use of the BuildKit build engine when building
       * Docker images, if BuildKit is available. This is primarily useful for
       * BuildKit's performance improvements over the legacy Docker build engine.
       * However, because this option does not guarantee BuildKit will be used,
       * BuildKit-only features such as secret mounting should not be used.
       *
       * Internally, this option sets the `DOCKER_BUILDKIT` environment
       * variable when performing builds, which enables BuildKit on Docker
       * systems that support it.
       *
       * For more information, see
       * [Build images with BuildKit](https://docs.docker.com/develop/develop-images/build_enhancements/).
       *
       * @defaultValue `true`
       */
      requestBuildKit?: boolean;
      forceRm?: boolean;
      imageName?: string;
      imageTag?: string;
      prevUniqueNameTag?: string;
      stdin?: string;
      /**
       * If true and the newly built image ID does not match the image ID for
       * prevUniqueNameTag (or prevUniqueNameTag is not set), a new unique nameTag is
       * generated for this image (from imageName and imageTag).
       * If true and the newly built image ID does match the image ID for
       * prevUniqueNameTag, then prevUniqueNameTag is returned as nameTag.
       * If false, imageName and imageTag are used without modification.
       */
      uniqueTag?: boolean;
      /**
       * If set, will add a Docker LABEL with the DeployID.
       */
      deployID?: string;
      buildArgs?: Environment;
  }/**
   * A dynamically-created file that can be used during the build of a Docker
   * image.
   *
   * @remarks
   * These `File` objects are used to create a temporary "scratch" image in a
   * {@link https://docs.docker.com/develop/develop-images/multistage-build/ | multi-stage build}
   * that contains only the specified files. Then, in later stages of that build,
   * the files within the temporary image can be copied into the later stage
   * image.
   * @public
   */
  export declare interface File {
      /**
       * The path in the temporary image where the file will be created.
       */
      path: string;
      /**
       * The contents of the file.
       */
      contents: Buffer | string;
  }/**
   * A stage to be added to a
   * {@link https://docs.docker.com/develop/develop-images/multistage-build/ | multi-stage Docker build}.
   *
   * @remarks
   * The stage will be added to the generated Dockerfile for the image as:
   * ```
   * FROM image as name
   * ```
   * @public
   */
  export declare interface Stage {
      /** The image (name + tag or digest) to use for the stage. */
      image: string;
      /** Name for the stage */
      name: string;
  }/**
   * A string that contains both a Docker repo and a registry digest.
   *
   * @remarks
   * This is a string that represents a specific image on a specific registry
   * contained in a particular repo on that registry. It's of the form:
   * ```
   * [registry/]repo@digest
   * ```
   * `registry` - (optional) The hostname or hostname:port of a Docker registry
   * where the repo is located. If not provided, the official default Docker
   * registry is assumed.
   *
   * `repo` - The more precise name for what's commonly referred to as an image
   * name. It may include 0 or more slashes to denote namespaces.
   *
   * `digest` - The repo digest for the image in the form `algorithm:hex`.
   * This digest is specific to the associated registry and repo and has no
   * significance without those additional pieces of information. If this image is
   * pushed to a different registry, it will have a different digest value.
   * The digest is also known as a "distribution hash".
   *
   * Examples:
   * ```
   * alpine@sha256:04696b491e0cc3c58a75bace8941c14c924b9f313b03ce5029ebbc040ed9dcd9
   * localhost:5000/mockdeploy-htws@sha256:899a03e9816e5283edba63d71ea528cd83576b28a7586cf617ce78af5526f209
   * ```
   * @public
   */
  export declare type RepoDigestString = string;/**
   * Docker image ID, in the form `algorithm:hex`.
   *
   * @remarks
   * The Docker image ID (also known as "Content Hash") is a single value
   * that uniquely identifies a specific image on a local Docker host.
   *
   * An image ID does not require a registry or repo qualifier to be significant.
   * It is distinct from a Docker image
   * {@link docker.RepoDigestString | repo digest}.
   *
   * Example:
   * ```
   * sha256:199e537da3a86126cd6eb114bd0b13ab178dc291bbb6ea4a4a3aa257b2366b71
   * ```
   * @public
   */
  export declare type ImageIdString = string;/**
   * A string reference to a Docker image that contains a repo name, and may
   * contain an optional registry and optional tag.
   *
   * @remarks
   * This is a string that references a Docker image. It's in the form of
   * one of:
   * ```
   * [registry/]repo
   * [registry/]repo:tag
   * ```
   * `registry` - (optional) The hostname or hostname:port of a Docker registry
   * where the repo is located. If not provided, depending on context, either
   * the official default Docker registry may be assumed or the image may just
   * be present locally and not on any registry.
   *
   * `repo` - The more precise name for what's commonly referred to as an image
   * name. It may include 0 or more slashes to denote namespaces.
   *
   * `tag` - A tag string identifying a version of image within the repo.
   *
   * Examples:
   * ```
   * alpine
   * ubuntu:16.04
   * ```
   * @public
   */
  export declare type NameTagString = string;/**
   * A string reference to a Docker image that contains a repo name, and may
   * contain an optional registry and optionally either a tag or a repo digest.
   *
   * @remarks
   * This is a string that references a Docker image. It's in the form of
   * one of:
   * ```
   * [registry/]repo
   * [registry/]repo:tag
   * [registry/]repo@digest
   * ```
   * For more detail, see {@link docker.NameTagString} and
   * {@link docker.RepoDigestString}.
   *
   * Examples:
   * ```
   * alpine
   * ubuntu:16.04
   * alpine@sha256:04696b491e0cc3c58a75bace8941c14c924b9f313b03ce5029ebbc040ed9dcd9
   * localhost:5000/mockdeploy-htws@sha256:899a03e9816e5283edba63d71ea528cd83576b28a7586cf617ce78af5526f209
   * ```
   * @public
   */
  export declare type ImageNameString = NameTagString | RepoDigestString;/**
   * A string that references a Docker registry that contains a hostname and
   * may optionally contain a port and/or path.
   *
   * @remarks
   * This string is in the form of one of:
   * ```
   * hostname[:port]
   * hostname[:port]/path
   * ```
   * This form does not include the protocol, such as `http:` or `https:` in
   * the string.
   *
   * @public
   */
  export declare type RegistryString = string;/**
   * Information about a specific instance of a Docker image, as identified by
   * its image ID.
   * @deprecated Replaced with {@link docker.ImageRef}.
   * @public
   */
  export declare interface ImageInfo {
      /**
       * Docker image ID, in the form `algorithm:hex`.
       * @remarks
       * See {@link docker.ImageIdString}.
       */
      id: ImageIdString;
      /**
       * Docker image name and optional tag in the form `name` or `name:tag`.
       * @remarks
       * See {@link docker.NameTagString}
       */
      nameTag?: NameTagString;
  }/**
   * Props for {@link docker.DockerContainer}
   *
   * @public
   */
  export declare interface DockerContainerProps extends DockerGlobalOptions, Pick<ContainerProps, "autoRemove" | "command" | "environment" | "portBindings" | "ports" | "restartPolicy" | "stopSignal"> {
      /** image name as a string, or a handle to a DockerImage component */
      image: ImageNameString | Handle<DockerImageInstance>;
      /**
       * Host and port of the remote docker host to use.
       *
       * @remarks
       * Defaults to the DOCKER_HOST environment variable
       */
      dockerHost: string;
      /**
       * Labels to apply to the container.
       */
      labels?: ContainerLabels;
      /**
       * Filesystems to be mounted in the container.
       */
      mounts?: Mount[];
      /**
       * Networks to connect the container to
       *
       * @remarks
       * Accepts the same strings as docker network connect
       */
      networks?: string[];
      /**
       * Enables the container to run in privileged mode.
       */
      privileged?: boolean;
  }/**
   * Represents a split registry, with pushes going to external and pulls going to internal
   * @beta
   */
  export declare interface DockerSplitRegistryInfo {
      external: RegistryString;
      internal: RegistryString;
  }/**
   * Describes bind mount filesystems to be mounted in a container.
   * @public
   */
  export declare interface BindMount {
      type: "bind";
      source: string;
      destination: string;
      readonly?: boolean;
      propagation?: "shared" | "slave" | "private" | "rshared" | "rslave" | "rprivate";
  }/**
   * Describes filesystems to be mounted in a container.
   * @public
   */
  export declare type Mount = BindMount;/**
   * Props for {@link docker.BuildKitImage}
   *
   * @public
   */
  export declare interface BuildKitImageProps {
      /** Directory for use as the build context */
      contextDir?: string;
      /**
       * Contents of the dockerfile
       *
       * @remarks
       * Should not be used if dockerfileName is set
       */
      dockerfile?: string;
      /**
       * Path to a local Dockerfile in the Adapt project.
       *
       * @remarks
       * This path is relative to the root of the Adapt project.
       * Should not be used if `dockerfile` is set.
       */
      dockerfileName?: string;
      /**
       * Extra files that should be included during the docker build
       *
       * @remarks
       * BuildKitImage uses a multi-stage build process.  It first creates
       * a temporary image that includes the files specified in this field.
       * This temporary image is then made available to the `dockerfile` with
       * stage name `files` and can then be copied into the final image, as
       * desired, using `COPY` or `ADD` commands in the `dockerfile`.
       *
       * @example
       * To create a final Docker image that contains a file that has some
       * programmatically created content, use the `dockerfile` prop along
       * with the `files` prop like this:
       * ```tsx
       * const files = [{
       *   path: '/path/to/myfile.txt',
       *   contents: 'contents for myfile\n'
       * }];
       * const dockerfile = `
       *   FROM alpine
       *   COPY --from=files /path/to/myfile.txt /app/myfile.txt
       *   ...
       * `;
       * return <BuildKitImage files={files} dockerfile={dockerfile} />
       * ```
       */
      files?: File[];
      /**
       * Options to control the behavior of docker build
       */
      options?: BuildKitBuildOptions;
      /**
       * Directs BuildKit where to store the built image.
       */
      output: BuildKitOutput;
      /**
       * Extra stages to include in a multi-stage docker build
       */
      stages?: Stage[];
  }/**
   * @internal
   */
  export declare interface BuildKitImageState {
      deployOpID?: DeployOpID;
      image?: WithId<ImageRefRegistry>;
      imagePropsJson?: string;
      prevUniqueNameTag?: string;
  }/**
   * Locally builds a docker image
   *
   * @remarks
   * See {@link docker.BuildKitImageProps}.
   *
   * @public
   */
  export declare class BuildKitImage extends Action<BuildKitImageProps, BuildKitImageState> implements DockerPushableImageInstance {
      static defaultProps: {
          options: {};
      };
      deployedWhenIsTrivial: boolean;
      private image_?;
      private imagePropsJson_?;
      private options_;
      constructor(props: BuildKitImageProps);
      buildComplete(): boolean;
      ready(): boolean;
      image(): WithId<ImageRefRegistry> | undefined;
      pushTo({ ref }: {
          ref: string;
      }): Promise<undefined | WithId<ImageRefRegistry>>;
      latestImage(): WithId<ImageRefRegistry> | undefined;
      /**
       * User-facing name to display in status messages.
       */
      displayName(): string;
      /**
       * Implementations for Action base class
       * @internal
       */
      shouldAct(op: ChangeType): Promise<ShouldAct>;
      /**
       * Implementations for Action base class
       * @internal
       */
      action(op: ChangeType, ctx: ActionContext): Promise<void>;
      /** @internal */
      initialState(): {};
      /** @internal */
      deployedWhen: (goalStatus: GoalStatus) => true | import("@adpt/core").Waiting;
      /** @internal */
      protected get imagePropsJson(): string;
  }/**
   * Components that provide a Docker image can implement this interface to
   * allow other components to get information about the Docker image.
   * @public
   */
  export declare interface DockerImageInstance {
      /**
       * Returns information about the version of the Docker image that reflects
       * the current set of props for the component.
       * @remarks
       * Returns undefined if no image has ever been built by
       * this component OR if the component props have changed and the image
       * that corresponds to the current props has not yet been built.
       */
      image(): ImageRef | undefined;
      /**
       * Returns information about the most current version of the Docker image
       * that has completed building, even if that version does not reflect the
       * current set of props for the component.
       * @remarks
       * Returns undefined if no image has ever been built by this component.
       */
      latestImage(): ImageRef | undefined;
      /**
       * Pushes the image returned by `latestImage` to a Docker registry.
       *
       * @param ref - A docker domain, path components, and tag to which this image should be pushed
       *
       * @remarks
       * If there is no latest image available (`latestImage` returns
       * undefined), then `pushTo` will return undefined. Otherwise, if the
       * push was successful, returns an {@link docker.ImageRefRegistry} that contains
       * the complete nameTag, including registry portion.
       */
      pushTo?({ ref }: {
          ref: NameTagString;
      }): MaybePromise<ImageRefRegistry | undefined>;
  }/**
   * Components that provide a Docker image can implement this interface to
   * allow other components to get information about the Docker image and
   * to be able to push the image to a registry.
   * @public
   */
  export declare interface DockerPushableImageInstance extends DockerImageInstance {
      /**
       * {@inheritdoc docker.DockerImageInstance.pushTo}
       */
      pushTo({ ref }: {
          ref: NameTagString;
      }): MaybePromise<ImageRefRegistry | undefined>;
  }/**
   * Props for {@link docker.DockerImage}.
   * @beta
   */
  export declare interface DockerImageProps {
  }/**
   * Abstract component representing a {@link https://docker.com | Docker}
   * image that can be used to create containers.
   * @remarks
   * See also {@link Container}.
   * @beta
   */
  export declare abstract class DockerImage extends Component<DockerImageProps> implements DockerImageInstance {
      /**
       * {@inheritdoc docker.DockerImageInstance.image}
       */
      image(): ImageRef | undefined;
      /**
       * {@inheritdoc docker.DockerImageInstance.latestImage}
       */
      latestImage(): ImageRef | undefined;
  }/**
   * Compute the status of a container based on a graphQL schema
   *
   * @internal
   */
  export declare function containerStatus(observe: ObserveForStatus, containerName: string, dockerHost: string): Promise<ContainerStatus | NoStatus>;/** @public */
  export declare interface DockerContainerStatus extends ContainerStatus {
  }/**
   * Compute a unique name for the container
   *
   * @internal
   */
  const computeContainerName: (elemKey: string, elemID: string, deployID: string) => string;/**
   * Component to instantiate an image container with docker
   *
   * @remarks
   * See {@link docker.DockerContainerProps}.
   *
   * @public
   */
  declare class DockerContainer extends Action<DockerContainerProps, DockerContainerState> {
      static defaultProps: {
          dockerHost: string;
          privileged: boolean;
      };
      info?: ContainerInfo;
      dependsOn: DependsOnMethod;
      /** @internal */
      shouldAct(diff: ChangeType, context: ActionContext): Promise<false | ShouldAct>;
      /** @internal */
      action(diff: ChangeType, context: ActionContext): Promise<void>;
      status(observe: ObserveForStatus, buildData: BuildData): Promise<NoStatus | ContainerStatus>;
      /**
       * Get the IP address of the container, optionally for a specific Docker
       * network.
       * @remarks
       * The IP addresses that are returned by this function are valid only
       * on the associated Docker network, which is often only associated
       * with a single host node for most Docker network types.
       *
       * @param network - Name of a Docker network. If `network` is provided
       * and the container is connected to the network with an IP address, that
       * address will be returned. If the container is not connected to the
       * network, `undefined` will be returned. If `network` is not provided,
       * the default container IP address will be returned.
       *
       * @beta
       */
      dockerIP(network?: string): string | undefined;
      /** @internal */
      initialState(): {};
      private displayName;
      private refreshContainerInfo;
  }/**
   * Component to instantiate an image container with docker
   *
   * @remarks
   * See {@link docker.DockerContainerProps}.
   *
   * @public
   */
  declare class DockerContainer extends Action<DockerContainerProps, DockerContainerState> {
      static defaultProps: {
          dockerHost: string;
          privileged: boolean;
      };
      info?: ContainerInfo;
      dependsOn: DependsOnMethod;
      /** @internal */
      shouldAct(diff: ChangeType, context: ActionContext): Promise<false | ShouldAct>;
      /** @internal */
      action(diff: ChangeType, context: ActionContext): Promise<void>;
      status(observe: ObserveForStatus, buildData: BuildData): Promise<NoStatus | ContainerStatus>;
      /**
       * Get the IP address of the container, optionally for a specific Docker
       * network.
       * @remarks
       * The IP addresses that are returned by this function are valid only
       * on the associated Docker network, which is often only associated
       * with a single host node for most Docker network types.
       *
       * @param network - Name of a Docker network. If `network` is provided
       * and the container is connected to the network with an IP address, that
       * address will be returned. If the container is not connected to the
       * network, `undefined` will be returned. If `network` is not provided,
       * the default container IP address will be returned.
       *
       * @beta
       */
      dockerIP(network?: string): string | undefined;
      /** @internal */
      initialState(): {};
      private displayName;
      private refreshContainerInfo;
  }/**
   * Type guard for determining whether a given object has a non-null `id`
   * property.
   * @public
   */
  export declare function hasId<T extends {
      id?: ImageIdString;
  }>(o: T): o is WithId<T>;/**
   * Factory function for creating a {@link docker.MutableImageRef}.
   * @remarks
   * Can also be used to clone an existing {@link docker.MutableImageRef} or
   * to create a mutable version of an existing {@link docker.ImageRef}.
   * @public
   */
  export declare function mutableImageRef(ref: ImageNameString, normalize?: boolean): MutableImageRef;/**
   * Factory function for creating a {@link docker.MutableImageRef}.
   * @remarks
   * Can also be used to clone an existing {@link docker.MutableImageRef} or
   * to create a mutable version of an existing {@link docker.ImageRef}.
   * @public
   */
  export declare function mutableImageRef(info?: ImageRefData): MutableImageRef;/**
   * Factory function for creating a {@link docker.ImageRef} or cloning an
   * existing one.
   * @public
   */
  export declare function imageRef(ref: ImageNameString, normalize?: boolean): ImageRef;/**
   * Factory function for creating a {@link docker.ImageRef} or cloning an
   * existing one.
   * @public
   */
  export declare function imageRef(info?: ImageRefData): ImageRef;/**
   * A type guard for determining whether a {@link docker.ImageRef} is a
   * {@link docker.ImageRefRegistry}.
   * @public
   */
  export declare function isImageRefRegistry(ref: ImageRef): ref is ImageRefRegistry;/**
   * A type guard for determining whether a {@link docker.ImageRef} is a
   * {@link docker.ImageRefRegistry} that has the `id` property set.
   * @public
   */
  export declare function isImageRefRegistryWithId(ref: ImageRef): ref is WithId<ImageRefRegistry>;/**
   * A type guard for determining whether a {@link docker.ImageRef} is a
   * {@link docker.ImageRefDockerHost}.
   * @public
   */
  export declare function isImageRefDockerhost(ref: ImageRef): ref is ImageRefDockerHost;/**
   * A type guard for determining whether a {@link docker.ImageRef} is a
   * {@link docker.ImageRefDockerHost} that has the `id` property set.
   * @public
   */
  export declare function isImageRefDockerhostWithId(ref: ImageRef): ref is WithId<ImageRefDockerHost>;/**
   * The most basic components that make up a {@link docker.ImageRef}.
   * All other properties of a {@link docker.ImageRef} can be computed from
   * these.
   * @remarks
   * See also {@link docker.ImageRef} for more information on references.
   * @public
   */
  export declare interface ImageRefData {
      /**
       * Image digest in the form `algorithm:hex`
       * @example
       * sha256:04696b491e0cc3c58a75bace8941c14c924b9f313b03ce5029ebbc040ed9dcd9
       */
      digest?: string;
      /**
       * Docker host string to contact the Docker daemon where this image is
       * located.
       *
       * @remarks
       * This should be in the same format that Docker expects for the `DOCKER_HOST`
       * environment variable. The special string `default` can also be used,
       * which will use the current value of the `DOCKER_HOST` environment variable,
       * if it is set and will otherwise use the default named pipe on Windows
       * (`npipe:///./pipe/docker_engine`) and the default socket on other
       * systems (`unix:///var/run/docker.sock`).
       * @example
       * tcp://localhost:2375
       */
      dockerHost?: "default" | string;
      /**
       * Hostname and optional port number of the container image registry where
       * this image is located.
       * @example
       * docker.io
       * @example
       * localhost:5000
       */
      domain?: RegistryString;
      /**
       * Image content ID in the form `algorithm:hex`
       * @example
       * sha256:199e537da3a86126cd6eb114bd0b13ab178dc291bbb6ea4a4a3aa257b2366b71
       */
      id?: ImageIdString;
      /**
       * The image repo path.
       * @example
       * google/cloud-sdk
       */
      path?: string;
      /**
       * Image tag
       * @example
       * latest
       */
      tag?: string;
  }/**
   * The type of an image reference indicates how the image can be
   * accessed, currently either through a Docker host (daemon) or directly to a
   * container registry via its API.
   *
   * @remarks
   * If not enough information is present to access and uniquely identify a
   * container image, the type is `incomplete`.
   * @public
   */
  export declare type ImageRefType = "incomplete" | "registry" | "dockerhost";/**
   * An immutable reference to a container image, including all information
   * known about the image.
   *
   * @remarks
   * This type is the base type for an image reference and is allowed to
   * contain partial or incomplete information about a container image.
   * It can include both information about how to access the image and
   * also information about the image itself.
   *
   * Many of the properties of {@link docker.ImageRef} are related to the
   * container image reference string used by Docker and other container-based
   * systems. A container image reference string is a structured string
   * containing multiple components. The most basic components are illustrated
   * below, using the example image reference string
   * `"my.registry:5000/a/repo/path:sometag@sha256:899a03e9816e5283edba63d"`.
   *
   * NOTE: The length of the `digest` has been shortened for formatting
   * purposes.
   *
   * ```
   * "my.registry:5000/a/repo/path:sometag@sha256:899a03e9816e5283edba63d"
   * |     domain     |   path    |  tag  |         digest               |
   * ```
   *
   * To aid in correct formatting, {@link docker.ImageRef} and related types and
   * classes also provide helper properties that combine these basic components
   * into combinations that are often useful, such as `name`, which is the
   * `domain` and `path` combined with a `/`.
   *
   * Many tools, such as the Docker UI, also accept a shortened form of a string
   * reference, called the `familiar` form. An example of a familiar reference is
   * `ubuntu`. In this form, only the `path` component is required. When
   * components of the reference are left out, default values are assumed. The
   * default `domain` is `docker.io` and the default `tag` is `latest`.
   * Additionally, if the `domain` is `docker.io` and there are no `/` characters
   * in the `path`, `library/` is prepended to the path. So `ubuntu` is the
   * familiar form for the complete reference `docker.io/library/ubuntu:latest`.
   *
   * An {@link docker.ImageRef} is designed to hold as much information about
   * an image as may be available and therefore some properties that are
   * not known will be `undefined`.
   *
   * See also {@link docker.MutableImageRef}, which can be used to parse
   * reference strings and construct or modify image references.
   * @public
   */
  export declare interface ImageRef extends Readonly<ImageRefData> {
      /**
       * The complete string reference for this image in familiar form, which
       * leaves out certain fields from the reference when they are set to
       * default values.
       * @remarks
       * This reference form is the form typically used in the Docker UI.
       * If the ImageRef is not complete, familiar will return `undefined`, as
       * the correct familiar representation cannot be determined.
       * @example
       * mysql
       * @example
       * gcr.io/my-project/image:1.0.1
       */
      readonly familiar?: string;
      /**
       * The image name, which is comprised of the optional domain and
       * the (non-optional) path. Will be `undefined` if there is no `path`.
       * @example
       * gcr.io/my-project/image
       */
      readonly name?: string;
      /**
       * The image name (including any registry) and image tag. Returns undefined
       * if either path or tag are not set.
       * If nameTag is set to a string that does not contain a tag (i.e. does
       * not include a ":"), the default tag of `latest` will be set.
       * To set nameTag without defaulting to `latest`, call the class method
       * `setNameTag` with the parameter `useDefaultTag` set to `false`.
       * @example
       * gcr.io/my-project/image:1.0.1
       */
      readonly nameTag?: string;
      /**
       * The image path (not including any registry) and image tag. Returns
       * undefined if either `path` or `tag` are not set.
       * @example
       * my-project/image:1.0.1
       */
      readonly pathTag?: string;
      /**
       * The best (most specific and complete) string reference for this image,
       * given the information available in this {@link docker.ImageRef}.
       */
      readonly ref: string;
      /**
       * An alias for `domain`.
       */
      readonly registry?: string;
      /**
       * The best remote reference available for this image in either
       * `domain/path@digest` format or `domain/path:tag` format.
       * @remarks
       * Returns `registryDigest` if it is set, otherwise returns `registryTag`.
       * If no remote reference is available, returns undefined.
       * @example
       * gcr.io/my-project/image\@sha256:899a03e9816e5283edba63d71ea528cd83576b28a7586cf617ce78af5526f209
       * @example
       * gcr.io/my-project/image:1.0.1
       */
      readonly registryRef?: string;
      /**
       * The remote digest reference in `domain/path@digest` form.
       * @remarks
       * Undefined if any of `domain`, `path`, or `digest` are unset.
       * @example
       * gcr.io/my-project/image\@sha256:899a03e9816e5283edba63d71ea528cd83576b28a7586cf617ce78af5526f209
       */
      readonly registryDigest?: string;
      /**
       * The remote tag reference in `domain/path:tag` form.
       * @remarks
       * Undefined if any of `domain`, `path`, or `tag` are unset.
       * @example
       * gcr.io/my-project/image:1.0.1
       */
      readonly registryTag?: string;
      /**
       * The type of an image reference indicates how the image can be
       * accessed, either through a Docker host (daemon) or directly to a
       * container registry.
       *
       * @remarks
       * A reference is a valid `dockerhost` type ref when it contains a valid
       * dockerHost string and either:
       * - A valid image id or
       * - A valid path and either a valid tag or digest.
       *
       * A reference is a valid `registry` type ref when it contains a valid
       * domain, path, and either a tag or a digest.
       *
       * If not enough information is present to access and uniquely identify a
       * container image, the type is `incomplete`.
       */
      readonly type: ImageRefType;
  }/**
   * Helper type that augments a base type to indicate that the `id` field
   * is present and has a valid image ID.
   * @public
   */
  export declare type WithId<T> = T & {
      id: ImageIdString;
  };/**
   * A mutable reference to a container image that can be used to parse,
   * construct, and modify an image reference, as well as to hold information
   * about the image and how to access it.
   *
   * @remarks
   * This class can be used to parse strings that contain complete or partial
   * container image references. It can also be used to construct an image
   * reference from scratch, from individual component parts, or from another
   * reference, then to correctly format the reference or its components for
   * use with various tools.
   *
   * To parse and normalize a "familiar" image reference, like is typically
   * seen in the Docker UI:
   * ```ts
   * const ref = mutableImageRef("redis", true);
   * console.log(ref.tag);         // => "latest"
   * console.log(ref.registryRef); // => "docker.io/library/redis:latest"
   * ```
   *
   * To construct a reference to an image present on the local Docker daemon
   * that has an image ID:
   * ```ts
   * const ref = mutableImageRef({
   *     dockerHost: "default",
   *     path: "myimage",
   *     tag: "just-built",
   *     id: "sha256:04696b491e0cc3c58a75bace8941c14c924b9f313b03ce5029ebbc040ed9dcd9",
   * });
   * ```
   *
   * To convert a `MutableImageRef` to an immutable plain object `ImageRef`,
   * use the `freeze` method.
   * @public
   */
  export declare class MutableImageRef implements ImageRef {
      _digest?: string;
      _dockerHost?: string;
      _domain?: string;
      _id?: ImageIdString;
      _path?: string;
      _tag?: string;
      constructor(ref: ImageNameString, normalize?: boolean);
      constructor(info?: ImageRefData | undefined);
      freeze(): ImageRef;
      toData(): ImageRefData;
      toJSON(): ImageRefData;
      /**
       * The digest string for this image in its associated registry and repo
       * in the form `algorithm:hex`.
       */
      get digest(): string | undefined;
      set digest(digest: string | undefined);
      get dockerHost(): string | undefined;
      set dockerHost(dockerHost: string | undefined);
      /**
       * The hostname and optional port of the image registry for this image.
       */
      get domain(): string | undefined;
      set domain(domain: string | undefined);
      /**
       * The complete string reference for this image in familiar form, which
       * leaves out certain fields from the reference when they are set to
       * default values.
       * @remarks
       * This reference form is the form typically used in the Docker UI.
       * If the ImageRef is not complete, familiar will return `undefined`, as
       * the correct familiar representation cannot be determined.
       */
      get familiar(): string | undefined;
      /**
       * The content ID of the image in `algorithm:hex` format.
       */
      get id(): ImageIdString | undefined;
      set id(id: ImageIdString | undefined);
      /**
       * The image name, which is comprised of the optional domain and
       * the (non-optional) path.
       */
      get name(): string | undefined;
      set name(name: string | undefined);
      /**
       * The image name (including any registry) and image tag. Returns undefined
       * if either path or tag are not set.
       * If nameTag is set to a string that does not contain a tag (i.e. does
       * not include a ":"), the default tag of `latest` will be set.
       * To set nameTag without defaulting to `latest`, call the class method
       * `setNameTag` with the parameter `useDefaultTag` set to `false`.
       */
      get nameTag(): NameTagString | undefined;
      set nameTag(nt: NameTagString | undefined);
      /**
       * Method to set the image name and image tag which also allows choice
       * of default behavior when `nameTag` does not contain a tag string.
       */
      setNameTag(nameTag: NameTagString | undefined, useDefaultTag?: boolean): void;
      /**
       * The image repo path.
       */
      get path(): string | undefined;
      set path(path: string | undefined);
      /**
       * The image path (not including any registry) and image tag. Returns
       * undefined if either path or tag are not set.
       * If pathTag is set to a string that does not contain a tag (i.e. does
       * not include a ":"), the default tag of `latest` will be set.
       * To set pathTag without defaulting to `latest`, call the class method
       * `setPathTag` with the parameter `useDefaultTag` set to `false`.
       */
      get pathTag(): string | undefined;
      set pathTag(pathTag: string | undefined);
      /**
       * Method to set the image path and image tag which also allows choice
       * of default behavior when `pathTag` does not contain a tag string.
       */
      setPathTag(pathTag: string | undefined, useDefaultTag?: boolean): void;
      get ref(): string;
      /**
       * Alias for domain
       */
      get registry(): string | undefined;
      /**
       * The best remote reference available for this image in either
       * `domain/path@digest` format or `domain/path:tag` format.
       * @remarks
       * Returns `registryDigest` if it is set, otherwise returns `registryTag`.
       * If no remote reference is available, returns undefined.
       */
      get registryRef(): ImageNameString | undefined;
      /**
       * The remote digest reference in `domain/path@digest` form.
       * @remarks
       * Undefined if any of `domain`, `path`, or `digest` are unset.
       */
      get registryDigest(): RepoDigestString | undefined;
      set registryDigest(rd: RepoDigestString | undefined);
      /**
       * The remote tag reference in `domain/path:tag` form.
       * @remarks
       * Undefined if any of `domain`, `path`, or `tag` are unset.
       */
      get registryTag(): NameTagString | undefined;
      set registryTag(rt: NameTagString | undefined);
      /**
       * The image tag.
       */
      get tag(): string | undefined;
      set tag(tag: string | undefined);
      /**
       * The type of an image reference indicates how the image can be
       * accessed, either through a Docker host (daemon) or directly to a
       * container registry.
       *
       * @remarks
       * A reference is a valid `dockerhost` type ref when it contains a valid
       * dockerHost string and either:
       * - A valid image id or
       * - A valid path and either a valid tag or digest.
       *
       * A reference is a valid `registry` type ref when it contains a valid
       * domain, path, and either a tag or a digest.
       *
       * If not enough information is present to access and uniquely identify a
       * container image, the type is `incomplete`.
       */
      get type(): ImageRefType;
  }/**
   * A more specific type of {@link docker.ImageRef} that contains sufficient
   * information to uniquely identify an image on a container registry.
   * @public
   */
  export declare interface ImageRefRegistry {
      readonly digest?: string;
      readonly domain: string;
      readonly familiar: string;
      readonly id?: ImageIdString;
      readonly name: string;
      readonly nameTag?: string;
      readonly path: string;
      readonly pathTag?: string;
      readonly ref: string;
      readonly registry: string;
      readonly registryRef: string;
      readonly registryDigest?: string;
      readonly registryTag?: string;
      readonly tag?: string;
      readonly type: "registry";
  }/**
   * A more specific type of {@link docker.ImageRef} that contains sufficient
   * information to uniquely identify an image on a specific Docker host
   * (daemon).
   * @public
   */
  export declare interface ImageRefDockerHost {
      readonly digest?: string;
      readonly dockerHost: string;
      readonly domain?: string;
      readonly familiar: string;
      readonly id?: ImageIdString;
      readonly name: string;
      readonly nameTag?: string;
      readonly path: string;
      readonly pathTag?: string;
      readonly ref: string;
      readonly registry?: string;
      readonly registryRef?: string;
      readonly registryDigest?: string;
      readonly registryTag?: string;
      readonly tag?: string;
      readonly type: "dockerhost";
  }/**
   * Docker network service component, compatible with the abstract
   * {@link NetworkService} component.
   *
   * @remarks
   *
   * Implements the {@link NetworkServiceInstance} interface.
   * In a Docker deployment, there is no actual network service object to deploy.
   * So this is a "virtual" component that simply implements the required
   * instance methods for a NetworkService, but renders to null.
   *
   * This component is typically used by {@link docker.ServiceContainerSet}. The
   * {@link docker.ServiceContainerSet} component can be used to ensure the proper
   * network port configuration is applied to the `props.endpoint` container.
   *
   * @public
   */
  export declare function NetworkService(props: SFCDeclProps<NetworkServiceProps, typeof defaultProps>): null;/**
   * The base string used for Adapt Docker labels.
   * @internal
   */
  const adaptDockerKey = "org.adaptjs";/**
   * Docker label for the deployID the object was created from.
   * @internal
   */
  const adaptDockerDeployIDKey: string;/**
   * Props for {@link docker.LocalDockerImage}
   *
   * @public
   */
  export declare interface LocalDockerImageProps {
      /** Directory for use as the build context in docker build */
      contextDir?: string;
      /**
       * Contents of the dockerfile
       *
       * @remarks
       * Should not be used if dockerfileName is set
       */
      dockerfile?: string;
      /**
       * Path to a local Dockerfile in the Adapt project.
       *
       * @remarks
       * This path is relative to the root of the Adapt project.
       * Should not be used if `dockerfile` is set.
       */
      dockerfileName?: string;
      /**
       * Extra files that should be included during the docker build
       *
       * @remarks
       * LocalDockerImage uses a multi-stage build process.  It first creates
       * a temporary image that includes the files specified in this field.
       * This temporary image is then made available to the `dockerfile` with
       * stage name `files` and can then be copied into the final image, as
       * desired, using `COPY` or `ADD` commands in the `dockerfile`.
       *
       * @example
       * To create a final Docker image that contains a file that has some
       * programmatically created content, use the `dockerfile` prop along
       * with the `files` prop like this:
       * ```tsx
       * const files = [{
       *   path: '/path/to/myfile.txt',
       *   contents: 'contents for myfile\n'
       * }];
       * const dockerfile = `
       *   FROM alpine
       *   COPY --from=files /path/to/myfile.txt /app/myfile.txt
       *   ...
       * `;
       * return <LocalDockerImage files={files} dockerfile={dockerfile} />
       * ```
       */
      files?: File[];
      /**
       * Options to control the behavior of docker build
       */
      options?: DockerBuildOptions;
      /**
       * Extra stages to include in a multi-stage docker build
       */
      stages?: Stage[];
  }/**
   * @internal
   */
  export declare interface LocalDockerImageState {
      deployOpID?: DeployOpID;
      image?: WithId<ImageRefDockerHost>;
      imagePropsJson?: string;
      prevUniqueNameTag?: string;
  }/**
   * Locally builds a docker image
   *
   * @remarks
   * See {@link docker.LocalDockerImageProps}.
   *
   * @public
   */
  export declare class LocalDockerImage extends Action<LocalDockerImageProps, LocalDockerImageState> implements DockerPushableImageInstance {
      static defaultProps: {
          options: {
              dockerHost: string | undefined;
              forceRm: boolean;
          };
      };
      deployedWhenIsTrivial: boolean;
      private image_?;
      private imagePropsJson_?;
      private options_;
      constructor(props: LocalDockerImageProps);
      buildComplete(): boolean;
      ready(): boolean;
      image(): WithId<ImageRefDockerHost> | undefined;
      pushTo({ ref }: {
          ref: string;
      }): Promise<undefined | WithId<ImageRefRegistry>>;
      latestImage(): WithId<ImageRefDockerHost> | undefined;
      /**
       * User-facing name to display in status messages.
       */
      displayName(): string | undefined;
      /**
       * Implementations for Action base class
       * @internal
       */
      shouldAct(op: ChangeType): Promise<ShouldAct>;
      /**
       * Implementations for Action base class
       * @internal
       */
      action(op: ChangeType, ctx: ActionContext): Promise<void>;
      /** @internal */
      initialState(): {};
      /** @internal */
      deployedWhen: (goalStatus: GoalStatus) => true | import("@adpt/core").Waiting;
      /** @internal */
      protected get imagePropsJson(): string;
  }/**
   * Runs a Docker registry in a container.
   * @remarks
   * Implements {@link docker.DockerRegistryInstance}.
   *
   * @public
   */
  export declare function LocalDockerRegistry(props: SFCDeclProps<LocalDockerRegistryProps, typeof defaultProps>): Adapt.JSX.Element;/**
   * Props for {@link docker.LocalDockerRegistry}
   * @public
   */
  export declare interface LocalDockerRegistryProps extends ExcludeKeys<DockerContainerProps, "image"> {
      /**
       * Tag to use for official Docker Hub `registry` image repo.
       */
      imageTag: NameTagString;
      /**
       * Port number to expose for the registry HTTP server.
       */
      port: number;
  }/** @public */
  export declare interface DockerRegistryInstance {
      registry(): RegistryString | undefined;
  }/**
   * Props for {@link docker.RegistryDockerImage}
   * @public
   */
  export declare interface RegistryDockerImageProps {
      /**
       * Handle for image source
       * @remarks
       * Currently, only handle to LocalDockerImage components and compatible
       * interfaces are supported.
       * @privateRemarks
       * FIXME(manishv) support string refs to other registries and handles of
       * other registry images
       */
      imageSrc: Handle<DockerPushableImageInstance>;
      /**
       * Registry and path where the image should be pushed and pulled
       *
       * @remarks
       * If this parameter is a string, registryPrefix will be used for both push and pull
       *
       * If registryPrefix is of the form `{ external: string, internal: string }`, docker images wil be
       * pushed to `external` and image strings will refer to `internal`.
       *
       * Registry prefixes can be of the form `domain/path/elements`, for example `gcr.io/myproject`.
       * However, the registryPrefix should not include the final name, use newPathTag instead.
       *
       * Note(manishv)
       * This is a bit of a hack to allow one hostname or IP address to push images from outside
       * a particular environment (say k8s) and a different URL for that environment to pull
       * images.
       *
       * A good example of this is a k3s-dind (k3s docker-in-docker) instance of kubernetes where
       * a private registry is running on a docker network attached to the k3s-dind instance, but where we
       * want to push {@link docker.LocalDockerImage} built images to that registry.  Since
       * {@link docker.LocalDockerImage | LocalDockerImage} is outside the k3s-dind environment, it must
       * use a host accessible network to push to the registry.  However, since the k3s-dind instance sees
       * the registry from within Docker, it must use a different address to pull the images for use.
       *
       * Once network scopes are fully supported, this interface will change to whatever is appropriate.  It
       * is best if you can arrange to have the same URL or registry string work for all access regardless
       * of which network the registry, Adapt host, and ultimate container running environment is uses.
       */
      registryPrefix: RegistryString | DockerSplitRegistryInfo;
      /**
       * Path and tag to be used for the image in the new registry in
       * `path:tag` or `path` format.
       * @remarks
       * The entire path and tag are blindly concatenated to the domain and path
       * in registryPrefix to form the full ref that will be used to push the
       * image.
       *
       * If omitted, the last component of the path and the tag from the source
       * image is used. The newPathTag should not include the registry
       * hostname/port prefix. If the `:tag` portion of `path:tag` is omitted,
       * the tag `latest` will be used.
       */
      newPathTag?: string;
      /**
       * Path and tag to be used for the image in the new registry in
       * `path:tag` or `path` format.
       * @deprecated This prop has been renamed to `newPathTag`. The functionality
       * for both props is the same and if both are set, `newPathTag` takes
       * priority.
       * @remarks
       * If omitted, the path and tag from the source image is used. The
       * newTag should not include the registry hostname/port prefix. If the
       * `:tag` portion of `path:tag` is omitted, the tag `latest` will be used.
       */
      newTag?: string;
  }/**
   * Represents a Docker image in a registry.
   * @remarks
   * If the image does not exist in the specified registry, it will be pushed
   * to that registry.
   * @public
   */
  export declare class RegistryDockerImage extends Action<RegistryDockerImageProps, State> implements DockerImageInstance {
      private latestImage_?;
      private latestRegistryUrl_?;
      private registry;
      constructor(props: RegistryDockerImageProps);
      /**
       * Returns information about the version of the Docker image that reflects
       * the current set of props for the component and has been pushed to the
       * registry.
       * @remarks
       * Returns undefined if the `props.imageSrc` component's `latestImage` method
       * returns undefined (depending on the component referenced by
       * `props.imageSrc`, that may indicate the source image has not been built).
       * Also returns undefined if the current image has not yet been
       * pushed to the registry.
       */
      image(): ImageRefRegistry | undefined;
      /**
       * Returns information about the most current version of the Docker image
       * that has been pushed to the registry.
       * @remarks
       * Returns undefined if no image has ever been pushed by this component.
       */
      latestImage(): ImageRefRegistry | undefined;
      /** @internal */
      initialState(): {};
      /** @internal */
      shouldAct(diff: ChangeType): false | {
          act: boolean;
          detail: string;
      };
      /** @internal */
      dependsOn: DependsOnMethod;
      /** @internal */
      action(op: ChangeType): Promise<void>;
      private currentNameTag;
      private getNewPathTag;
      private srcImageName;
  }/**
   * Props for {@link docker.ServiceContainerSet}
   *
   * @public
   */
  export declare interface ServiceContainerSetProps extends ServiceProps {
      /**
       * Props to apply to all {@link docker.DockerContainer}s within this
       * ServiceContainerSet. If a prop is specified in the source {@link Container}
       * component and in `containerProps`, `containerProps` will take
       * precedence.
       */
      containerProps?: Partial<DockerContainerProps>;
      /**
       * If set, all children of this ServiceContainerSet that support the
       * `dockerHost` prop will get this value, overriding any other value for
       * this prop.
       */
      dockerHost?: string;
  }/**
   * A component for mapping a group of abstract {@link Container}s and
   * {@link NetworkService}s to Docker {@link docker.DockerContainer | DockerContainer}s
   * and {@link docker.NetworkService}s.
   *
   * @remarks
   * This component is intended to be used to replace {@link Container} and
   * {@link NetworkService} components that are grouped together, as the
   * only children of a common parent in a pattern that looks like this:
   * ```tsx
   * <Service>
   *   <Container ... />
   *   <Container ... />
   *   <NetworkService ... />
   * </Service>
   * ```
   * `ServiceContainerSet` maps those abstract components into Docker components
   * like this:
   * ```tsx
   * <Group>
   *   <docker.DockerContainer ... >
   *   <docker.DockerContainer ... >
   *   <docker.NetworkService ... >
   * </Group>
   * ```
   * An example style rule to do this is:
   * ```tsx
   * {Service}
   * {Adapt.rule((matchedProps) => {
   *     const { handle, ...remainingProps } = matchedProps;
   *     return <ServiceContainerSet {...remainingProps} />;
   * })}
   * ```
   *
   * Currently, {@link docker.NetworkService} implements the {@link NetworkServiceInstance}
   * interface, but does not deploy a network proxy component. So the Docker
   * ServiceContainerSet component applies the network port configuration specified by
   * the {@link NetworkService}s to their target
   * {@link docker.DockerContainer | DockerContainer}s.
   *
   * @public
   */
  export declare class ServiceContainerSet extends DeferredComponent<ServiceContainerSetProps> {
      build(helpers: BuildHelpers): Adapt.JSX.Element;
  }/**
   * Options for interacting with Docker Engine that apply to all
   * operations.
   * @public
   */
  export declare interface DockerGlobalOptions {
      dockerHost?: string;
  }/**
   * Options for performing Docker image builds.
   * @public
   */
  export declare interface DockerBuildOptions extends DockerGlobalOptions {
      /**
       * Requests BuildKit as the internal Docker build engine.
       *
       * @remarks
       * This option requests the use of the BuildKit build engine when building
       * Docker images, if BuildKit is available. This is primarily useful for
       * BuildKit's performance improvements over the legacy Docker build engine.
       * However, because this option does not guarantee BuildKit will be used,
       * BuildKit-only features such as secret mounting should not be used.
       *
       * Internally, this option sets the `DOCKER_BUILDKIT` environment
       * variable when performing builds, which enables BuildKit on Docker
       * systems that support it.
       *
       * For more information, see
       * [Build images with BuildKit](https://docs.docker.com/develop/develop-images/build_enhancements/).
       *
       * @defaultValue `true`
       */
      requestBuildKit?: boolean;
      forceRm?: boolean;
      imageName?: string;
      imageTag?: string;
      prevUniqueNameTag?: string;
      stdin?: string;
      /**
       * If true and the newly built image ID does not match the image ID for
       * prevUniqueNameTag (or prevUniqueNameTag is not set), a new unique nameTag is
       * generated for this image (from imageName and imageTag).
       * If true and the newly built image ID does match the image ID for
       * prevUniqueNameTag, then prevUniqueNameTag is returned as nameTag.
       * If false, imageName and imageTag are used without modification.
       */
      uniqueTag?: boolean;
      /**
       * If set, will add a Docker LABEL with the DeployID.
       */
      deployID?: string;
      buildArgs?: Environment;
  }/**
   * A dynamically-created file that can be used during the build of a Docker
   * image.
   *
   * @remarks
   * These `File` objects are used to create a temporary "scratch" image in a
   * {@link https://docs.docker.com/develop/develop-images/multistage-build/ | multi-stage build}
   * that contains only the specified files. Then, in later stages of that build,
   * the files within the temporary image can be copied into the later stage
   * image.
   * @public
   */
  export declare interface File {
      /**
       * The path in the temporary image where the file will be created.
       */
      path: string;
      /**
       * The contents of the file.
       */
      contents: Buffer | string;
  }/**
   * A stage to be added to a
   * {@link https://docs.docker.com/develop/develop-images/multistage-build/ | multi-stage Docker build}.
   *
   * @remarks
   * The stage will be added to the generated Dockerfile for the image as:
   * ```
   * FROM image as name
   * ```
   * @public
   */
  export declare interface Stage {
      /** The image (name + tag or digest) to use for the stage. */
      image: string;
      /** Name for the stage */
      name: string;
  }/**
   * A string that contains both a Docker repo and a registry digest.
   *
   * @remarks
   * This is a string that represents a specific image on a specific registry
   * contained in a particular repo on that registry. It's of the form:
   * ```
   * [registry/]repo@digest
   * ```
   * `registry` - (optional) The hostname or hostname:port of a Docker registry
   * where the repo is located. If not provided, the official default Docker
   * registry is assumed.
   *
   * `repo` - The more precise name for what's commonly referred to as an image
   * name. It may include 0 or more slashes to denote namespaces.
   *
   * `digest` - The repo digest for the image in the form `algorithm:hex`.
   * This digest is specific to the associated registry and repo and has no
   * significance without those additional pieces of information. If this image is
   * pushed to a different registry, it will have a different digest value.
   * The digest is also known as a "distribution hash".
   *
   * Examples:
   * ```
   * alpine@sha256:04696b491e0cc3c58a75bace8941c14c924b9f313b03ce5029ebbc040ed9dcd9
   * localhost:5000/mockdeploy-htws@sha256:899a03e9816e5283edba63d71ea528cd83576b28a7586cf617ce78af5526f209
   * ```
   * @public
   */
  export declare type RepoDigestString = string;/**
   * Docker image ID, in the form `algorithm:hex`.
   *
   * @remarks
   * The Docker image ID (also known as "Content Hash") is a single value
   * that uniquely identifies a specific image on a local Docker host.
   *
   * An image ID does not require a registry or repo qualifier to be significant.
   * It is distinct from a Docker image
   * {@link docker.RepoDigestString | repo digest}.
   *
   * Example:
   * ```
   * sha256:199e537da3a86126cd6eb114bd0b13ab178dc291bbb6ea4a4a3aa257b2366b71
   * ```
   * @public
   */
  export declare type ImageIdString = string;/**
   * A string reference to a Docker image that contains a repo name, and may
   * contain an optional registry and optional tag.
   *
   * @remarks
   * This is a string that references a Docker image. It's in the form of
   * one of:
   * ```
   * [registry/]repo
   * [registry/]repo:tag
   * ```
   * `registry` - (optional) The hostname or hostname:port of a Docker registry
   * where the repo is located. If not provided, depending on context, either
   * the official default Docker registry may be assumed or the image may just
   * be present locally and not on any registry.
   *
   * `repo` - The more precise name for what's commonly referred to as an image
   * name. It may include 0 or more slashes to denote namespaces.
   *
   * `tag` - A tag string identifying a version of image within the repo.
   *
   * Examples:
   * ```
   * alpine
   * ubuntu:16.04
   * ```
   * @public
   */
  export declare type NameTagString = string;/**
   * A string reference to a Docker image that contains a repo name, and may
   * contain an optional registry and optionally either a tag or a repo digest.
   *
   * @remarks
   * This is a string that references a Docker image. It's in the form of
   * one of:
   * ```
   * [registry/]repo
   * [registry/]repo:tag
   * [registry/]repo@digest
   * ```
   * For more detail, see {@link docker.NameTagString} and
   * {@link docker.RepoDigestString}.
   *
   * Examples:
   * ```
   * alpine
   * ubuntu:16.04
   * alpine@sha256:04696b491e0cc3c58a75bace8941c14c924b9f313b03ce5029ebbc040ed9dcd9
   * localhost:5000/mockdeploy-htws@sha256:899a03e9816e5283edba63d71ea528cd83576b28a7586cf617ce78af5526f209
   * ```
   * @public
   */
  export declare type ImageNameString = NameTagString | RepoDigestString;/**
   * A string that references a Docker registry that contains a hostname and
   * may optionally contain a port and/or path.
   *
   * @remarks
   * This string is in the form of one of:
   * ```
   * hostname[:port]
   * hostname[:port]/path
   * ```
   * This form does not include the protocol, such as `http:` or `https:` in
   * the string.
   *
   * @public
   */
  export declare type RegistryString = string;/**
   * Information about a specific instance of a Docker image, as identified by
   * its image ID.
   * @deprecated Replaced with {@link docker.ImageRef}.
   * @public
   */
  export declare interface ImageInfo {
      /**
       * Docker image ID, in the form `algorithm:hex`.
       * @remarks
       * See {@link docker.ImageIdString}.
       */
      id: ImageIdString;
      /**
       * Docker image name and optional tag in the form `name` or `name:tag`.
       * @remarks
       * See {@link docker.NameTagString}
       */
      nameTag?: NameTagString;
  }/**
   * Props for {@link docker.DockerContainer}
   *
   * @public
   */
  export declare interface DockerContainerProps extends DockerGlobalOptions, Pick<ContainerProps, "autoRemove" | "command" | "environment" | "portBindings" | "ports" | "restartPolicy" | "stopSignal"> {
      /** image name as a string, or a handle to a DockerImage component */
      image: ImageNameString | Handle<DockerImageInstance>;
      /**
       * Host and port of the remote docker host to use.
       *
       * @remarks
       * Defaults to the DOCKER_HOST environment variable
       */
      dockerHost: string;
      /**
       * Labels to apply to the container.
       */
      labels?: ContainerLabels;
      /**
       * Filesystems to be mounted in the container.
       */
      mounts?: Mount[];
      /**
       * Networks to connect the container to
       *
       * @remarks
       * Accepts the same strings as docker network connect
       */
      networks?: string[];
      /**
       * Enables the container to run in privileged mode.
       */
      privileged?: boolean;
  }/**
   * Represents a split registry, with pushes going to external and pulls going to internal
   * @beta
   */
  export declare interface DockerSplitRegistryInfo {
      external: RegistryString;
      internal: RegistryString;
  }/**
   * Describes bind mount filesystems to be mounted in a container.
   * @public
   */
  export declare interface BindMount {
      type: "bind";
      source: string;
      destination: string;
      readonly?: boolean;
      propagation?: "shared" | "slave" | "private" | "rshared" | "rslave" | "rprivate";
  }/**
   * Describes filesystems to be mounted in a container.
   * @public
   */
  export declare type Mount = BindMount;/**
   * Props for {@link docker.BuildKitImage}
   *
   * @public
   */
  export declare interface BuildKitImageProps {
      /** Directory for use as the build context */
      contextDir?: string;
      /**
       * Contents of the dockerfile
       *
       * @remarks
       * Should not be used if dockerfileName is set
       */
      dockerfile?: string;
      /**
       * Path to a local Dockerfile in the Adapt project.
       *
       * @remarks
       * This path is relative to the root of the Adapt project.
       * Should not be used if `dockerfile` is set.
       */
      dockerfileName?: string;
      /**
       * Extra files that should be included during the docker build
       *
       * @remarks
       * BuildKitImage uses a multi-stage build process.  It first creates
       * a temporary image that includes the files specified in this field.
       * This temporary image is then made available to the `dockerfile` with
       * stage name `files` and can then be copied into the final image, as
       * desired, using `COPY` or `ADD` commands in the `dockerfile`.
       *
       * @example
       * To create a final Docker image that contains a file that has some
       * programmatically created content, use the `dockerfile` prop along
       * with the `files` prop like this:
       * ```tsx
       * const files = [{
       *   path: '/path/to/myfile.txt',
       *   contents: 'contents for myfile\n'
       * }];
       * const dockerfile = `
       *   FROM alpine
       *   COPY --from=files /path/to/myfile.txt /app/myfile.txt
       *   ...
       * `;
       * return <BuildKitImage files={files} dockerfile={dockerfile} />
       * ```
       */
      files?: File[];
      /**
       * Options to control the behavior of docker build
       */
      options?: BuildKitBuildOptions;
      /**
       * Directs BuildKit where to store the built image.
       */
      output: BuildKitOutput;
      /**
       * Extra stages to include in a multi-stage docker build
       */
      stages?: Stage[];
  }/**
   * @internal
   */
  export declare interface BuildKitImageState {
      deployOpID?: DeployOpID;
      image?: WithId<ImageRefRegistry>;
      imagePropsJson?: string;
      prevUniqueNameTag?: string;
  }/**
   * Locally builds a docker image
   *
   * @remarks
   * See {@link docker.BuildKitImageProps}.
   *
   * @public
   */
  export declare class BuildKitImage extends Action<BuildKitImageProps, BuildKitImageState> implements DockerPushableImageInstance {
      static defaultProps: {
          options: {};
      };
      deployedWhenIsTrivial: boolean;
      private image_?;
      private imagePropsJson_?;
      private options_;
      constructor(props: BuildKitImageProps);
      buildComplete(): boolean;
      ready(): boolean;
      image(): WithId<ImageRefRegistry> | undefined;
      pushTo({ ref }: {
          ref: string;
      }): Promise<undefined | WithId<ImageRefRegistry>>;
      latestImage(): WithId<ImageRefRegistry> | undefined;
      /**
       * User-facing name to display in status messages.
       */
      displayName(): string;
      /**
       * Implementations for Action base class
       * @internal
       */
      shouldAct(op: ChangeType): Promise<ShouldAct>;
      /**
       * Implementations for Action base class
       * @internal
       */
      action(op: ChangeType, ctx: ActionContext): Promise<void>;
      /** @internal */
      initialState(): {};
      /** @internal */
      deployedWhen: (goalStatus: GoalStatus) => true | import("@adpt/core").Waiting;
      /** @internal */
      protected get imagePropsJson(): string;
  }/**
   * Components that provide a Docker image can implement this interface to
   * allow other components to get information about the Docker image.
   * @public
   */
  export declare interface DockerImageInstance {
      /**
       * Returns information about the version of the Docker image that reflects
       * the current set of props for the component.
       * @remarks
       * Returns undefined if no image has ever been built by
       * this component OR if the component props have changed and the image
       * that corresponds to the current props has not yet been built.
       */
      image(): ImageRef | undefined;
      /**
       * Returns information about the most current version of the Docker image
       * that has completed building, even if that version does not reflect the
       * current set of props for the component.
       * @remarks
       * Returns undefined if no image has ever been built by this component.
       */
      latestImage(): ImageRef | undefined;
      /**
       * Pushes the image returned by `latestImage` to a Docker registry.
       *
       * @param ref - A docker domain, path components, and tag to which this image should be pushed
       *
       * @remarks
       * If there is no latest image available (`latestImage` returns
       * undefined), then `pushTo` will return undefined. Otherwise, if the
       * push was successful, returns an {@link docker.ImageRefRegistry} that contains
       * the complete nameTag, including registry portion.
       */
      pushTo?({ ref }: {
          ref: NameTagString;
      }): MaybePromise<ImageRefRegistry | undefined>;
  }/**
   * Components that provide a Docker image can implement this interface to
   * allow other components to get information about the Docker image and
   * to be able to push the image to a registry.
   * @public
   */
  export declare interface DockerPushableImageInstance extends DockerImageInstance {
      /**
       * {@inheritdoc docker.DockerImageInstance.pushTo}
       */
      pushTo({ ref }: {
          ref: NameTagString;
      }): MaybePromise<ImageRefRegistry | undefined>;
  }/**
   * Props for {@link docker.DockerImage}.
   * @beta
   */
  export declare interface DockerImageProps {
  }/**
   * Abstract component representing a {@link https://docker.com | Docker}
   * image that can be used to create containers.
   * @remarks
   * See also {@link Container}.
   * @beta
   */
  export declare abstract class DockerImage extends Component<DockerImageProps> implements DockerImageInstance {
      /**
       * {@inheritdoc docker.DockerImageInstance.image}
       */
      image(): ImageRef | undefined;
      /**
       * {@inheritdoc docker.DockerImageInstance.latestImage}
       */
      latestImage(): ImageRef | undefined;
  }/**
   * Compute the status of a container based on a graphQL schema
   *
   * @internal
   */
  export declare function containerStatus(observe: ObserveForStatus, containerName: string, dockerHost: string): Promise<ContainerStatus | NoStatus>;/** @public */
  export declare interface DockerContainerStatus extends ContainerStatus {
  }/**
   * Compute a unique name for the container
   *
   * @internal
   */
  const computeContainerName: (elemKey: string, elemID: string, deployID: string) => string;/**
   * Component to instantiate an image container with docker
   *
   * @remarks
   * See {@link docker.DockerContainerProps}.
   *
   * @public
   */
  declare class DockerContainer extends Action<DockerContainerProps, DockerContainerState> {
      static defaultProps: {
          dockerHost: string;
          privileged: boolean;
      };
      info?: ContainerInfo;
      dependsOn: DependsOnMethod;
      /** @internal */
      shouldAct(diff: ChangeType, context: ActionContext): Promise<false | ShouldAct>;
      /** @internal */
      action(diff: ChangeType, context: ActionContext): Promise<void>;
      status(observe: ObserveForStatus, buildData: BuildData): Promise<NoStatus | ContainerStatus>;
      /**
       * Get the IP address of the container, optionally for a specific Docker
       * network.
       * @remarks
       * The IP addresses that are returned by this function are valid only
       * on the associated Docker network, which is often only associated
       * with a single host node for most Docker network types.
       *
       * @param network - Name of a Docker network. If `network` is provided
       * and the container is connected to the network with an IP address, that
       * address will be returned. If the container is not connected to the
       * network, `undefined` will be returned. If `network` is not provided,
       * the default container IP address will be returned.
       *
       * @beta
       */
      dockerIP(network?: string): string | undefined;
      /** @internal */
      initialState(): {};
      private displayName;
      private refreshContainerInfo;
  }/**
   * Component to instantiate an image container with docker
   *
   * @remarks
   * See {@link docker.DockerContainerProps}.
   *
   * @public
   */
  declare class DockerContainer extends Action<DockerContainerProps, DockerContainerState> {
      static defaultProps: {
          dockerHost: string;
          privileged: boolean;
      };
      info?: ContainerInfo;
      dependsOn: DependsOnMethod;
      /** @internal */
      shouldAct(diff: ChangeType, context: ActionContext): Promise<false | ShouldAct>;
      /** @internal */
      action(diff: ChangeType, context: ActionContext): Promise<void>;
      status(observe: ObserveForStatus, buildData: BuildData): Promise<NoStatus | ContainerStatus>;
      /**
       * Get the IP address of the container, optionally for a specific Docker
       * network.
       * @remarks
       * The IP addresses that are returned by this function are valid only
       * on the associated Docker network, which is often only associated
       * with a single host node for most Docker network types.
       *
       * @param network - Name of a Docker network. If `network` is provided
       * and the container is connected to the network with an IP address, that
       * address will be returned. If the container is not connected to the
       * network, `undefined` will be returned. If `network` is not provided,
       * the default container IP address will be returned.
       *
       * @beta
       */
      dockerIP(network?: string): string | undefined;
      /** @internal */
      initialState(): {};
      private displayName;
      private refreshContainerInfo;
  }/**
   * Type guard for determining whether a given object has a non-null `id`
   * property.
   * @public
   */
  export declare function hasId<T extends {
      id?: ImageIdString;
  }>(o: T): o is WithId<T>;/**
   * Factory function for creating a {@link docker.MutableImageRef}.
   * @remarks
   * Can also be used to clone an existing {@link docker.MutableImageRef} or
   * to create a mutable version of an existing {@link docker.ImageRef}.
   * @public
   */
  export declare function mutableImageRef(ref: ImageNameString, normalize?: boolean): MutableImageRef;/**
   * Factory function for creating a {@link docker.MutableImageRef}.
   * @remarks
   * Can also be used to clone an existing {@link docker.MutableImageRef} or
   * to create a mutable version of an existing {@link docker.ImageRef}.
   * @public
   */
  export declare function mutableImageRef(info?: ImageRefData): MutableImageRef;/**
   * Factory function for creating a {@link docker.ImageRef} or cloning an
   * existing one.
   * @public
   */
  export declare function imageRef(ref: ImageNameString, normalize?: boolean): ImageRef;/**
   * Factory function for creating a {@link docker.ImageRef} or cloning an
   * existing one.
   * @public
   */
  export declare function imageRef(info?: ImageRefData): ImageRef;/**
   * A type guard for determining whether a {@link docker.ImageRef} is a
   * {@link docker.ImageRefRegistry}.
   * @public
   */
  export declare function isImageRefRegistry(ref: ImageRef): ref is ImageRefRegistry;/**
   * A type guard for determining whether a {@link docker.ImageRef} is a
   * {@link docker.ImageRefRegistry} that has the `id` property set.
   * @public
   */
  export declare function isImageRefRegistryWithId(ref: ImageRef): ref is WithId<ImageRefRegistry>;/**
   * A type guard for determining whether a {@link docker.ImageRef} is a
   * {@link docker.ImageRefDockerHost}.
   * @public
   */
  export declare function isImageRefDockerhost(ref: ImageRef): ref is ImageRefDockerHost;/**
   * A type guard for determining whether a {@link docker.ImageRef} is a
   * {@link docker.ImageRefDockerHost} that has the `id` property set.
   * @public
   */
  export declare function isImageRefDockerhostWithId(ref: ImageRef): ref is WithId<ImageRefDockerHost>;/**
   * The most basic components that make up a {@link docker.ImageRef}.
   * All other properties of a {@link docker.ImageRef} can be computed from
   * these.
   * @remarks
   * See also {@link docker.ImageRef} for more information on references.
   * @public
   */
  export declare interface ImageRefData {
      /**
       * Image digest in the form `algorithm:hex`
       * @example
       * sha256:04696b491e0cc3c58a75bace8941c14c924b9f313b03ce5029ebbc040ed9dcd9
       */
      digest?: string;
      /**
       * Docker host string to contact the Docker daemon where this image is
       * located.
       *
       * @remarks
       * This should be in the same format that Docker expects for the `DOCKER_HOST`
       * environment variable. The special string `default` can also be used,
       * which will use the current value of the `DOCKER_HOST` environment variable,
       * if it is set and will otherwise use the default named pipe on Windows
       * (`npipe:///./pipe/docker_engine`) and the default socket on other
       * systems (`unix:///var/run/docker.sock`).
       * @example
       * tcp://localhost:2375
       */
      dockerHost?: "default" | string;
      /**
       * Hostname and optional port number of the container image registry where
       * this image is located.
       * @example
       * docker.io
       * @example
       * localhost:5000
       */
      domain?: RegistryString;
      /**
       * Image content ID in the form `algorithm:hex`
       * @example
       * sha256:199e537da3a86126cd6eb114bd0b13ab178dc291bbb6ea4a4a3aa257b2366b71
       */
      id?: ImageIdString;
      /**
       * The image repo path.
       * @example
       * google/cloud-sdk
       */
      path?: string;
      /**
       * Image tag
       * @example
       * latest
       */
      tag?: string;
  }/**
   * The type of an image reference indicates how the image can be
   * accessed, currently either through a Docker host (daemon) or directly to a
   * container registry via its API.
   *
   * @remarks
   * If not enough information is present to access and uniquely identify a
   * container image, the type is `incomplete`.
   * @public
   */
  export declare type ImageRefType = "incomplete" | "registry" | "dockerhost";/**
   * An immutable reference to a container image, including all information
   * known about the image.
   *
   * @remarks
   * This type is the base type for an image reference and is allowed to
   * contain partial or incomplete information about a container image.
   * It can include both information about how to access the image and
   * also information about the image itself.
   *
   * Many of the properties of {@link docker.ImageRef} are related to the
   * container image reference string used by Docker and other container-based
   * systems. A container image reference string is a structured string
   * containing multiple components. The most basic components are illustrated
   * below, using the example image reference string
   * `"my.registry:5000/a/repo/path:sometag@sha256:899a03e9816e5283edba63d"`.
   *
   * NOTE: The length of the `digest` has been shortened for formatting
   * purposes.
   *
   * ```
   * "my.registry:5000/a/repo/path:sometag@sha256:899a03e9816e5283edba63d"
   * |     domain     |   path    |  tag  |         digest               |
   * ```
   *
   * To aid in correct formatting, {@link docker.ImageRef} and related types and
   * classes also provide helper properties that combine these basic components
   * into combinations that are often useful, such as `name`, which is the
   * `domain` and `path` combined with a `/`.
   *
   * Many tools, such as the Docker UI, also accept a shortened form of a string
   * reference, called the `familiar` form. An example of a familiar reference is
   * `ubuntu`. In this form, only the `path` component is required. When
   * components of the reference are left out, default values are assumed. The
   * default `domain` is `docker.io` and the default `tag` is `latest`.
   * Additionally, if the `domain` is `docker.io` and there are no `/` characters
   * in the `path`, `library/` is prepended to the path. So `ubuntu` is the
   * familiar form for the complete reference `docker.io/library/ubuntu:latest`.
   *
   * An {@link docker.ImageRef} is designed to hold as much information about
   * an image as may be available and therefore some properties that are
   * not known will be `undefined`.
   *
   * See also {@link docker.MutableImageRef}, which can be used to parse
   * reference strings and construct or modify image references.
   * @public
   */
  export declare interface ImageRef extends Readonly<ImageRefData> {
      /**
       * The complete string reference for this image in familiar form, which
       * leaves out certain fields from the reference when they are set to
       * default values.
       * @remarks
       * This reference form is the form typically used in the Docker UI.
       * If the ImageRef is not complete, familiar will return `undefined`, as
       * the correct familiar representation cannot be determined.
       * @example
       * mysql
       * @example
       * gcr.io/my-project/image:1.0.1
       */
      readonly familiar?: string;
      /**
       * The image name, which is comprised of the optional domain and
       * the (non-optional) path. Will be `undefined` if there is no `path`.
       * @example
       * gcr.io/my-project/image
       */
      readonly name?: string;
      /**
       * The image name (including any registry) and image tag. Returns undefined
       * if either path or tag are not set.
       * If nameTag is set to a string that does not contain a tag (i.e. does
       * not include a ":"), the default tag of `latest` will be set.
       * To set nameTag without defaulting to `latest`, call the class method
       * `setNameTag` with the parameter `useDefaultTag` set to `false`.
       * @example
       * gcr.io/my-project/image:1.0.1
       */
      readonly nameTag?: string;
      /**
       * The image path (not including any registry) and image tag. Returns
       * undefined if either `path` or `tag` are not set.
       * @example
       * my-project/image:1.0.1
       */
      readonly pathTag?: string;
      /**
       * The best (most specific and complete) string reference for this image,
       * given the information available in this {@link docker.ImageRef}.
       */
      readonly ref: string;
      /**
       * An alias for `domain`.
       */
      readonly registry?: string;
      /**
       * The best remote reference available for this image in either
       * `domain/path@digest` format or `domain/path:tag` format.
       * @remarks
       * Returns `registryDigest` if it is set, otherwise returns `registryTag`.
       * If no remote reference is available, returns undefined.
       * @example
       * gcr.io/my-project/image\@sha256:899a03e9816e5283edba63d71ea528cd83576b28a7586cf617ce78af5526f209
       * @example
       * gcr.io/my-project/image:1.0.1
       */
      readonly registryRef?: string;
      /**
       * The remote digest reference in `domain/path@digest` form.
       * @remarks
       * Undefined if any of `domain`, `path`, or `digest` are unset.
       * @example
       * gcr.io/my-project/image\@sha256:899a03e9816e5283edba63d71ea528cd83576b28a7586cf617ce78af5526f209
       */
      readonly registryDigest?: string;
      /**
       * The remote tag reference in `domain/path:tag` form.
       * @remarks
       * Undefined if any of `domain`, `path`, or `tag` are unset.
       * @example
       * gcr.io/my-project/image:1.0.1
       */
      readonly registryTag?: string;
      /**
       * The type of an image reference indicates how the image can be
       * accessed, either through a Docker host (daemon) or directly to a
       * container registry.
       *
       * @remarks
       * A reference is a valid `dockerhost` type ref when it contains a valid
       * dockerHost string and either:
       * - A valid image id or
       * - A valid path and either a valid tag or digest.
       *
       * A reference is a valid `registry` type ref when it contains a valid
       * domain, path, and either a tag or a digest.
       *
       * If not enough information is present to access and uniquely identify a
       * container image, the type is `incomplete`.
       */
      readonly type: ImageRefType;
  }/**
   * Helper type that augments a base type to indicate that the `id` field
   * is present and has a valid image ID.
   * @public
   */
  export declare type WithId<T> = T & {
      id: ImageIdString;
  };/**
   * A mutable reference to a container image that can be used to parse,
   * construct, and modify an image reference, as well as to hold information
   * about the image and how to access it.
   *
   * @remarks
   * This class can be used to parse strings that contain complete or partial
   * container image references. It can also be used to construct an image
   * reference from scratch, from individual component parts, or from another
   * reference, then to correctly format the reference or its components for
   * use with various tools.
   *
   * To parse and normalize a "familiar" image reference, like is typically
   * seen in the Docker UI:
   * ```ts
   * const ref = mutableImageRef("redis", true);
   * console.log(ref.tag);         // => "latest"
   * console.log(ref.registryRef); // => "docker.io/library/redis:latest"
   * ```
   *
   * To construct a reference to an image present on the local Docker daemon
   * that has an image ID:
   * ```ts
   * const ref = mutableImageRef({
   *     dockerHost: "default",
   *     path: "myimage",
   *     tag: "just-built",
   *     id: "sha256:04696b491e0cc3c58a75bace8941c14c924b9f313b03ce5029ebbc040ed9dcd9",
   * });
   * ```
   *
   * To convert a `MutableImageRef` to an immutable plain object `ImageRef`,
   * use the `freeze` method.
   * @public
   */
  export declare class MutableImageRef implements ImageRef {
      _digest?: string;
      _dockerHost?: string;
      _domain?: string;
      _id?: ImageIdString;
      _path?: string;
      _tag?: string;
      constructor(ref: ImageNameString, normalize?: boolean);
      constructor(info?: ImageRefData | undefined);
      freeze(): ImageRef;
      toData(): ImageRefData;
      toJSON(): ImageRefData;
      /**
       * The digest string for this image in its associated registry and repo
       * in the form `algorithm:hex`.
       */
      get digest(): string | undefined;
      set digest(digest: string | undefined);
      get dockerHost(): string | undefined;
      set dockerHost(dockerHost: string | undefined);
      /**
       * The hostname and optional port of the image registry for this image.
       */
      get domain(): string | undefined;
      set domain(domain: string | undefined);
      /**
       * The complete string reference for this image in familiar form, which
       * leaves out certain fields from the reference when they are set to
       * default values.
       * @remarks
       * This reference form is the form typically used in the Docker UI.
       * If the ImageRef is not complete, familiar will return `undefined`, as
       * the correct familiar representation cannot be determined.
       */
      get familiar(): string | undefined;
      /**
       * The content ID of the image in `algorithm:hex` format.
       */
      get id(): ImageIdString | undefined;
      set id(id: ImageIdString | undefined);
      /**
       * The image name, which is comprised of the optional domain and
       * the (non-optional) path.
       */
      get name(): string | undefined;
      set name(name: string | undefined);
      /**
       * The image name (including any registry) and image tag. Returns undefined
       * if either path or tag are not set.
       * If nameTag is set to a string that does not contain a tag (i.e. does
       * not include a ":"), the default tag of `latest` will be set.
       * To set nameTag without defaulting to `latest`, call the class method
       * `setNameTag` with the parameter `useDefaultTag` set to `false`.
       */
      get nameTag(): NameTagString | undefined;
      set nameTag(nt: NameTagString | undefined);
      /**
       * Method to set the image name and image tag which also allows choice
       * of default behavior when `nameTag` does not contain a tag string.
       */
      setNameTag(nameTag: NameTagString | undefined, useDefaultTag?: boolean): void;
      /**
       * The image repo path.
       */
      get path(): string | undefined;
      set path(path: string | undefined);
      /**
       * The image path (not including any registry) and image tag. Returns
       * undefined if either path or tag are not set.
       * If pathTag is set to a string that does not contain a tag (i.e. does
       * not include a ":"), the default tag of `latest` will be set.
       * To set pathTag without defaulting to `latest`, call the class method
       * `setPathTag` with the parameter `useDefaultTag` set to `false`.
       */
      get pathTag(): string | undefined;
      set pathTag(pathTag: string | undefined);
      /**
       * Method to set the image path and image tag which also allows choice
       * of default behavior when `pathTag` does not contain a tag string.
       */
      setPathTag(pathTag: string | undefined, useDefaultTag?: boolean): void;
      get ref(): string;
      /**
       * Alias for domain
       */
      get registry(): string | undefined;
      /**
       * The best remote reference available for this image in either
       * `domain/path@digest` format or `domain/path:tag` format.
       * @remarks
       * Returns `registryDigest` if it is set, otherwise returns `registryTag`.
       * If no remote reference is available, returns undefined.
       */
      get registryRef(): ImageNameString | undefined;
      /**
       * The remote digest reference in `domain/path@digest` form.
       * @remarks
       * Undefined if any of `domain`, `path`, or `digest` are unset.
       */
      get registryDigest(): RepoDigestString | undefined;
      set registryDigest(rd: RepoDigestString | undefined);
      /**
       * The remote tag reference in `domain/path:tag` form.
       * @remarks
       * Undefined if any of `domain`, `path`, or `tag` are unset.
       */
      get registryTag(): NameTagString | undefined;
      set registryTag(rt: NameTagString | undefined);
      /**
       * The image tag.
       */
      get tag(): string | undefined;
      set tag(tag: string | undefined);
      /**
       * The type of an image reference indicates how the image can be
       * accessed, either through a Docker host (daemon) or directly to a
       * container registry.
       *
       * @remarks
       * A reference is a valid `dockerhost` type ref when it contains a valid
       * dockerHost string and either:
       * - A valid image id or
       * - A valid path and either a valid tag or digest.
       *
       * A reference is a valid `registry` type ref when it contains a valid
       * domain, path, and either a tag or a digest.
       *
       * If not enough information is present to access and uniquely identify a
       * container image, the type is `incomplete`.
       */
      get type(): ImageRefType;
  }/**
   * A more specific type of {@link docker.ImageRef} that contains sufficient
   * information to uniquely identify an image on a container registry.
   * @public
   */
  export declare interface ImageRefRegistry {
      readonly digest?: string;
      readonly domain: string;
      readonly familiar: string;
      readonly id?: ImageIdString;
      readonly name: string;
      readonly nameTag?: string;
      readonly path: string;
      readonly pathTag?: string;
      readonly ref: string;
      readonly registry: string;
      readonly registryRef: string;
      readonly registryDigest?: string;
      readonly registryTag?: string;
      readonly tag?: string;
      readonly type: "registry";
  }/**
   * A more specific type of {@link docker.ImageRef} that contains sufficient
   * information to uniquely identify an image on a specific Docker host
   * (daemon).
   * @public
   */
  export declare interface ImageRefDockerHost {
      readonly digest?: string;
      readonly dockerHost: string;
      readonly domain?: string;
      readonly familiar: string;
      readonly id?: ImageIdString;
      readonly name: string;
      readonly nameTag?: string;
      readonly path: string;
      readonly pathTag?: string;
      readonly ref: string;
      readonly registry?: string;
      readonly registryRef?: string;
      readonly registryDigest?: string;
      readonly registryTag?: string;
      readonly tag?: string;
      readonly type: "dockerhost";
  }/**
   * Docker network service component, compatible with the abstract
   * {@link NetworkService} component.
   *
   * @remarks
   *
   * Implements the {@link NetworkServiceInstance} interface.
   * In a Docker deployment, there is no actual network service object to deploy.
   * So this is a "virtual" component that simply implements the required
   * instance methods for a NetworkService, but renders to null.
   *
   * This component is typically used by {@link docker.ServiceContainerSet}. The
   * {@link docker.ServiceContainerSet} component can be used to ensure the proper
   * network port configuration is applied to the `props.endpoint` container.
   *
   * @public
   */
  export declare function NetworkService(props: SFCDeclProps<NetworkServiceProps, typeof defaultProps>): null;/**
   * The base string used for Adapt Docker labels.
   * @internal
   */
  const adaptDockerKey = "org.adaptjs";/**
   * Docker label for the deployID the object was created from.
   * @internal
   */
  const adaptDockerDeployIDKey: string;/**
   * Props for {@link docker.LocalDockerImage}
   *
   * @public
   */
  export declare interface LocalDockerImageProps {
      /** Directory for use as the build context in docker build */
      contextDir?: string;
      /**
       * Contents of the dockerfile
       *
       * @remarks
       * Should not be used if dockerfileName is set
       */
      dockerfile?: string;
      /**
       * Path to a local Dockerfile in the Adapt project.
       *
       * @remarks
       * This path is relative to the root of the Adapt project.
       * Should not be used if `dockerfile` is set.
       */
      dockerfileName?: string;
      /**
       * Extra files that should be included during the docker build
       *
       * @remarks
       * LocalDockerImage uses a multi-stage build process.  It first creates
       * a temporary image that includes the files specified in this field.
       * This temporary image is then made available to the `dockerfile` with
       * stage name `files` and can then be copied into the final image, as
       * desired, using `COPY` or `ADD` commands in the `dockerfile`.
       *
       * @example
       * To create a final Docker image that contains a file that has some
       * programmatically created content, use the `dockerfile` prop along
       * with the `files` prop like this:
       * ```tsx
       * const files = [{
       *   path: '/path/to/myfile.txt',
       *   contents: 'contents for myfile\n'
       * }];
       * const dockerfile = `
       *   FROM alpine
       *   COPY --from=files /path/to/myfile.txt /app/myfile.txt
       *   ...
       * `;
       * return <LocalDockerImage files={files} dockerfile={dockerfile} />
       * ```
       */
      files?: File[];
      /**
       * Options to control the behavior of docker build
       */
      options?: DockerBuildOptions;
      /**
       * Extra stages to include in a multi-stage docker build
       */
      stages?: Stage[];
  }/**
   * @internal
   */
  export declare interface LocalDockerImageState {
      deployOpID?: DeployOpID;
      image?: WithId<ImageRefDockerHost>;
      imagePropsJson?: string;
      prevUniqueNameTag?: string;
  }/**
   * Locally builds a docker image
   *
   * @remarks
   * See {@link docker.LocalDockerImageProps}.
   *
   * @public
   */
  export declare class LocalDockerImage extends Action<LocalDockerImageProps, LocalDockerImageState> implements DockerPushableImageInstance {
      static defaultProps: {
          options: {
              dockerHost: string | undefined;
              forceRm: boolean;
          };
      };
      deployedWhenIsTrivial: boolean;
      private image_?;
      private imagePropsJson_?;
      private options_;
      constructor(props: LocalDockerImageProps);
      buildComplete(): boolean;
      ready(): boolean;
      image(): WithId<ImageRefDockerHost> | undefined;
      pushTo({ ref }: {
          ref: string;
      }): Promise<undefined | WithId<ImageRefRegistry>>;
      latestImage(): WithId<ImageRefDockerHost> | undefined;
      /**
       * User-facing name to display in status messages.
       */
      displayName(): string | undefined;
      /**
       * Implementations for Action base class
       * @internal
       */
      shouldAct(op: ChangeType): Promise<ShouldAct>;
      /**
       * Implementations for Action base class
       * @internal
       */
      action(op: ChangeType, ctx: ActionContext): Promise<void>;
      /** @internal */
      initialState(): {};
      /** @internal */
      deployedWhen: (goalStatus: GoalStatus) => true | import("@adpt/core").Waiting;
      /** @internal */
      protected get imagePropsJson(): string;
  }/**
   * Runs a Docker registry in a container.
   * @remarks
   * Implements {@link docker.DockerRegistryInstance}.
   *
   * @public
   */
  export declare function LocalDockerRegistry(props: SFCDeclProps<LocalDockerRegistryProps, typeof defaultProps>): Adapt.JSX.Element;/**
   * Props for {@link docker.LocalDockerRegistry}
   * @public
   */
  export declare interface LocalDockerRegistryProps extends ExcludeKeys<DockerContainerProps, "image"> {
      /**
       * Tag to use for official Docker Hub `registry` image repo.
       */
      imageTag: NameTagString;
      /**
       * Port number to expose for the registry HTTP server.
       */
      port: number;
  }/** @public */
  export declare interface DockerRegistryInstance {
      registry(): RegistryString | undefined;
  }/**
   * Props for {@link docker.RegistryDockerImage}
   * @public
   */
  export declare interface RegistryDockerImageProps {
      /**
       * Handle for image source
       * @remarks
       * Currently, only handle to LocalDockerImage components and compatible
       * interfaces are supported.
       * @privateRemarks
       * FIXME(manishv) support string refs to other registries and handles of
       * other registry images
       */
      imageSrc: Handle<DockerPushableImageInstance>;
      /**
       * Registry and path where the image should be pushed and pulled
       *
       * @remarks
       * If this parameter is a string, registryPrefix will be used for both push and pull
       *
       * If registryPrefix is of the form `{ external: string, internal: string }`, docker images wil be
       * pushed to `external` and image strings will refer to `internal`.
       *
       * Registry prefixes can be of the form `domain/path/elements`, for example `gcr.io/myproject`.
       * However, the registryPrefix should not include the final name, use newPathTag instead.
       *
       * Note(manishv)
       * This is a bit of a hack to allow one hostname or IP address to push images from outside
       * a particular environment (say k8s) and a different URL for that environment to pull
       * images.
       *
       * A good example of this is a k3s-dind (k3s docker-in-docker) instance of kubernetes where
       * a private registry is running on a docker network attached to the k3s-dind instance, but where we
       * want to push {@link docker.LocalDockerImage} built images to that registry.  Since
       * {@link docker.LocalDockerImage | LocalDockerImage} is outside the k3s-dind environment, it must
       * use a host accessible network to push to the registry.  However, since the k3s-dind instance sees
       * the registry from within Docker, it must use a different address to pull the images for use.
       *
       * Once network scopes are fully supported, this interface will change to whatever is appropriate.  It
       * is best if you can arrange to have the same URL or registry string work for all access regardless
       * of which network the registry, Adapt host, and ultimate container running environment is uses.
       */
      registryPrefix: RegistryString | DockerSplitRegistryInfo;
      /**
       * Path and tag to be used for the image in the new registry in
       * `path:tag` or `path` format.
       * @remarks
       * The entire path and tag are blindly concatenated to the domain and path
       * in registryPrefix to form the full ref that will be used to push the
       * image.
       *
       * If omitted, the last component of the path and the tag from the source
       * image is used. The newPathTag should not include the registry
       * hostname/port prefix. If the `:tag` portion of `path:tag` is omitted,
       * the tag `latest` will be used.
       */
      newPathTag?: string;
      /**
       * Path and tag to be used for the image in the new registry in
       * `path:tag` or `path` format.
       * @deprecated This prop has been renamed to `newPathTag`. The functionality
       * for both props is the same and if both are set, `newPathTag` takes
       * priority.
       * @remarks
       * If omitted, the path and tag from the source image is used. The
       * newTag should not include the registry hostname/port prefix. If the
       * `:tag` portion of `path:tag` is omitted, the tag `latest` will be used.
       */
      newTag?: string;
  }/**
   * Represents a Docker image in a registry.
   * @remarks
   * If the image does not exist in the specified registry, it will be pushed
   * to that registry.
   * @public
   */
  export declare class RegistryDockerImage extends Action<RegistryDockerImageProps, State> implements DockerImageInstance {
      private latestImage_?;
      private latestRegistryUrl_?;
      private registry;
      constructor(props: RegistryDockerImageProps);
      /**
       * Returns information about the version of the Docker image that reflects
       * the current set of props for the component and has been pushed to the
       * registry.
       * @remarks
       * Returns undefined if the `props.imageSrc` component's `latestImage` method
       * returns undefined (depending on the component referenced by
       * `props.imageSrc`, that may indicate the source image has not been built).
       * Also returns undefined if the current image has not yet been
       * pushed to the registry.
       */
      image(): ImageRefRegistry | undefined;
      /**
       * Returns information about the most current version of the Docker image
       * that has been pushed to the registry.
       * @remarks
       * Returns undefined if no image has ever been pushed by this component.
       */
      latestImage(): ImageRefRegistry | undefined;
      /** @internal */
      initialState(): {};
      /** @internal */
      shouldAct(diff: ChangeType): false | {
          act: boolean;
          detail: string;
      };
      /** @internal */
      dependsOn: DependsOnMethod;
      /** @internal */
      action(op: ChangeType): Promise<void>;
      private currentNameTag;
      private getNewPathTag;
      private srcImageName;
  }/**
   * Props for {@link docker.ServiceContainerSet}
   *
   * @public
   */
  export declare interface ServiceContainerSetProps extends ServiceProps {
      /**
       * Props to apply to all {@link docker.DockerContainer}s within this
       * ServiceContainerSet. If a prop is specified in the source {@link Container}
       * component and in `containerProps`, `containerProps` will take
       * precedence.
       */
      containerProps?: Partial<DockerContainerProps>;
      /**
       * If set, all children of this ServiceContainerSet that support the
       * `dockerHost` prop will get this value, overriding any other value for
       * this prop.
       */
      dockerHost?: string;
  }/**
   * A component for mapping a group of abstract {@link Container}s and
   * {@link NetworkService}s to Docker {@link docker.DockerContainer | DockerContainer}s
   * and {@link docker.NetworkService}s.
   *
   * @remarks
   * This component is intended to be used to replace {@link Container} and
   * {@link NetworkService} components that are grouped together, as the
   * only children of a common parent in a pattern that looks like this:
   * ```tsx
   * <Service>
   *   <Container ... />
   *   <Container ... />
   *   <NetworkService ... />
   * </Service>
   * ```
   * `ServiceContainerSet` maps those abstract components into Docker components
   * like this:
   * ```tsx
   * <Group>
   *   <docker.DockerContainer ... >
   *   <docker.DockerContainer ... >
   *   <docker.NetworkService ... >
   * </Group>
   * ```
   * An example style rule to do this is:
   * ```tsx
   * {Service}
   * {Adapt.rule((matchedProps) => {
   *     const { handle, ...remainingProps } = matchedProps;
   *     return <ServiceContainerSet {...remainingProps} />;
   * })}
   * ```
   *
   * Currently, {@link docker.NetworkService} implements the {@link NetworkServiceInstance}
   * interface, but does not deploy a network proxy component. So the Docker
   * ServiceContainerSet component applies the network port configuration specified by
   * the {@link NetworkService}s to their target
   * {@link docker.DockerContainer | DockerContainer}s.
   *
   * @public
   */
  export declare class ServiceContainerSet extends DeferredComponent<ServiceContainerSetProps> {
      build(helpers: BuildHelpers): Adapt.JSX.Element;
  }/**
   * Options for interacting with Docker Engine that apply to all
   * operations.
   * @public
   */
  export declare interface DockerGlobalOptions {
      dockerHost?: string;
  }/**
   * Options for performing Docker image builds.
   * @public
   */
  export declare interface DockerBuildOptions extends DockerGlobalOptions {
      /**
       * Requests BuildKit as the internal Docker build engine.
       *
       * @remarks
       * This option requests the use of the BuildKit build engine when building
       * Docker images, if BuildKit is available. This is primarily useful for
       * BuildKit's performance improvements over the legacy Docker build engine.
       * However, because this option does not guarantee BuildKit will be used,
       * BuildKit-only features such as secret mounting should not be used.
       *
       * Internally, this option sets the `DOCKER_BUILDKIT` environment
       * variable when performing builds, which enables BuildKit on Docker
       * systems that support it.
       *
       * For more information, see
       * [Build images with BuildKit](https://docs.docker.com/develop/develop-images/build_enhancements/).
       *
       * @defaultValue `true`
       */
      requestBuildKit?: boolean;
      forceRm?: boolean;
      imageName?: string;
      imageTag?: string;
      prevUniqueNameTag?: string;
      stdin?: string;
      /**
       * If true and the newly built image ID does not match the image ID for
       * prevUniqueNameTag (or prevUniqueNameTag is not set), a new unique nameTag is
       * generated for this image (from imageName and imageTag).
       * If true and the newly built image ID does match the image ID for
       * prevUniqueNameTag, then prevUniqueNameTag is returned as nameTag.
       * If false, imageName and imageTag are used without modification.
       */
      uniqueTag?: boolean;
      /**
       * If set, will add a Docker LABEL with the DeployID.
       */
      deployID?: string;
      buildArgs?: Environment;
  }/**
   * A dynamically-created file that can be used during the build of a Docker
   * image.
   *
   * @remarks
   * These `File` objects are used to create a temporary "scratch" image in a
   * {@link https://docs.docker.com/develop/develop-images/multistage-build/ | multi-stage build}
   * that contains only the specified files. Then, in later stages of that build,
   * the files within the temporary image can be copied into the later stage
   * image.
   * @public
   */
  export declare interface File {
      /**
       * The path in the temporary image where the file will be created.
       */
      path: string;
      /**
       * The contents of the file.
       */
      contents: Buffer | string;
  }/**
   * A stage to be added to a
   * {@link https://docs.docker.com/develop/develop-images/multistage-build/ | multi-stage Docker build}.
   *
   * @remarks
   * The stage will be added to the generated Dockerfile for the image as:
   * ```
   * FROM image as name
   * ```
   * @public
   */
  export declare interface Stage {
      /** The image (name + tag or digest) to use for the stage. */
      image: string;
      /** Name for the stage */
      name: string;
  }/**
   * A string that contains both a Docker repo and a registry digest.
   *
   * @remarks
   * This is a string that represents a specific image on a specific registry
   * contained in a particular repo on that registry. It's of the form:
   * ```
   * [registry/]repo@digest
   * ```
   * `registry` - (optional) The hostname or hostname:port of a Docker registry
   * where the repo is located. If not provided, the official default Docker
   * registry is assumed.
   *
   * `repo` - The more precise name for what's commonly referred to as an image
   * name. It may include 0 or more slashes to denote namespaces.
   *
   * `digest` - The repo digest for the image in the form `algorithm:hex`.
   * This digest is specific to the associated registry and repo and has no
   * significance without those additional pieces of information. If this image is
   * pushed to a different registry, it will have a different digest value.
   * The digest is also known as a "distribution hash".
   *
   * Examples:
   * ```
   * alpine@sha256:04696b491e0cc3c58a75bace8941c14c924b9f313b03ce5029ebbc040ed9dcd9
   * localhost:5000/mockdeploy-htws@sha256:899a03e9816e5283edba63d71ea528cd83576b28a7586cf617ce78af5526f209
   * ```
   * @public
   */
  export declare type RepoDigestString = string;/**
   * Docker image ID, in the form `algorithm:hex`.
   *
   * @remarks
   * The Docker image ID (also known as "Content Hash") is a single value
   * that uniquely identifies a specific image on a local Docker host.
   *
   * An image ID does not require a registry or repo qualifier to be significant.
   * It is distinct from a Docker image
   * {@link docker.RepoDigestString | repo digest}.
   *
   * Example:
   * ```
   * sha256:199e537da3a86126cd6eb114bd0b13ab178dc291bbb6ea4a4a3aa257b2366b71
   * ```
   * @public
   */
  export declare type ImageIdString = string;/**
   * A string reference to a Docker image that contains a repo name, and may
   * contain an optional registry and optional tag.
   *
   * @remarks
   * This is a string that references a Docker image. It's in the form of
   * one of:
   * ```
   * [registry/]repo
   * [registry/]repo:tag
   * ```
   * `registry` - (optional) The hostname or hostname:port of a Docker registry
   * where the repo is located. If not provided, depending on context, either
   * the official default Docker registry may be assumed or the image may just
   * be present locally and not on any registry.
   *
   * `repo` - The more precise name for what's commonly referred to as an image
   * name. It may include 0 or more slashes to denote namespaces.
   *
   * `tag` - A tag string identifying a version of image within the repo.
   *
   * Examples:
   * ```
   * alpine
   * ubuntu:16.04
   * ```
   * @public
   */
  export declare type NameTagString = string;/**
   * A string reference to a Docker image that contains a repo name, and may
   * contain an optional registry and optionally either a tag or a repo digest.
   *
   * @remarks
   * This is a string that references a Docker image. It's in the form of
   * one of:
   * ```
   * [registry/]repo
   * [registry/]repo:tag
   * [registry/]repo@digest
   * ```
   * For more detail, see {@link docker.NameTagString} and
   * {@link docker.RepoDigestString}.
   *
   * Examples:
   * ```
   * alpine
   * ubuntu:16.04
   * alpine@sha256:04696b491e0cc3c58a75bace8941c14c924b9f313b03ce5029ebbc040ed9dcd9
   * localhost:5000/mockdeploy-htws@sha256:899a03e9816e5283edba63d71ea528cd83576b28a7586cf617ce78af5526f209
   * ```
   * @public
   */
  export declare type ImageNameString = NameTagString | RepoDigestString;/**
   * A string that references a Docker registry that contains a hostname and
   * may optionally contain a port and/or path.
   *
   * @remarks
   * This string is in the form of one of:
   * ```
   * hostname[:port]
   * hostname[:port]/path
   * ```
   * This form does not include the protocol, such as `http:` or `https:` in
   * the string.
   *
   * @public
   */
  export declare type RegistryString = string;/**
   * Information about a specific instance of a Docker image, as identified by
   * its image ID.
   * @deprecated Replaced with {@link docker.ImageRef}.
   * @public
   */
  export declare interface ImageInfo {
      /**
       * Docker image ID, in the form `algorithm:hex`.
       * @remarks
       * See {@link docker.ImageIdString}.
       */
      id: ImageIdString;
      /**
       * Docker image name and optional tag in the form `name` or `name:tag`.
       * @remarks
       * See {@link docker.NameTagString}
       */
      nameTag?: NameTagString;
  }/**
   * Props for {@link docker.DockerContainer}
   *
   * @public
   */
  export declare interface DockerContainerProps extends DockerGlobalOptions, Pick<ContainerProps, "autoRemove" | "command" | "environment" | "portBindings" | "ports" | "restartPolicy" | "stopSignal"> {
      /** image name as a string, or a handle to a DockerImage component */
      image: ImageNameString | Handle<DockerImageInstance>;
      /**
       * Host and port of the remote docker host to use.
       *
       * @remarks
       * Defaults to the DOCKER_HOST environment variable
       */
      dockerHost: string;
      /**
       * Labels to apply to the container.
       */
      labels?: ContainerLabels;
      /**
       * Filesystems to be mounted in the container.
       */
      mounts?: Mount[];
      /**
       * Networks to connect the container to
       *
       * @remarks
       * Accepts the same strings as docker network connect
       */
      networks?: string[];
      /**
       * Enables the container to run in privileged mode.
       */
      privileged?: boolean;
  }/**
   * Represents a split registry, with pushes going to external and pulls going to internal
   * @beta
   */
  export declare interface DockerSplitRegistryInfo {
      external: RegistryString;
      internal: RegistryString;
  }/**
   * Describes bind mount filesystems to be mounted in a container.
   * @public
   */
  export declare interface BindMount {
      type: "bind";
      source: string;
      destination: string;
      readonly?: boolean;
      propagation?: "shared" | "slave" | "private" | "rshared" | "rslave" | "rprivate";
  }/**
   * Describes filesystems to be mounted in a container.
   * @public
   */
  export declare type Mount = BindMount;/**
   * Props for {@link docker.BuildKitImage}
   *
   * @public
   */
  export declare interface BuildKitImageProps {
      /** Directory for use as the build context */
      contextDir?: string;
      /**
       * Contents of the dockerfile
       *
       * @remarks
       * Should not be used if dockerfileName is set
       */
      dockerfile?: string;
      /**
       * Path to a local Dockerfile in the Adapt project.
       *
       * @remarks
       * This path is relative to the root of the Adapt project.
       * Should not be used if `dockerfile` is set.
       */
      dockerfileName?: string;
      /**
       * Extra files that should be included during the docker build
       *
       * @remarks
       * BuildKitImage uses a multi-stage build process.  It first creates
       * a temporary image that includes the files specified in this field.
       * This temporary image is then made available to the `dockerfile` with
       * stage name `files` and can then be copied into the final image, as
       * desired, using `COPY` or `ADD` commands in the `dockerfile`.
       *
       * @example
       * To create a final Docker image that contains a file that has some
       * programmatically created content, use the `dockerfile` prop along
       * with the `files` prop like this:
       * ```tsx
       * const files = [{
       *   path: '/path/to/myfile.txt',
       *   contents: 'contents for myfile\n'
       * }];
       * const dockerfile = `
       *   FROM alpine
       *   COPY --from=files /path/to/myfile.txt /app/myfile.txt
       *   ...
       * `;
       * return <BuildKitImage files={files} dockerfile={dockerfile} />
       * ```
       */
      files?: File[];
      /**
       * Options to control the behavior of docker build
       */
      options?: BuildKitBuildOptions;
      /**
       * Directs BuildKit where to store the built image.
       */
      output: BuildKitOutput;
      /**
       * Extra stages to include in a multi-stage docker build
       */
      stages?: Stage[];
  }/**
   * @internal
   */
  export declare interface BuildKitImageState {
      deployOpID?: DeployOpID;
      image?: WithId<ImageRefRegistry>;
      imagePropsJson?: string;
      prevUniqueNameTag?: string;
  }/**
   * Locally builds a docker image
   *
   * @remarks
   * See {@link docker.BuildKitImageProps}.
   *
   * @public
   */
  export declare class BuildKitImage extends Action<BuildKitImageProps, BuildKitImageState> implements DockerPushableImageInstance {
      static defaultProps: {
          options: {};
      };
      deployedWhenIsTrivial: boolean;
      private image_?;
      private imagePropsJson_?;
      private options_;
      constructor(props: BuildKitImageProps);
      buildComplete(): boolean;
      ready(): boolean;
      image(): WithId<ImageRefRegistry> | undefined;
      pushTo({ ref }: {
          ref: string;
      }): Promise<undefined | WithId<ImageRefRegistry>>;
      latestImage(): WithId<ImageRefRegistry> | undefined;
      /**
       * User-facing name to display in status messages.
       */
      displayName(): string;
      /**
       * Implementations for Action base class
       * @internal
       */
      shouldAct(op: ChangeType): Promise<ShouldAct>;
      /**
       * Implementations for Action base class
       * @internal
       */
      action(op: ChangeType, ctx: ActionContext): Promise<void>;
      /** @internal */
      initialState(): {};
      /** @internal */
      deployedWhen: (goalStatus: GoalStatus) => true | import("@adpt/core").Waiting;
      /** @internal */
      protected get imagePropsJson(): string;
  }/**
   * Components that provide a Docker image can implement this interface to
   * allow other components to get information about the Docker image.
   * @public
   */
  export declare interface DockerImageInstance {
      /**
       * Returns information about the version of the Docker image that reflects
       * the current set of props for the component.
       * @remarks
       * Returns undefined if no image has ever been built by
       * this component OR if the component props have changed and the image
       * that corresponds to the current props has not yet been built.
       */
      image(): ImageRef | undefined;
      /**
       * Returns information about the most current version of the Docker image
       * that has completed building, even if that version does not reflect the
       * current set of props for the component.
       * @remarks
       * Returns undefined if no image has ever been built by this component.
       */
      latestImage(): ImageRef | undefined;
      /**
       * Pushes the image returned by `latestImage` to a Docker registry.
       *
       * @param ref - A docker domain, path components, and tag to which this image should be pushed
       *
       * @remarks
       * If there is no latest image available (`latestImage` returns
       * undefined), then `pushTo` will return undefined. Otherwise, if the
       * push was successful, returns an {@link docker.ImageRefRegistry} that contains
       * the complete nameTag, including registry portion.
       */
      pushTo?({ ref }: {
          ref: NameTagString;
      }): MaybePromise<ImageRefRegistry | undefined>;
  }/**
   * Components that provide a Docker image can implement this interface to
   * allow other components to get information about the Docker image and
   * to be able to push the image to a registry.
   * @public
   */
  export declare interface DockerPushableImageInstance extends DockerImageInstance {
      /**
       * {@inheritdoc docker.DockerImageInstance.pushTo}
       */
      pushTo({ ref }: {
          ref: NameTagString;
      }): MaybePromise<ImageRefRegistry | undefined>;
  }/**
   * Props for {@link docker.DockerImage}.
   * @beta
   */
  export declare interface DockerImageProps {
  }/**
   * Abstract component representing a {@link https://docker.com | Docker}
   * image that can be used to create containers.
   * @remarks
   * See also {@link Container}.
   * @beta
   */
  export declare abstract class DockerImage extends Component<DockerImageProps> implements DockerImageInstance {
      /**
       * {@inheritdoc docker.DockerImageInstance.image}
       */
      image(): ImageRef | undefined;
      /**
       * {@inheritdoc docker.DockerImageInstance.latestImage}
       */
      latestImage(): ImageRef | undefined;
  }/**
   * Compute the status of a container based on a graphQL schema
   *
   * @internal
   */
  export declare function containerStatus(observe: ObserveForStatus, containerName: string, dockerHost: string): Promise<ContainerStatus | NoStatus>;/** @public */
  export declare interface DockerContainerStatus extends ContainerStatus {
  }/**
   * Compute a unique name for the container
   *
   * @internal
   */
  const computeContainerName: (elemKey: string, elemID: string, deployID: string) => string;/**
   * Component to instantiate an image container with docker
   *
   * @remarks
   * See {@link docker.DockerContainerProps}.
   *
   * @public
   */
  declare class DockerContainer extends Action<DockerContainerProps, DockerContainerState> {
      static defaultProps: {
          dockerHost: string;
          privileged: boolean;
      };
      info?: ContainerInfo;
      dependsOn: DependsOnMethod;
      /** @internal */
      shouldAct(diff: ChangeType, context: ActionContext): Promise<false | ShouldAct>;
      /** @internal */
      action(diff: ChangeType, context: ActionContext): Promise<void>;
      status(observe: ObserveForStatus, buildData: BuildData): Promise<NoStatus | ContainerStatus>;
      /**
       * Get the IP address of the container, optionally for a specific Docker
       * network.
       * @remarks
       * The IP addresses that are returned by this function are valid only
       * on the associated Docker network, which is often only associated
       * with a single host node for most Docker network types.
       *
       * @param network - Name of a Docker network. If `network` is provided
       * and the container is connected to the network with an IP address, that
       * address will be returned. If the container is not connected to the
       * network, `undefined` will be returned. If `network` is not provided,
       * the default container IP address will be returned.
       *
       * @beta
       */
      dockerIP(network?: string): string | undefined;
      /** @internal */
      initialState(): {};
      private displayName;
      private refreshContainerInfo;
  }/**
   * Component to instantiate an image container with docker
   *
   * @remarks
   * See {@link docker.DockerContainerProps}.
   *
   * @public
   */
  declare class DockerContainer extends Action<DockerContainerProps, DockerContainerState> {
      static defaultProps: {
          dockerHost: string;
          privileged: boolean;
      };
      info?: ContainerInfo;
      dependsOn: DependsOnMethod;
      /** @internal */
      shouldAct(diff: ChangeType, context: ActionContext): Promise<false | ShouldAct>;
      /** @internal */
      action(diff: ChangeType, context: ActionContext): Promise<void>;
      status(observe: ObserveForStatus, buildData: BuildData): Promise<NoStatus | ContainerStatus>;
      /**
       * Get the IP address of the container, optionally for a specific Docker
       * network.
       * @remarks
       * The IP addresses that are returned by this function are valid only
       * on the associated Docker network, which is often only associated
       * with a single host node for most Docker network types.
       *
       * @param network - Name of a Docker network. If `network` is provided
       * and the container is connected to the network with an IP address, that
       * address will be returned. If the container is not connected to the
       * network, `undefined` will be returned. If `network` is not provided,
       * the default container IP address will be returned.
       *
       * @beta
       */
      dockerIP(network?: string): string | undefined;
      /** @internal */
      initialState(): {};
      private displayName;
      private refreshContainerInfo;
  }/**
   * Type guard for determining whether a given object has a non-null `id`
   * property.
   * @public
   */
  export declare function hasId<T extends {
      id?: ImageIdString;
  }>(o: T): o is WithId<T>;/**
   * Factory function for creating a {@link docker.MutableImageRef}.
   * @remarks
   * Can also be used to clone an existing {@link docker.MutableImageRef} or
   * to create a mutable version of an existing {@link docker.ImageRef}.
   * @public
   */
  export declare function mutableImageRef(ref: ImageNameString, normalize?: boolean): MutableImageRef;/**
   * Factory function for creating a {@link docker.MutableImageRef}.
   * @remarks
   * Can also be used to clone an existing {@link docker.MutableImageRef} or
   * to create a mutable version of an existing {@link docker.ImageRef}.
   * @public
   */
  export declare function mutableImageRef(info?: ImageRefData): MutableImageRef;/**
   * Factory function for creating a {@link docker.ImageRef} or cloning an
   * existing one.
   * @public
   */
  export declare function imageRef(ref: ImageNameString, normalize?: boolean): ImageRef;/**
   * Factory function for creating a {@link docker.ImageRef} or cloning an
   * existing one.
   * @public
   */
  export declare function imageRef(info?: ImageRefData): ImageRef;/**
   * A type guard for determining whether a {@link docker.ImageRef} is a
   * {@link docker.ImageRefRegistry}.
   * @public
   */
  export declare function isImageRefRegistry(ref: ImageRef): ref is ImageRefRegistry;/**
   * A type guard for determining whether a {@link docker.ImageRef} is a
   * {@link docker.ImageRefRegistry} that has the `id` property set.
   * @public
   */
  export declare function isImageRefRegistryWithId(ref: ImageRef): ref is WithId<ImageRefRegistry>;/**
   * A type guard for determining whether a {@link docker.ImageRef} is a
   * {@link docker.ImageRefDockerHost}.
   * @public
   */
  export declare function isImageRefDockerhost(ref: ImageRef): ref is ImageRefDockerHost;/**
   * A type guard for determining whether a {@link docker.ImageRef} is a
   * {@link docker.ImageRefDockerHost} that has the `id` property set.
   * @public
   */
  export declare function isImageRefDockerhostWithId(ref: ImageRef): ref is WithId<ImageRefDockerHost>;/**
   * The most basic components that make up a {@link docker.ImageRef}.
   * All other properties of a {@link docker.ImageRef} can be computed from
   * these.
   * @remarks
   * See also {@link docker.ImageRef} for more information on references.
   * @public
   */
  export declare interface ImageRefData {
      /**
       * Image digest in the form `algorithm:hex`
       * @example
       * sha256:04696b491e0cc3c58a75bace8941c14c924b9f313b03ce5029ebbc040ed9dcd9
       */
      digest?: string;
      /**
       * Docker host string to contact the Docker daemon where this image is
       * located.
       *
       * @remarks
       * This should be in the same format that Docker expects for the `DOCKER_HOST`
       * environment variable. The special string `default` can also be used,
       * which will use the current value of the `DOCKER_HOST` environment variable,
       * if it is set and will otherwise use the default named pipe on Windows
       * (`npipe:///./pipe/docker_engine`) and the default socket on other
       * systems (`unix:///var/run/docker.sock`).
       * @example
       * tcp://localhost:2375
       */
      dockerHost?: "default" | string;
      /**
       * Hostname and optional port number of the container image registry where
       * this image is located.
       * @example
       * docker.io
       * @example
       * localhost:5000
       */
      domain?: RegistryString;
      /**
       * Image content ID in the form `algorithm:hex`
       * @example
       * sha256:199e537da3a86126cd6eb114bd0b13ab178dc291bbb6ea4a4a3aa257b2366b71
       */
      id?: ImageIdString;
      /**
       * The image repo path.
       * @example
       * google/cloud-sdk
       */
      path?: string;
      /**
       * Image tag
       * @example
       * latest
       */
      tag?: string;
  }/**
   * The type of an image reference indicates how the image can be
   * accessed, currently either through a Docker host (daemon) or directly to a
   * container registry via its API.
   *
   * @remarks
   * If not enough information is present to access and uniquely identify a
   * container image, the type is `incomplete`.
   * @public
   */
  export declare type ImageRefType = "incomplete" | "registry" | "dockerhost";/**
   * An immutable reference to a container image, including all information
   * known about the image.
   *
   * @remarks
   * This type is the base type for an image reference and is allowed to
   * contain partial or incomplete information about a container image.
   * It can include both information about how to access the image and
   * also information about the image itself.
   *
   * Many of the properties of {@link docker.ImageRef} are related to the
   * container image reference string used by Docker and other container-based
   * systems. A container image reference string is a structured string
   * containing multiple components. The most basic components are illustrated
   * below, using the example image reference string
   * `"my.registry:5000/a/repo/path:sometag@sha256:899a03e9816e5283edba63d"`.
   *
   * NOTE: The length of the `digest` has been shortened for formatting
   * purposes.
   *
   * ```
   * "my.registry:5000/a/repo/path:sometag@sha256:899a03e9816e5283edba63d"
   * |     domain     |   path    |  tag  |         digest               |
   * ```
   *
   * To aid in correct formatting, {@link docker.ImageRef} and related types and
   * classes also provide helper properties that combine these basic components
   * into combinations that are often useful, such as `name`, which is the
   * `domain` and `path` combined with a `/`.
   *
   * Many tools, such as the Docker UI, also accept a shortened form of a string
   * reference, called the `familiar` form. An example of a familiar reference is
   * `ubuntu`. In this form, only the `path` component is required. When
   * components of the reference are left out, default values are assumed. The
   * default `domain` is `docker.io` and the default `tag` is `latest`.
   * Additionally, if the `domain` is `docker.io` and there are no `/` characters
   * in the `path`, `library/` is prepended to the path. So `ubuntu` is the
   * familiar form for the complete reference `docker.io/library/ubuntu:latest`.
   *
   * An {@link docker.ImageRef} is designed to hold as much information about
   * an image as may be available and therefore some properties that are
   * not known will be `undefined`.
   *
   * See also {@link docker.MutableImageRef}, which can be used to parse
   * reference strings and construct or modify image references.
   * @public
   */
  export declare interface ImageRef extends Readonly<ImageRefData> {
      /**
       * The complete string reference for this image in familiar form, which
       * leaves out certain fields from the reference when they are set to
       * default values.
       * @remarks
       * This reference form is the form typically used in the Docker UI.
       * If the ImageRef is not complete, familiar will return `undefined`, as
       * the correct familiar representation cannot be determined.
       * @example
       * mysql
       * @example
       * gcr.io/my-project/image:1.0.1
       */
      readonly familiar?: string;
      /**
       * The image name, which is comprised of the optional domain and
       * the (non-optional) path. Will be `undefined` if there is no `path`.
       * @example
       * gcr.io/my-project/image
       */
      readonly name?: string;
      /**
       * The image name (including any registry) and image tag. Returns undefined
       * if either path or tag are not set.
       * If nameTag is set to a string that does not contain a tag (i.e. does
       * not include a ":"), the default tag of `latest` will be set.
       * To set nameTag without defaulting to `latest`, call the class method
       * `setNameTag` with the parameter `useDefaultTag` set to `false`.
       * @example
       * gcr.io/my-project/image:1.0.1
       */
      readonly nameTag?: string;
      /**
       * The image path (not including any registry) and image tag. Returns
       * undefined if either `path` or `tag` are not set.
       * @example
       * my-project/image:1.0.1
       */
      readonly pathTag?: string;
      /**
       * The best (most specific and complete) string reference for this image,
       * given the information available in this {@link docker.ImageRef}.
       */
      readonly ref: string;
      /**
       * An alias for `domain`.
       */
      readonly registry?: string;
      /**
       * The best remote reference available for this image in either
       * `domain/path@digest` format or `domain/path:tag` format.
       * @remarks
       * Returns `registryDigest` if it is set, otherwise returns `registryTag`.
       * If no remote reference is available, returns undefined.
       * @example
       * gcr.io/my-project/image\@sha256:899a03e9816e5283edba63d71ea528cd83576b28a7586cf617ce78af5526f209
       * @example
       * gcr.io/my-project/image:1.0.1
       */
      readonly registryRef?: string;
      /**
       * The remote digest reference in `domain/path@digest` form.
       * @remarks
       * Undefined if any of `domain`, `path`, or `digest` are unset.
       * @example
       * gcr.io/my-project/image\@sha256:899a03e9816e5283edba63d71ea528cd83576b28a7586cf617ce78af5526f209
       */
      readonly registryDigest?: string;
      /**
       * The remote tag reference in `domain/path:tag` form.
       * @remarks
       * Undefined if any of `domain`, `path`, or `tag` are unset.
       * @example
       * gcr.io/my-project/image:1.0.1
       */
      readonly registryTag?: string;
      /**
       * The type of an image reference indicates how the image can be
       * accessed, either through a Docker host (daemon) or directly to a
       * container registry.
       *
       * @remarks
       * A reference is a valid `dockerhost` type ref when it contains a valid
       * dockerHost string and either:
       * - A valid image id or
       * - A valid path and either a valid tag or digest.
       *
       * A reference is a valid `registry` type ref when it contains a valid
       * domain, path, and either a tag or a digest.
       *
       * If not enough information is present to access and uniquely identify a
       * container image, the type is `incomplete`.
       */
      readonly type: ImageRefType;
  }/**
   * Helper type that augments a base type to indicate that the `id` field
   * is present and has a valid image ID.
   * @public
   */
  export declare type WithId<T> = T & {
      id: ImageIdString;
  };/**
   * A mutable reference to a container image that can be used to parse,
   * construct, and modify an image reference, as well as to hold information
   * about the image and how to access it.
   *
   * @remarks
   * This class can be used to parse strings that contain complete or partial
   * container image references. It can also be used to construct an image
   * reference from scratch, from individual component parts, or from another
   * reference, then to correctly format the reference or its components for
   * use with various tools.
   *
   * To parse and normalize a "familiar" image reference, like is typically
   * seen in the Docker UI:
   * ```ts
   * const ref = mutableImageRef("redis", true);
   * console.log(ref.tag);         // => "latest"
   * console.log(ref.registryRef); // => "docker.io/library/redis:latest"
   * ```
   *
   * To construct a reference to an image present on the local Docker daemon
   * that has an image ID:
   * ```ts
   * const ref = mutableImageRef({
   *     dockerHost: "default",
   *     path: "myimage",
   *     tag: "just-built",
   *     id: "sha256:04696b491e0cc3c58a75bace8941c14c924b9f313b03ce5029ebbc040ed9dcd9",
   * });
   * ```
   *
   * To convert a `MutableImageRef` to an immutable plain object `ImageRef`,
   * use the `freeze` method.
   * @public
   */
  export declare class MutableImageRef implements ImageRef {
      _digest?: string;
      _dockerHost?: string;
      _domain?: string;
      _id?: ImageIdString;
      _path?: string;
      _tag?: string;
      constructor(ref: ImageNameString, normalize?: boolean);
      constructor(info?: ImageRefData | undefined);
      freeze(): ImageRef;
      toData(): ImageRefData;
      toJSON(): ImageRefData;
      /**
       * The digest string for this image in its associated registry and repo
       * in the form `algorithm:hex`.
       */
      get digest(): string | undefined;
      set digest(digest: string | undefined);
      get dockerHost(): string | undefined;
      set dockerHost(dockerHost: string | undefined);
      /**
       * The hostname and optional port of the image registry for this image.
       */
      get domain(): string | undefined;
      set domain(domain: string | undefined);
      /**
       * The complete string reference for this image in familiar form, which
       * leaves out certain fields from the reference when they are set to
       * default values.
       * @remarks
       * This reference form is the form typically used in the Docker UI.
       * If the ImageRef is not complete, familiar will return `undefined`, as
       * the correct familiar representation cannot be determined.
       */
      get familiar(): string | undefined;
      /**
       * The content ID of the image in `algorithm:hex` format.
       */
      get id(): ImageIdString | undefined;
      set id(id: ImageIdString | undefined);
      /**
       * The image name, which is comprised of the optional domain and
       * the (non-optional) path.
       */
      get name(): string | undefined;
      set name(name: string | undefined);
      /**
       * The image name (including any registry) and image tag. Returns undefined
       * if either path or tag are not set.
       * If nameTag is set to a string that does not contain a tag (i.e. does
       * not include a ":"), the default tag of `latest` will be set.
       * To set nameTag without defaulting to `latest`, call the class method
       * `setNameTag` with the parameter `useDefaultTag` set to `false`.
       */
      get nameTag(): NameTagString | undefined;
      set nameTag(nt: NameTagString | undefined);
      /**
       * Method to set the image name and image tag which also allows choice
       * of default behavior when `nameTag` does not contain a tag string.
       */
      setNameTag(nameTag: NameTagString | undefined, useDefaultTag?: boolean): void;
      /**
       * The image repo path.
       */
      get path(): string | undefined;
      set path(path: string | undefined);
      /**
       * The image path (not including any registry) and image tag. Returns
       * undefined if either path or tag are not set.
       * If pathTag is set to a string that does not contain a tag (i.e. does
       * not include a ":"), the default tag of `latest` will be set.
       * To set pathTag without defaulting to `latest`, call the class method
       * `setPathTag` with the parameter `useDefaultTag` set to `false`.
       */
      get pathTag(): string | undefined;
      set pathTag(pathTag: string | undefined);
      /**
       * Method to set the image path and image tag which also allows choice
       * of default behavior when `pathTag` does not contain a tag string.
       */
      setPathTag(pathTag: string | undefined, useDefaultTag?: boolean): void;
      get ref(): string;
      /**
       * Alias for domain
       */
      get registry(): string | undefined;
      /**
       * The best remote reference available for this image in either
       * `domain/path@digest` format or `domain/path:tag` format.
       * @remarks
       * Returns `registryDigest` if it is set, otherwise returns `registryTag`.
       * If no remote reference is available, returns undefined.
       */
      get registryRef(): ImageNameString | undefined;
      /**
       * The remote digest reference in `domain/path@digest` form.
       * @remarks
       * Undefined if any of `domain`, `path`, or `digest` are unset.
       */
      get registryDigest(): RepoDigestString | undefined;
      set registryDigest(rd: RepoDigestString | undefined);
      /**
       * The remote tag reference in `domain/path:tag` form.
       * @remarks
       * Undefined if any of `domain`, `path`, or `tag` are unset.
       */
      get registryTag(): NameTagString | undefined;
      set registryTag(rt: NameTagString | undefined);
      /**
       * The image tag.
       */
      get tag(): string | undefined;
      set tag(tag: string | undefined);
      /**
       * The type of an image reference indicates how the image can be
       * accessed, either through a Docker host (daemon) or directly to a
       * container registry.
       *
       * @remarks
       * A reference is a valid `dockerhost` type ref when it contains a valid
       * dockerHost string and either:
       * - A valid image id or
       * - A valid path and either a valid tag or digest.
       *
       * A reference is a valid `registry` type ref when it contains a valid
       * domain, path, and either a tag or a digest.
       *
       * If not enough information is present to access and uniquely identify a
       * container image, the type is `incomplete`.
       */
      get type(): ImageRefType;
  }/**
   * A more specific type of {@link docker.ImageRef} that contains sufficient
   * information to uniquely identify an image on a container registry.
   * @public
   */
  export declare interface ImageRefRegistry {
      readonly digest?: string;
      readonly domain: string;
      readonly familiar: string;
      readonly id?: ImageIdString;
      readonly name: string;
      readonly nameTag?: string;
      readonly path: string;
      readonly pathTag?: string;
      readonly ref: string;
      readonly registry: string;
      readonly registryRef: string;
      readonly registryDigest?: string;
      readonly registryTag?: string;
      readonly tag?: string;
      readonly type: "registry";
  }/**
   * A more specific type of {@link docker.ImageRef} that contains sufficient
   * information to uniquely identify an image on a specific Docker host
   * (daemon).
   * @public
   */
  export declare interface ImageRefDockerHost {
      readonly digest?: string;
      readonly dockerHost: string;
      readonly domain?: string;
      readonly familiar: string;
      readonly id?: ImageIdString;
      readonly name: string;
      readonly nameTag?: string;
      readonly path: string;
      readonly pathTag?: string;
      readonly ref: string;
      readonly registry?: string;
      readonly registryRef?: string;
      readonly registryDigest?: string;
      readonly registryTag?: string;
      readonly tag?: string;
      readonly type: "dockerhost";
  }/**
   * Docker network service component, compatible with the abstract
   * {@link NetworkService} component.
   *
   * @remarks
   *
   * Implements the {@link NetworkServiceInstance} interface.
   * In a Docker deployment, there is no actual network service object to deploy.
   * So this is a "virtual" component that simply implements the required
   * instance methods for a NetworkService, but renders to null.
   *
   * This component is typically used by {@link docker.ServiceContainerSet}. The
   * {@link docker.ServiceContainerSet} component can be used to ensure the proper
   * network port configuration is applied to the `props.endpoint` container.
   *
   * @public
   */
  export declare function NetworkService(props: SFCDeclProps<NetworkServiceProps, typeof defaultProps>): null;/**
   * The base string used for Adapt Docker labels.
   * @internal
   */
  const adaptDockerKey = "org.adaptjs";/**
   * Docker label for the deployID the object was created from.
   * @internal
   */
  const adaptDockerDeployIDKey: string;/**
   * Props for {@link docker.LocalDockerImage}
   *
   * @public
   */
  export declare interface LocalDockerImageProps {
      /** Directory for use as the build context in docker build */
      contextDir?: string;
      /**
       * Contents of the dockerfile
       *
       * @remarks
       * Should not be used if dockerfileName is set
       */
      dockerfile?: string;
      /**
       * Path to a local Dockerfile in the Adapt project.
       *
       * @remarks
       * This path is relative to the root of the Adapt project.
       * Should not be used if `dockerfile` is set.
       */
      dockerfileName?: string;
      /**
       * Extra files that should be included during the docker build
       *
       * @remarks
       * LocalDockerImage uses a multi-stage build process.  It first creates
       * a temporary image that includes the files specified in this field.
       * This temporary image is then made available to the `dockerfile` with
       * stage name `files` and can then be copied into the final image, as
       * desired, using `COPY` or `ADD` commands in the `dockerfile`.
       *
       * @example
       * To create a final Docker image that contains a file that has some
       * programmatically created content, use the `dockerfile` prop along
       * with the `files` prop like this:
       * ```tsx
       * const files = [{
       *   path: '/path/to/myfile.txt',
       *   contents: 'contents for myfile\n'
       * }];
       * const dockerfile = `
       *   FROM alpine
       *   COPY --from=files /path/to/myfile.txt /app/myfile.txt
       *   ...
       * `;
       * return <LocalDockerImage files={files} dockerfile={dockerfile} />
       * ```
       */
      files?: File[];
      /**
       * Options to control the behavior of docker build
       */
      options?: DockerBuildOptions;
      /**
       * Extra stages to include in a multi-stage docker build
       */
      stages?: Stage[];
  }/**
   * @internal
   */
  export declare interface LocalDockerImageState {
      deployOpID?: DeployOpID;
      image?: WithId<ImageRefDockerHost>;
      imagePropsJson?: string;
      prevUniqueNameTag?: string;
  }/**
   * Locally builds a docker image
   *
   * @remarks
   * See {@link docker.LocalDockerImageProps}.
   *
   * @public
   */
  export declare class LocalDockerImage extends Action<LocalDockerImageProps, LocalDockerImageState> implements DockerPushableImageInstance {
      static defaultProps: {
          options: {
              dockerHost: string | undefined;
              forceRm: boolean;
          };
      };
      deployedWhenIsTrivial: boolean;
      private image_?;
      private imagePropsJson_?;
      private options_;
      constructor(props: LocalDockerImageProps);
      buildComplete(): boolean;
      ready(): boolean;
      image(): WithId<ImageRefDockerHost> | undefined;
      pushTo({ ref }: {
          ref: string;
      }): Promise<undefined | WithId<ImageRefRegistry>>;
      latestImage(): WithId<ImageRefDockerHost> | undefined;
      /**
       * User-facing name to display in status messages.
       */
      displayName(): string | undefined;
      /**
       * Implementations for Action base class
       * @internal
       */
      shouldAct(op: ChangeType): Promise<ShouldAct>;
      /**
       * Implementations for Action base class
       * @internal
       */
      action(op: ChangeType, ctx: ActionContext): Promise<void>;
      /** @internal */
      initialState(): {};
      /** @internal */
      deployedWhen: (goalStatus: GoalStatus) => true | import("@adpt/core").Waiting;
      /** @internal */
      protected get imagePropsJson(): string;
  }/**
   * Runs a Docker registry in a container.
   * @remarks
   * Implements {@link docker.DockerRegistryInstance}.
   *
   * @public
   */
  export declare function LocalDockerRegistry(props: SFCDeclProps<LocalDockerRegistryProps, typeof defaultProps>): Adapt.JSX.Element;/**
   * Props for {@link docker.LocalDockerRegistry}
   * @public
   */
  export declare interface LocalDockerRegistryProps extends ExcludeKeys<DockerContainerProps, "image"> {
      /**
       * Tag to use for official Docker Hub `registry` image repo.
       */
      imageTag: NameTagString;
      /**
       * Port number to expose for the registry HTTP server.
       */
      port: number;
  }/** @public */
  export declare interface DockerRegistryInstance {
      registry(): RegistryString | undefined;
  }/**
   * Props for {@link docker.RegistryDockerImage}
   * @public
   */
  export declare interface RegistryDockerImageProps {
      /**
       * Handle for image source
       * @remarks
       * Currently, only handle to LocalDockerImage components and compatible
       * interfaces are supported.
       * @privateRemarks
       * FIXME(manishv) support string refs to other registries and handles of
       * other registry images
       */
      imageSrc: Handle<DockerPushableImageInstance>;
      /**
       * Registry and path where the image should be pushed and pulled
       *
       * @remarks
       * If this parameter is a string, registryPrefix will be used for both push and pull
       *
       * If registryPrefix is of the form `{ external: string, internal: string }`, docker images wil be
       * pushed to `external` and image strings will refer to `internal`.
       *
       * Registry prefixes can be of the form `domain/path/elements`, for example `gcr.io/myproject`.
       * However, the registryPrefix should not include the final name, use newPathTag instead.
       *
       * Note(manishv)
       * This is a bit of a hack to allow one hostname or IP address to push images from outside
       * a particular environment (say k8s) and a different URL for that environment to pull
       * images.
       *
       * A good example of this is a k3s-dind (k3s docker-in-docker) instance of kubernetes where
       * a private registry is running on a docker network attached to the k3s-dind instance, but where we
       * want to push {@link docker.LocalDockerImage} built images to that registry.  Since
       * {@link docker.LocalDockerImage | LocalDockerImage} is outside the k3s-dind environment, it must
       * use a host accessible network to push to the registry.  However, since the k3s-dind instance sees
       * the registry from within Docker, it must use a different address to pull the images for use.
       *
       * Once network scopes are fully supported, this interface will change to whatever is appropriate.  It
       * is best if you can arrange to have the same URL or registry string work for all access regardless
       * of which network the registry, Adapt host, and ultimate container running environment is uses.
       */
      registryPrefix: RegistryString | DockerSplitRegistryInfo;
      /**
       * Path and tag to be used for the image in the new registry in
       * `path:tag` or `path` format.
       * @remarks
       * The entire path and tag are blindly concatenated to the domain and path
       * in registryPrefix to form the full ref that will be used to push the
       * image.
       *
       * If omitted, the last component of the path and the tag from the source
       * image is used. The newPathTag should not include the registry
       * hostname/port prefix. If the `:tag` portion of `path:tag` is omitted,
       * the tag `latest` will be used.
       */
      newPathTag?: string;
      /**
       * Path and tag to be used for the image in the new registry in
       * `path:tag` or `path` format.
       * @deprecated This prop has been renamed to `newPathTag`. The functionality
       * for both props is the same and if both are set, `newPathTag` takes
       * priority.
       * @remarks
       * If omitted, the path and tag from the source image is used. The
       * newTag should not include the registry hostname/port prefix. If the
       * `:tag` portion of `path:tag` is omitted, the tag `latest` will be used.
       */
      newTag?: string;
  }/**
   * Represents a Docker image in a registry.
   * @remarks
   * If the image does not exist in the specified registry, it will be pushed
   * to that registry.
   * @public
   */
  export declare class RegistryDockerImage extends Action<RegistryDockerImageProps, State> implements DockerImageInstance {
      private latestImage_?;
      private latestRegistryUrl_?;
      private registry;
      constructor(props: RegistryDockerImageProps);
      /**
       * Returns information about the version of the Docker image that reflects
       * the current set of props for the component and has been pushed to the
       * registry.
       * @remarks
       * Returns undefined if the `props.imageSrc` component's `latestImage` method
       * returns undefined (depending on the component referenced by
       * `props.imageSrc`, that may indicate the source image has not been built).
       * Also returns undefined if the current image has not yet been
       * pushed to the registry.
       */
      image(): ImageRefRegistry | undefined;
      /**
       * Returns information about the most current version of the Docker image
       * that has been pushed to the registry.
       * @remarks
       * Returns undefined if no image has ever been pushed by this component.
       */
      latestImage(): ImageRefRegistry | undefined;
      /** @internal */
      initialState(): {};
      /** @internal */
      shouldAct(diff: ChangeType): false | {
          act: boolean;
          detail: string;
      };
      /** @internal */
      dependsOn: DependsOnMethod;
      /** @internal */
      action(op: ChangeType): Promise<void>;
      private currentNameTag;
      private getNewPathTag;
      private srcImageName;
  }/**
   * Props for {@link docker.ServiceContainerSet}
   *
   * @public
   */
  export declare interface ServiceContainerSetProps extends ServiceProps {
      /**
       * Props to apply to all {@link docker.DockerContainer}s within this
       * ServiceContainerSet. If a prop is specified in the source {@link Container}
       * component and in `containerProps`, `containerProps` will take
       * precedence.
       */
      containerProps?: Partial<DockerContainerProps>;
      /**
       * If set, all children of this ServiceContainerSet that support the
       * `dockerHost` prop will get this value, overriding any other value for
       * this prop.
       */
      dockerHost?: string;
  }/**
   * A component for mapping a group of abstract {@link Container}s and
   * {@link NetworkService}s to Docker {@link docker.DockerContainer | DockerContainer}s
   * and {@link docker.NetworkService}s.
   *
   * @remarks
   * This component is intended to be used to replace {@link Container} and
   * {@link NetworkService} components that are grouped together, as the
   * only children of a common parent in a pattern that looks like this:
   * ```tsx
   * <Service>
   *   <Container ... />
   *   <Container ... />
   *   <NetworkService ... />
   * </Service>
   * ```
   * `ServiceContainerSet` maps those abstract components into Docker components
   * like this:
   * ```tsx
   * <Group>
   *   <docker.DockerContainer ... >
   *   <docker.DockerContainer ... >
   *   <docker.NetworkService ... >
   * </Group>
   * ```
   * An example style rule to do this is:
   * ```tsx
   * {Service}
   * {Adapt.rule((matchedProps) => {
   *     const { handle, ...remainingProps } = matchedProps;
   *     return <ServiceContainerSet {...remainingProps} />;
   * })}
   * ```
   *
   * Currently, {@link docker.NetworkService} implements the {@link NetworkServiceInstance}
   * interface, but does not deploy a network proxy component. So the Docker
   * ServiceContainerSet component applies the network port configuration specified by
   * the {@link NetworkService}s to their target
   * {@link docker.DockerContainer | DockerContainer}s.
   *
   * @public
   */
  export declare class ServiceContainerSet extends DeferredComponent<ServiceContainerSetProps> {
      build(helpers: BuildHelpers): Adapt.JSX.Element;
  }/**
   * Options for interacting with Docker Engine that apply to all
   * operations.
   * @public
   */
  export declare interface DockerGlobalOptions {
      dockerHost?: string;
  }/**
   * Options for performing Docker image builds.
   * @public
   */
  export declare interface DockerBuildOptions extends DockerGlobalOptions {
      /**
       * Requests BuildKit as the internal Docker build engine.
       *
       * @remarks
       * This option requests the use of the BuildKit build engine when building
       * Docker images, if BuildKit is available. This is primarily useful for
       * BuildKit's performance improvements over the legacy Docker build engine.
       * However, because this option does not guarantee BuildKit will be used,
       * BuildKit-only features such as secret mounting should not be used.
       *
       * Internally, this option sets the `DOCKER_BUILDKIT` environment
       * variable when performing builds, which enables BuildKit on Docker
       * systems that support it.
       *
       * For more information, see
       * [Build images with BuildKit](https://docs.docker.com/develop/develop-images/build_enhancements/).
       *
       * @defaultValue `true`
       */
      requestBuildKit?: boolean;
      forceRm?: boolean;
      imageName?: string;
      imageTag?: string;
      prevUniqueNameTag?: string;
      stdin?: string;
      /**
       * If true and the newly built image ID does not match the image ID for
       * prevUniqueNameTag (or prevUniqueNameTag is not set), a new unique nameTag is
       * generated for this image (from imageName and imageTag).
       * If true and the newly built image ID does match the image ID for
       * prevUniqueNameTag, then prevUniqueNameTag is returned as nameTag.
       * If false, imageName and imageTag are used without modification.
       */
      uniqueTag?: boolean;
      /**
       * If set, will add a Docker LABEL with the DeployID.
       */
      deployID?: string;
      buildArgs?: Environment;
  }/**
   * A dynamically-created file that can be used during the build of a Docker
   * image.
   *
   * @remarks
   * These `File` objects are used to create a temporary "scratch" image in a
   * {@link https://docs.docker.com/develop/develop-images/multistage-build/ | multi-stage build}
   * that contains only the specified files. Then, in later stages of that build,
   * the files within the temporary image can be copied into the later stage
   * image.
   * @public
   */
  export declare interface File {
      /**
       * The path in the temporary image where the file will be created.
       */
      path: string;
      /**
       * The contents of the file.
       */
      contents: Buffer | string;
  }/**
   * A stage to be added to a
   * {@link https://docs.docker.com/develop/develop-images/multistage-build/ | multi-stage Docker build}.
   *
   * @remarks
   * The stage will be added to the generated Dockerfile for the image as:
   * ```
   * FROM image as name
   * ```
   * @public
   */
  export declare interface Stage {
      /** The image (name + tag or digest) to use for the stage. */
      image: string;
      /** Name for the stage */
      name: string;
  }/**
   * A string that contains both a Docker repo and a registry digest.
   *
   * @remarks
   * This is a string that represents a specific image on a specific registry
   * contained in a particular repo on that registry. It's of the form:
   * ```
   * [registry/]repo@digest
   * ```
   * `registry` - (optional) The hostname or hostname:port of a Docker registry
   * where the repo is located. If not provided, the official default Docker
   * registry is assumed.
   *
   * `repo` - The more precise name for what's commonly referred to as an image
   * name. It may include 0 or more slashes to denote namespaces.
   *
   * `digest` - The repo digest for the image in the form `algorithm:hex`.
   * This digest is specific to the associated registry and repo and has no
   * significance without those additional pieces of information. If this image is
   * pushed to a different registry, it will have a different digest value.
   * The digest is also known as a "distribution hash".
   *
   * Examples:
   * ```
   * alpine@sha256:04696b491e0cc3c58a75bace8941c14c924b9f313b03ce5029ebbc040ed9dcd9
   * localhost:5000/mockdeploy-htws@sha256:899a03e9816e5283edba63d71ea528cd83576b28a7586cf617ce78af5526f209
   * ```
   * @public
   */
  export declare type RepoDigestString = string;/**
   * Docker image ID, in the form `algorithm:hex`.
   *
   * @remarks
   * The Docker image ID (also known as "Content Hash") is a single value
   * that uniquely identifies a specific image on a local Docker host.
   *
   * An image ID does not require a registry or repo qualifier to be significant.
   * It is distinct from a Docker image
   * {@link docker.RepoDigestString | repo digest}.
   *
   * Example:
   * ```
   * sha256:199e537da3a86126cd6eb114bd0b13ab178dc291bbb6ea4a4a3aa257b2366b71
   * ```
   * @public
   */
  export declare type ImageIdString = string;/**
   * A string reference to a Docker image that contains a repo name, and may
   * contain an optional registry and optional tag.
   *
   * @remarks
   * This is a string that references a Docker image. It's in the form of
   * one of:
   * ```
   * [registry/]repo
   * [registry/]repo:tag
   * ```
   * `registry` - (optional) The hostname or hostname:port of a Docker registry
   * where the repo is located. If not provided, depending on context, either
   * the official default Docker registry may be assumed or the image may just
   * be present locally and not on any registry.
   *
   * `repo` - The more precise name for what's commonly referred to as an image
   * name. It may include 0 or more slashes to denote namespaces.
   *
   * `tag` - A tag string identifying a version of image within the repo.
   *
   * Examples:
   * ```
   * alpine
   * ubuntu:16.04
   * ```
   * @public
   */
  export declare type NameTagString = string;/**
   * A string reference to a Docker image that contains a repo name, and may
   * contain an optional registry and optionally either a tag or a repo digest.
   *
   * @remarks
   * This is a string that references a Docker image. It's in the form of
   * one of:
   * ```
   * [registry/]repo
   * [registry/]repo:tag
   * [registry/]repo@digest
   * ```
   * For more detail, see {@link docker.NameTagString} and
   * {@link docker.RepoDigestString}.
   *
   * Examples:
   * ```
   * alpine
   * ubuntu:16.04
   * alpine@sha256:04696b491e0cc3c58a75bace8941c14c924b9f313b03ce5029ebbc040ed9dcd9
   * localhost:5000/mockdeploy-htws@sha256:899a03e9816e5283edba63d71ea528cd83576b28a7586cf617ce78af5526f209
   * ```
   * @public
   */
  export declare type ImageNameString = NameTagString | RepoDigestString;/**
   * A string that references a Docker registry that contains a hostname and
   * may optionally contain a port and/or path.
   *
   * @remarks
   * This string is in the form of one of:
   * ```
   * hostname[:port]
   * hostname[:port]/path
   * ```
   * This form does not include the protocol, such as `http:` or `https:` in
   * the string.
   *
   * @public
   */
  export declare type RegistryString = string;/**
   * Information about a specific instance of a Docker image, as identified by
   * its image ID.
   * @deprecated Replaced with {@link docker.ImageRef}.
   * @public
   */
  export declare interface ImageInfo {
      /**
       * Docker image ID, in the form `algorithm:hex`.
       * @remarks
       * See {@link docker.ImageIdString}.
       */
      id: ImageIdString;
      /**
       * Docker image name and optional tag in the form `name` or `name:tag`.
       * @remarks
       * See {@link docker.NameTagString}
       */
      nameTag?: NameTagString;
  }/**
   * Props for {@link docker.DockerContainer}
   *
   * @public
   */
  export declare interface DockerContainerProps extends DockerGlobalOptions, Pick<ContainerProps, "autoRemove" | "command" | "environment" | "portBindings" | "ports" | "restartPolicy" | "stopSignal"> {
      /** image name as a string, or a handle to a DockerImage component */
      image: ImageNameString | Handle<DockerImageInstance>;
      /**
       * Host and port of the remote docker host to use.
       *
       * @remarks
       * Defaults to the DOCKER_HOST environment variable
       */
      dockerHost: string;
      /**
       * Labels to apply to the container.
       */
      labels?: ContainerLabels;
      /**
       * Filesystems to be mounted in the container.
       */
      mounts?: Mount[];
      /**
       * Networks to connect the container to
       *
       * @remarks
       * Accepts the same strings as docker network connect
       */
      networks?: string[];
      /**
       * Enables the container to run in privileged mode.
       */
      privileged?: boolean;
  }/**
   * Represents a split registry, with pushes going to external and pulls going to internal
   * @beta
   */
  export declare interface DockerSplitRegistryInfo {
      external: RegistryString;
      internal: RegistryString;
  }/**
   * Describes bind mount filesystems to be mounted in a container.
   * @public
   */
  export declare interface BindMount {
      type: "bind";
      source: string;
      destination: string;
      readonly?: boolean;
      propagation?: "shared" | "slave" | "private" | "rshared" | "rslave" | "rprivate";
  }/**
   * Describes filesystems to be mounted in a container.
   * @public
   */
  export declare type Mount = BindMount;
}

/**
 * Represents a Docker Host
 *
 * @alpha
 */
export declare class DockerHost extends Component<DockerHostProps> {
    build(): AdaptElementOrNull;
}

/**
 * Props for {@link DockerHostProps}
 *
 * @alpha
 */
export declare interface DockerHostProps {
    dockerHost?: string;
}

/**
 * A set of environment variables for a {@link Container}.
 *
 * @remarks
 * See the
 * {@link https://docs.docker.com/engine/api/v1.40/#operation/ContainerCreate | Docker API Reference}
 * for more information.
 * @public
 */
export declare type Environment = EnvPair[] | EnvSimple;

/**
 * A single environment variable for a {@link Container}, expressed as an
 * object with `name` and `value` properties.
 *
 * @public
 */
export declare interface EnvPair {
    name: string;
    value: string;
}

/**
 * A set of environment variables for a {@link Container}, expressed as an
 * array of objects with `name` and `value` properties.
 *
 * @remarks
 * See the
 * {@link https://docs.docker.com/engine/api/v1.40/#operation/ContainerCreate | Docker API Reference}
 * for more information.
 * @public
 */
export declare type EnvPairs = EnvPair[];

/**
 * A set of environment variables for a {@link Container}, expressed as a
 * single object with keys and associated values.
 *
 * @remarks
 * See the
 * {@link https://docs.docker.com/engine/api/v1.40/#operation/ContainerCreate | Docker API Reference}
 * for more information.
 * @public
 */
export declare interface EnvSimple {
    [key: string]: string;
}

/** @alpha */
export declare interface ExtendedHandle extends Handle {
    [method: string]: any;
}

/** @alpha */
export declare function extendedHandle(): Handle<import("@adpt/core").GenericInstance & import("@adpt/core").GenericInstanceMethods>;

/**
 * Represents an remote Docker Host
 *
 * @alpha
 */
export declare class ExternalDockerHost extends PrimitiveComponent<ExternalDockerHostProps> {
    updateState(state: any): void;
}

/**
 * Props for {@link ExternalDockerHost}
 *
 * @alpha
 */
export declare interface ExternalDockerHostProps {
    dockerHost: string;
}

/**
 * Formats an {@link Environment} for printing in human-readable format.
 *
 * @param env - The environment to be printed.
 * @returns - A string representation of the environment for use in logging
 * or debugging.
 *
 * @public
 */
export declare function formatEnvVars(env: Environment): string;

export declare namespace gcloud {
/**
   * Temporary adapter to allow handle for image
   *
   * @beta
   */
  export declare function CloudRunAdapter(propsIn: CloudRunAdapterProps): Adapt.JSX.Element;/**
   * Props for the {@link gcloud.CloudRun} component
   *
   * @public
   */
  export declare interface CloudRunProps {
      /** Environment for the container in the deployment */
      env?: Environment;
      /** Arguments for the container entrypoint */
      args?: string[];
      /** Image from which to start the container */
      image: string;
      /**
       * Name of the Cloud Run service in gcloud
       *
       * @remarks
       * This is the absolute name of the service to use.  If not specified
       * Adapt will automatically generate a name for the service.
       */
      serviceName?: string;
      /** Region in which to create the cloud run deployment */
      region: string;
      /**
       * Port on which the container will listen
       *
       * @remarks
       * The container must listen on this port.  There is no port mapping
       * in CloudRun.  However, this will set the `PORT` environment variable
       * for the container, and so the container can listen on this port
       * to get the effect of port mapping.
       */
      port: number;
      /**
       * Percentage of traffic for the latest revision of the deployment
       *
       * @remarks
       *
       * CloudRun can send traffic to multiple revisions of the same
       * service.  Every deploy to cloud run creates a new revision. After
       * health checks pass, the latest container will receive trafficPct/100
       * of the total traffic.  Set this to 100 to ensure that the
       * latest deployment gets all the traffic once up and running, set it to 0
       * for the latest version to get no traffic.
       *
       * NOTE: This value ranges from 0 to 100, not 0.0 to 1.0
       */
      trafficPct: number;
      /**
       * CPU resources that can be consumed by this CloudRun deployment
       *
       * @remarks
       * This is a Kubernetes style cpu specification string.
       * 1 is 1 cpu, 2 is 2 cpus, 100m is 100minutes of CPU allocation, etc.
       *
       * Please look at Google's Cloud Run documentation for more information and any
       * restrictions vs. Kubernetes.
       */
      cpu: string | number;
      /**
       * Memory allocated to this deployment
       *
       * @remarks
       * This is a Kubernetes style string.  128Mi is 128 Mibibytes, etc.
       *
       * Please look at Google's Cloud Run documentation for more information
       * and any restrictions vs. Kubernetes.
       */
      memory: string | number;
      /**
       * Allow public access to this service
       *
       * @remarks
       * If set to `true`, the service will be public.  Otherwise,
       * authentication will be required to access the service from outside
       * the project.
       */
      allowUnauthenticated: boolean;
      /**
       * Specify a gcloud configuration to use
       *
       * @remarks
       * For unit test use only, functionality may change or disappear.
       *
       * @internal
       */
      configuration?: string;
  }/**
   * Instance methods for the {@link gcloud.CloudRun} component.
   *
   * @public
   */
  export declare interface CloudRunInstance {
      /** Returns the https URL for the Cloud Run service. */
      url(): Promise<string | undefined>;
  }/**
   * State for the {@link gcloud.CloudRun} component.
   *
   * @public
   */
  export declare interface CloudRunState {
      /** URL for the service the last time it was queried (may not be current). */
      url?: string;
  }/**
   * Primitive Component for GCP Cloud Run deployments
   * @public
   */
  export declare class CloudRun extends Action<CloudRunProps, CloudRunState> implements CloudRunInstance {
      static defaultProps: {
          trafficPct: number;
          memory: string;
          cpu: number;
          allowUnauthenticated: boolean;
      };
      config_: Config;
      constructor(props: CloudRunProps);
      validate(): "Resource elements cannot have children" | undefined;
      shouldAct(op: ChangeType, ctx: ActionContext): Promise<ShouldAct>;
      action(op: ChangeType, ctx: ActionContext): Promise<void>;
      deployedWhen: (goalStatus: GoalStatus) => Promise<true | Adapt.Waiting>;
      url(): Promise<string | undefined>;
      initialState(): {};
      private mountedElement;
      private config;
      private describe;
  }/**
   * Exported for testing only
   *
   * @internal
   */
  const makeCloudRunName: (elemKey: string, elemID: string, deployID: string) => string;/**
   * Props for the {@link gcloud.CloudRunAdapter} component
   *
   * @beta
   */
  export declare type CloudRunAdapterProps = SFCDeclProps<Omit<CloudRunProps, "image"> & {
      image: Handle;
      registryPrefix: string;
  } & Partial<BuiltinProps>, typeof CloudRun.defaultProps>;
}

/** @alpha */
export declare type Handles = HandlesCreate & HandlesIndex;

/** @alpha */
export declare function handles(): Handles;

/** @alpha */
export declare interface HandlesCreate {
    create: HandlesIndex;
}

/** @alpha */
export declare interface HandlesIndex {
    [hand: string]: ExtendedHandle;
}

/**
 * HostConfig for {@link ContainerStatus}
 * @public
 */
export declare interface HostConfigStatus {
    Binds: string[] | null;
    PortBindings: PortBindingsStatus;
    Privileged: boolean;
    RestartPolicy: RestartPolicyStatus;
}

export declare namespace http {
/** @public */
  export declare function useResolvedFiles(files: Files[]): FilesResolved[] | undefined;/** @public */
  export declare function useFilesInfo(files: Files[]): FilesInfo[] | undefined;/**
   * Returns all `Handle`s referenced by the set of `files`.
   * @public
   */
  export declare function fileHandles(files: Files[]): Handle[];/**
   *  Abstract component that represents an HTTP server
   *  @public
   */
  export declare abstract class HttpServer extends Component<HttpServerProps> {
      static defaultProps: {
          port: number;
          scope: string;
      };
  }/** @public */
  export declare function isFilesResolved(f: Files): f is FilesResolved;/** @public */
  export declare type Match = MatchPath | MatchRegex;/** @public */
  export declare interface MatchPath {
      type: "path";
      path: string;
  }/** @public */
  export declare interface MatchRegex {
      type: "regex";
      regex: string;
  }/** @public */
  export declare type Destination = DestFiles;/** @public */
  export declare interface DestFiles {
      type: "files";
      filesRoot?: string;
  }/** @public */
  export declare interface PathPair {
      src: string;
      dest: string;
  }/** @public */
  export declare interface FilesLocal {
      type: "local";
      localRoot: string;
      files: PathPair[];
  }/** @public */
  export declare interface FilesImageHandle {
      type: "image";
      image: Handle;
      files: PathPair[];
      stage: string;
  }/** @public */
  export declare interface FilesImageResolved {
      type: "image";
      image: string;
      files: PathPair[];
      stage: string;
  }/** @public */
  export declare type FilesResolved = FilesLocal | FilesImageResolved;/** @public */
  export declare type Files = FilesResolved | FilesImageHandle;/** @public */
  export declare interface FilesInfo {
      dockerCommands: string;
      stage?: Stage;
  }/** @public */
  export declare interface Location {
      match: Match;
      dest: Destination;
  }/** @public */
  export declare interface VirtualServer {
      filesRoot?: string;
      locations: Location[];
  }/** @public */
  export declare interface HttpServerProps {
      add: Files[];
      localAddRoot?: string;
      port: number;
      scope: NetworkServiceScope;
      servers?: VirtualServer[];
  }/**
   * Function to check if the routes prop for {@link http.UrlRouter | UrlRouter} components is valid
   * @param routes - routes from {@link http.UrlRouter | UrlRouter} props
   *
   * @remarks
   * Throws and error if the routes are invalid, along with specific error details in the exception
   *
   * This can be used by concrete implementation of {@link http.UrlRouter | UrlRouter} to check
   * their props for validity.
   *
   * @public
   */
  export declare function checkUrlEndpoints(routes: UrlRouterRoute[]): void;/** @public */
  export declare interface UrlRouterRoute {
      path: string;
      endpoint: Handle | string;
      upstreamPath?: string;
  }/** @public */
  export declare interface UrlRouterProps {
      port: number;
      externalPort?: number;
      routes: UrlRouterRoute[];
  }/** @public */
  export declare interface ResolvedRoute {
      path: string;
      upstreamPath: string;
      url: string;
  }/**
   * Abstract component for URL routing
   * @public
   */
  declare abstract class UrlRouter extends PrimitiveComponent<UrlRouterProps> {
      static defaultProps: {
          port: number;
      };
  }/**
   * Abstract component for URL routing
   * @public
   */
  declare abstract class UrlRouter extends PrimitiveComponent<UrlRouterProps> {
      static defaultProps: {
          port: number;
      };
  }/** @public */
  export declare function useResolvedFiles(files: Files[]): FilesResolved[] | undefined;/** @public */
  export declare function useFilesInfo(files: Files[]): FilesInfo[] | undefined;/**
   * Returns all `Handle`s referenced by the set of `files`.
   * @public
   */
  export declare function fileHandles(files: Files[]): Handle[];/**
   *  Abstract component that represents an HTTP server
   *  @public
   */
  export declare abstract class HttpServer extends Component<HttpServerProps> {
      static defaultProps: {
          port: number;
          scope: string;
      };
  }/** @public */
  export declare function isFilesResolved(f: Files): f is FilesResolved;/** @public */
  export declare type Match = MatchPath | MatchRegex;/** @public */
  export declare interface MatchPath {
      type: "path";
      path: string;
  }/** @public */
  export declare interface MatchRegex {
      type: "regex";
      regex: string;
  }/** @public */
  export declare type Destination = DestFiles;/** @public */
  export declare interface DestFiles {
      type: "files";
      filesRoot?: string;
  }/** @public */
  export declare interface PathPair {
      src: string;
      dest: string;
  }/** @public */
  export declare interface FilesLocal {
      type: "local";
      localRoot: string;
      files: PathPair[];
  }/** @public */
  export declare interface FilesImageHandle {
      type: "image";
      image: Handle;
      files: PathPair[];
      stage: string;
  }/** @public */
  export declare interface FilesImageResolved {
      type: "image";
      image: string;
      files: PathPair[];
      stage: string;
  }/** @public */
  export declare type FilesResolved = FilesLocal | FilesImageResolved;/** @public */
  export declare type Files = FilesResolved | FilesImageHandle;/** @public */
  export declare interface FilesInfo {
      dockerCommands: string;
      stage?: Stage;
  }/** @public */
  export declare interface Location {
      match: Match;
      dest: Destination;
  }/** @public */
  export declare interface VirtualServer {
      filesRoot?: string;
      locations: Location[];
  }/** @public */
  export declare interface HttpServerProps {
      add: Files[];
      localAddRoot?: string;
      port: number;
      scope: NetworkServiceScope;
      servers?: VirtualServer[];
  }/**
   * Function to check if the routes prop for {@link http.UrlRouter | UrlRouter} components is valid
   * @param routes - routes from {@link http.UrlRouter | UrlRouter} props
   *
   * @remarks
   * Throws and error if the routes are invalid, along with specific error details in the exception
   *
   * This can be used by concrete implementation of {@link http.UrlRouter | UrlRouter} to check
   * their props for validity.
   *
   * @public
   */
  export declare function checkUrlEndpoints(routes: UrlRouterRoute[]): void;/** @public */
  export declare interface UrlRouterRoute {
      path: string;
      endpoint: Handle | string;
      upstreamPath?: string;
  }/** @public */
  export declare interface UrlRouterProps {
      port: number;
      externalPort?: number;
      routes: UrlRouterRoute[];
  }/** @public */
  export declare interface ResolvedRoute {
      path: string;
      upstreamPath: string;
      url: string;
  }/**
   * Abstract component for URL routing
   * @public
   */
  declare abstract class UrlRouter extends PrimitiveComponent<UrlRouterProps> {
      static defaultProps: {
          port: number;
      };
  }/**
   * Abstract component for URL routing
   * @public
   */
  declare abstract class UrlRouter extends PrimitiveComponent<UrlRouterProps> {
      static defaultProps: {
          port: number;
      };
  }/** @public */
  export declare function useResolvedFiles(files: Files[]): FilesResolved[] | undefined;/** @public */
  export declare function useFilesInfo(files: Files[]): FilesInfo[] | undefined;/**
   * Returns all `Handle`s referenced by the set of `files`.
   * @public
   */
  export declare function fileHandles(files: Files[]): Handle[];/**
   *  Abstract component that represents an HTTP server
   *  @public
   */
  export declare abstract class HttpServer extends Component<HttpServerProps> {
      static defaultProps: {
          port: number;
          scope: string;
      };
  }/** @public */
  export declare function isFilesResolved(f: Files): f is FilesResolved;/** @public */
  export declare type Match = MatchPath | MatchRegex;/** @public */
  export declare interface MatchPath {
      type: "path";
      path: string;
  }/** @public */
  export declare interface MatchRegex {
      type: "regex";
      regex: string;
  }/** @public */
  export declare type Destination = DestFiles;/** @public */
  export declare interface DestFiles {
      type: "files";
      filesRoot?: string;
  }/** @public */
  export declare interface PathPair {
      src: string;
      dest: string;
  }/** @public */
  export declare interface FilesLocal {
      type: "local";
      localRoot: string;
      files: PathPair[];
  }/** @public */
  export declare interface FilesImageHandle {
      type: "image";
      image: Handle;
      files: PathPair[];
      stage: string;
  }/** @public */
  export declare interface FilesImageResolved {
      type: "image";
      image: string;
      files: PathPair[];
      stage: string;
  }/** @public */
  export declare type FilesResolved = FilesLocal | FilesImageResolved;/** @public */
  export declare type Files = FilesResolved | FilesImageHandle;/** @public */
  export declare interface FilesInfo {
      dockerCommands: string;
      stage?: Stage;
  }/** @public */
  export declare interface Location {
      match: Match;
      dest: Destination;
  }/** @public */
  export declare interface VirtualServer {
      filesRoot?: string;
      locations: Location[];
  }/** @public */
  export declare interface HttpServerProps {
      add: Files[];
      localAddRoot?: string;
      port: number;
      scope: NetworkServiceScope;
      servers?: VirtualServer[];
  }/**
   * Function to check if the routes prop for {@link http.UrlRouter | UrlRouter} components is valid
   * @param routes - routes from {@link http.UrlRouter | UrlRouter} props
   *
   * @remarks
   * Throws and error if the routes are invalid, along with specific error details in the exception
   *
   * This can be used by concrete implementation of {@link http.UrlRouter | UrlRouter} to check
   * their props for validity.
   *
   * @public
   */
  export declare function checkUrlEndpoints(routes: UrlRouterRoute[]): void;/** @public */
  export declare interface UrlRouterRoute {
      path: string;
      endpoint: Handle | string;
      upstreamPath?: string;
  }/** @public */
  export declare interface UrlRouterProps {
      port: number;
      externalPort?: number;
      routes: UrlRouterRoute[];
  }/** @public */
  export declare interface ResolvedRoute {
      path: string;
      upstreamPath: string;
      url: string;
  }/**
   * Abstract component for URL routing
   * @public
   */
  declare abstract class UrlRouter extends PrimitiveComponent<UrlRouterProps> {
      static defaultProps: {
          port: number;
      };
  }/**
   * Abstract component for URL routing
   * @public
   */
  declare abstract class UrlRouter extends PrimitiveComponent<UrlRouterProps> {
      static defaultProps: {
          port: number;
      };
  }/** @public */
  export declare function useResolvedFiles(files: Files[]): FilesResolved[] | undefined;/** @public */
  export declare function useFilesInfo(files: Files[]): FilesInfo[] | undefined;/**
   * Returns all `Handle`s referenced by the set of `files`.
   * @public
   */
  export declare function fileHandles(files: Files[]): Handle[];/**
   *  Abstract component that represents an HTTP server
   *  @public
   */
  export declare abstract class HttpServer extends Component<HttpServerProps> {
      static defaultProps: {
          port: number;
          scope: string;
      };
  }/** @public */
  export declare function isFilesResolved(f: Files): f is FilesResolved;/** @public */
  export declare type Match = MatchPath | MatchRegex;/** @public */
  export declare interface MatchPath {
      type: "path";
      path: string;
  }/** @public */
  export declare interface MatchRegex {
      type: "regex";
      regex: string;
  }/** @public */
  export declare type Destination = DestFiles;/** @public */
  export declare interface DestFiles {
      type: "files";
      filesRoot?: string;
  }/** @public */
  export declare interface PathPair {
      src: string;
      dest: string;
  }/** @public */
  export declare interface FilesLocal {
      type: "local";
      localRoot: string;
      files: PathPair[];
  }/** @public */
  export declare interface FilesImageHandle {
      type: "image";
      image: Handle;
      files: PathPair[];
      stage: string;
  }/** @public */
  export declare interface FilesImageResolved {
      type: "image";
      image: string;
      files: PathPair[];
      stage: string;
  }/** @public */
  export declare type FilesResolved = FilesLocal | FilesImageResolved;/** @public */
  export declare type Files = FilesResolved | FilesImageHandle;/** @public */
  export declare interface FilesInfo {
      dockerCommands: string;
      stage?: Stage;
  }/** @public */
  export declare interface Location {
      match: Match;
      dest: Destination;
  }/** @public */
  export declare interface VirtualServer {
      filesRoot?: string;
      locations: Location[];
  }/** @public */
  export declare interface HttpServerProps {
      add: Files[];
      localAddRoot?: string;
      port: number;
      scope: NetworkServiceScope;
      servers?: VirtualServer[];
  }/**
   * Function to check if the routes prop for {@link http.UrlRouter | UrlRouter} components is valid
   * @param routes - routes from {@link http.UrlRouter | UrlRouter} props
   *
   * @remarks
   * Throws and error if the routes are invalid, along with specific error details in the exception
   *
   * This can be used by concrete implementation of {@link http.UrlRouter | UrlRouter} to check
   * their props for validity.
   *
   * @public
   */
  export declare function checkUrlEndpoints(routes: UrlRouterRoute[]): void;/** @public */
  export declare interface UrlRouterRoute {
      path: string;
      endpoint: Handle | string;
      upstreamPath?: string;
  }/** @public */
  export declare interface UrlRouterProps {
      port: number;
      externalPort?: number;
      routes: UrlRouterRoute[];
  }/** @public */
  export declare interface ResolvedRoute {
      path: string;
      upstreamPath: string;
      url: string;
  }/**
   * Abstract component for URL routing
   * @public
   */
  declare abstract class UrlRouter extends PrimitiveComponent<UrlRouterProps> {
      static defaultProps: {
          port: number;
      };
  }/**
   * Abstract component for URL routing
   * @public
   */
  declare abstract class UrlRouter extends PrimitiveComponent<UrlRouterProps> {
      static defaultProps: {
          port: number;
      };
  }
}

/**
 * An image for a {@link Container}.
 *
 * @remarks
 * See the
 * {@link https://docs.docker.com/engine/api/v1.40/#operation/ContainerCreate | Docker API Reference}
 * for more information.
 * @public
 */
export declare type ImageId = string | Handle<DockerImageInstance>;

/**
 * Function to check whether an {@link @adpt/core#AdaptElement} is an
 * abstract {@link Container}.
 * @public
 */
export declare function isContainerElement(el: AdaptElement): el is AdaptElement<ContainerProps>;

/**
 * Type assertion that tests an element to see if it is a {@link NetworkService}
 *
 * @param el - the element to be tested
 * @returns `true` if  `el` is a NetworkService, `false` otherwise
 *
 * @remarks
 * Also functions as a type assertion for Typescript, so the arguments
 * type will be adjusted to reflect that it is an `AdaptElement<NetworkServiceProps>`
 * instead of a generic `AdaptElement`.
 *
 * @public
 */
export declare function isNetworkServiceElement(el: AdaptElement): el is AdaptElement<NetworkServiceProps>;

export declare namespace k8s {
/**
   * k8s ClusterRole resource
   *
   * @param propsIn - props for ServiceAccount as specifed in {@link k8s.ClusterRoleProps}
   *
   * @public
   */
  export declare function ClusterRole(propsIn: SFCDeclProps<ClusterRoleProps, typeof defaultProps>): Adapt.JSX.Element;/** @public */
  export declare function isClusterRoleProps(props: ResourceProps): props is ResourceProps & ResourceClusterRole;/** @internal */
  const clusterRoleResourceInfo: {
      kind: string;
      deployedWhen: () => true;
      statusQuery: (props: ResourcePropsWithConfig, observe: ObserveForStatus, buildData: BuildData) => Promise<any>;
      makeManifest: (manifest: Manifest, elem: AdaptElement<ResourceProps>, _deployID: string) => {
          aggregationRule: AggregationRule | undefined;
          rules: PolicyRule[] | undefined;
          apiVersion: string;
          kind: string;
          metadata: import("./manifest_support").MetadataInRequest;
          spec?: import("./DaemonSet").DaemonSetSpec | import("./common").CRSpec | import("./Pod").PodSpec | import("./Service").ServiceSpec | import("./Deployment").DeploymentSpec | undefined;
      };
  };/**
   * k8s ClusterRoleBinding resource
   *
   * @param propsIn - props for ServiceAccount as specifed in {@link k8s.ClusterRoleBindingProps}
   *
   * @public
   */
  export declare function ClusterRoleBinding(propsIn: SFCDeclProps<ClusterRoleBindingProps, typeof defaultProps>): Adapt.JSX.Element | null;/** @internal */
  const clusterRoleBindingResourceInfo: {
      kind: string;
      deployedWhen: () => true;
      statusQuery: (props: ResourcePropsWithConfig, observe: ObserveForStatus, buildData: BuildData) => Promise<any>;
      makeManifest: (manifest: Manifest, elem: AdaptElement<ResourceProps>, _deployID: string) => {
          roleRef: RoleRef;
          subjects: Subject[];
          apiVersion: string;
          kind: string;
          metadata: import("./manifest_support").MetadataInRequest;
          spec?: import("./DaemonSet").DaemonSetSpec | import("./common").CRSpec | import("./Pod").PodSpec | import("./Service").ServiceSpec | import("./Deployment").DeploymentSpec | undefined;
      };
  };/**
   * k8s ConfigMap resource
   *
   * @param propsIn - props for ConfigMap as specifed in {@link k8s.ConfigMapProps}
   *
   * @public
   */
  export declare function ConfigMap(propsIn: SFCDeclProps<ConfigMapProps, typeof defaultProps>): Adapt.JSX.Element;/** @internal */
  const configMapResourceInfo: {
      kind: string;
      deployedWhen: () => true;
      statusQuery: (props: ResourcePropsWithConfig, observe: ObserveForStatus, buildData: BuildData) => Promise<any>;
      makeManifest: (manifest: Manifest, elem: AdaptElement<ResourceProps>, _deployID: string) => {
          data: {
              [key: string]: string;
          } | undefined;
          binaryData: {
              [key: string]: string;
          } | undefined;
          immutable: boolean | undefined;
          apiVersion: string;
          kind: string;
          metadata: import("./manifest_support").MetadataInRequest;
          spec?: import("./DaemonSet").DaemonSetSpec | import("./common").CRSpec | import("./Pod").PodSpec | import("./Service").ServiceSpec | import("./Deployment").DeploymentSpec | undefined;
      };
  };/**
   * Low level utility function to translate from the abstract {@link Container}
   * component props ({@link ContainerProps}) to {@link k8s.K8sContainerProps}
   * to be used in a {@link k8s.K8sContainer}.
   * @remarks
   * Note: The `image` property in the passed in {@link ContainerProps} must
   * be a `string`, not a `Handle`.
   * In most cases, it is preferable to use the {@link k8s.Container} component
   * instead, which is designed specifically to deal with this issue.
   *
   * @param abstractProps - The abstract {@link ContainerProps} to translate from.
   * @param k8sProps - Props that are specific to the {@link k8s.K8sContainer}
   *     component that should be merged into the resulting returned
   *     {@link k8s.K8sContainerProps} object.
   * @public
   */
  export declare function k8sContainerProps(abstractProps: FromContainerProps, k8sProps?: Partial<K8sContainerProps>): K8sContainerProps;/**
   * Tests whether an element is a {@link k8s.K8sContainer} element
   * @param x - element to test
   * @returns `true` if element is a {@link k8s.K8sContainer}, `false` otherwise
   *
   * @remarks
   * Acts as a TypeScript type assertion that will assert that `x` is `AdaptElement<K8sContainerProps>`
   *
   * @public
   */
  export declare function isK8sContainerElement(x: AdaptElement): x is AdaptElement<K8sContainerProps>;/**
   * Component that implements the abstract {@link Container} interface and
   * translates to a Kubernetes-specific {@link k8s.K8sContainer}.
   * @public
   */
  export declare function Container(props: ContainerProps): Adapt.JSX.Element | null;/** @public */
  export declare interface VolumeMount {
      /**
       * Path within the container at which the volume should be mounted.
       *
       * Must not contain ':'.
       */
      mountPath: string;
      /**
       * mountPropagation determines how mounts are propagated from the host to container and the other way around.
       *
       * When not set, MountPropagationNone is used. This field is beta in 1.10.
       *
       * @defaultValue MountPropagationNone
       */
      mountPropagation?: string;
      /** This must match the Name of a Volume. */
      name: string;
      /**
       * Mounted read-only if true, read-write otherwise (false or unspecified).
       *
       * @defaultValue false
       */
      readOnly?: boolean;
      /**
       * Path within the volume from which the container's volume should be mounted.
       *
       * Defaults to "" (volume's root).
       *
       * @defaultValue ""
       */
      subPath?: string;
      /**
       * Expanded path within the volume from which the container's volume should be mounted.
       *
       * Behaves similarly to SubPath but environment variable references $(VAR_NAME)
       * are expanded using the container's environment.
       *
       * Defaults to "" (volume's root).
       *
       * SubPathExpr and SubPath are mutually exclusive.
       *
       * @defaultValue ""
       */
      subPathExpr?: string;
  }/** @public */
  export declare interface ConfigMapEnvSource {
      /**
       * Name of the referent.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names}
       */
      name?: string;
      /**
       * Specify whether the ConfigMap must be defined
       */
      optional?: boolean;
  }/** @public */
  export declare interface SecretEnvSource {
      /**
       * Name of the referent.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names}
       */
      name?: string;
      /**
       * Specify whether the Secret must be defined
       */
      optional?: boolean;
  }/** @public */
  export declare interface EnvFromSource {
      /** The ConfigMap to select from */
      configMapRef?: ConfigMapEnvSource;
      /** An optional identifier to prepend to each key in the ConfigMap. Must be a C_IDENTIFIER. */
      prefix?: string;
      /** SecretEnvSource	The Secret to select from */
      secretRef?: SecretEnvSource;
  }/** @public */
  export declare interface ExecAction {
      /**
       * Command is the command line to execute inside the container.
       *
       * The working directory for the command is root ('/') in the container's filesystem.
       * The command is simply exec'd, it is not run inside a shell,
       * so traditional shell instructions ('|', etc) won't work.
       * To use a shell, you need to explicitly call out to that shell.
       *
       * Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
       */
      command: string[];
  }/** @public */
  export declare interface HTTPGetAction {
      /**
       * Host name to connect to, defaults to the pod IP.
       *
       * You probably want to set "Host" in httpHeaders instead.
       */
      host?: string;
      /** Custom headers to set in the request. HTTP allows repeated headers. */
      httpHeaders?: {
          name: string;
          value: string;
      }[];
      /** Path to access on the HTTP server. */
      path: string;
      /**
       * Name or number of the port to access on the container.
       *
       * Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
       */
      port: number | string;
      /**
       * Scheme to use for connecting to the host.
       *
       * @defaultValue HTTP.
       */
      scheme?: string;
  }/** @public */
  export declare interface TCPSocketAction {
      /** Host name to connect to, defaults to the pod IP. */
      host?: string;
      /**
       * Number or name of the port to access on the container.
       *
       * Number must be in the range 1 to 65535.
       * Name must be an IANA_SVC_NAME.
       */
      port: string | number;
  }/** @public */
  export declare interface Probe {
      /**
       * Exec specifies the action to take.
       *
       * Only one of exec, httpGet, or tcpSocket should be specified
       */
      exec?: ExecAction;
      /**
       * Minimum consecutive failures for the probe to be considered failed after having succeeded.
       *
       * Defaults to 3. Minimum value is 1.
       *
       * @defaultValue 3
       */
      failureThreshold?: number;
      /** Specifies the http request to perform. */
      httpGet?: HTTPGetAction;
      /**
       *  Seconds after the container has started before liveness probes are initiated.
       *  More info: {@link https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes}
       */
      initialDelaySeconds?: number;
      /** How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. */
      periodSeconds?: number;
      /**
       * Minimum consecutive successes for the probe to be considered successful after having failed.
       *
       * Must be 1 for liveness and startup. Minimum value is 1.
       *
       * @defaultValue 1
       */
      successThreshold?: number;
      /**
       * Specifies an action involving a TCP port.
       *
       * TCP hooks not yet supported
       */
      tcpSocket?: TCPSocketAction;
      /**
       * Number of seconds after which the probe times out.
       *
       * Defaults to 1 second. Minimum value is 1.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes}
       *
       * @defaultValue 1
       */
      timeoutSeconds?: number;
  }/** @public */
  export declare interface ResourceRequirements {
      /**
       * Limits describes the maximum amount of compute resources allowed.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/}
       */
      limits?: {
          [key: string]: any;
      };
      /**
       * Describes the minimum amount of compute resources required.
       *
       * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
       * otherwise to an implementation-defined value.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/}
       */
      requests?: {
          [key: string]: any;
      };
  }/** @public */
  export declare type Handler = {
      exec: ExecAction;
  } | {
      httpGet: HTTPGetAction;
  } | {
      tcpSocket: TCPSocketAction;
  };/** @public */
  export declare interface Lifecycle {
      /**
       * PostStart is called immediately after a container is created.
       *
       * If the handler fails, the container is terminated and restarted according to its restart policy.
       * Other management of the container blocks until the hook completes.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks}
       */
      postStart: Handler;
      /**
       * Called immediately before a container is terminated due to an API request or management event such as liveness/startup probe failure, preemption, resource contention, etc.
       *
       * The handler is not called if the container crashes or exits.
       * The reason for termination is passed to the handler.
       * The Pod's termination grace period countdown begins before the PreStop hooked is executed.
       * Regardless of the outcome of the handler, the container will eventually terminate within the Pod's termination grace period.
       * Other management of the container blocks until the hook completes or until the termination grace period is reached.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks}
       */
      preStop: Handler;
  }/** @public */
  export declare interface VolumeDevice {
      /** The path inside of the container that the device will be mapped to. */
      devicePath: string;
      /** name must match the name of a persistentVolumeClaim in the pod */
      name: string;
  }/**
   * Resource spec for a Kubernetes container.
   * See the Kubernetes
   * {@link https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#container-v1-core | API docs }
   * for more details.
   * @public
   */
  export declare interface ContainerSpec {
      /**
       * Arguments to the entrypoint.
       *
       * The docker image's CMD is used if this is not provided.
       * Variable references $(VAR_NAME) are expanded using the container's environment.
       * If a variable cannot be resolved, the reference in the input string will be unchanged.
       * The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME).
       * Escaped references will never be expanded, regardless of whether the variable exists or not.
       * Cannot be updated.
       * More info: {@link https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell}
       */
      args?: string[];
      /**
       * Entrypoint array.
       *
       * Not executed within a shell.
       * The docker image's ENTRYPOINT is used if this is not provided.
       * Variable references $(VAR_NAME) are expanded using the container's environment.
       * If a variable cannot be resolved, the reference in the input string will be unchanged.
       * The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME).
       * Escaped references will never be expanded, regardless of whether the variable exists or not.
       * Cannot be updated.
       * More info: {@link https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell}
       */
      command?: string[];
      /**
       * List of environment variables to set in the container. Cannot be updated.
       */
      env?: EnvVar[];
      /**
       * List of sources to populate environment variables in the container.
       *
       * The keys defined within a source must be a C_IDENTIFIER.
       * All invalid keys will be reported as an event when the container is starting.
       * When a key exists in multiple sources, the value associated with the last source will take precedence.
       * Values defined by an Env with a duplicate key will take precedence. Cannot be updated.
       */
      envFrom?: EnvFromSource[];
      /**
       * Docker image name.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/containers/images}
       *
       * This field is optional to allow higher level config management to default or override container
       * images in workload controllers like Deployments and StatefulSets.
       */
      image?: string;
      /**
       * Image pull policy.
       *
       * One of Always, Never, IfNotPresent.
       * Defaults to Always if :latest tag is specified,
       * or IfNotPresent otherwise.
       * Cannot be updated.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/containers/images#updating-images}
       */
      imagePullPolicy?: "Always" | "Never" | "IfNotPresent";
      /**
       * List of sources to populate environment variables in the container.
       *
       * The keys defined within a source must be a C_IDENTIFIER.
       * All invalid keys will be reported as an event when the container is starting.
       * When a key exists in multiple sources, the value associated with the last source will take precedence.
       * Values defined by an Env with a duplicate key will take precedence. Cannot be updated.
       */
      lifecycle?: Lifecycle;
      /**
       * Periodic probe of container liveness.
       *
       * Container will be restarted if the probe fails.
       * Cannot be updated.
       * More info: {@link https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes}
       */
      livenessProbe?: Probe;
      /**
       * Name of the container specified as a DNS_LABEL.
       *
       * Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated.
       */
      name: string;
      /**
       * List of ports to expose from the container.
       *
       * Exposing a port here gives the system additional information about the network connections a container uses,
       * but is primarily informational.
       * Not specifying a port here DOES NOT prevent that port from being exposed.
       * Any port which is listening on the default "0.0.0.0" address inside a container will be accessible from
       * the network.
       * Cannot be updated.
       */
      ports?: ContainerPort[];
      /**
       * Periodic probe of container service readiness.
       *
       * Container will be removed from service endpoints if the probe fails.
       * Cannot be updated.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes}
       */
      readinessProbe?: Probe;
      /**
       * Compute Resources required by this container.
       *
       * Cannot be updated.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/}
       */
      resources?: ResourceRequirements;
      /**
       * Security options the pod should run with.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/policy/security-context/}
       * More info: {@link https://kubernetes.io/docs/tasks/configure-pod-container/security-context/}
       */
      securityContext?: PodSecurityContext;
      /**
       * Indicates that the Pod has successfully initialized.
       *
       * If specified, no other probes are executed until this completes successfully.
       * If this probe fails, the Pod will be restarted, just as if the livenessProbe failed.
       * This can be used to provide different probe parameters at the beginning of a Pod's lifecycle,
       * when it might take a long time to load data or warm a cache, than during steady-state operation.
       *
       * This cannot be updated.
       * This is a beta feature enabled by the StartupProbe feature flag.
       * More info: {@link https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes}
       */
      startupProbe?: Probe;
      /**
       * Whether this container should allocate a buffer for stdin in the container runtime.
       *
       * If this is not set, reads from stdin in the container will always result in EOF. Default is false.
       */
      stdin?: boolean;
      /**
       * Whether the container runtime should close the stdin channel after it has been opened by a single attach.
       *
       * When stdin is true the stdin stream will remain open across multiple attach sessions.
       * If stdinOnce is set to true, stdin is opened on container start,
       * is empty until the first client attaches to stdin,
       * and then remains open and accepts data until the client disconnects,
       * at which time stdin is closed and remains closed until the container is restarted.
       * If this flag is false, a container processes that reads from stdin will never receive an EOF. Default is false
       */
      stdinOnce?: boolean;
      /**
       * Path at which the file to which the container's termination message will be written is mounted into the container's filesystem.
       *
       * Message written is intended to be brief final status, such as an assertion failure message.
       * Will be truncated by the node if greater than 4096 bytes.
       * The total message length across all containers will be limited to 12kb.
       * Defaults to /dev/termination-log. Cannot be updated.
       */
      terminationMessagePath?: string;
      /**
       * Indicate how the termination message should be populated.
       *
       * File will use the contents of terminationMessagePath to populate the container status
       * message on both success and failure. FallbackToLogsOnError will use the last chunk of
       * container log output if the termination message file is empty and the container exited
       * with an error.
       * The log output is limited to 2048 bytes or 80 lines, whichever is smaller.
       * Defaults to File.
       * Cannot be updated.
       *
       * @defaultValue File
       */
      terminationMessagePolicy?: "File" | "FallbackToLogsOnError";
      /**
       * Whether this container should allocate a TTY for itself, also requires 'stdin' to be true.
       *
       * @defaultValue false
       */
      tty?: boolean;
      /**
       * volumeDevices is the list of block devices to be used by the container.
       */
      volumeDevices?: VolumeDevice[];
      /** volumeDevices is the list of block devices to be used by the container. */
      volumeMounts?: VolumeMount[];
      /**
       * Container's working directory.
       *
       * If not specified, the container runtime's default will be used,
       * which might be configured in the container image.
       * Cannot be updated.
       */
      workingDir?: string;
  }/**
   * Props for the Kubernetes-specific {@link k8s.K8sContainer} component.
   * @public
   */
  export declare interface K8sContainerProps extends ContainerSpec {
  }/** @public */
  export declare interface ContainerPort {
      /**
       * Number of port to expose on the pod's IP address.
       * @remarks
       * This must be a valid integer port number, `0 < x < 65536`.
       */
      containerPort: number;
      /** What host IP to bind the external port to. */
      hostIP?: string;
      /**
       * Number of port to expose on the host.
       * @remarks
       * If specified, this must be a valid integer port number,
       * `0 < x < 65536`. If HostNetwork is specified,
       * this must match ContainerPort. Most containers do not need this.
       */
      hostPort?: number;
      /**
       * A unique-within-pod name for the container
       * @remarks
       * If specified, this must be an IANA_SVC_NAME and unique within the pod.
       * Each named port in a pod must have a unique name. Name for the port
       * that can be referred to by services.
       */
      name?: string;
      /** Protocol for port. Must be UDP or TCP. Defaults to "TCP". */
      protocol?: string;
  }/** @public */
  export declare type EnvVar = EnvVarSimple | EnvVarFrom;/** @public */
  export declare interface EnvVarSimple {
      /** Name of the environment variable. Must be a C_IDENTIFIER. */
      name: string;
      /**
       * Variable references $(VAR_NAME) are expanded using the previous defined
       * environment variables in the container and any service environment
       * variables. If a variable cannot be resolved, the reference in the input
       * string will be unchanged. The $(VAR_NAME) syntax can be escaped with a
       * double $$, ie: $$(VAR_NAME). Escaped references will never be expanded,
       * regardless of whether the variable exists or not. Defaults to "".
       */
      value: string;
  }/** @public */
  export declare interface EnvVarFrom {
      /** Source for the environment variable's value. Cannot be used if value is not empty. */
      valueFrom?: any;
  }/**
   * See {@link k8s.k8sContainerProps}.
   * @public
   */
  export declare type FromContainerProps = ReplaceT<ContainerProps, {
      image: string;
  }> & BuiltinProps;/**
   * Kubernetes-specific container.
   * @public
   */
  export declare class K8sContainer extends PrimitiveComponent<K8sContainerProps> {
      static defaultProps: {
          imagePullPolicy: string;
      };
      validate(): undefined;
  }/**
   * Props for {@link k8s.Container}.
   * @public
   */
  export declare interface ContainerProps extends SFCDeclProps<ContainerProps> {
      /**
       * Additional {@link k8s.K8sContainerProps}-specific props that should be
       * added to the instantiated {@link k8s.K8sContainer}.
       */
      k8sContainerProps?: Partial<K8sContainerProps>;
  }/**
   * Spec for {@link k8s.DaemonSet} for use in {@link k8s.Resource}
   *
   * @public
   */
  export declare type DaemonSetSpec = Exclude<DaemonSetProps, ResourceBase> & {
      template: PodTemplateSpec;
  };/**
   * Component for Kubernetes DaemonSet
   *
   * @public
   */
  export declare class DaemonSet extends DeferredComponent<DaemonSetProps> {
      static defaultProps: {
          metadata: {};
          minReadySeconds: number;
          revisionHistoryLimit: number;
          updateStrategy: {
              type: string;
              rollingUpdate: {
                  maxUnavailable: number;
              };
          };
      };
      constructor(props: DaemonSetProps);
      build(helpers: BuildHelpers): Adapt.JSX.Element;
      status(_observe: ObserveForStatus, buildData: BuildData): Promise<Adapt.Status | undefined>;
  }/** @internal */
  const daemonSetResourceInfo: {
      kind: string;
      deployedWhen: typeof deployedWhen;
      statusQuery: (props: ResourcePropsWithConfig, observe: ObserveForStatus, buildData: BuildData) => Promise<any>;
  };/** @public */
  export declare interface DeploymentUpdateStrategyRecreate {
      type: "Recreate";
  }/** @public */
  export declare interface RollingUpdateDeployment {
      /**
       * The maximum number of pods that can be scheduled above the desired number of pods.
       *
       * Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
       * This can not be 0 if MaxUnavailable is 0.
       * Absolute number is calculated from percentage by rounding up.
       * Defaults to 25%.
       *
       * @example
       * When this is set to 30%, the new ReplicaSet can be scaled up immediately when the rolling update starts,
       * such that the total number of old and new pods do not exceed 130% of desired pods. Once old pods have been
       * killed, new ReplicaSet can be scaled up further, ensuring that total number of pods running at any time
       * during the update is at most 130% of desired pods.
       */
      maxSurge?: number | string;
      /**
       * The maximum number of pods that can be unavailable during the update.
       *
       * Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
       * Absolute number is calculated from percentage by rounding down.
       * This can not be 0 if MaxSurge is 0. Defaults to 25%.
       *
       * @example
       * When this is set to 30%, the old ReplicaSet can be scaled down to 70% of desired pods
       * immediately when the rolling update starts. Once new pods are ready, old ReplicaSet
       * can be scaled down further, followed by scaling up the new ReplicaSet, ensuring that
       * the total number of pods available at all times during the update is at least 70% of
       * desired pods.
       */
      maxUnavailable?: number | string;
  }/**
   * Spec for {@link k8s.Deployment} for use in {@link k8s.Resource}
   *
   * @public
   */
  export declare type DeploymentSpec = Exclude<DeploymentProps, ResourceBase> & {
      template: PodTemplateSpec;
  };/**
   * Props for {@link k8s.Deployment}
   *
   * @public
   */
  export declare interface DeploymentProps extends WithChildren {
      /** Information about the k8s cluster (ip address, auth info, etc.) */
      config: ClusterInfo;
      /** k8s metadata */
      metadata: Metadata;
      /**
       * The minimum number of seconds for which a newly created pod should
       * be ready without any of its container crashing, for it to be considered
       * available. Defaults to 0 (pod will be considered available as soon as it is ready).
       */
      minReadySeconds: number;
      /** Indicates that the deployment is paused */
      paused: boolean;
      /**
       * The maximum time in seconds for a deployment to make progress before it is considered to be failed.
       *
       * The deployment controller will continue to process failed deployments and a condition with a
       * ProgressDeadlineExceeded reason will be surfaced in the deployment status. Note that progress
       * will not be estimated during the time a deployment is paused. Defaults to 600s.
       */
      progressDeadlineSeconds: number;
      /**
       * Number of desired pods.
       *
       * Defaults to 1. 0 is not allowed.
       *
       * @defaultValue 1
       */
      replicas: number;
      /**
       * The number of old ReplicaSets to retain to allow rollback.
       *
       * This is a pointer to distinguish between explicit zero and not specified. Defaults to 10.
       *
       * @defaultValue 10
       */
      revisionHistoryLimit: number;
      /**
       * Label selector for pods.
       *
       * Existing ReplicaSets whose pods are selected by this will be the ones affected by this deployment.
       * It must match the pod template's labels.
       *
       * @remarks
       *
       * With Adapt, this is optional.  If not specified, adapt will pick a selector that will work with the pods
       * it creates as part of this {@link k8s.Deployment}
       */
      selector?: LabelSelector;
      /**
       * An deployment strategy to use to replace existing pods with new ones
       */
      strategy: DeploymentUpdateStrategy;
  }/**
   * Component for Kubernetes Deployment
   *
   * @public
   */
  export declare class Deployment extends DeferredComponent<DeploymentProps> {
      static defaultProps: {
          metadata: {};
          paused: boolean;
          replicas: number;
          progressDeadlineSeconds: number;
          minReadySeconds: number;
          revisionHistoryLimit: number;
          strategy: {
              type: string;
              rollingUpdate: {
                  maxSurge: string;
                  maxUnavailable: string;
              };
          };
      };
      constructor(props: DeploymentProps);
      build(helpers: BuildHelpers): Adapt.JSX.Element | null;
      deployedWhen: () => true | Adapt.Waiting;
      status(_observe: ObserveForStatus, buildData: BuildData): Promise<Adapt.Status | undefined>;
  }/** @internal */
  const deploymentResourceInfo: {
      kind: string;
      deployedWhen: typeof deployedWhen;
      statusQuery: (props: ResourcePropsWithConfig, observe: ObserveForStatus, buildData: BuildData) => Promise<any>;
  };/**
   * Type assertion to see if an element is both a {@link k8s.Resource | Resource}
   * and a {@link @adpt/core#FinalElement | FinalElement}
   *
   * @param e - element to test
   * @returns `true` if e is both a FinalElement and a {@link k8s.Resource | Resource}, `false` otherwise
   *
   * @public
   */
  export declare function isResourceFinalElement(e: AdaptElement): e is FinalDomElement<ResourceProps & Adapt.BuiltinProps>;/**
   * Tests whether a ResourceProps is for a template object
   *
   * @public
   */
  export declare function isResourcePropsWithConfig(x: ResourceProps & Partial<BuiltinProps>): x is ResourcePropsWithConfig & Partial<BuiltinProps>;/**
   * Tests to see if an object is a {@link k8s.Resource} element
   * @param x - object to test
   * @returns true if object is an AdaptElement of type {@link k8s.Resource}
   *
   * @public
   */
  export declare function isResource(x: any): x is AdaptElement<ResourceProps>;/**
   * Primitive Component recognized by the k8s plugin to represent resources
   * @public
   */
  export declare class Resource extends Action<ResourceProps> {
      defaultProps: {
          apiVersion: "v1";
          con: false;
      };
      manifest_: Manifest;
      constructor(props: ResourceProps);
      validate(): "Resource elements cannot have children" | undefined;
      shouldAct(op: ChangeType, ctx: ActionContext): Promise<ShouldAct>;
      action(op: ChangeType, ctx: ActionContext): Promise<void>;
      deployedWhen: (goalStatus: GoalStatus, helpers: DeployHelpers) => Promise<true | Adapt.Waiting | Adapt.Waiting[]>;
      status(observe: ObserveForStatus, buildData: BuildData): Promise<any>;
      private mountedElement;
      private manifest;
  }/** @internal */
  export declare function makePodManifest(props: PodProps & BuiltinProps, data: {
      volumes?: Volume[];
      serviceAccountName?: string;
  }): {
      kind: string;
      metadata: Metadata;
      spec: PodSpec;
  };/**
   * Tests whether x is a Pod element
   *
   * @param x - value to test
   * @returns `true` if x is a Pod element, false otherwise
   *
   * @public
   */
  export declare function isPod(x: any): x is AdaptElement<PodProps>;/** @public */
  export declare interface NodeSelectorRequirement {
      /** The label key that the selector applies to. */
      key: string;
      /**
       * Represents a key's relationship to a set of values.
       *
       * Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
       */
      operator: "In" | "NotIn" | "Exists" | "DoesNotExist" | "Gt" | "Lt";
      /**
       * Values for operator
       *
       * If the operator is In or NotIn, the values array must be non-empty.
       * If the operator is Exists or DoesNotExist, the values array must be empty.
       * If the operator is Gt or Lt, the values array must have a single element,
       * which will be interpreted as an integer.
       * This array is replaced during a strategic merge patch.
       */
      values: string[];
  }/** @public */
  export declare interface NodeSelectorTerm {
      /** A list of node selector requirements by node's labels. */
      matchExpressions?: NodeSelectorRequirement[];
      /** A list of node selector requirements by node's fields. */
      matchFields?: NodeSelectorRequirement[];
  }/** @public */
  export declare interface PreferredSchedulingTerm {
      /**
       * A node selector term, associated with the corresponding weight.
       */
      preference: NodeSelectorTerm;
      /** Weight associated with matching the corresponding nodeSelectorTerm, in the range 1-100. */
      weight: number;
  }/** @public */
  export declare interface NodeSelector {
      /** A list of node selector terms. The terms are ORed */
      nodeSelectorTerms: NodeSelectorTerm[];
  }/** @public */
  export declare interface NodeAffinity {
      /** The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding "weight" to the sum if the node matches the corresponding matchExpressions; the node(s) with the highest sum are the most preferred. */
      preferredDuringSchedulingIgnoredDuringExecution?: PreferredSchedulingTerm[];
      /** If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to an update), the system may or may not try to eventually evict the pod from its node. */
      requiredDuringSchedulingIgnoredDuringExecution?: NodeSelector;
  }/** @public */
  export declare interface PodAffinityTerm {
      /**
       * Label query over a set of resources, in this case pods.
       */
      labelSelector: LabelSelector;
      /** Specifies which namespaces the labelSelector applies to (matches against); null or empty list means "this pod's namespace" */
      namespaces?: string[];
      /** This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed. */
      topologyKey: string;
  }/** @public */
  export declare interface WeightedPodAffinityTerm {
      /** A pod affinity term, associated with the corresponding weight. */
      podAffinityTerm: PodAffinityTerm;
      /**
       * weight associated with matching the corresponding podAffinityTerm, in the range 1-100.
       */
      weight: number;
  }/** @public */
  export declare interface PodAffinity {
      /**
       * The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions.
       *
       * The node that is most preferred is the one with the greatest sum of weights,
       * i.e. for each node that meets all of the scheduling requirements (resource request,
       * requiredDuringScheduling affinity expressions, etc.), compute a sum by iterating
       * through the elements of this field and adding "weight" to the sum if the node has pods
       * which matches the corresponding podAffinityTerm; the node(s) with the highest sum are the most preferred.
       */
      preferredDuringSchedulingIgnoredDuringExecution: WeightedPodAffinityTerm[];
      /**
       * If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node.
       *
       * If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system may or may not try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each podAffinityTerm are intersected, i.e. all terms must be satisfied.
       */
      requiredDuringSchedulingIgnoredDuringExecution: PodAffinityTerm[];
  }/** @public */
  export declare interface PodAntiAffinity {
      /** The scheduler will prefer to schedule pods to nodes that satisfy the anti-affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling anti-affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the node(s) with the highest sum are the most preferred. */
      preferredDuringSchedulingIgnoredDuringExecution: WeightedPodAffinityTerm[];
      /** If the anti-affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the anti-affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system may or may not try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each podAffinityTerm are intersected, i.e. all terms must be satisfied. */
      requiredDuringSchedulingIgnoredDuringExecution: PodAffinity;
  }/** @public */
  export declare interface Affinity {
      /** Describes node affinity scheduling rules for the pod. */
      nodeAffinity: NodeAffinity;
      /** Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)). */
      podAffinity: PodAffinity;
      /** PodAntiAffinity	Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)). */
      podAntiAffinity: PodAntiAffinity;
  }/** @public */
  export declare interface PodDNSConfigOption {
      name: string;
      value?: string;
  }/** @public */
  export declare interface PodDNSConfig {
      /**
       * A list of DNS name server IP addresses.
       *
       * This will be appended to the base nameservers generated from DNSPolicy. Duplicated nameservers will be removed.
       */
      nameservers: string[];
      /**
       * A list of DNS resolver options.
       *
       * This will be merged with the base options generated from DNSPolicy.
       * Duplicated entries will be removed.
       * Resolution options given in Options will override those that appear in the base DNSPolicy.
       */
      options: PodDNSConfigOption[];
      /**
       * A list of DNS search domains for host-name lookup.
       *
       * This will be appended to the base search paths generated from DNSPolicy. Duplicated search paths will be removed.
       */
      searches: string[];
  }/** @public */
  export declare interface PodReadinessGate {
      /** Refers to a condition in the pod's condition list with matching type. */
      conditionType: string;
  }/** @public */
  export declare interface SELinuxOptions {
      /** SELinux level label that applies to the container. */
      level: string;
      /** SELinux role label that applies to the container. */
      role: string;
      /** SELinux type label that applies to the container. */
      type: string;
      /** SELinux user label that applies to the container */
      user: string;
  }/** @public */
  export declare interface SeccompProfile {
      /**
       * Indicates a profile defined in a file on the node should be used.
       *
       * The profile must be preconfigured on the node to work.
       * Must be a descending path, relative to the kubelet's configured seccomp profile location.
       * Must only be set if type is "Localhost".
       */
      localhostProfile?: string;
      /**
       * Indicates which kind of seccomp profile will be applied.
       *
       * Valid options are:
       * * Localhost - a profile defined in a file on the node should be used.
       * * RuntimeDefault - the container runtime default profile should be used.
       * * Unconfined - no profile should be applied.
       */
      type: "Localhost" | "RuntimeDefault" | "Unconfined";
  }/** @public */
  export declare interface Sysctl {
      name: string;
      value: string;
  }/** @public */
  export declare interface WindowsSecurityContextOptions {
      /**
       * The GMSA admission webhook ({@link https://github.com/kubernetes-sigs/windows-gmsa}) inlines the contents of the GMSA credential spec named by the GMSACredentialSpecName field.
       */
      gmsaCredentialSpec?: string;
      /**
       * GMSACredentialSpecName is the name of the GMSA credential spec to use.
       */
      gmsaCredentialSpecName?: string;
      /**
       * The UserName in Windows to run the entrypoint of the container process.
       *
       * Defaults to the user specified in image metadata if unspecified. May also be set in PodSecurityContext.
       * If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
       */
      runAsUserName?: string;
  }/** @public */
  export declare interface PodSecurityContext {
      /**
       * A special supplemental group that applies to all containers in a pod.
       *
       * Some volume types allow the Kubelet to change the ownership of that volume to be owned by the pod:
       *
       * 1. The owning GID will be the FSGroup
       * 2. The setgid bit is set (new files created in the volume will be owned by FSGroup)
       * 3. The permission bits are OR'd with rw-rw----
       *
       * If unset, the Kubelet will not modify the ownership and permissions of any volume.
       */
      fsGroup?: number;
      /**
       * Defines behavior of changing ownership and permission of the volume before being exposed inside Pod.
       *
       * This field will only apply to volume types which support fsGroup based ownership(and permissions).
       * It will have no effect on ephemeral volume types such as: secret, configmaps and emptydir.
       * Valid values are "OnRootMismatch" and "Always". If not specified defaults to "Always".
       *
       * @defaultValue Always
       */
      fsGroupChangePolicy?: "OnRootMismatch" | "Always";
      /**
       * The GID to run the entrypoint of the container process.
       *
       * Uses runtime default if unset. May also be set in SecurityContext.
       * If set in both SecurityContext and PodSecurityContext, the value specified in
       * SecurityContext takes precedence for that container.
       */
      runAsGroup?: number;
      /**
       * Indicates that the container must run as a non-root user.
       *
       * If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and
       * fail to start the container if it does. If unset or false, no such validation will be performed.
       * May also be set in SecurityContext.
       * If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
       */
      runAsNonRoot?: boolean;
      /**
       * The UID to run the entrypoint of the container process.
       *
       * Defaults to user specified in image metadata if unspecified.
       * May also be set in SecurityContext.
       * If set in both SecurityContext and PodSecurityContext, the value specified in
       * SecurityContext takes precedence for that container.
       */
      runAsUser?: number;
      /**
       * The SELinux context to be applied to all containers.
       *
       * If unspecified, the container runtime will allocate a random SELinux context for each container.
       * May also be set in SecurityContext.
       * If set in both SecurityContext and PodSecurityContext, the value specified in
       * SecurityContext takes precedence for that container.
       */
      seLinuxOptions?: SELinuxOptions;
      /**
       * The seccomp options to use by the containers in this pod.
       */
      seccompProfile?: SeccompProfile;
      /**
       * 	A list of groups applied to the first process run in each container, in addition to the container's primary GID.
       *
       *  If unspecified, no groups will be added to any container.
       */
      supplementalGroups?: number[];
      /**
       * Sysctls hold a list of namespaced sysctls used for the pod.
       *
       * Pods with unsupported sysctls (by the container runtime) might fail to launch.
       */
      sysctls?: Sysctl[];
      /**
       * The Windows specific settings applied to all containers.
       *
       * If unspecified, the options within a container's SecurityContext will be used.
       * If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
       */
      windowsOptions: WindowsSecurityContextOptions;
  }/** @public */
  export declare interface Toleration {
      /**
       * Indicates the taint effect to match.
       *
       * Empty means match all taint effects.
       * When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
       */
      effect?: "NoSchedule" | "PreferNoSchedule" | "NoExecute";
      /**
       * The taint key that the toleration applies to.
       *
       * Empty means match all taint keys.
       * If the key is empty, operator must be Exists;
       * this combination means to match all values and all keys.
       */
      key?: string;
      /**
       * Represents a key's relationship to the value.
       *
       * Valid operators are Exists and Equal.
       * Defaults to Equal.
       * Exists is equivalent to wildcard for value, so that a pod can tolerate all taints of a particular category.
       *
       * @defaultValue Equal
       */
      operator?: "Exists" | "Equal";
      /**
       * Represents the period of time the toleration (which must be of effect NoExecute, otherwise this field is ignored) tolerates the taint.
       *
       * By default, it is not set, which means tolerate the taint forever (do not evict).
       * Zero and negative values will be treated as 0 (evict immediately) by the system.
       */
      tolerationSeconds?: number;
      /**
       * Value is the taint value the toleration matches to.
       *
       * If the operator is Exists, the value should be empty, otherwise just a regular string.
       */
      value?: string;
  }/** @public */
  export declare interface TopologySpreadConstraint {
      /**
       * Used to find matching pods.
       *
       * Pods that match this label selector are counted to determine the
       * number of pods in their corresponding topology domain.
       */
      labelSelector: LabelSelector;
      /**
       * Describes the degree to which pods may be unevenly distributed.
       *
       * When `whenUnsatisfiable=DoNotSchedule`, it is the maximum permitted
       * difference between the number of matching pods in the target topology
       * and the global minimum.
       * For example, in a 3-zone cluster, MaxSkew is set to 1, and pods with
       * the same labelSelector spread as 1/1/0: | zone1 | zone2 | zone3 | | P | P | |
       * - if MaxSkew is 1, incoming pod can only be scheduled to zone3 to become 1/1/1;
       *   scheduling it onto zone1(zone2) would make the ActualSkew(2-0) on zone1(zone2) violate MaxSkew(1).
       * - if MaxSkew is 2, incoming pod can be scheduled onto any zone.
       * When `whenUnsatisfiable=ScheduleAnyway`, it is used to give higher precedence to topologies that satisfy it.
       * It's a required field. Default value is 1 and 0 is not allowed.
       *
       * @example
       *
       * @defaultValue 1
       */
      maxSkew: number;
      /**
       * The key of node labels.
       *
       * Nodes that have a label with this key and identical values are considered to be in the same topology.
       * We consider each \<key, value\> as a "bucket", and try to put balanced number of pods into each bucket.
       * It's a required field.
       */
      topologyKey: string;
      /**
       * Indicates how to deal with a pod if it doesn't satisfy the spread constraint.
       *
       * - DoNotSchedule (default) tells the scheduler not to schedule it.
       * - ScheduleAnyway tells the scheduler to schedule the pod in any location,
       *   but giving higher precedence to topologies that would help reduce the skew.
       *
       * A constraint is considered "Unsatisfiable" for an incoming pod if and only if every possible
       * node assigment for that pod would violate "MaxSkew" on some topology.
       * For example, in a 3-zone cluster, MaxSkew is set to 1, and pods with the same labelSelector
       * spread as 3/1/1: | zone1 | zone2 | zone3 | | P P P | P | P | If WhenUnsatisfiable is set to DoNotSchedule,
       * incoming pod can only be scheduled to zone2(zone3) to become 3/2/1(3/1/2)
       * as ActualSkew(2-1) on zone2(zone3) satisfies MaxSkew(1).
       * In other words, the cluster can still be imbalanced, but scheduler won't make it
       * *more* imbalanced.
       *
       * It's a required field.
       */
      whenUnsatisfiable: string;
  }/** @public */
  export declare interface KeyToPath {
      /** The key to project. */
      key: string;
      /**
       * mode bits to use on this file,
       * Must be a value between 0 and 0777.
       * If not specified, the volume defaultMode will be used.
       * This might be in conflict with other options that affect the file mode, like fsGroup,
       * and the result can be other mode bits set.
       */
      mode?: number;
      /**
       * The relative path of the file to map the key to.
       *
       * May not be an absolute path. May not contain the path element '..'. May not start with the string '..'.
       */
      path: string;
  }/** @public */
  export declare interface ConfigMapVolumeSource {
      /**
       * mode bits to use on created files by default.
       *
       * Must be a value between 0 and 0777. Defaults to 0644.
       * Directories within the path are not affected by this setting.
       * This might be in conflict with other options that affect the file mode,
       * like fsGroup, and the result can be other mode bits set.
       */
      defaultMode?: number;
      /**
       * If unspecified, each key-value pair in the Data field of the referenced ConfigMap will be projected into the volume as a file whose name is the key and content is the value.
       *
       * If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present.
       * If a key is specified which is not present in the ConfigMap, the volume setup will error unless it is marked optional.
       * Paths must be relative and may not contain the '..' path or start with '..'.
       */
      items?: KeyToPath[];
      /**
       * Name of the referent.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names}
       */
      name: string | Handle;
      /** Specify whether the ConfigMap or its keys must be defined */
      optional?: boolean;
  }/** @public */
  export declare interface SecretVolumeSource {
      /**
       * mode bits to use on created files by default.
       *
       * Must be a value between 0 and 0777. Defaults to 0644.
       * Directories within the path are not affected by this setting.
       * This might be in conflict with other options that affect the file mode,
       * like fsGroup, and the result can be other mode bits set.
       */
      defaultMode?: number;
      /**
       * If unspecified, each key-value pair in the Data field of the referenced Secret will be projected into the volume as a file whose name is the key and content is the value.
       *
       * If specified, the listed keys will be projected into the specified paths,
       * and unlisted keys will not be present. If a key is specified which is not
       * present in the Secret, the volume setup will error unless it is marked optional.
       *
       * Paths must be relative and may not contain the '..' path or start with '..'.
       */
      items?: KeyToPath[];
      /** Specify whether the Secret or its keys must be defined */
      optional?: boolean;
      /**
       * Name of the secret in the pod's namespace to use.
       *
       *  More info: {@link https://kubernetes.io/docs/concepts/storage/volumes#secret}
       */
      secretName: string | Handle;
  }/** @public */
  export declare interface EmptyDirVolumeSource {
      /**
       * What type of storage medium should back this directory.
       *
       * The default is "" which means to use the node's default medium.
       * Must be an empty string (default) or Memory.
       * More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
       */
      medium: string;
      /**
       * Total amount of local storage required for this EmptyDir volume.
       *
       * The size limit is also applicable for memory medium.
       * The maximum usage on memory medium EmptyDir would be the minimum
       * value between the SizeLimit specified here and the sum of memory limits of all containers in a pod.
       * The default is nil which means that the limit is undefined.
       * More info: {@link http://kubernetes.io/docs/user-guide/volumes#emptydir}
       */
      sizeLimit: string;
  }/**
   * Volumes for {@link k8s.PodProps}
   *
   * @public
   */
  export declare interface Volume {
      /**
       * Volume's name.
       *
       * Must be a DNS_LABEL and unique within the pod.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names}
       */
      name: string;
      /**
       * Represents a configMap that should populate this volume
       */
      configMap?: ConfigMapVolumeSource;
      /**
       * EmptyDir represents a temporary directory that shares a pod's lifetime.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/storage/volumes#emptydir}
       *
       */
      emptyDir?: EmptyDirVolumeSource;
      /**
       * Represents a secret that should populate this volume.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/storage/volumes#secret}
       */
      secret?: SecretVolumeSource;
      /** Other k8s volume kinds not typed yet for \@adpt/cloud */
      [key: string]: any;
  }/**
   * Props for the {@link k8s.Pod} component
   *
   * @public
   */
  export declare interface PodProps extends WithChildren {
      /**
       *  True is this is a template for use in a controller, false otherwise
       *  @defaultValue false
       */
      isTemplate: boolean;
      /** Information about the k8s cluster (ip address, auth info, etc.) */
      config?: ClusterInfo;
      /** k8s metadata */
      metadata: Metadata;
      /**
       * Optional duration in seconds the pod may be active on the node relative to StartTime before the system will actively try to mark it failed and kill associated containers.
       *
       * Value must be a positive integer.
       */
      activeDeadlineSeconds?: number;
      /** If specified, the pod's scheduling constraints */
      affinity?: Affinity;
      /** AutomountServiceAccountToken indicates whether a service account token should be automatically mounted. */
      automountServiceAccountToken?: boolean;
      /**
       *  Specifies the DNS parameters of a pod.
       *
       *  Parameters specified here will be merged to the generated DNS configuration based on DNSPolicy.
       */
      dnsConfig?: PodDNSConfig;
      /**
       * Set DNS policy for the pod.
       *
       * Valid values are 'ClusterFirstWithHostNet', 'ClusterFirst', 'Default' or 'None'.
       * DNS parameters given in DNSConfig will be merged with the policy selected with DNSPolicy.
       * To have DNS options set along with hostNetwork, you have to specify DNS policy explicitly
       * to 'ClusterFirstWithHostNet'.
       *
       * @defaultValue ClusterFirst
       */
      dnsPolicy: "ClusterFirstWithHostNet" | "ClusterFirst" | "Default" | "None";
      /**
       * Indicates whether information about services should be injected into pod's environment variables matching the syntax of Docker links.
       *
       * @defaultValue true
       */
      enableServiceLinks: boolean;
      /**
       * An optional list of hosts and IPs that will be injected into the pod's hosts file if specified.
       *
       * This is only valid for non-hostNetwork pods.
       */
      hostAliases?: HostAlias[];
      /**
       * Use the host's ipc namespace.
       * @defaultValue false
       */
      hostIPC: boolean;
      /**
       * Host networking requested for this pod.
       *
       * Use the host's network namespace.
       * If this option is set, the ports that will be used must be specified. Default to false.
       */
      hostNetwork?: boolean;
      /**
       * Use the host's pid namespace.
       * @defaultValue false
       */
      hostPID: boolean;
      /**
       * Specifies the hostname of the Pod.
       *
       * If not specified, the pod's hostname will be set to a system-defined value.
       */
      hostname?: string;
      /**
       * List of references to secrets in the same namespace to use for pulling any of the images used by this PodSpec.
       *
       * If specified, these secrets will be passed to individual puller implementations for them to use.
       * For example, in the case of docker, only DockerConfig type secrets are honored.
       * More info: {@link https://kubernetes.io/docs/concepts/containers/images#specifying-imagepullsecrets-on-a-pod}
       */
      imagePullSecrets?: LocalObjectReference[];
      /**
       * A request to schedule this pod onto a specific node.
       *
       * If it is non-empty, the scheduler simply schedules this pod onto that node,
       * assuming that it fits resource requirements.
       */
      nodeName?: string;
      /**
       * A selector which must be true for the pod to fit on a node.
       *
       * Selector which must match a node's labels for the pod to be scheduled on that node.
       * More info: {@link https://kubernetes.io/docs/concepts/configuration/assign-pod-node/}
       */
      nodeSelector?: {
          [label: string]: boolean | string;
      };
      /**
       * Overhead represents the resource overhead associated with running a pod for a given RuntimeClass.
       *
       * This field will be autopopulated at admission time by the RuntimeClass admission controller.
       * If the RuntimeClass admission controller is enabled, overhead must not be set in Pod create requests.
       * The RuntimeClass admission controller will reject Pod create requests which have the overhead already set.
       * If RuntimeClass is configured and selected in the PodSpec, Overhead will be set to the value defined in
       * the corresponding RuntimeClass, otherwise it will remain unset and treated as zero.
       *
       * More info: {@link https://git.k8s.io/enhancements/keps/sig-node/20190226-pod-overhead.md}
       *
       * This field is alpha-level as of Kubernetes v1.16, and is only honored by servers that enable
       * the PodOverhead feature.
       * @alpha
       */
      overhead?: unknown;
      /**
       * PreemptionPolicy is the Policy for preempting pods with lower priority.
       *
       * This field is beta-level, gated by the NonPreemptingPriority feature-gate.
       *
       * @defaultValue PreemptLowerPriority
       * @beta
       */
      preemptionPolicy?: "Never" | "PreemptLowerPriority";
      /**
       * The priority various system components use this field to find the priority of the pod.
       *
       * When Priority Admission Controller is enabled, it prevents users from setting this field.
       * The admission controller populates this field from PriorityClassName.
       * The higher the value, the higher the priority.
       */
      priority?: number;
      /**
       * If specified, indicates the pod's priority.
       *
       * "system-node-critical" and "system-cluster-critical" are two special keywords which indicate the highest
       * priorities with the former being the highest priority. Any other name must be defined by creating a PriorityClass
       * object with that name. If not specified, the pod priority will be default or zero if there is no default.
       */
      priorityClassName?: string;
      /**
       *  If specified, all readiness gates will be evaluated for pod readiness.
       *
       *  A pod is ready when all its containers are ready AND all conditions specified
       *  in the readiness gates have status equal to "True"
       *
       *  More info: {@link https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#pod-readiness-gate}
       */
      readinessGates?: PodReadinessGate[];
      /**
       * Restart policy for all containers within the pod.
       *
       * One of Always, OnFailure, Never. Default to Always.
       * More info: {@link https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy}
       *
       * @defaultValue Always
       */
      restartPolicy: "Always" | "OnFailure" | "Never";
      /**
       * Refers to a RuntimeClass object in the node.k8s.io group, which should be used to run this pod.
       *
       * If no RuntimeClass resource matches the named class, the pod will not be run.
       * If unset or empty, the "legacy" RuntimeClass will be used, which is an implicit
       * class with an empty definition that uses the default runtime handler.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/containers/runtime-class/}
       *
       * This is a beta feature as of Kubernetes v1.14.
       */
      runtimeClassName?: string;
      /**
       *  If specified, the pod will be dispatched by specified scheduler.
       *  If not specified, the pod will be dispatched by default scheduler.
       */
      schedulerName?: string;
      /**
       * SecurityContext holds pod-level security attributes and common container settings.
       * See type description for default values of each field.
       *
       * @defaultValue \{\}
       */
      securityContext: PodSecurityContext;
      /**
       * ServiceAccountName is the name of the ServiceAccount to use to run this pod.
       * More info: {@link https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/}
       */
      serviceAccountName?: string | Handle;
      /**
       * If true the pod's hostname will be configured as the pod's FQDN, rather than the leaf name (the default).
       * In Linux containers, this means setting the FQDN in the hostname field of the kernel
       * (the nodename field of struct utsname).
       * In Windows containers, this means setting the registry value of hostname for the registry key
       * HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters to FQDN.
       * If a pod does not have FQDN, this has no effect.
       *
       * @defaultValue false
       */
      setHostnameAsFQDN?: boolean;
      /**
       * Share a single process namespace between all of the containers in a pod.
       * When this is set containers will be able to view and signal processes from other containers in the same pod,
       * and the first process in each container will not be assigned PID 1.
       * HostPID and ShareProcessNamespace cannot both be set.
       *
       * @defaultValue false
       */
      shareProcessNamespace: boolean;
      /**
       *  If specified, the fully qualified Pod hostname will be "\<hostname\>.\<subdomain\>.\<pod namespace\>.svc.\<cluster domain\>".
       *  If not specified, the pod will not have a domainname at all.
       */
      subdomain?: string;
      /**
       * Optional duration in seconds the pod needs to terminate gracefully.
       *
       * May be decreased in delete request. Value must be non-negative integer.
       * The value zero indicates delete immediately. If this value is nil, the default
       * grace period will be used instead. The grace period is the duration in seconds
       * after the processes running in the pod are sent a termination signal and the time
       * when the processes are forcibly halted with a kill signal. Set this value longer
       * than the expected cleanup time for your process. Defaults to 30 seconds.
       */
      terminationGracePeriodSeconds?: number;
      /** If specified, the pod's tolerations. */
      tolerations?: Toleration[];
      /**
       *  TopologySpreadConstraints describes how a group of pods ought to spread across topology domains.
       *
       *  Scheduler will schedule pods in a way which abides by the constraints. All topologySpreadConstraints are ANDed.
       */
      topologySpreadConstraints?: TopologySpreadConstraint[];
      /**
       * List of volumes that can be mounted by containers belonging to the pod.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/storage/volumes}
       */
      volumes?: Volume[];
  }/**
   * Component for Kubernetes Pods
   *
   * @public
   */
  export declare class Pod extends DeferredComponent<PodProps, ResolvedVolumes & ResolvedServiceAccountName> {
      static defaultProps: {
          isTemplate: boolean;
          metadata: {};
          dnsPolicy: string;
          enableServiceLinks: boolean;
          hostIPC: boolean;
          hostPID: boolean;
          restartPolicy: string;
          securityContext: {};
          shareProcessNamespace: boolean;
          terminationGracePeriodSeconds: number;
      };
      initialState(): {};
      build(helpers: BuildHelpers): Adapt.JSX.Element | null;
      status(_observe: ObserveForStatus, buildData: BuildData): Promise<Adapt.Status | undefined>;
  }/**
   * Spec for for Kubernetes Pods
   *
   * @public
   */
  export declare interface PodSpec extends Omit<PodProps, "config" | "metadata" | "isTemplate"> {
      containers: ContainerSpec[];
      terminationGracePeriodSeconds?: number;
  }/** @internal */
  const podResourceInfo: {
      kind: string;
      deployedWhen: typeof deployedWhen;
      statusQuery: (props: ResourcePropsWithConfig, observe: ObserveForStatus, buildData: BuildData) => Promise<any>;
  };/**
   * k8s Secret resource
   *
   * @param propsIn - props for Secret as specifed in {@link k8s.SecretProps}
   *
   * @public
   */
  export declare function Secret(propsIn: SFCDeclProps<SecretProps, typeof defaultProps>): Adapt.JSX.Element;/** @internal */
  const secretResourceInfo: {
      kind: string;
      deployedWhen: () => true;
      statusQuery: (props: ResourcePropsWithConfig, observe: ObserveForStatus, buildData: BuildData) => Promise<any>;
      makeManifest: (manifest: Manifest, elem: AdaptElement<ResourceProps>, _deployID: string) => {
          data: {
              [key: string]: string;
          } | undefined;
          stringData: {
              [key: string]: string;
          } | undefined;
          type: string | undefined;
          apiVersion: string; /**
           * stringData allows specifying non-binary secret data in string form.
           *
           * It is provided as a write-only convenience method. All keys and values are merged into the data field on write,
           * overwriting any existing values. It is never output when reading from the API.
           */
          kind: string;
          metadata: import("./manifest_support").MetadataInRequest;
          spec?: import("./DaemonSet").DaemonSetSpec | import("./common").CRSpec | import("./Pod").PodSpec | import("./Service").ServiceSpec | import("./Deployment").DeploymentSpec | undefined;
      };
  };/**
   * Convert {@link NetworkService} props to {@link k8s.Service} props
   * @param abstractProps - props to convert
   * @returns Kubernetes spec corresponding to `abstractProps`
   *
   * @internal
   */
  export declare function k8sServiceProps(abstractProps: NetworkServiceProps & BuiltinProps): Omit<ServiceProps, keyof ResourceBase>;/**
   * Native Kubernetes Service resource
   *
   * @remarks
   *
   * Implements the {@link NetworkServiceInstance} interface.
   *
   * @public
   */
  export declare function Service(propsIn: SFCDeclProps<ServiceProps, typeof defaultProps>): Adapt.JSX.Element;/** @public */
  export declare interface ServiceProps extends ServiceSpec {
      /** Legal configuration loaded from kubeconfig */
      config: ClusterInfo;
      metadata?: Metadata;
      selector?: Handle | EndpointSelector;
  }/** @public */
  export declare interface ServiceSpec {
      /**
       * Cluster IP for a {@link k8s.Service}
       *
       * @remarks
       * `clusterIP` is the IP address of the service and is usually assigned
       * randomly by the master. If an address is specified manually and is not
       * in use by others, it will be allocated to the service; otherwise,
       * creation of the service will fail. This field can not be changed through
       * updates. Valid values are "None", empty string (""), or a valid IP
       * address. "None" can be specified for headless services when proxying is
       * not required. Only applies to types ClusterIP, NodePort, and
       * LoadBalancer. Ignored if type is ExternalName.
       *
       * For more information, see the
       * {@link https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies |
       * Kubernetes documentation}.
       */
      clusterIP?: string;
      /**
       * A list of IP addresses for which nodes in the cluster
       * will also accept traffic for this service.
       *
       * @remarks
       * These IPs are not managed by
       * Kubernetes. The user is responsible for ensuring that traffic arrives at
       * a node with this IP. A common example is external load balancers that are
       * not part of the Kubernetes system.
       */
      externalIPs?: string[];
      /**
       * The external reference that kubedns or equivalent
       * will return as a CNAME record for this service.
       *
       * @remarks
       * No proxying will be involved. Must be a
       * {@link https://tools.ietf.org/html/rfc1123 | valid RFC-1123 hostname}
       * and requires Type to be ExternalName.
       */
      externalName?: string;
      /**
       * Denotes if this Service desires to route
       * external traffic to node-local or cluster-wide endpoints.
       *
       * @remarks
       * "Local" preserves the client source IP and avoids a second hop for
       * LoadBalancer and Nodeport type services, but risks potentially
       * imbalanced traffic spreading. "Cluster" obscures the client source IP
       * and may cause a second hop to another node, but should have good overall
       * load-spreading.
       */
      externalTrafficPolicy?: string;
      /**
       * Specifies the healthcheck nodePort for the service.
       *
       * @remarks
       * If not specified, HealthCheckNodePort is created by the service
       * api backend with the allocated nodePort. Will use user-specified nodePort
       * value if specified by the client. Only affects when Type is set to
       * LoadBalancer and ExternalTrafficPolicy is set to Local.
       */
      healthCheckNodePort?: number;
      /**
       * Only applies to Service Type: LoadBalancer. LoadBalancer will
       * get created with the IP specified in this field.
       *
       * @remarks
       * This feature depends on
       * whether the underlying cloud provider supports specifying the loadBalancerIP
       * when a load balancer is created. This field will be ignored if the
       * cloud provider does not support the feature.
       */
      loadBalancerIP?: string;
      /**
       * If specified and supported by the platform, this will
       * restrict traffic through the cloud provider load balancer
       * to the specified client IPs.
       *
       * @remarks
       * This field will be ignored if the cloud provider
       * does not support the feature.
       *
       * For more information, see the
       * {@link https://v1-17.docs.kubernetes.io/docs/tasks/access-application-cluster/configure-cloud-provider-firewall/ |
       * Kubernetes documentation}.
       */
      loadBalancerSourceRanges?: string[];
      /**
       * The list of ports that are exposed by this service.
       *
       * @remarks
       * For more information, see the
       * {@link https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies |
       * Kubernetes documentation}.
       */
      ports?: ServicePort[];
      /**
       * When set to true, indicates that
       * DNS implementations must publish the notReadyAddresses of subsets for the
       * Endpoints associated with the Service.
       *
       * @remarks
       * The default value is false. The
       * primary use case for setting this field is to use a StatefulSet's Headless
       * Service to propagate SRV records for its Pods without respect to their
       * readiness for purpose of peer discovery.
       */
      publishNotReadyAddresses?: boolean;
      /**
       * Route service traffic to pods with label keys and values
       * matching this selector.
       *
       * @remarks
       * If empty or not present, the service is assumed to
       * have an external process managing its endpoints, which Kubernetes will not
       * modify. Only applies to types ClusterIP, NodePort, and LoadBalancer.
       * Ignored if type is ExternalName.
       *
       * For more information, see the
       * {@link https://kubernetes.io/docs/concepts/services-networking/service/ |
       * Kubernetes documentation}.
       */
      selector?: EndpointSelector | object;
      /**
       * Used to maintain session affinity.
       *
       * @remarks
       * Possible values are:
       *
       * - `"ClientIP"`: Enables client IP based session affinity.
       *
       * - `"None"`: Disables session affinity.
       *
       * For more information, see the
       * {@link https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies |
       * Kubernetes documentation}.
       * @defaultValue `"None"`
       */
      sessionAffinity?: string;
      /**
       * Determines how the Service is exposed.
       *
       * @remarks
       * Valid options are:
       *
       * - `"ExternalName"`: maps to the specified externalName.
       *
       * - `"ClusterIP"`: allocates a cluster-internal IP address for load
       * balancing to endpoints. Endpoints are determined by the selector or if
       * that is not specified, by manual construction of an Endpoints object. If
       * clusterIP is "None", no virtual IP is allocated and the endpoints are
       * published as a set of endpoints rather than a stable IP.
       *
       * - `"NodePort"`: Builds on ClusterIP and allocates a port on every node
       * which routes to the clusterIP.
       *
       * - `"LoadBalancer"`: Builds on NodePort and creates an external load
       * balancer (if supported in the current cloud) which routes to the
       * clusterIP.
       *
       * For more information, see the
       * {@link https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services---service-types |
       * Kubernetes documentation}.
       * @defaultValue `"ClusterIP"`
       */
      type?: string;
  }/** @public */
  export declare interface ServicePort {
      /**
       * The name of this port within the service.
       *
       * @remarks
       * This must be a DNS_LABEL.
       * All ports within a ServiceSpec must have unique names.This maps to the
       * Name' field in EndpointPort objects. Optional if only one ServicePort is
       * defined on this service.
       */
      name?: string;
      /**
       * The port on each node on which this service is exposed when
       * type=NodePort or LoadBalancer.
       *
       * @remarks
       * Usually assigned by the system. If
       * specified, it will be allocated to the service if unused or else creation
       * of the service will fail.
       *
       * For more information, see the
       * {@link https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport |
       * Kubernetes documentation}.
       * @defaultValue Automatically allocates a port if the ServiceType of this
       * Service requires one.
       */
      nodePort?: number;
      /** The port that will be exposed by this service. */
      port?: number;
      /** The IP protocol for this port.Supports "TCP" and "UDP".Default is TCP. */
      protocol?: string;
      /**
       * Number or name of the port to access on the pods targeted by the
       * service.
       *
       * @remarks
       * Number must be in the range 1 to 65535. Name must be an
       * IANA_SVC_NAME. If this is a string, it will be looked up as a named port
       * in the target Pod's container ports. If this is not specified, the value
       * of the 'port' field is used (an identity map). This field is ignored for
       * services with clusterIP = None, and should be omitted or set equal to the
       * 'port' field.
       *
       * For more information, see the
       * {@link https://kubernetes.io/docs/concepts/services-networking/service/#defining-a-service |
       * Kubernetes documentation}.
       */
      targetPort?: number | string;
  }/** @internal */
  const serviceResourceInfo: {
      kind: string;
      deployedWhen: typeof deployedWhen;
      statusQuery: (props: ResourcePropsWithConfig, observe: ObserveForStatus, buildData: BuildData) => Promise<any>;
  };/**
   * k8s ServiceAccount resource
   *
   * @param propsIn - props for ServiceAccount as specifed in {@link k8s.ServiceAccountProps}
   *
   * @public
   */
  export declare function ServiceAccount(propsIn: SFCDeclProps<ServiceAccountProps, typeof defaultProps>): Adapt.JSX.Element;/** @public */
  export declare function isServiceAccountProps(p: ResourceProps): p is ResourceProps & ResourceServiceAccount;/** @internal */
  const serviceAccountResourceInfo: {
      kind: string;
      deployedWhen: () => true;
      statusQuery: (props: ResourcePropsWithConfig, observe: ObserveForStatus, buildData: BuildData) => Promise<any>;
      makeManifest: (manifest: Manifest, elem: AdaptElement<ResourceProps>, _deployID: string) => {
          automountServiceAccountToken: boolean | undefined;
          imagePullSecrets: {
              name: string;
          }[] | undefined;
          secrets: ObjectReference[] | undefined;
          apiVersion: string;
          kind: string;
          metadata: import("./manifest_support").MetadataInRequest;
          spec?: import("./DaemonSet").DaemonSetSpec | import("./common").CRSpec | import("./Pod").PodSpec | import("./Service").ServiceSpec | import("./Deployment").DeploymentSpec | undefined;
      };
  };/**
   * Props for {@link k8s.ServiceDeployment}
   *
   * @public
   */
  export declare interface ServiceDeploymentProps<T extends AllowableComponentProps = DeploymentProps> extends ServiceProps {
      config: ClusterInfo;
      serviceProps?: Partial<ServiceProps>;
      component: ComponentType<T>;
      componentProps: T;
      podProps?: Partial<PodProps>;
      containerProps?: Partial<OmitT<K8sContainerProps, "image">>;
  }/**
   * A component for mapping a group of abstract {@link Container}s and
   * {@link NetworkService}s to Kubernetes {@link k8s.Pod}s and
   * {@link k8s.K8sContainer}s.
   *
   * @remarks
   * This component is intended to be used to replace {@link Container} and
   * {@link NetworkService} components that are grouped together, as the
   * only children of a common parent in a pattern that looks like this:
   *
   * ```tsx
   * <Service>
   *   <Container ... />
   *   <Container ... />
   *   <NetworkService ... />
   * </Service>
   * ```
   *
   * `ServiceDeployment` would map those abstract components into corresponding
   * k8s components like this:
   * ```tsx
   * <Group>
   *   <docker.RegistryDockerImage ... /> //If props.config specifies a registry
   *   <k8s.Deployment ... >
   *     <Pod isTemplate>
   *       <k8s.K8sContainer ... />
   *     </Pod>
   *   </k8s.Deployment>
   *   <docker.RegistryDockerImage ... /> //If props.config specifies a registry
   *   <k8s.Deployment ... >
   *     <Pod isTemplate>
   *       <k8s.K8sContainer ... />
   *     </Pod>
   *   </k8s.Pod>
   *   <k8s.Service ... />
   * </Group>
   * ```
   * An example style rule to do this is:
   * ```tsx
   * {Adapt.rule((matchedProps) => {
   *     const { handle, ...remainingProps } = matchedProps;
   *     return <ServiceDeployment config={kubeconfig} {...remainingProps} />;
   * })}
   * ```
   * `ServiceDeployment` also requires the `config` prop which specifies
   * connection and authentication information for the Kubernetes cluster on
   * which these objects should be created.
   *
   * @public
   */
  export declare class ServiceDeployment<T extends AllowableComponentProps> extends DeferredComponent<ServiceDeploymentProps<T>> {
      static defaultProps: {
          component: typeof Deployment;
          componentProps: {
              replicas: number;
          };
      };
      build(helpers: BuildHelpers): Adapt.JSX.Element;
  }/** @public */
  export declare function computeNamespaceFromMetadata(metadata?: Metadata): string;/** @public */
  export declare function isLabelSelector(x: any): x is LabelSelector;/**
   * Kubernetes Kind
   *
   * @public
   */
  export declare type Kind = string;/** @public */
  export declare interface CRSpec {
      [key: string]: any;
  }/** @public */
  export declare type Spec = DaemonSetSpec | DeploymentSpec | PodSpec | ServiceSpec | CRSpec;/** @public */
  export declare interface Metadata {
      namespace?: string;
      labels?: {
          [key: string]: string;
      };
      annotations?: {
          [key: string]: string;
      };
  }/** @public */
  export declare type ResourceProps = {
      key: string;
  } & (ResourceClusterRole | ResourceClusterRoleBinding | ResourceDaemonSet | ResourcePod | ResourceService | ResourceServiceAccount | ResourceConfigMap | ResourceSecret | ResourceCR);/** @public */
  export declare type ResourcePropsWithConfig = ResourceProps & {
      config: ClusterInfo;
  };/** @public */
  export declare interface ResourceInfo {
      kind: Kind;
      statusQuery?: (props: ResourceProps, observe: ObserveForStatus, buildData: BuildData) => unknown | Promise<unknown>;
      specsEqual(actual: Spec, element: Spec): boolean;
  }/**
   * Holds the information needed to connect, authenticate, and run code in a kuberenetes cluster
   *
   * @public
   */
  export declare interface ClusterInfo {
      /** Javascript object formed by parsing a valid kubeconfig file */
      kubeconfig: Kubeconfig;
      /**
       * Registry to which Docker images used by the cluster in `kubeconfig` should be pushed and pulled
       *
       * @remarks
       * If `registryPrefix` is a string, it is assumed that the cluster can pull from the same string
       * that outsiders can push to.
       *
       * If `registryPrefix` is of the form `{ external: string, internal: string }` then the `external`
       * string will be used to push images, and the `internal` string will be used to pull images.
       *
       * Note(manishv)
       * This is a bit of a hack to allow one hostname or IP address to push images from outside
       * a particular environment (say k8s) and a different URL for that environment to pull
       * images.
       *
       * A good example of this is a k3s-dind (k3s docker-in-docker) instance of kubernetes where
       * a private registry is running on a docker network attached to the k3s-dind instance, but where we
       * want to push {@link docker.LocalDockerImage} built images to that registry.  Since
       * {@link docker.LocalDockerImage | LocalDockerImage} is outside the k3s-dind environment, it must
       * use a host accessible network to push to the registry.  However, since the k3s-dind instance sees
       * the registry from within Docker, it must use a different address to pull the images for use.
       *
       * Once network scopes are fully supported, this interface will change to whatever is appropriate.  It
       * is best if you can arrange to have the same URL or registry string work for all access regardless
       * of which network the registry, Adapt host, and ultimate container running environment uses.
       *
       */
      registryPrefix?: string | DockerSplitRegistryInfo;
  }/** @public */
  export declare interface ResourceBase {
      /**
       * config to connect to the k8s cluster
       *
       * required if isTemplate is false
       */
      config?: ClusterInfo;
      /**
       * Specifies whether this resource is just a template for use in a controller
       */
      isTemplate?: boolean;
      apiVersion?: string;
      kind: Kind;
      metadata?: Metadata;
  }/**
   * @public
   */
  export declare interface PolicyRule {
      /**
       * APIGroups is the name of the APIGroup that contains the resources.
       *
       * If multiple API groups are specified, any action requested against one
       * of the enumerated resources in any API group will be allowed.
       */
      apiGroups?: string[];
      /**
       * NonResourceURLs is a set of partial urls that a user should have access to.
       *
       * *s are allowed, but only as the full, final step in the path.
       * Since non-resource URLs are not namespaced, this field is only applicable
       * for ClusterRoles referenced from a ClusterRoleBinding.
       * Rules can either apply to API resources (such as "pods" or "secrets") or
       * non-resource URL paths (such as "/api"), but not both.
       */
      nonResourceURLs?: string[];
      /**
       * ResourceNames is an optional white list of names that the rule applies to.
       *
       * An empty set means that everything is allowed.
       */
      resourceNames?: string[];
      /**
       * Resources is a list of resources this rule applies to.
       *
       * ResourceAll represents all resources.
       */
      resources: string[];
      /**
       * Verbs is a list of Verbs that apply to ALL the ResourceKinds and
       * AttributeRestrictions contained in this rule.
       *
       * VerbAll represents all kinds.
       */
      verbs: string[];
  }/**
   * AggregationRule for {@link k8s.ClusterRole}
   *
   * @public
   */
  export declare interface AggregationRule {
      /**
       * ClusterRoleSelectors holds a list of selectors which will be used to
       * find ClusterRoles and create the rules.
       *
       * If any of the selectors match, then the ClusterRole's permissions will be added
       */
      clusterRoleSelector: LabelSelector;
  }/** @public */
  export declare interface ResourceClusterRole extends ResourceBase {
      apiVersion: "rbac.authorization.k8s.io/v1";
      kind: "ClusterRole";
      aggregationRule?: AggregationRule;
      rules?: PolicyRule[];
  }/**
   * RoleRef for {@link k8s.ResourceClusterRoleBinding}
   *
   * @public
   */
  export declare interface RoleRef {
      /** apiGroup is the group for the resource being referenced */
      apiGroup: string;
      /** kind is the type of resource being referenced */
      kind: string;
      /** Name is the name of resource being referenced */
      name: string;
  }/**
   * Subject for {@link k8s.ResourceClusterRoleBinding}
   *
   * @public
   */
  export declare interface Subject {
      /** apiGroup is the group for the object being referenced */
      apiGroup: string;
      /** kind is the type of object being referenced */
      kind: string;
      /**
       * Name of the object being referenced.
       */
      name: string;
      /**
       * Namespace of the referenced object.
       *
       * If the object kind is non-namespace, such as "User" or "Group", and this value
       * is not empty the Authorizer should report an error.
       */
      namespace?: string;
  }/** @public */
  export declare interface ResourceClusterRoleBinding extends ResourceBase {
      apiVersion: "rbac.authorization.k8s.io/v1";
      kind: "ClusterRoleBinding";
      roleRef: RoleRef;
      subjects: Subject[];
  }/** @public */
  export declare interface ResourceDaemonSet extends ResourceBase {
      apiVersion: "apps/v1";
      kind: "DaemonSet";
      spec: DaemonSetSpec;
  }/** @public */
  export declare interface ResourcePod extends ResourceBase {
      kind: "Pod";
      spec: PodSpec;
  }/** @public */
  export declare interface ResourceService extends ResourceBase {
      kind: "Service";
      spec: ServiceSpec;
  }/** @public */
  export declare interface ResourceServiceAccount extends ResourceBase {
      kind: "ServiceAccount";
      automountServiceAccountToken?: boolean;
      imagePullSecrets?: {
          name: string;
      }[];
      secrets?: ObjectReference[];
  }/** @public */
  export declare interface ResourceConfigMap extends ResourceBase {
      kind: "ConfigMap";
      binaryData?: {
          [key: string]: string;
      };
      data?: {
          [key: string]: string;
      };
      /** @beta */
      immutable?: boolean;
  }/** @public */
  export declare interface ResourceSecret extends ResourceBase {
      kind: "Secret";
      data?: {
          [key: string]: string;
      };
      stringData?: {
          [key: string]: string;
      };
      type?: string;
  }/** @public */
  export declare interface ResourceCR extends ResourceBase {
      kind: string;
      spec: CRSpec;
  }/** @public */
  export declare interface Kubeconfig {
      apiVersion?: "v1";
      kind: "Config";
      "current-context": string;
      contexts: {
          name: string;
          context: {
              cluster: string;
              user: string;
          };
      }[];
      clusters: {
          name: string;
          cluster: {
              "certificate-authority-data": string;
              server: string;
          };
      }[];
      preferences?: unknown;
      users: {
          name: string;
          user: {
              "client-certificate-data"?: string;
              "client-key-data"?: string;
              "username"?: string;
              "password"?: string;
          };
      }[];
  }/** @public */
  export declare interface LabelSelector {
      /**
       * matchExpressions is a list of label selector requirements. The requirements are ANDed.
       */
      matchExpressions?: LabelSelectorRequirement[];
      /**
       * matchLabels is a map of `{key,value}`pairs. A single `{key,value}` in the matchLabels map
       * is equivalent to an element of matchExpressions, whose key field is "key", the operator
       * is "In", and the values array contains only "value". The requirements are ANDed.
       */
      matchLabels?: {
          [key: string]: string;
      };
  }/** @public */
  export declare interface LocalObjectReference {
      /**
       * Name of the referent.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names}
       */
      name: string;
  }/**
   * PodTemplateSpec from k8s API
   *
   * @public
   */
  export declare interface PodTemplateSpec {
      /**
       * Standard object's metadata.
       * More Info: {@link https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata}
       */
      metadata: Metadata;
      /**
       * Specification of the desired behavior of the pod.
       * More Info: {@link https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status}
       */
      spec: PodSpec;
  }/**
   * ObjectReference from k8s API
   *
   * @public
   */
  export declare interface ObjectReference {
      /**
       * If referring to a piece of an object instead of an entire object,
       * this string should contain a valid JSON/Go field access statement,
       * such as desiredState.manifest.containers[2].
       *
       * For example, if the object reference is to a container within a pod,
       * this would take on a value like: "spec.containers\{name\}" (where "name"
       * refers to the name of the container that triggered the event) or if no
       * container name is specified "spec.containers[2]"
       * (container with index 2 in this pod).
       * This syntax is chosen only to have some well-defined way of referencing a
       * part of an object.
       */
      fieldPath: string;
      /**
       * Name of the referent.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names}
       *
       */
      name: string;
      /**
       * Namespace of the referent.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/}
       */
      namespace: string;
      /**
       * Specific resourceVersion to which this reference is made, if any.
       *
       * More info: {@link https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency}
       */
      resourceVersion: string;
      /**
       * UID of the referent.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids}
       */
      uid: string;
  }/**
   * Make a {@link k8s.ClusterInfo} object suitable for use with k8s resources
   *
   * @remarks
   *
   * This function will take a set of options and generate a {@link k8s.ClusterInfo}
   * object that contains the kubeconfig, registryPrefix for private images, and any other
   * relevant information for the cluster
   *
   * See {@link k8s.MakeClusterInfoOptions} for information on how the information
   * is computed.
   *
   * @returns A {@link k8s.ClusterInfo} object.
   *
   * @public
   */
  export declare function makeClusterInfo(options: MakeClusterInfoOptions): Promise<ClusterInfo>;/** @internal */
  export declare function isResourcePodTemplate(x: any): x is AdaptElement<ResourcePod>;/**
   * Hook that allows a prop to be either an array of handle to k8s resources and values
   *
   * @param initial - initial value of the prop, before the handles are be resolved
   * @param notReady - is a marker value to indicate that a handle's value isn't available yet
   * @param kinds - an array of legal k8s Kinds that a prop handle can point to
   * @param thisResourceName - the name of the resource using the hook, for error messages
   * @param propName - the name of the prop being resolved, again for error messages
   *
   * @returns A two element array, the first element is the current value, the second the update function
   *
   * This hook will start by returning the initial value and an update function that updates
   * the value the hook returns.  The update function takes 2 arguments - the prop value which
   * is an array with a mix of values and handles to be resolved, and a function that receives
   * the elements that any handles point to along with that elements props.  This function
   * can be passed by the caller of update to resolve handles as appropriate for the component.
   *
   * For example, {@link k8s.ClusterRoleBinding} uses this hook to resolve the subjects prop,
   * which is an array of other objects (typically {@link ServiceAccount}) that a particular
   * {@link k8s.ClusterRole} should point to.  When ClusterRoleBinding calls the update method,
   * it passes a function that will convert a {@link k8s.Resource} element of Kind `ServiceAccount`
   * to the underlying `Subject` object that kubernetes expects, namely
   * `{ apiGroup: "", kind: "ServiceAccount", name: resourceIdToName(elem, deployID), namespace: <element namespace> }`
   *
   * @example
   * ```
   * function MyResource({ serviceAccountNames }: { serviceAccountNames: (string | Handle)[]}) {
   *   const { deployID } = useBuildHelpers();
   *   const [ resolvedServiceAccountNames, updateSANs] = useResources({
   *      initial: [],
   *      notReady: null,
   *      kinds: ["ServiceAccount"],
   *      thisResourceName: "MyResources",
   *      propName: "serviceAccountNames",
   *   });
   *
   *   updateSANs(serviceAccountNames, (e, props) => {
   *      return {
   *        apiGroup: (e.metadata.apiVersion?.split("/")[0]) || "",
   *        name: resourceElementToName(e, deployID),
   *        namespace: props.metadata.namespace,
   *      }
   *   });
   *
   *   return null;
   * }
   * ```
   *
   * @beta
   */
  export declare function useResources<ValT, NotReadyT>({ initial, notReady, kinds, thisResourceName, propName, }: {
      initial: ValT[];
      notReady: NotReadyT;
      kinds: string[];
      thisResourceName: string;
      propName: string;
  }): [
      (ValT | NotReadyT)[],
      (props: (ValT | Handle)[], f: (e: AdaptMountedElement, props: ResourceProps) => Promise<ValT> | ValT) => void
  ];/**
   * Hook to allow conversion of a prop that could be a value or a handle
   *
   * This function behaves similarly to {@link k8s.useResources}, but works for
   * a prop that is either a Handle or a single value instead of an array of
   * Handles and values.
   *
   * See {@link k8s.useResources} for more detailed documentation.
   *
   * @beta
   */
  export declare function useResource<ValT, NotReadyT>(opts: {
      initial: ValT | NotReadyT;
      notReady: NotReadyT;
      kinds: string[];
      thisResourceName: string;
      propName: string;
  }): [
      ValT | NotReadyT,
      (prop: ValT | Handle, f: (e: AdaptMountedElement, props: ResourceProps) => Promise<ValT> | ValT) => void
  ];/**
   * Options for {@link k8s.makeClusterInfo}
   *
   * @public
   */
  export declare interface MakeClusterInfoOptions {
      /**
       * A Javascript Object representing a valid kubeconfig, or a YAML string, or a path to a kubeconfig file.
       *
       * @remarks
       * If this is a Javascript object, it will be treated like a parsed kubeconfig.  If this is a string,
       * {@link k8s.makeClusterInfo} will first attempt to parse it as JSON.  If that fails, it will attempt
       * to parse it as YAML.  If that fails it will treat the string as a path of configs (like with the `KUBECONFIG`
       * environment variable).
       *
       * If kubeconfig is missing {@link k8s.makeClusterInfo} will use the `KUBECONFIG` environment variable to build
       * a suitable config using `kubectl config view --flatten` and return that as the kubeconfig in the resulting
       * {@link k8s.ClusterInfo}
       */
      kubeconfig?: Kubeconfig | string;
      /**
       * URL to the docker registry that this cluster uses to pull private images.
       *
       * @remarks
       * This is identical to the `registryPrefix` field in {@link k8s.ClusterInfo}.  It will
       * be returned verbatim in the resulting {@link k8s.ClusterInfo} object.
       */
      registryPrefix?: string | DockerSplitRegistryInfo;
  }/**
   * k8s ClusterRole resource
   *
   * @param propsIn - props for ServiceAccount as specifed in {@link k8s.ClusterRoleProps}
   *
   * @public
   */
  export declare function ClusterRole(propsIn: SFCDeclProps<ClusterRoleProps, typeof defaultProps>): Adapt.JSX.Element;/** @public */
  export declare function isClusterRoleProps(props: ResourceProps): props is ResourceProps & ResourceClusterRole;/** @internal */
  const clusterRoleResourceInfo: {
      kind: string;
      deployedWhen: () => true;
      statusQuery: (props: ResourcePropsWithConfig, observe: ObserveForStatus, buildData: BuildData) => Promise<any>;
      makeManifest: (manifest: Manifest, elem: AdaptElement<ResourceProps>, _deployID: string) => {
          aggregationRule: AggregationRule | undefined;
          rules: PolicyRule[] | undefined;
          apiVersion: string;
          kind: string;
          metadata: import("./manifest_support").MetadataInRequest;
          spec?: import("./DaemonSet").DaemonSetSpec | import("./common").CRSpec | import("./Pod").PodSpec | import("./Service").ServiceSpec | import("./Deployment").DeploymentSpec | undefined;
      };
  };/**
   * k8s ClusterRoleBinding resource
   *
   * @param propsIn - props for ServiceAccount as specifed in {@link k8s.ClusterRoleBindingProps}
   *
   * @public
   */
  export declare function ClusterRoleBinding(propsIn: SFCDeclProps<ClusterRoleBindingProps, typeof defaultProps>): Adapt.JSX.Element | null;/** @internal */
  const clusterRoleBindingResourceInfo: {
      kind: string;
      deployedWhen: () => true;
      statusQuery: (props: ResourcePropsWithConfig, observe: ObserveForStatus, buildData: BuildData) => Promise<any>;
      makeManifest: (manifest: Manifest, elem: AdaptElement<ResourceProps>, _deployID: string) => {
          roleRef: RoleRef;
          subjects: Subject[];
          apiVersion: string;
          kind: string;
          metadata: import("./manifest_support").MetadataInRequest;
          spec?: import("./DaemonSet").DaemonSetSpec | import("./common").CRSpec | import("./Pod").PodSpec | import("./Service").ServiceSpec | import("./Deployment").DeploymentSpec | undefined;
      };
  };/**
   * k8s ConfigMap resource
   *
   * @param propsIn - props for ConfigMap as specifed in {@link k8s.ConfigMapProps}
   *
   * @public
   */
  export declare function ConfigMap(propsIn: SFCDeclProps<ConfigMapProps, typeof defaultProps>): Adapt.JSX.Element;/** @internal */
  const configMapResourceInfo: {
      kind: string;
      deployedWhen: () => true;
      statusQuery: (props: ResourcePropsWithConfig, observe: ObserveForStatus, buildData: BuildData) => Promise<any>;
      makeManifest: (manifest: Manifest, elem: AdaptElement<ResourceProps>, _deployID: string) => {
          data: {
              [key: string]: string;
          } | undefined;
          binaryData: {
              [key: string]: string;
          } | undefined;
          immutable: boolean | undefined;
          apiVersion: string;
          kind: string;
          metadata: import("./manifest_support").MetadataInRequest;
          spec?: import("./DaemonSet").DaemonSetSpec | import("./common").CRSpec | import("./Pod").PodSpec | import("./Service").ServiceSpec | import("./Deployment").DeploymentSpec | undefined;
      };
  };/**
   * Low level utility function to translate from the abstract {@link Container}
   * component props ({@link ContainerProps}) to {@link k8s.K8sContainerProps}
   * to be used in a {@link k8s.K8sContainer}.
   * @remarks
   * Note: The `image` property in the passed in {@link ContainerProps} must
   * be a `string`, not a `Handle`.
   * In most cases, it is preferable to use the {@link k8s.Container} component
   * instead, which is designed specifically to deal with this issue.
   *
   * @param abstractProps - The abstract {@link ContainerProps} to translate from.
   * @param k8sProps - Props that are specific to the {@link k8s.K8sContainer}
   *     component that should be merged into the resulting returned
   *     {@link k8s.K8sContainerProps} object.
   * @public
   */
  export declare function k8sContainerProps(abstractProps: FromContainerProps, k8sProps?: Partial<K8sContainerProps>): K8sContainerProps;/**
   * Tests whether an element is a {@link k8s.K8sContainer} element
   * @param x - element to test
   * @returns `true` if element is a {@link k8s.K8sContainer}, `false` otherwise
   *
   * @remarks
   * Acts as a TypeScript type assertion that will assert that `x` is `AdaptElement<K8sContainerProps>`
   *
   * @public
   */
  export declare function isK8sContainerElement(x: AdaptElement): x is AdaptElement<K8sContainerProps>;/**
   * Component that implements the abstract {@link Container} interface and
   * translates to a Kubernetes-specific {@link k8s.K8sContainer}.
   * @public
   */
  export declare function Container(props: ContainerProps): Adapt.JSX.Element | null;/** @public */
  export declare interface VolumeMount {
      /**
       * Path within the container at which the volume should be mounted.
       *
       * Must not contain ':'.
       */
      mountPath: string;
      /**
       * mountPropagation determines how mounts are propagated from the host to container and the other way around.
       *
       * When not set, MountPropagationNone is used. This field is beta in 1.10.
       *
       * @defaultValue MountPropagationNone
       */
      mountPropagation?: string;
      /** This must match the Name of a Volume. */
      name: string;
      /**
       * Mounted read-only if true, read-write otherwise (false or unspecified).
       *
       * @defaultValue false
       */
      readOnly?: boolean;
      /**
       * Path within the volume from which the container's volume should be mounted.
       *
       * Defaults to "" (volume's root).
       *
       * @defaultValue ""
       */
      subPath?: string;
      /**
       * Expanded path within the volume from which the container's volume should be mounted.
       *
       * Behaves similarly to SubPath but environment variable references $(VAR_NAME)
       * are expanded using the container's environment.
       *
       * Defaults to "" (volume's root).
       *
       * SubPathExpr and SubPath are mutually exclusive.
       *
       * @defaultValue ""
       */
      subPathExpr?: string;
  }/** @public */
  export declare interface ConfigMapEnvSource {
      /**
       * Name of the referent.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names}
       */
      name?: string;
      /**
       * Specify whether the ConfigMap must be defined
       */
      optional?: boolean;
  }/** @public */
  export declare interface SecretEnvSource {
      /**
       * Name of the referent.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names}
       */
      name?: string;
      /**
       * Specify whether the Secret must be defined
       */
      optional?: boolean;
  }/** @public */
  export declare interface EnvFromSource {
      /** The ConfigMap to select from */
      configMapRef?: ConfigMapEnvSource;
      /** An optional identifier to prepend to each key in the ConfigMap. Must be a C_IDENTIFIER. */
      prefix?: string;
      /** SecretEnvSource	The Secret to select from */
      secretRef?: SecretEnvSource;
  }/** @public */
  export declare interface ExecAction {
      /**
       * Command is the command line to execute inside the container.
       *
       * The working directory for the command is root ('/') in the container's filesystem.
       * The command is simply exec'd, it is not run inside a shell,
       * so traditional shell instructions ('|', etc) won't work.
       * To use a shell, you need to explicitly call out to that shell.
       *
       * Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
       */
      command: string[];
  }/** @public */
  export declare interface HTTPGetAction {
      /**
       * Host name to connect to, defaults to the pod IP.
       *
       * You probably want to set "Host" in httpHeaders instead.
       */
      host?: string;
      /** Custom headers to set in the request. HTTP allows repeated headers. */
      httpHeaders?: {
          name: string;
          value: string;
      }[];
      /** Path to access on the HTTP server. */
      path: string;
      /**
       * Name or number of the port to access on the container.
       *
       * Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
       */
      port: number | string;
      /**
       * Scheme to use for connecting to the host.
       *
       * @defaultValue HTTP.
       */
      scheme?: string;
  }/** @public */
  export declare interface TCPSocketAction {
      /** Host name to connect to, defaults to the pod IP. */
      host?: string;
      /**
       * Number or name of the port to access on the container.
       *
       * Number must be in the range 1 to 65535.
       * Name must be an IANA_SVC_NAME.
       */
      port: string | number;
  }/** @public */
  export declare interface Probe {
      /**
       * Exec specifies the action to take.
       *
       * Only one of exec, httpGet, or tcpSocket should be specified
       */
      exec?: ExecAction;
      /**
       * Minimum consecutive failures for the probe to be considered failed after having succeeded.
       *
       * Defaults to 3. Minimum value is 1.
       *
       * @defaultValue 3
       */
      failureThreshold?: number;
      /** Specifies the http request to perform. */
      httpGet?: HTTPGetAction;
      /**
       *  Seconds after the container has started before liveness probes are initiated.
       *  More info: {@link https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes}
       */
      initialDelaySeconds?: number;
      /** How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. */
      periodSeconds?: number;
      /**
       * Minimum consecutive successes for the probe to be considered successful after having failed.
       *
       * Must be 1 for liveness and startup. Minimum value is 1.
       *
       * @defaultValue 1
       */
      successThreshold?: number;
      /**
       * Specifies an action involving a TCP port.
       *
       * TCP hooks not yet supported
       */
      tcpSocket?: TCPSocketAction;
      /**
       * Number of seconds after which the probe times out.
       *
       * Defaults to 1 second. Minimum value is 1.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes}
       *
       * @defaultValue 1
       */
      timeoutSeconds?: number;
  }/** @public */
  export declare interface ResourceRequirements {
      /**
       * Limits describes the maximum amount of compute resources allowed.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/}
       */
      limits?: {
          [key: string]: any;
      };
      /**
       * Describes the minimum amount of compute resources required.
       *
       * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
       * otherwise to an implementation-defined value.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/}
       */
      requests?: {
          [key: string]: any;
      };
  }/** @public */
  export declare type Handler = {
      exec: ExecAction;
  } | {
      httpGet: HTTPGetAction;
  } | {
      tcpSocket: TCPSocketAction;
  };/** @public */
  export declare interface Lifecycle {
      /**
       * PostStart is called immediately after a container is created.
       *
       * If the handler fails, the container is terminated and restarted according to its restart policy.
       * Other management of the container blocks until the hook completes.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks}
       */
      postStart: Handler;
      /**
       * Called immediately before a container is terminated due to an API request or management event such as liveness/startup probe failure, preemption, resource contention, etc.
       *
       * The handler is not called if the container crashes or exits.
       * The reason for termination is passed to the handler.
       * The Pod's termination grace period countdown begins before the PreStop hooked is executed.
       * Regardless of the outcome of the handler, the container will eventually terminate within the Pod's termination grace period.
       * Other management of the container blocks until the hook completes or until the termination grace period is reached.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks}
       */
      preStop: Handler;
  }/** @public */
  export declare interface VolumeDevice {
      /** The path inside of the container that the device will be mapped to. */
      devicePath: string;
      /** name must match the name of a persistentVolumeClaim in the pod */
      name: string;
  }/**
   * Resource spec for a Kubernetes container.
   * See the Kubernetes
   * {@link https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#container-v1-core | API docs }
   * for more details.
   * @public
   */
  export declare interface ContainerSpec {
      /**
       * Arguments to the entrypoint.
       *
       * The docker image's CMD is used if this is not provided.
       * Variable references $(VAR_NAME) are expanded using the container's environment.
       * If a variable cannot be resolved, the reference in the input string will be unchanged.
       * The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME).
       * Escaped references will never be expanded, regardless of whether the variable exists or not.
       * Cannot be updated.
       * More info: {@link https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell}
       */
      args?: string[];
      /**
       * Entrypoint array.
       *
       * Not executed within a shell.
       * The docker image's ENTRYPOINT is used if this is not provided.
       * Variable references $(VAR_NAME) are expanded using the container's environment.
       * If a variable cannot be resolved, the reference in the input string will be unchanged.
       * The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME).
       * Escaped references will never be expanded, regardless of whether the variable exists or not.
       * Cannot be updated.
       * More info: {@link https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell}
       */
      command?: string[];
      /**
       * List of environment variables to set in the container. Cannot be updated.
       */
      env?: EnvVar[];
      /**
       * List of sources to populate environment variables in the container.
       *
       * The keys defined within a source must be a C_IDENTIFIER.
       * All invalid keys will be reported as an event when the container is starting.
       * When a key exists in multiple sources, the value associated with the last source will take precedence.
       * Values defined by an Env with a duplicate key will take precedence. Cannot be updated.
       */
      envFrom?: EnvFromSource[];
      /**
       * Docker image name.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/containers/images}
       *
       * This field is optional to allow higher level config management to default or override container
       * images in workload controllers like Deployments and StatefulSets.
       */
      image?: string;
      /**
       * Image pull policy.
       *
       * One of Always, Never, IfNotPresent.
       * Defaults to Always if :latest tag is specified,
       * or IfNotPresent otherwise.
       * Cannot be updated.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/containers/images#updating-images}
       */
      imagePullPolicy?: "Always" | "Never" | "IfNotPresent";
      /**
       * List of sources to populate environment variables in the container.
       *
       * The keys defined within a source must be a C_IDENTIFIER.
       * All invalid keys will be reported as an event when the container is starting.
       * When a key exists in multiple sources, the value associated with the last source will take precedence.
       * Values defined by an Env with a duplicate key will take precedence. Cannot be updated.
       */
      lifecycle?: Lifecycle;
      /**
       * Periodic probe of container liveness.
       *
       * Container will be restarted if the probe fails.
       * Cannot be updated.
       * More info: {@link https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes}
       */
      livenessProbe?: Probe;
      /**
       * Name of the container specified as a DNS_LABEL.
       *
       * Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated.
       */
      name: string;
      /**
       * List of ports to expose from the container.
       *
       * Exposing a port here gives the system additional information about the network connections a container uses,
       * but is primarily informational.
       * Not specifying a port here DOES NOT prevent that port from being exposed.
       * Any port which is listening on the default "0.0.0.0" address inside a container will be accessible from
       * the network.
       * Cannot be updated.
       */
      ports?: ContainerPort[];
      /**
       * Periodic probe of container service readiness.
       *
       * Container will be removed from service endpoints if the probe fails.
       * Cannot be updated.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes}
       */
      readinessProbe?: Probe;
      /**
       * Compute Resources required by this container.
       *
       * Cannot be updated.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/}
       */
      resources?: ResourceRequirements;
      /**
       * Security options the pod should run with.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/policy/security-context/}
       * More info: {@link https://kubernetes.io/docs/tasks/configure-pod-container/security-context/}
       */
      securityContext?: PodSecurityContext;
      /**
       * Indicates that the Pod has successfully initialized.
       *
       * If specified, no other probes are executed until this completes successfully.
       * If this probe fails, the Pod will be restarted, just as if the livenessProbe failed.
       * This can be used to provide different probe parameters at the beginning of a Pod's lifecycle,
       * when it might take a long time to load data or warm a cache, than during steady-state operation.
       *
       * This cannot be updated.
       * This is a beta feature enabled by the StartupProbe feature flag.
       * More info: {@link https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes}
       */
      startupProbe?: Probe;
      /**
       * Whether this container should allocate a buffer for stdin in the container runtime.
       *
       * If this is not set, reads from stdin in the container will always result in EOF. Default is false.
       */
      stdin?: boolean;
      /**
       * Whether the container runtime should close the stdin channel after it has been opened by a single attach.
       *
       * When stdin is true the stdin stream will remain open across multiple attach sessions.
       * If stdinOnce is set to true, stdin is opened on container start,
       * is empty until the first client attaches to stdin,
       * and then remains open and accepts data until the client disconnects,
       * at which time stdin is closed and remains closed until the container is restarted.
       * If this flag is false, a container processes that reads from stdin will never receive an EOF. Default is false
       */
      stdinOnce?: boolean;
      /**
       * Path at which the file to which the container's termination message will be written is mounted into the container's filesystem.
       *
       * Message written is intended to be brief final status, such as an assertion failure message.
       * Will be truncated by the node if greater than 4096 bytes.
       * The total message length across all containers will be limited to 12kb.
       * Defaults to /dev/termination-log. Cannot be updated.
       */
      terminationMessagePath?: string;
      /**
       * Indicate how the termination message should be populated.
       *
       * File will use the contents of terminationMessagePath to populate the container status
       * message on both success and failure. FallbackToLogsOnError will use the last chunk of
       * container log output if the termination message file is empty and the container exited
       * with an error.
       * The log output is limited to 2048 bytes or 80 lines, whichever is smaller.
       * Defaults to File.
       * Cannot be updated.
       *
       * @defaultValue File
       */
      terminationMessagePolicy?: "File" | "FallbackToLogsOnError";
      /**
       * Whether this container should allocate a TTY for itself, also requires 'stdin' to be true.
       *
       * @defaultValue false
       */
      tty?: boolean;
      /**
       * volumeDevices is the list of block devices to be used by the container.
       */
      volumeDevices?: VolumeDevice[];
      /** volumeDevices is the list of block devices to be used by the container. */
      volumeMounts?: VolumeMount[];
      /**
       * Container's working directory.
       *
       * If not specified, the container runtime's default will be used,
       * which might be configured in the container image.
       * Cannot be updated.
       */
      workingDir?: string;
  }/**
   * Props for the Kubernetes-specific {@link k8s.K8sContainer} component.
   * @public
   */
  export declare interface K8sContainerProps extends ContainerSpec {
  }/** @public */
  export declare interface ContainerPort {
      /**
       * Number of port to expose on the pod's IP address.
       * @remarks
       * This must be a valid integer port number, `0 < x < 65536`.
       */
      containerPort: number;
      /** What host IP to bind the external port to. */
      hostIP?: string;
      /**
       * Number of port to expose on the host.
       * @remarks
       * If specified, this must be a valid integer port number,
       * `0 < x < 65536`. If HostNetwork is specified,
       * this must match ContainerPort. Most containers do not need this.
       */
      hostPort?: number;
      /**
       * A unique-within-pod name for the container
       * @remarks
       * If specified, this must be an IANA_SVC_NAME and unique within the pod.
       * Each named port in a pod must have a unique name. Name for the port
       * that can be referred to by services.
       */
      name?: string;
      /** Protocol for port. Must be UDP or TCP. Defaults to "TCP". */
      protocol?: string;
  }/** @public */
  export declare type EnvVar = EnvVarSimple | EnvVarFrom;/** @public */
  export declare interface EnvVarSimple {
      /** Name of the environment variable. Must be a C_IDENTIFIER. */
      name: string;
      /**
       * Variable references $(VAR_NAME) are expanded using the previous defined
       * environment variables in the container and any service environment
       * variables. If a variable cannot be resolved, the reference in the input
       * string will be unchanged. The $(VAR_NAME) syntax can be escaped with a
       * double $$, ie: $$(VAR_NAME). Escaped references will never be expanded,
       * regardless of whether the variable exists or not. Defaults to "".
       */
      value: string;
  }/** @public */
  export declare interface EnvVarFrom {
      /** Source for the environment variable's value. Cannot be used if value is not empty. */
      valueFrom?: any;
  }/**
   * See {@link k8s.k8sContainerProps}.
   * @public
   */
  export declare type FromContainerProps = ReplaceT<ContainerProps, {
      image: string;
  }> & BuiltinProps;/**
   * Kubernetes-specific container.
   * @public
   */
  export declare class K8sContainer extends PrimitiveComponent<K8sContainerProps> {
      static defaultProps: {
          imagePullPolicy: string;
      };
      validate(): undefined;
  }/**
   * Props for {@link k8s.Container}.
   * @public
   */
  export declare interface ContainerProps extends SFCDeclProps<ContainerProps> {
      /**
       * Additional {@link k8s.K8sContainerProps}-specific props that should be
       * added to the instantiated {@link k8s.K8sContainer}.
       */
      k8sContainerProps?: Partial<K8sContainerProps>;
  }/**
   * Spec for {@link k8s.DaemonSet} for use in {@link k8s.Resource}
   *
   * @public
   */
  export declare type DaemonSetSpec = Exclude<DaemonSetProps, ResourceBase> & {
      template: PodTemplateSpec;
  };/**
   * Component for Kubernetes DaemonSet
   *
   * @public
   */
  export declare class DaemonSet extends DeferredComponent<DaemonSetProps> {
      static defaultProps: {
          metadata: {};
          minReadySeconds: number;
          revisionHistoryLimit: number;
          updateStrategy: {
              type: string;
              rollingUpdate: {
                  maxUnavailable: number;
              };
          };
      };
      constructor(props: DaemonSetProps);
      build(helpers: BuildHelpers): Adapt.JSX.Element;
      status(_observe: ObserveForStatus, buildData: BuildData): Promise<Adapt.Status | undefined>;
  }/** @internal */
  const daemonSetResourceInfo: {
      kind: string;
      deployedWhen: typeof deployedWhen;
      statusQuery: (props: ResourcePropsWithConfig, observe: ObserveForStatus, buildData: BuildData) => Promise<any>;
  };/** @public */
  export declare interface DeploymentUpdateStrategyRecreate {
      type: "Recreate";
  }/** @public */
  export declare interface RollingUpdateDeployment {
      /**
       * The maximum number of pods that can be scheduled above the desired number of pods.
       *
       * Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
       * This can not be 0 if MaxUnavailable is 0.
       * Absolute number is calculated from percentage by rounding up.
       * Defaults to 25%.
       *
       * @example
       * When this is set to 30%, the new ReplicaSet can be scaled up immediately when the rolling update starts,
       * such that the total number of old and new pods do not exceed 130% of desired pods. Once old pods have been
       * killed, new ReplicaSet can be scaled up further, ensuring that total number of pods running at any time
       * during the update is at most 130% of desired pods.
       */
      maxSurge?: number | string;
      /**
       * The maximum number of pods that can be unavailable during the update.
       *
       * Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
       * Absolute number is calculated from percentage by rounding down.
       * This can not be 0 if MaxSurge is 0. Defaults to 25%.
       *
       * @example
       * When this is set to 30%, the old ReplicaSet can be scaled down to 70% of desired pods
       * immediately when the rolling update starts. Once new pods are ready, old ReplicaSet
       * can be scaled down further, followed by scaling up the new ReplicaSet, ensuring that
       * the total number of pods available at all times during the update is at least 70% of
       * desired pods.
       */
      maxUnavailable?: number | string;
  }/**
   * Spec for {@link k8s.Deployment} for use in {@link k8s.Resource}
   *
   * @public
   */
  export declare type DeploymentSpec = Exclude<DeploymentProps, ResourceBase> & {
      template: PodTemplateSpec;
  };/**
   * Props for {@link k8s.Deployment}
   *
   * @public
   */
  export declare interface DeploymentProps extends WithChildren {
      /** Information about the k8s cluster (ip address, auth info, etc.) */
      config: ClusterInfo;
      /** k8s metadata */
      metadata: Metadata;
      /**
       * The minimum number of seconds for which a newly created pod should
       * be ready without any of its container crashing, for it to be considered
       * available. Defaults to 0 (pod will be considered available as soon as it is ready).
       */
      minReadySeconds: number;
      /** Indicates that the deployment is paused */
      paused: boolean;
      /**
       * The maximum time in seconds for a deployment to make progress before it is considered to be failed.
       *
       * The deployment controller will continue to process failed deployments and a condition with a
       * ProgressDeadlineExceeded reason will be surfaced in the deployment status. Note that progress
       * will not be estimated during the time a deployment is paused. Defaults to 600s.
       */
      progressDeadlineSeconds: number;
      /**
       * Number of desired pods.
       *
       * Defaults to 1. 0 is not allowed.
       *
       * @defaultValue 1
       */
      replicas: number;
      /**
       * The number of old ReplicaSets to retain to allow rollback.
       *
       * This is a pointer to distinguish between explicit zero and not specified. Defaults to 10.
       *
       * @defaultValue 10
       */
      revisionHistoryLimit: number;
      /**
       * Label selector for pods.
       *
       * Existing ReplicaSets whose pods are selected by this will be the ones affected by this deployment.
       * It must match the pod template's labels.
       *
       * @remarks
       *
       * With Adapt, this is optional.  If not specified, adapt will pick a selector that will work with the pods
       * it creates as part of this {@link k8s.Deployment}
       */
      selector?: LabelSelector;
      /**
       * An deployment strategy to use to replace existing pods with new ones
       */
      strategy: DeploymentUpdateStrategy;
  }/**
   * Component for Kubernetes Deployment
   *
   * @public
   */
  export declare class Deployment extends DeferredComponent<DeploymentProps> {
      static defaultProps: {
          metadata: {};
          paused: boolean;
          replicas: number;
          progressDeadlineSeconds: number;
          minReadySeconds: number;
          revisionHistoryLimit: number;
          strategy: {
              type: string;
              rollingUpdate: {
                  maxSurge: string;
                  maxUnavailable: string;
              };
          };
      };
      constructor(props: DeploymentProps);
      build(helpers: BuildHelpers): Adapt.JSX.Element | null;
      deployedWhen: () => true | Adapt.Waiting;
      status(_observe: ObserveForStatus, buildData: BuildData): Promise<Adapt.Status | undefined>;
  }/** @internal */
  const deploymentResourceInfo: {
      kind: string;
      deployedWhen: typeof deployedWhen;
      statusQuery: (props: ResourcePropsWithConfig, observe: ObserveForStatus, buildData: BuildData) => Promise<any>;
  };/**
   * Type assertion to see if an element is both a {@link k8s.Resource | Resource}
   * and a {@link @adpt/core#FinalElement | FinalElement}
   *
   * @param e - element to test
   * @returns `true` if e is both a FinalElement and a {@link k8s.Resource | Resource}, `false` otherwise
   *
   * @public
   */
  export declare function isResourceFinalElement(e: AdaptElement): e is FinalDomElement<ResourceProps & Adapt.BuiltinProps>;/**
   * Tests whether a ResourceProps is for a template object
   *
   * @public
   */
  export declare function isResourcePropsWithConfig(x: ResourceProps & Partial<BuiltinProps>): x is ResourcePropsWithConfig & Partial<BuiltinProps>;/**
   * Tests to see if an object is a {@link k8s.Resource} element
   * @param x - object to test
   * @returns true if object is an AdaptElement of type {@link k8s.Resource}
   *
   * @public
   */
  export declare function isResource(x: any): x is AdaptElement<ResourceProps>;/**
   * Primitive Component recognized by the k8s plugin to represent resources
   * @public
   */
  export declare class Resource extends Action<ResourceProps> {
      defaultProps: {
          apiVersion: "v1";
          con: false;
      };
      manifest_: Manifest;
      constructor(props: ResourceProps);
      validate(): "Resource elements cannot have children" | undefined;
      shouldAct(op: ChangeType, ctx: ActionContext): Promise<ShouldAct>;
      action(op: ChangeType, ctx: ActionContext): Promise<void>;
      deployedWhen: (goalStatus: GoalStatus, helpers: DeployHelpers) => Promise<true | Adapt.Waiting | Adapt.Waiting[]>;
      status(observe: ObserveForStatus, buildData: BuildData): Promise<any>;
      private mountedElement;
      private manifest;
  }/** @internal */
  export declare function makePodManifest(props: PodProps & BuiltinProps, data: {
      volumes?: Volume[];
      serviceAccountName?: string;
  }): {
      kind: string;
      metadata: Metadata;
      spec: PodSpec;
  };/**
   * Tests whether x is a Pod element
   *
   * @param x - value to test
   * @returns `true` if x is a Pod element, false otherwise
   *
   * @public
   */
  export declare function isPod(x: any): x is AdaptElement<PodProps>;/** @public */
  export declare interface NodeSelectorRequirement {
      /** The label key that the selector applies to. */
      key: string;
      /**
       * Represents a key's relationship to a set of values.
       *
       * Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
       */
      operator: "In" | "NotIn" | "Exists" | "DoesNotExist" | "Gt" | "Lt";
      /**
       * Values for operator
       *
       * If the operator is In or NotIn, the values array must be non-empty.
       * If the operator is Exists or DoesNotExist, the values array must be empty.
       * If the operator is Gt or Lt, the values array must have a single element,
       * which will be interpreted as an integer.
       * This array is replaced during a strategic merge patch.
       */
      values: string[];
  }/** @public */
  export declare interface NodeSelectorTerm {
      /** A list of node selector requirements by node's labels. */
      matchExpressions?: NodeSelectorRequirement[];
      /** A list of node selector requirements by node's fields. */
      matchFields?: NodeSelectorRequirement[];
  }/** @public */
  export declare interface PreferredSchedulingTerm {
      /**
       * A node selector term, associated with the corresponding weight.
       */
      preference: NodeSelectorTerm;
      /** Weight associated with matching the corresponding nodeSelectorTerm, in the range 1-100. */
      weight: number;
  }/** @public */
  export declare interface NodeSelector {
      /** A list of node selector terms. The terms are ORed */
      nodeSelectorTerms: NodeSelectorTerm[];
  }/** @public */
  export declare interface NodeAffinity {
      /** The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding "weight" to the sum if the node matches the corresponding matchExpressions; the node(s) with the highest sum are the most preferred. */
      preferredDuringSchedulingIgnoredDuringExecution?: PreferredSchedulingTerm[];
      /** If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to an update), the system may or may not try to eventually evict the pod from its node. */
      requiredDuringSchedulingIgnoredDuringExecution?: NodeSelector;
  }/** @public */
  export declare interface PodAffinityTerm {
      /**
       * Label query over a set of resources, in this case pods.
       */
      labelSelector: LabelSelector;
      /** Specifies which namespaces the labelSelector applies to (matches against); null or empty list means "this pod's namespace" */
      namespaces?: string[];
      /** This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed. */
      topologyKey: string;
  }/** @public */
  export declare interface WeightedPodAffinityTerm {
      /** A pod affinity term, associated with the corresponding weight. */
      podAffinityTerm: PodAffinityTerm;
      /**
       * weight associated with matching the corresponding podAffinityTerm, in the range 1-100.
       */
      weight: number;
  }/** @public */
  export declare interface PodAffinity {
      /**
       * The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions.
       *
       * The node that is most preferred is the one with the greatest sum of weights,
       * i.e. for each node that meets all of the scheduling requirements (resource request,
       * requiredDuringScheduling affinity expressions, etc.), compute a sum by iterating
       * through the elements of this field and adding "weight" to the sum if the node has pods
       * which matches the corresponding podAffinityTerm; the node(s) with the highest sum are the most preferred.
       */
      preferredDuringSchedulingIgnoredDuringExecution: WeightedPodAffinityTerm[];
      /**
       * If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node.
       *
       * If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system may or may not try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each podAffinityTerm are intersected, i.e. all terms must be satisfied.
       */
      requiredDuringSchedulingIgnoredDuringExecution: PodAffinityTerm[];
  }/** @public */
  export declare interface PodAntiAffinity {
      /** The scheduler will prefer to schedule pods to nodes that satisfy the anti-affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling anti-affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the node(s) with the highest sum are the most preferred. */
      preferredDuringSchedulingIgnoredDuringExecution: WeightedPodAffinityTerm[];
      /** If the anti-affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the anti-affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system may or may not try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each podAffinityTerm are intersected, i.e. all terms must be satisfied. */
      requiredDuringSchedulingIgnoredDuringExecution: PodAffinity;
  }/** @public */
  export declare interface Affinity {
      /** Describes node affinity scheduling rules for the pod. */
      nodeAffinity: NodeAffinity;
      /** Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)). */
      podAffinity: PodAffinity;
      /** PodAntiAffinity	Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)). */
      podAntiAffinity: PodAntiAffinity;
  }/** @public */
  export declare interface PodDNSConfigOption {
      name: string;
      value?: string;
  }/** @public */
  export declare interface PodDNSConfig {
      /**
       * A list of DNS name server IP addresses.
       *
       * This will be appended to the base nameservers generated from DNSPolicy. Duplicated nameservers will be removed.
       */
      nameservers: string[];
      /**
       * A list of DNS resolver options.
       *
       * This will be merged with the base options generated from DNSPolicy.
       * Duplicated entries will be removed.
       * Resolution options given in Options will override those that appear in the base DNSPolicy.
       */
      options: PodDNSConfigOption[];
      /**
       * A list of DNS search domains for host-name lookup.
       *
       * This will be appended to the base search paths generated from DNSPolicy. Duplicated search paths will be removed.
       */
      searches: string[];
  }/** @public */
  export declare interface PodReadinessGate {
      /** Refers to a condition in the pod's condition list with matching type. */
      conditionType: string;
  }/** @public */
  export declare interface SELinuxOptions {
      /** SELinux level label that applies to the container. */
      level: string;
      /** SELinux role label that applies to the container. */
      role: string;
      /** SELinux type label that applies to the container. */
      type: string;
      /** SELinux user label that applies to the container */
      user: string;
  }/** @public */
  export declare interface SeccompProfile {
      /**
       * Indicates a profile defined in a file on the node should be used.
       *
       * The profile must be preconfigured on the node to work.
       * Must be a descending path, relative to the kubelet's configured seccomp profile location.
       * Must only be set if type is "Localhost".
       */
      localhostProfile?: string;
      /**
       * Indicates which kind of seccomp profile will be applied.
       *
       * Valid options are:
       * * Localhost - a profile defined in a file on the node should be used.
       * * RuntimeDefault - the container runtime default profile should be used.
       * * Unconfined - no profile should be applied.
       */
      type: "Localhost" | "RuntimeDefault" | "Unconfined";
  }/** @public */
  export declare interface Sysctl {
      name: string;
      value: string;
  }/** @public */
  export declare interface WindowsSecurityContextOptions {
      /**
       * The GMSA admission webhook ({@link https://github.com/kubernetes-sigs/windows-gmsa}) inlines the contents of the GMSA credential spec named by the GMSACredentialSpecName field.
       */
      gmsaCredentialSpec?: string;
      /**
       * GMSACredentialSpecName is the name of the GMSA credential spec to use.
       */
      gmsaCredentialSpecName?: string;
      /**
       * The UserName in Windows to run the entrypoint of the container process.
       *
       * Defaults to the user specified in image metadata if unspecified. May also be set in PodSecurityContext.
       * If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
       */
      runAsUserName?: string;
  }/** @public */
  export declare interface PodSecurityContext {
      /**
       * A special supplemental group that applies to all containers in a pod.
       *
       * Some volume types allow the Kubelet to change the ownership of that volume to be owned by the pod:
       *
       * 1. The owning GID will be the FSGroup
       * 2. The setgid bit is set (new files created in the volume will be owned by FSGroup)
       * 3. The permission bits are OR'd with rw-rw----
       *
       * If unset, the Kubelet will not modify the ownership and permissions of any volume.
       */
      fsGroup?: number;
      /**
       * Defines behavior of changing ownership and permission of the volume before being exposed inside Pod.
       *
       * This field will only apply to volume types which support fsGroup based ownership(and permissions).
       * It will have no effect on ephemeral volume types such as: secret, configmaps and emptydir.
       * Valid values are "OnRootMismatch" and "Always". If not specified defaults to "Always".
       *
       * @defaultValue Always
       */
      fsGroupChangePolicy?: "OnRootMismatch" | "Always";
      /**
       * The GID to run the entrypoint of the container process.
       *
       * Uses runtime default if unset. May also be set in SecurityContext.
       * If set in both SecurityContext and PodSecurityContext, the value specified in
       * SecurityContext takes precedence for that container.
       */
      runAsGroup?: number;
      /**
       * Indicates that the container must run as a non-root user.
       *
       * If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and
       * fail to start the container if it does. If unset or false, no such validation will be performed.
       * May also be set in SecurityContext.
       * If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
       */
      runAsNonRoot?: boolean;
      /**
       * The UID to run the entrypoint of the container process.
       *
       * Defaults to user specified in image metadata if unspecified.
       * May also be set in SecurityContext.
       * If set in both SecurityContext and PodSecurityContext, the value specified in
       * SecurityContext takes precedence for that container.
       */
      runAsUser?: number;
      /**
       * The SELinux context to be applied to all containers.
       *
       * If unspecified, the container runtime will allocate a random SELinux context for each container.
       * May also be set in SecurityContext.
       * If set in both SecurityContext and PodSecurityContext, the value specified in
       * SecurityContext takes precedence for that container.
       */
      seLinuxOptions?: SELinuxOptions;
      /**
       * The seccomp options to use by the containers in this pod.
       */
      seccompProfile?: SeccompProfile;
      /**
       * 	A list of groups applied to the first process run in each container, in addition to the container's primary GID.
       *
       *  If unspecified, no groups will be added to any container.
       */
      supplementalGroups?: number[];
      /**
       * Sysctls hold a list of namespaced sysctls used for the pod.
       *
       * Pods with unsupported sysctls (by the container runtime) might fail to launch.
       */
      sysctls?: Sysctl[];
      /**
       * The Windows specific settings applied to all containers.
       *
       * If unspecified, the options within a container's SecurityContext will be used.
       * If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
       */
      windowsOptions: WindowsSecurityContextOptions;
  }/** @public */
  export declare interface Toleration {
      /**
       * Indicates the taint effect to match.
       *
       * Empty means match all taint effects.
       * When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
       */
      effect?: "NoSchedule" | "PreferNoSchedule" | "NoExecute";
      /**
       * The taint key that the toleration applies to.
       *
       * Empty means match all taint keys.
       * If the key is empty, operator must be Exists;
       * this combination means to match all values and all keys.
       */
      key?: string;
      /**
       * Represents a key's relationship to the value.
       *
       * Valid operators are Exists and Equal.
       * Defaults to Equal.
       * Exists is equivalent to wildcard for value, so that a pod can tolerate all taints of a particular category.
       *
       * @defaultValue Equal
       */
      operator?: "Exists" | "Equal";
      /**
       * Represents the period of time the toleration (which must be of effect NoExecute, otherwise this field is ignored) tolerates the taint.
       *
       * By default, it is not set, which means tolerate the taint forever (do not evict).
       * Zero and negative values will be treated as 0 (evict immediately) by the system.
       */
      tolerationSeconds?: number;
      /**
       * Value is the taint value the toleration matches to.
       *
       * If the operator is Exists, the value should be empty, otherwise just a regular string.
       */
      value?: string;
  }/** @public */
  export declare interface TopologySpreadConstraint {
      /**
       * Used to find matching pods.
       *
       * Pods that match this label selector are counted to determine the
       * number of pods in their corresponding topology domain.
       */
      labelSelector: LabelSelector;
      /**
       * Describes the degree to which pods may be unevenly distributed.
       *
       * When `whenUnsatisfiable=DoNotSchedule`, it is the maximum permitted
       * difference between the number of matching pods in the target topology
       * and the global minimum.
       * For example, in a 3-zone cluster, MaxSkew is set to 1, and pods with
       * the same labelSelector spread as 1/1/0: | zone1 | zone2 | zone3 | | P | P | |
       * - if MaxSkew is 1, incoming pod can only be scheduled to zone3 to become 1/1/1;
       *   scheduling it onto zone1(zone2) would make the ActualSkew(2-0) on zone1(zone2) violate MaxSkew(1).
       * - if MaxSkew is 2, incoming pod can be scheduled onto any zone.
       * When `whenUnsatisfiable=ScheduleAnyway`, it is used to give higher precedence to topologies that satisfy it.
       * It's a required field. Default value is 1 and 0 is not allowed.
       *
       * @example
       *
       * @defaultValue 1
       */
      maxSkew: number;
      /**
       * The key of node labels.
       *
       * Nodes that have a label with this key and identical values are considered to be in the same topology.
       * We consider each \<key, value\> as a "bucket", and try to put balanced number of pods into each bucket.
       * It's a required field.
       */
      topologyKey: string;
      /**
       * Indicates how to deal with a pod if it doesn't satisfy the spread constraint.
       *
       * - DoNotSchedule (default) tells the scheduler not to schedule it.
       * - ScheduleAnyway tells the scheduler to schedule the pod in any location,
       *   but giving higher precedence to topologies that would help reduce the skew.
       *
       * A constraint is considered "Unsatisfiable" for an incoming pod if and only if every possible
       * node assigment for that pod would violate "MaxSkew" on some topology.
       * For example, in a 3-zone cluster, MaxSkew is set to 1, and pods with the same labelSelector
       * spread as 3/1/1: | zone1 | zone2 | zone3 | | P P P | P | P | If WhenUnsatisfiable is set to DoNotSchedule,
       * incoming pod can only be scheduled to zone2(zone3) to become 3/2/1(3/1/2)
       * as ActualSkew(2-1) on zone2(zone3) satisfies MaxSkew(1).
       * In other words, the cluster can still be imbalanced, but scheduler won't make it
       * *more* imbalanced.
       *
       * It's a required field.
       */
      whenUnsatisfiable: string;
  }/** @public */
  export declare interface KeyToPath {
      /** The key to project. */
      key: string;
      /**
       * mode bits to use on this file,
       * Must be a value between 0 and 0777.
       * If not specified, the volume defaultMode will be used.
       * This might be in conflict with other options that affect the file mode, like fsGroup,
       * and the result can be other mode bits set.
       */
      mode?: number;
      /**
       * The relative path of the file to map the key to.
       *
       * May not be an absolute path. May not contain the path element '..'. May not start with the string '..'.
       */
      path: string;
  }/** @public */
  export declare interface ConfigMapVolumeSource {
      /**
       * mode bits to use on created files by default.
       *
       * Must be a value between 0 and 0777. Defaults to 0644.
       * Directories within the path are not affected by this setting.
       * This might be in conflict with other options that affect the file mode,
       * like fsGroup, and the result can be other mode bits set.
       */
      defaultMode?: number;
      /**
       * If unspecified, each key-value pair in the Data field of the referenced ConfigMap will be projected into the volume as a file whose name is the key and content is the value.
       *
       * If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present.
       * If a key is specified which is not present in the ConfigMap, the volume setup will error unless it is marked optional.
       * Paths must be relative and may not contain the '..' path or start with '..'.
       */
      items?: KeyToPath[];
      /**
       * Name of the referent.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names}
       */
      name: string | Handle;
      /** Specify whether the ConfigMap or its keys must be defined */
      optional?: boolean;
  }/** @public */
  export declare interface SecretVolumeSource {
      /**
       * mode bits to use on created files by default.
       *
       * Must be a value between 0 and 0777. Defaults to 0644.
       * Directories within the path are not affected by this setting.
       * This might be in conflict with other options that affect the file mode,
       * like fsGroup, and the result can be other mode bits set.
       */
      defaultMode?: number;
      /**
       * If unspecified, each key-value pair in the Data field of the referenced Secret will be projected into the volume as a file whose name is the key and content is the value.
       *
       * If specified, the listed keys will be projected into the specified paths,
       * and unlisted keys will not be present. If a key is specified which is not
       * present in the Secret, the volume setup will error unless it is marked optional.
       *
       * Paths must be relative and may not contain the '..' path or start with '..'.
       */
      items?: KeyToPath[];
      /** Specify whether the Secret or its keys must be defined */
      optional?: boolean;
      /**
       * Name of the secret in the pod's namespace to use.
       *
       *  More info: {@link https://kubernetes.io/docs/concepts/storage/volumes#secret}
       */
      secretName: string | Handle;
  }/** @public */
  export declare interface EmptyDirVolumeSource {
      /**
       * What type of storage medium should back this directory.
       *
       * The default is "" which means to use the node's default medium.
       * Must be an empty string (default) or Memory.
       * More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
       */
      medium: string;
      /**
       * Total amount of local storage required for this EmptyDir volume.
       *
       * The size limit is also applicable for memory medium.
       * The maximum usage on memory medium EmptyDir would be the minimum
       * value between the SizeLimit specified here and the sum of memory limits of all containers in a pod.
       * The default is nil which means that the limit is undefined.
       * More info: {@link http://kubernetes.io/docs/user-guide/volumes#emptydir}
       */
      sizeLimit: string;
  }/**
   * Volumes for {@link k8s.PodProps}
   *
   * @public
   */
  export declare interface Volume {
      /**
       * Volume's name.
       *
       * Must be a DNS_LABEL and unique within the pod.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names}
       */
      name: string;
      /**
       * Represents a configMap that should populate this volume
       */
      configMap?: ConfigMapVolumeSource;
      /**
       * EmptyDir represents a temporary directory that shares a pod's lifetime.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/storage/volumes#emptydir}
       *
       */
      emptyDir?: EmptyDirVolumeSource;
      /**
       * Represents a secret that should populate this volume.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/storage/volumes#secret}
       */
      secret?: SecretVolumeSource;
      /** Other k8s volume kinds not typed yet for \@adpt/cloud */
      [key: string]: any;
  }/**
   * Props for the {@link k8s.Pod} component
   *
   * @public
   */
  export declare interface PodProps extends WithChildren {
      /**
       *  True is this is a template for use in a controller, false otherwise
       *  @defaultValue false
       */
      isTemplate: boolean;
      /** Information about the k8s cluster (ip address, auth info, etc.) */
      config?: ClusterInfo;
      /** k8s metadata */
      metadata: Metadata;
      /**
       * Optional duration in seconds the pod may be active on the node relative to StartTime before the system will actively try to mark it failed and kill associated containers.
       *
       * Value must be a positive integer.
       */
      activeDeadlineSeconds?: number;
      /** If specified, the pod's scheduling constraints */
      affinity?: Affinity;
      /** AutomountServiceAccountToken indicates whether a service account token should be automatically mounted. */
      automountServiceAccountToken?: boolean;
      /**
       *  Specifies the DNS parameters of a pod.
       *
       *  Parameters specified here will be merged to the generated DNS configuration based on DNSPolicy.
       */
      dnsConfig?: PodDNSConfig;
      /**
       * Set DNS policy for the pod.
       *
       * Valid values are 'ClusterFirstWithHostNet', 'ClusterFirst', 'Default' or 'None'.
       * DNS parameters given in DNSConfig will be merged with the policy selected with DNSPolicy.
       * To have DNS options set along with hostNetwork, you have to specify DNS policy explicitly
       * to 'ClusterFirstWithHostNet'.
       *
       * @defaultValue ClusterFirst
       */
      dnsPolicy: "ClusterFirstWithHostNet" | "ClusterFirst" | "Default" | "None";
      /**
       * Indicates whether information about services should be injected into pod's environment variables matching the syntax of Docker links.
       *
       * @defaultValue true
       */
      enableServiceLinks: boolean;
      /**
       * An optional list of hosts and IPs that will be injected into the pod's hosts file if specified.
       *
       * This is only valid for non-hostNetwork pods.
       */
      hostAliases?: HostAlias[];
      /**
       * Use the host's ipc namespace.
       * @defaultValue false
       */
      hostIPC: boolean;
      /**
       * Host networking requested for this pod.
       *
       * Use the host's network namespace.
       * If this option is set, the ports that will be used must be specified. Default to false.
       */
      hostNetwork?: boolean;
      /**
       * Use the host's pid namespace.
       * @defaultValue false
       */
      hostPID: boolean;
      /**
       * Specifies the hostname of the Pod.
       *
       * If not specified, the pod's hostname will be set to a system-defined value.
       */
      hostname?: string;
      /**
       * List of references to secrets in the same namespace to use for pulling any of the images used by this PodSpec.
       *
       * If specified, these secrets will be passed to individual puller implementations for them to use.
       * For example, in the case of docker, only DockerConfig type secrets are honored.
       * More info: {@link https://kubernetes.io/docs/concepts/containers/images#specifying-imagepullsecrets-on-a-pod}
       */
      imagePullSecrets?: LocalObjectReference[];
      /**
       * A request to schedule this pod onto a specific node.
       *
       * If it is non-empty, the scheduler simply schedules this pod onto that node,
       * assuming that it fits resource requirements.
       */
      nodeName?: string;
      /**
       * A selector which must be true for the pod to fit on a node.
       *
       * Selector which must match a node's labels for the pod to be scheduled on that node.
       * More info: {@link https://kubernetes.io/docs/concepts/configuration/assign-pod-node/}
       */
      nodeSelector?: {
          [label: string]: boolean | string;
      };
      /**
       * Overhead represents the resource overhead associated with running a pod for a given RuntimeClass.
       *
       * This field will be autopopulated at admission time by the RuntimeClass admission controller.
       * If the RuntimeClass admission controller is enabled, overhead must not be set in Pod create requests.
       * The RuntimeClass admission controller will reject Pod create requests which have the overhead already set.
       * If RuntimeClass is configured and selected in the PodSpec, Overhead will be set to the value defined in
       * the corresponding RuntimeClass, otherwise it will remain unset and treated as zero.
       *
       * More info: {@link https://git.k8s.io/enhancements/keps/sig-node/20190226-pod-overhead.md}
       *
       * This field is alpha-level as of Kubernetes v1.16, and is only honored by servers that enable
       * the PodOverhead feature.
       * @alpha
       */
      overhead?: unknown;
      /**
       * PreemptionPolicy is the Policy for preempting pods with lower priority.
       *
       * This field is beta-level, gated by the NonPreemptingPriority feature-gate.
       *
       * @defaultValue PreemptLowerPriority
       * @beta
       */
      preemptionPolicy?: "Never" | "PreemptLowerPriority";
      /**
       * The priority various system components use this field to find the priority of the pod.
       *
       * When Priority Admission Controller is enabled, it prevents users from setting this field.
       * The admission controller populates this field from PriorityClassName.
       * The higher the value, the higher the priority.
       */
      priority?: number;
      /**
       * If specified, indicates the pod's priority.
       *
       * "system-node-critical" and "system-cluster-critical" are two special keywords which indicate the highest
       * priorities with the former being the highest priority. Any other name must be defined by creating a PriorityClass
       * object with that name. If not specified, the pod priority will be default or zero if there is no default.
       */
      priorityClassName?: string;
      /**
       *  If specified, all readiness gates will be evaluated for pod readiness.
       *
       *  A pod is ready when all its containers are ready AND all conditions specified
       *  in the readiness gates have status equal to "True"
       *
       *  More info: {@link https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#pod-readiness-gate}
       */
      readinessGates?: PodReadinessGate[];
      /**
       * Restart policy for all containers within the pod.
       *
       * One of Always, OnFailure, Never. Default to Always.
       * More info: {@link https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy}
       *
       * @defaultValue Always
       */
      restartPolicy: "Always" | "OnFailure" | "Never";
      /**
       * Refers to a RuntimeClass object in the node.k8s.io group, which should be used to run this pod.
       *
       * If no RuntimeClass resource matches the named class, the pod will not be run.
       * If unset or empty, the "legacy" RuntimeClass will be used, which is an implicit
       * class with an empty definition that uses the default runtime handler.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/containers/runtime-class/}
       *
       * This is a beta feature as of Kubernetes v1.14.
       */
      runtimeClassName?: string;
      /**
       *  If specified, the pod will be dispatched by specified scheduler.
       *  If not specified, the pod will be dispatched by default scheduler.
       */
      schedulerName?: string;
      /**
       * SecurityContext holds pod-level security attributes and common container settings.
       * See type description for default values of each field.
       *
       * @defaultValue \{\}
       */
      securityContext: PodSecurityContext;
      /**
       * ServiceAccountName is the name of the ServiceAccount to use to run this pod.
       * More info: {@link https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/}
       */
      serviceAccountName?: string | Handle;
      /**
       * If true the pod's hostname will be configured as the pod's FQDN, rather than the leaf name (the default).
       * In Linux containers, this means setting the FQDN in the hostname field of the kernel
       * (the nodename field of struct utsname).
       * In Windows containers, this means setting the registry value of hostname for the registry key
       * HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters to FQDN.
       * If a pod does not have FQDN, this has no effect.
       *
       * @defaultValue false
       */
      setHostnameAsFQDN?: boolean;
      /**
       * Share a single process namespace between all of the containers in a pod.
       * When this is set containers will be able to view and signal processes from other containers in the same pod,
       * and the first process in each container will not be assigned PID 1.
       * HostPID and ShareProcessNamespace cannot both be set.
       *
       * @defaultValue false
       */
      shareProcessNamespace: boolean;
      /**
       *  If specified, the fully qualified Pod hostname will be "\<hostname\>.\<subdomain\>.\<pod namespace\>.svc.\<cluster domain\>".
       *  If not specified, the pod will not have a domainname at all.
       */
      subdomain?: string;
      /**
       * Optional duration in seconds the pod needs to terminate gracefully.
       *
       * May be decreased in delete request. Value must be non-negative integer.
       * The value zero indicates delete immediately. If this value is nil, the default
       * grace period will be used instead. The grace period is the duration in seconds
       * after the processes running in the pod are sent a termination signal and the time
       * when the processes are forcibly halted with a kill signal. Set this value longer
       * than the expected cleanup time for your process. Defaults to 30 seconds.
       */
      terminationGracePeriodSeconds?: number;
      /** If specified, the pod's tolerations. */
      tolerations?: Toleration[];
      /**
       *  TopologySpreadConstraints describes how a group of pods ought to spread across topology domains.
       *
       *  Scheduler will schedule pods in a way which abides by the constraints. All topologySpreadConstraints are ANDed.
       */
      topologySpreadConstraints?: TopologySpreadConstraint[];
      /**
       * List of volumes that can be mounted by containers belonging to the pod.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/storage/volumes}
       */
      volumes?: Volume[];
  }/**
   * Component for Kubernetes Pods
   *
   * @public
   */
  export declare class Pod extends DeferredComponent<PodProps, ResolvedVolumes & ResolvedServiceAccountName> {
      static defaultProps: {
          isTemplate: boolean;
          metadata: {};
          dnsPolicy: string;
          enableServiceLinks: boolean;
          hostIPC: boolean;
          hostPID: boolean;
          restartPolicy: string;
          securityContext: {};
          shareProcessNamespace: boolean;
          terminationGracePeriodSeconds: number;
      };
      initialState(): {};
      build(helpers: BuildHelpers): Adapt.JSX.Element | null;
      status(_observe: ObserveForStatus, buildData: BuildData): Promise<Adapt.Status | undefined>;
  }/**
   * Spec for for Kubernetes Pods
   *
   * @public
   */
  export declare interface PodSpec extends Omit<PodProps, "config" | "metadata" | "isTemplate"> {
      containers: ContainerSpec[];
      terminationGracePeriodSeconds?: number;
  }/** @internal */
  const podResourceInfo: {
      kind: string;
      deployedWhen: typeof deployedWhen;
      statusQuery: (props: ResourcePropsWithConfig, observe: ObserveForStatus, buildData: BuildData) => Promise<any>;
  };/**
   * k8s Secret resource
   *
   * @param propsIn - props for Secret as specifed in {@link k8s.SecretProps}
   *
   * @public
   */
  export declare function Secret(propsIn: SFCDeclProps<SecretProps, typeof defaultProps>): Adapt.JSX.Element;/** @internal */
  const secretResourceInfo: {
      kind: string;
      deployedWhen: () => true;
      statusQuery: (props: ResourcePropsWithConfig, observe: ObserveForStatus, buildData: BuildData) => Promise<any>;
      makeManifest: (manifest: Manifest, elem: AdaptElement<ResourceProps>, _deployID: string) => {
          data: {
              [key: string]: string;
          } | undefined;
          stringData: {
              [key: string]: string;
          } | undefined;
          type: string | undefined;
          apiVersion: string; /**
           * stringData allows specifying non-binary secret data in string form.
           *
           * It is provided as a write-only convenience method. All keys and values are merged into the data field on write,
           * overwriting any existing values. It is never output when reading from the API.
           */
          kind: string;
          metadata: import("./manifest_support").MetadataInRequest;
          spec?: import("./DaemonSet").DaemonSetSpec | import("./common").CRSpec | import("./Pod").PodSpec | import("./Service").ServiceSpec | import("./Deployment").DeploymentSpec | undefined;
      };
  };/**
   * Convert {@link NetworkService} props to {@link k8s.Service} props
   * @param abstractProps - props to convert
   * @returns Kubernetes spec corresponding to `abstractProps`
   *
   * @internal
   */
  export declare function k8sServiceProps(abstractProps: NetworkServiceProps & BuiltinProps): Omit<ServiceProps, keyof ResourceBase>;/**
   * Native Kubernetes Service resource
   *
   * @remarks
   *
   * Implements the {@link NetworkServiceInstance} interface.
   *
   * @public
   */
  export declare function Service(propsIn: SFCDeclProps<ServiceProps, typeof defaultProps>): Adapt.JSX.Element;/** @public */
  export declare interface ServiceProps extends ServiceSpec {
      /** Legal configuration loaded from kubeconfig */
      config: ClusterInfo;
      metadata?: Metadata;
      selector?: Handle | EndpointSelector;
  }/** @public */
  export declare interface ServiceSpec {
      /**
       * Cluster IP for a {@link k8s.Service}
       *
       * @remarks
       * `clusterIP` is the IP address of the service and is usually assigned
       * randomly by the master. If an address is specified manually and is not
       * in use by others, it will be allocated to the service; otherwise,
       * creation of the service will fail. This field can not be changed through
       * updates. Valid values are "None", empty string (""), or a valid IP
       * address. "None" can be specified for headless services when proxying is
       * not required. Only applies to types ClusterIP, NodePort, and
       * LoadBalancer. Ignored if type is ExternalName.
       *
       * For more information, see the
       * {@link https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies |
       * Kubernetes documentation}.
       */
      clusterIP?: string;
      /**
       * A list of IP addresses for which nodes in the cluster
       * will also accept traffic for this service.
       *
       * @remarks
       * These IPs are not managed by
       * Kubernetes. The user is responsible for ensuring that traffic arrives at
       * a node with this IP. A common example is external load balancers that are
       * not part of the Kubernetes system.
       */
      externalIPs?: string[];
      /**
       * The external reference that kubedns or equivalent
       * will return as a CNAME record for this service.
       *
       * @remarks
       * No proxying will be involved. Must be a
       * {@link https://tools.ietf.org/html/rfc1123 | valid RFC-1123 hostname}
       * and requires Type to be ExternalName.
       */
      externalName?: string;
      /**
       * Denotes if this Service desires to route
       * external traffic to node-local or cluster-wide endpoints.
       *
       * @remarks
       * "Local" preserves the client source IP and avoids a second hop for
       * LoadBalancer and Nodeport type services, but risks potentially
       * imbalanced traffic spreading. "Cluster" obscures the client source IP
       * and may cause a second hop to another node, but should have good overall
       * load-spreading.
       */
      externalTrafficPolicy?: string;
      /**
       * Specifies the healthcheck nodePort for the service.
       *
       * @remarks
       * If not specified, HealthCheckNodePort is created by the service
       * api backend with the allocated nodePort. Will use user-specified nodePort
       * value if specified by the client. Only affects when Type is set to
       * LoadBalancer and ExternalTrafficPolicy is set to Local.
       */
      healthCheckNodePort?: number;
      /**
       * Only applies to Service Type: LoadBalancer. LoadBalancer will
       * get created with the IP specified in this field.
       *
       * @remarks
       * This feature depends on
       * whether the underlying cloud provider supports specifying the loadBalancerIP
       * when a load balancer is created. This field will be ignored if the
       * cloud provider does not support the feature.
       */
      loadBalancerIP?: string;
      /**
       * If specified and supported by the platform, this will
       * restrict traffic through the cloud provider load balancer
       * to the specified client IPs.
       *
       * @remarks
       * This field will be ignored if the cloud provider
       * does not support the feature.
       *
       * For more information, see the
       * {@link https://v1-17.docs.kubernetes.io/docs/tasks/access-application-cluster/configure-cloud-provider-firewall/ |
       * Kubernetes documentation}.
       */
      loadBalancerSourceRanges?: string[];
      /**
       * The list of ports that are exposed by this service.
       *
       * @remarks
       * For more information, see the
       * {@link https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies |
       * Kubernetes documentation}.
       */
      ports?: ServicePort[];
      /**
       * When set to true, indicates that
       * DNS implementations must publish the notReadyAddresses of subsets for the
       * Endpoints associated with the Service.
       *
       * @remarks
       * The default value is false. The
       * primary use case for setting this field is to use a StatefulSet's Headless
       * Service to propagate SRV records for its Pods without respect to their
       * readiness for purpose of peer discovery.
       */
      publishNotReadyAddresses?: boolean;
      /**
       * Route service traffic to pods with label keys and values
       * matching this selector.
       *
       * @remarks
       * If empty or not present, the service is assumed to
       * have an external process managing its endpoints, which Kubernetes will not
       * modify. Only applies to types ClusterIP, NodePort, and LoadBalancer.
       * Ignored if type is ExternalName.
       *
       * For more information, see the
       * {@link https://kubernetes.io/docs/concepts/services-networking/service/ |
       * Kubernetes documentation}.
       */
      selector?: EndpointSelector | object;
      /**
       * Used to maintain session affinity.
       *
       * @remarks
       * Possible values are:
       *
       * - `"ClientIP"`: Enables client IP based session affinity.
       *
       * - `"None"`: Disables session affinity.
       *
       * For more information, see the
       * {@link https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies |
       * Kubernetes documentation}.
       * @defaultValue `"None"`
       */
      sessionAffinity?: string;
      /**
       * Determines how the Service is exposed.
       *
       * @remarks
       * Valid options are:
       *
       * - `"ExternalName"`: maps to the specified externalName.
       *
       * - `"ClusterIP"`: allocates a cluster-internal IP address for load
       * balancing to endpoints. Endpoints are determined by the selector or if
       * that is not specified, by manual construction of an Endpoints object. If
       * clusterIP is "None", no virtual IP is allocated and the endpoints are
       * published as a set of endpoints rather than a stable IP.
       *
       * - `"NodePort"`: Builds on ClusterIP and allocates a port on every node
       * which routes to the clusterIP.
       *
       * - `"LoadBalancer"`: Builds on NodePort and creates an external load
       * balancer (if supported in the current cloud) which routes to the
       * clusterIP.
       *
       * For more information, see the
       * {@link https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services---service-types |
       * Kubernetes documentation}.
       * @defaultValue `"ClusterIP"`
       */
      type?: string;
  }/** @public */
  export declare interface ServicePort {
      /**
       * The name of this port within the service.
       *
       * @remarks
       * This must be a DNS_LABEL.
       * All ports within a ServiceSpec must have unique names.This maps to the
       * Name' field in EndpointPort objects. Optional if only one ServicePort is
       * defined on this service.
       */
      name?: string;
      /**
       * The port on each node on which this service is exposed when
       * type=NodePort or LoadBalancer.
       *
       * @remarks
       * Usually assigned by the system. If
       * specified, it will be allocated to the service if unused or else creation
       * of the service will fail.
       *
       * For more information, see the
       * {@link https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport |
       * Kubernetes documentation}.
       * @defaultValue Automatically allocates a port if the ServiceType of this
       * Service requires one.
       */
      nodePort?: number;
      /** The port that will be exposed by this service. */
      port?: number;
      /** The IP protocol for this port.Supports "TCP" and "UDP".Default is TCP. */
      protocol?: string;
      /**
       * Number or name of the port to access on the pods targeted by the
       * service.
       *
       * @remarks
       * Number must be in the range 1 to 65535. Name must be an
       * IANA_SVC_NAME. If this is a string, it will be looked up as a named port
       * in the target Pod's container ports. If this is not specified, the value
       * of the 'port' field is used (an identity map). This field is ignored for
       * services with clusterIP = None, and should be omitted or set equal to the
       * 'port' field.
       *
       * For more information, see the
       * {@link https://kubernetes.io/docs/concepts/services-networking/service/#defining-a-service |
       * Kubernetes documentation}.
       */
      targetPort?: number | string;
  }/** @internal */
  const serviceResourceInfo: {
      kind: string;
      deployedWhen: typeof deployedWhen;
      statusQuery: (props: ResourcePropsWithConfig, observe: ObserveForStatus, buildData: BuildData) => Promise<any>;
  };/**
   * k8s ServiceAccount resource
   *
   * @param propsIn - props for ServiceAccount as specifed in {@link k8s.ServiceAccountProps}
   *
   * @public
   */
  export declare function ServiceAccount(propsIn: SFCDeclProps<ServiceAccountProps, typeof defaultProps>): Adapt.JSX.Element;/** @public */
  export declare function isServiceAccountProps(p: ResourceProps): p is ResourceProps & ResourceServiceAccount;/** @internal */
  const serviceAccountResourceInfo: {
      kind: string;
      deployedWhen: () => true;
      statusQuery: (props: ResourcePropsWithConfig, observe: ObserveForStatus, buildData: BuildData) => Promise<any>;
      makeManifest: (manifest: Manifest, elem: AdaptElement<ResourceProps>, _deployID: string) => {
          automountServiceAccountToken: boolean | undefined;
          imagePullSecrets: {
              name: string;
          }[] | undefined;
          secrets: ObjectReference[] | undefined;
          apiVersion: string;
          kind: string;
          metadata: import("./manifest_support").MetadataInRequest;
          spec?: import("./DaemonSet").DaemonSetSpec | import("./common").CRSpec | import("./Pod").PodSpec | import("./Service").ServiceSpec | import("./Deployment").DeploymentSpec | undefined;
      };
  };/**
   * Props for {@link k8s.ServiceDeployment}
   *
   * @public
   */
  export declare interface ServiceDeploymentProps<T extends AllowableComponentProps = DeploymentProps> extends ServiceProps {
      config: ClusterInfo;
      serviceProps?: Partial<ServiceProps>;
      component: ComponentType<T>;
      componentProps: T;
      podProps?: Partial<PodProps>;
      containerProps?: Partial<OmitT<K8sContainerProps, "image">>;
  }/**
   * A component for mapping a group of abstract {@link Container}s and
   * {@link NetworkService}s to Kubernetes {@link k8s.Pod}s and
   * {@link k8s.K8sContainer}s.
   *
   * @remarks
   * This component is intended to be used to replace {@link Container} and
   * {@link NetworkService} components that are grouped together, as the
   * only children of a common parent in a pattern that looks like this:
   *
   * ```tsx
   * <Service>
   *   <Container ... />
   *   <Container ... />
   *   <NetworkService ... />
   * </Service>
   * ```
   *
   * `ServiceDeployment` would map those abstract components into corresponding
   * k8s components like this:
   * ```tsx
   * <Group>
   *   <docker.RegistryDockerImage ... /> //If props.config specifies a registry
   *   <k8s.Deployment ... >
   *     <Pod isTemplate>
   *       <k8s.K8sContainer ... />
   *     </Pod>
   *   </k8s.Deployment>
   *   <docker.RegistryDockerImage ... /> //If props.config specifies a registry
   *   <k8s.Deployment ... >
   *     <Pod isTemplate>
   *       <k8s.K8sContainer ... />
   *     </Pod>
   *   </k8s.Pod>
   *   <k8s.Service ... />
   * </Group>
   * ```
   * An example style rule to do this is:
   * ```tsx
   * {Adapt.rule((matchedProps) => {
   *     const { handle, ...remainingProps } = matchedProps;
   *     return <ServiceDeployment config={kubeconfig} {...remainingProps} />;
   * })}
   * ```
   * `ServiceDeployment` also requires the `config` prop which specifies
   * connection and authentication information for the Kubernetes cluster on
   * which these objects should be created.
   *
   * @public
   */
  export declare class ServiceDeployment<T extends AllowableComponentProps> extends DeferredComponent<ServiceDeploymentProps<T>> {
      static defaultProps: {
          component: typeof Deployment;
          componentProps: {
              replicas: number;
          };
      };
      build(helpers: BuildHelpers): Adapt.JSX.Element;
  }/** @public */
  export declare function computeNamespaceFromMetadata(metadata?: Metadata): string;/** @public */
  export declare function isLabelSelector(x: any): x is LabelSelector;/**
   * Kubernetes Kind
   *
   * @public
   */
  export declare type Kind = string;/** @public */
  export declare interface CRSpec {
      [key: string]: any;
  }/** @public */
  export declare type Spec = DaemonSetSpec | DeploymentSpec | PodSpec | ServiceSpec | CRSpec;/** @public */
  export declare interface Metadata {
      namespace?: string;
      labels?: {
          [key: string]: string;
      };
      annotations?: {
          [key: string]: string;
      };
  }/** @public */
  export declare type ResourceProps = {
      key: string;
  } & (ResourceClusterRole | ResourceClusterRoleBinding | ResourceDaemonSet | ResourcePod | ResourceService | ResourceServiceAccount | ResourceConfigMap | ResourceSecret | ResourceCR);/** @public */
  export declare type ResourcePropsWithConfig = ResourceProps & {
      config: ClusterInfo;
  };/** @public */
  export declare interface ResourceInfo {
      kind: Kind;
      statusQuery?: (props: ResourceProps, observe: ObserveForStatus, buildData: BuildData) => unknown | Promise<unknown>;
      specsEqual(actual: Spec, element: Spec): boolean;
  }/**
   * Holds the information needed to connect, authenticate, and run code in a kuberenetes cluster
   *
   * @public
   */
  export declare interface ClusterInfo {
      /** Javascript object formed by parsing a valid kubeconfig file */
      kubeconfig: Kubeconfig;
      /**
       * Registry to which Docker images used by the cluster in `kubeconfig` should be pushed and pulled
       *
       * @remarks
       * If `registryPrefix` is a string, it is assumed that the cluster can pull from the same string
       * that outsiders can push to.
       *
       * If `registryPrefix` is of the form `{ external: string, internal: string }` then the `external`
       * string will be used to push images, and the `internal` string will be used to pull images.
       *
       * Note(manishv)
       * This is a bit of a hack to allow one hostname or IP address to push images from outside
       * a particular environment (say k8s) and a different URL for that environment to pull
       * images.
       *
       * A good example of this is a k3s-dind (k3s docker-in-docker) instance of kubernetes where
       * a private registry is running on a docker network attached to the k3s-dind instance, but where we
       * want to push {@link docker.LocalDockerImage} built images to that registry.  Since
       * {@link docker.LocalDockerImage | LocalDockerImage} is outside the k3s-dind environment, it must
       * use a host accessible network to push to the registry.  However, since the k3s-dind instance sees
       * the registry from within Docker, it must use a different address to pull the images for use.
       *
       * Once network scopes are fully supported, this interface will change to whatever is appropriate.  It
       * is best if you can arrange to have the same URL or registry string work for all access regardless
       * of which network the registry, Adapt host, and ultimate container running environment uses.
       *
       */
      registryPrefix?: string | DockerSplitRegistryInfo;
  }/** @public */
  export declare interface ResourceBase {
      /**
       * config to connect to the k8s cluster
       *
       * required if isTemplate is false
       */
      config?: ClusterInfo;
      /**
       * Specifies whether this resource is just a template for use in a controller
       */
      isTemplate?: boolean;
      apiVersion?: string;
      kind: Kind;
      metadata?: Metadata;
  }/**
   * @public
   */
  export declare interface PolicyRule {
      /**
       * APIGroups is the name of the APIGroup that contains the resources.
       *
       * If multiple API groups are specified, any action requested against one
       * of the enumerated resources in any API group will be allowed.
       */
      apiGroups?: string[];
      /**
       * NonResourceURLs is a set of partial urls that a user should have access to.
       *
       * *s are allowed, but only as the full, final step in the path.
       * Since non-resource URLs are not namespaced, this field is only applicable
       * for ClusterRoles referenced from a ClusterRoleBinding.
       * Rules can either apply to API resources (such as "pods" or "secrets") or
       * non-resource URL paths (such as "/api"), but not both.
       */
      nonResourceURLs?: string[];
      /**
       * ResourceNames is an optional white list of names that the rule applies to.
       *
       * An empty set means that everything is allowed.
       */
      resourceNames?: string[];
      /**
       * Resources is a list of resources this rule applies to.
       *
       * ResourceAll represents all resources.
       */
      resources: string[];
      /**
       * Verbs is a list of Verbs that apply to ALL the ResourceKinds and
       * AttributeRestrictions contained in this rule.
       *
       * VerbAll represents all kinds.
       */
      verbs: string[];
  }/**
   * AggregationRule for {@link k8s.ClusterRole}
   *
   * @public
   */
  export declare interface AggregationRule {
      /**
       * ClusterRoleSelectors holds a list of selectors which will be used to
       * find ClusterRoles and create the rules.
       *
       * If any of the selectors match, then the ClusterRole's permissions will be added
       */
      clusterRoleSelector: LabelSelector;
  }/** @public */
  export declare interface ResourceClusterRole extends ResourceBase {
      apiVersion: "rbac.authorization.k8s.io/v1";
      kind: "ClusterRole";
      aggregationRule?: AggregationRule;
      rules?: PolicyRule[];
  }/**
   * RoleRef for {@link k8s.ResourceClusterRoleBinding}
   *
   * @public
   */
  export declare interface RoleRef {
      /** apiGroup is the group for the resource being referenced */
      apiGroup: string;
      /** kind is the type of resource being referenced */
      kind: string;
      /** Name is the name of resource being referenced */
      name: string;
  }/**
   * Subject for {@link k8s.ResourceClusterRoleBinding}
   *
   * @public
   */
  export declare interface Subject {
      /** apiGroup is the group for the object being referenced */
      apiGroup: string;
      /** kind is the type of object being referenced */
      kind: string;
      /**
       * Name of the object being referenced.
       */
      name: string;
      /**
       * Namespace of the referenced object.
       *
       * If the object kind is non-namespace, such as "User" or "Group", and this value
       * is not empty the Authorizer should report an error.
       */
      namespace?: string;
  }/** @public */
  export declare interface ResourceClusterRoleBinding extends ResourceBase {
      apiVersion: "rbac.authorization.k8s.io/v1";
      kind: "ClusterRoleBinding";
      roleRef: RoleRef;
      subjects: Subject[];
  }/** @public */
  export declare interface ResourceDaemonSet extends ResourceBase {
      apiVersion: "apps/v1";
      kind: "DaemonSet";
      spec: DaemonSetSpec;
  }/** @public */
  export declare interface ResourcePod extends ResourceBase {
      kind: "Pod";
      spec: PodSpec;
  }/** @public */
  export declare interface ResourceService extends ResourceBase {
      kind: "Service";
      spec: ServiceSpec;
  }/** @public */
  export declare interface ResourceServiceAccount extends ResourceBase {
      kind: "ServiceAccount";
      automountServiceAccountToken?: boolean;
      imagePullSecrets?: {
          name: string;
      }[];
      secrets?: ObjectReference[];
  }/** @public */
  export declare interface ResourceConfigMap extends ResourceBase {
      kind: "ConfigMap";
      binaryData?: {
          [key: string]: string;
      };
      data?: {
          [key: string]: string;
      };
      /** @beta */
      immutable?: boolean;
  }/** @public */
  export declare interface ResourceSecret extends ResourceBase {
      kind: "Secret";
      data?: {
          [key: string]: string;
      };
      stringData?: {
          [key: string]: string;
      };
      type?: string;
  }/** @public */
  export declare interface ResourceCR extends ResourceBase {
      kind: string;
      spec: CRSpec;
  }/** @public */
  export declare interface Kubeconfig {
      apiVersion?: "v1";
      kind: "Config";
      "current-context": string;
      contexts: {
          name: string;
          context: {
              cluster: string;
              user: string;
          };
      }[];
      clusters: {
          name: string;
          cluster: {
              "certificate-authority-data": string;
              server: string;
          };
      }[];
      preferences?: unknown;
      users: {
          name: string;
          user: {
              "client-certificate-data"?: string;
              "client-key-data"?: string;
              "username"?: string;
              "password"?: string;
          };
      }[];
  }/** @public */
  export declare interface LabelSelector {
      /**
       * matchExpressions is a list of label selector requirements. The requirements are ANDed.
       */
      matchExpressions?: LabelSelectorRequirement[];
      /**
       * matchLabels is a map of `{key,value}`pairs. A single `{key,value}` in the matchLabels map
       * is equivalent to an element of matchExpressions, whose key field is "key", the operator
       * is "In", and the values array contains only "value". The requirements are ANDed.
       */
      matchLabels?: {
          [key: string]: string;
      };
  }/** @public */
  export declare interface LocalObjectReference {
      /**
       * Name of the referent.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names}
       */
      name: string;
  }/**
   * PodTemplateSpec from k8s API
   *
   * @public
   */
  export declare interface PodTemplateSpec {
      /**
       * Standard object's metadata.
       * More Info: {@link https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata}
       */
      metadata: Metadata;
      /**
       * Specification of the desired behavior of the pod.
       * More Info: {@link https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status}
       */
      spec: PodSpec;
  }/**
   * ObjectReference from k8s API
   *
   * @public
   */
  export declare interface ObjectReference {
      /**
       * If referring to a piece of an object instead of an entire object,
       * this string should contain a valid JSON/Go field access statement,
       * such as desiredState.manifest.containers[2].
       *
       * For example, if the object reference is to a container within a pod,
       * this would take on a value like: "spec.containers\{name\}" (where "name"
       * refers to the name of the container that triggered the event) or if no
       * container name is specified "spec.containers[2]"
       * (container with index 2 in this pod).
       * This syntax is chosen only to have some well-defined way of referencing a
       * part of an object.
       */
      fieldPath: string;
      /**
       * Name of the referent.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names}
       *
       */
      name: string;
      /**
       * Namespace of the referent.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/}
       */
      namespace: string;
      /**
       * Specific resourceVersion to which this reference is made, if any.
       *
       * More info: {@link https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency}
       */
      resourceVersion: string;
      /**
       * UID of the referent.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids}
       */
      uid: string;
  }/**
   * Make a {@link k8s.ClusterInfo} object suitable for use with k8s resources
   *
   * @remarks
   *
   * This function will take a set of options and generate a {@link k8s.ClusterInfo}
   * object that contains the kubeconfig, registryPrefix for private images, and any other
   * relevant information for the cluster
   *
   * See {@link k8s.MakeClusterInfoOptions} for information on how the information
   * is computed.
   *
   * @returns A {@link k8s.ClusterInfo} object.
   *
   * @public
   */
  export declare function makeClusterInfo(options: MakeClusterInfoOptions): Promise<ClusterInfo>;/** @internal */
  export declare function isResourcePodTemplate(x: any): x is AdaptElement<ResourcePod>;/**
   * Hook that allows a prop to be either an array of handle to k8s resources and values
   *
   * @param initial - initial value of the prop, before the handles are be resolved
   * @param notReady - is a marker value to indicate that a handle's value isn't available yet
   * @param kinds - an array of legal k8s Kinds that a prop handle can point to
   * @param thisResourceName - the name of the resource using the hook, for error messages
   * @param propName - the name of the prop being resolved, again for error messages
   *
   * @returns A two element array, the first element is the current value, the second the update function
   *
   * This hook will start by returning the initial value and an update function that updates
   * the value the hook returns.  The update function takes 2 arguments - the prop value which
   * is an array with a mix of values and handles to be resolved, and a function that receives
   * the elements that any handles point to along with that elements props.  This function
   * can be passed by the caller of update to resolve handles as appropriate for the component.
   *
   * For example, {@link k8s.ClusterRoleBinding} uses this hook to resolve the subjects prop,
   * which is an array of other objects (typically {@link ServiceAccount}) that a particular
   * {@link k8s.ClusterRole} should point to.  When ClusterRoleBinding calls the update method,
   * it passes a function that will convert a {@link k8s.Resource} element of Kind `ServiceAccount`
   * to the underlying `Subject` object that kubernetes expects, namely
   * `{ apiGroup: "", kind: "ServiceAccount", name: resourceIdToName(elem, deployID), namespace: <element namespace> }`
   *
   * @example
   * ```
   * function MyResource({ serviceAccountNames }: { serviceAccountNames: (string | Handle)[]}) {
   *   const { deployID } = useBuildHelpers();
   *   const [ resolvedServiceAccountNames, updateSANs] = useResources({
   *      initial: [],
   *      notReady: null,
   *      kinds: ["ServiceAccount"],
   *      thisResourceName: "MyResources",
   *      propName: "serviceAccountNames",
   *   });
   *
   *   updateSANs(serviceAccountNames, (e, props) => {
   *      return {
   *        apiGroup: (e.metadata.apiVersion?.split("/")[0]) || "",
   *        name: resourceElementToName(e, deployID),
   *        namespace: props.metadata.namespace,
   *      }
   *   });
   *
   *   return null;
   * }
   * ```
   *
   * @beta
   */
  export declare function useResources<ValT, NotReadyT>({ initial, notReady, kinds, thisResourceName, propName, }: {
      initial: ValT[];
      notReady: NotReadyT;
      kinds: string[];
      thisResourceName: string;
      propName: string;
  }): [
      (ValT | NotReadyT)[],
      (props: (ValT | Handle)[], f: (e: AdaptMountedElement, props: ResourceProps) => Promise<ValT> | ValT) => void
  ];/**
   * Hook to allow conversion of a prop that could be a value or a handle
   *
   * This function behaves similarly to {@link k8s.useResources}, but works for
   * a prop that is either a Handle or a single value instead of an array of
   * Handles and values.
   *
   * See {@link k8s.useResources} for more detailed documentation.
   *
   * @beta
   */
  export declare function useResource<ValT, NotReadyT>(opts: {
      initial: ValT | NotReadyT;
      notReady: NotReadyT;
      kinds: string[];
      thisResourceName: string;
      propName: string;
  }): [
      ValT | NotReadyT,
      (prop: ValT | Handle, f: (e: AdaptMountedElement, props: ResourceProps) => Promise<ValT> | ValT) => void
  ];/**
   * Options for {@link k8s.makeClusterInfo}
   *
   * @public
   */
  export declare interface MakeClusterInfoOptions {
      /**
       * A Javascript Object representing a valid kubeconfig, or a YAML string, or a path to a kubeconfig file.
       *
       * @remarks
       * If this is a Javascript object, it will be treated like a parsed kubeconfig.  If this is a string,
       * {@link k8s.makeClusterInfo} will first attempt to parse it as JSON.  If that fails, it will attempt
       * to parse it as YAML.  If that fails it will treat the string as a path of configs (like with the `KUBECONFIG`
       * environment variable).
       *
       * If kubeconfig is missing {@link k8s.makeClusterInfo} will use the `KUBECONFIG` environment variable to build
       * a suitable config using `kubectl config view --flatten` and return that as the kubeconfig in the resulting
       * {@link k8s.ClusterInfo}
       */
      kubeconfig?: Kubeconfig | string;
      /**
       * URL to the docker registry that this cluster uses to pull private images.
       *
       * @remarks
       * This is identical to the `registryPrefix` field in {@link k8s.ClusterInfo}.  It will
       * be returned verbatim in the resulting {@link k8s.ClusterInfo} object.
       */
      registryPrefix?: string | DockerSplitRegistryInfo;
  }/**
   * k8s ClusterRole resource
   *
   * @param propsIn - props for ServiceAccount as specifed in {@link k8s.ClusterRoleProps}
   *
   * @public
   */
  export declare function ClusterRole(propsIn: SFCDeclProps<ClusterRoleProps, typeof defaultProps>): Adapt.JSX.Element;/** @public */
  export declare function isClusterRoleProps(props: ResourceProps): props is ResourceProps & ResourceClusterRole;/** @internal */
  const clusterRoleResourceInfo: {
      kind: string;
      deployedWhen: () => true;
      statusQuery: (props: ResourcePropsWithConfig, observe: ObserveForStatus, buildData: BuildData) => Promise<any>;
      makeManifest: (manifest: Manifest, elem: AdaptElement<ResourceProps>, _deployID: string) => {
          aggregationRule: AggregationRule | undefined;
          rules: PolicyRule[] | undefined;
          apiVersion: string;
          kind: string;
          metadata: import("./manifest_support").MetadataInRequest;
          spec?: import("./DaemonSet").DaemonSetSpec | import("./common").CRSpec | import("./Pod").PodSpec | import("./Service").ServiceSpec | import("./Deployment").DeploymentSpec | undefined;
      };
  };/**
   * k8s ClusterRoleBinding resource
   *
   * @param propsIn - props for ServiceAccount as specifed in {@link k8s.ClusterRoleBindingProps}
   *
   * @public
   */
  export declare function ClusterRoleBinding(propsIn: SFCDeclProps<ClusterRoleBindingProps, typeof defaultProps>): Adapt.JSX.Element | null;/** @internal */
  const clusterRoleBindingResourceInfo: {
      kind: string;
      deployedWhen: () => true;
      statusQuery: (props: ResourcePropsWithConfig, observe: ObserveForStatus, buildData: BuildData) => Promise<any>;
      makeManifest: (manifest: Manifest, elem: AdaptElement<ResourceProps>, _deployID: string) => {
          roleRef: RoleRef;
          subjects: Subject[];
          apiVersion: string;
          kind: string;
          metadata: import("./manifest_support").MetadataInRequest;
          spec?: import("./DaemonSet").DaemonSetSpec | import("./common").CRSpec | import("./Pod").PodSpec | import("./Service").ServiceSpec | import("./Deployment").DeploymentSpec | undefined;
      };
  };/**
   * k8s ConfigMap resource
   *
   * @param propsIn - props for ConfigMap as specifed in {@link k8s.ConfigMapProps}
   *
   * @public
   */
  export declare function ConfigMap(propsIn: SFCDeclProps<ConfigMapProps, typeof defaultProps>): Adapt.JSX.Element;/** @internal */
  const configMapResourceInfo: {
      kind: string;
      deployedWhen: () => true;
      statusQuery: (props: ResourcePropsWithConfig, observe: ObserveForStatus, buildData: BuildData) => Promise<any>;
      makeManifest: (manifest: Manifest, elem: AdaptElement<ResourceProps>, _deployID: string) => {
          data: {
              [key: string]: string;
          } | undefined;
          binaryData: {
              [key: string]: string;
          } | undefined;
          immutable: boolean | undefined;
          apiVersion: string;
          kind: string;
          metadata: import("./manifest_support").MetadataInRequest;
          spec?: import("./DaemonSet").DaemonSetSpec | import("./common").CRSpec | import("./Pod").PodSpec | import("./Service").ServiceSpec | import("./Deployment").DeploymentSpec | undefined;
      };
  };/**
   * Low level utility function to translate from the abstract {@link Container}
   * component props ({@link ContainerProps}) to {@link k8s.K8sContainerProps}
   * to be used in a {@link k8s.K8sContainer}.
   * @remarks
   * Note: The `image` property in the passed in {@link ContainerProps} must
   * be a `string`, not a `Handle`.
   * In most cases, it is preferable to use the {@link k8s.Container} component
   * instead, which is designed specifically to deal with this issue.
   *
   * @param abstractProps - The abstract {@link ContainerProps} to translate from.
   * @param k8sProps - Props that are specific to the {@link k8s.K8sContainer}
   *     component that should be merged into the resulting returned
   *     {@link k8s.K8sContainerProps} object.
   * @public
   */
  export declare function k8sContainerProps(abstractProps: FromContainerProps, k8sProps?: Partial<K8sContainerProps>): K8sContainerProps;/**
   * Tests whether an element is a {@link k8s.K8sContainer} element
   * @param x - element to test
   * @returns `true` if element is a {@link k8s.K8sContainer}, `false` otherwise
   *
   * @remarks
   * Acts as a TypeScript type assertion that will assert that `x` is `AdaptElement<K8sContainerProps>`
   *
   * @public
   */
  export declare function isK8sContainerElement(x: AdaptElement): x is AdaptElement<K8sContainerProps>;/**
   * Component that implements the abstract {@link Container} interface and
   * translates to a Kubernetes-specific {@link k8s.K8sContainer}.
   * @public
   */
  export declare function Container(props: ContainerProps): Adapt.JSX.Element | null;/** @public */
  export declare interface VolumeMount {
      /**
       * Path within the container at which the volume should be mounted.
       *
       * Must not contain ':'.
       */
      mountPath: string;
      /**
       * mountPropagation determines how mounts are propagated from the host to container and the other way around.
       *
       * When not set, MountPropagationNone is used. This field is beta in 1.10.
       *
       * @defaultValue MountPropagationNone
       */
      mountPropagation?: string;
      /** This must match the Name of a Volume. */
      name: string;
      /**
       * Mounted read-only if true, read-write otherwise (false or unspecified).
       *
       * @defaultValue false
       */
      readOnly?: boolean;
      /**
       * Path within the volume from which the container's volume should be mounted.
       *
       * Defaults to "" (volume's root).
       *
       * @defaultValue ""
       */
      subPath?: string;
      /**
       * Expanded path within the volume from which the container's volume should be mounted.
       *
       * Behaves similarly to SubPath but environment variable references $(VAR_NAME)
       * are expanded using the container's environment.
       *
       * Defaults to "" (volume's root).
       *
       * SubPathExpr and SubPath are mutually exclusive.
       *
       * @defaultValue ""
       */
      subPathExpr?: string;
  }/** @public */
  export declare interface ConfigMapEnvSource {
      /**
       * Name of the referent.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names}
       */
      name?: string;
      /**
       * Specify whether the ConfigMap must be defined
       */
      optional?: boolean;
  }/** @public */
  export declare interface SecretEnvSource {
      /**
       * Name of the referent.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names}
       */
      name?: string;
      /**
       * Specify whether the Secret must be defined
       */
      optional?: boolean;
  }/** @public */
  export declare interface EnvFromSource {
      /** The ConfigMap to select from */
      configMapRef?: ConfigMapEnvSource;
      /** An optional identifier to prepend to each key in the ConfigMap. Must be a C_IDENTIFIER. */
      prefix?: string;
      /** SecretEnvSource	The Secret to select from */
      secretRef?: SecretEnvSource;
  }/** @public */
  export declare interface ExecAction {
      /**
       * Command is the command line to execute inside the container.
       *
       * The working directory for the command is root ('/') in the container's filesystem.
       * The command is simply exec'd, it is not run inside a shell,
       * so traditional shell instructions ('|', etc) won't work.
       * To use a shell, you need to explicitly call out to that shell.
       *
       * Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
       */
      command: string[];
  }/** @public */
  export declare interface HTTPGetAction {
      /**
       * Host name to connect to, defaults to the pod IP.
       *
       * You probably want to set "Host" in httpHeaders instead.
       */
      host?: string;
      /** Custom headers to set in the request. HTTP allows repeated headers. */
      httpHeaders?: {
          name: string;
          value: string;
      }[];
      /** Path to access on the HTTP server. */
      path: string;
      /**
       * Name or number of the port to access on the container.
       *
       * Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
       */
      port: number | string;
      /**
       * Scheme to use for connecting to the host.
       *
       * @defaultValue HTTP.
       */
      scheme?: string;
  }/** @public */
  export declare interface TCPSocketAction {
      /** Host name to connect to, defaults to the pod IP. */
      host?: string;
      /**
       * Number or name of the port to access on the container.
       *
       * Number must be in the range 1 to 65535.
       * Name must be an IANA_SVC_NAME.
       */
      port: string | number;
  }/** @public */
  export declare interface Probe {
      /**
       * Exec specifies the action to take.
       *
       * Only one of exec, httpGet, or tcpSocket should be specified
       */
      exec?: ExecAction;
      /**
       * Minimum consecutive failures for the probe to be considered failed after having succeeded.
       *
       * Defaults to 3. Minimum value is 1.
       *
       * @defaultValue 3
       */
      failureThreshold?: number;
      /** Specifies the http request to perform. */
      httpGet?: HTTPGetAction;
      /**
       *  Seconds after the container has started before liveness probes are initiated.
       *  More info: {@link https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes}
       */
      initialDelaySeconds?: number;
      /** How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. */
      periodSeconds?: number;
      /**
       * Minimum consecutive successes for the probe to be considered successful after having failed.
       *
       * Must be 1 for liveness and startup. Minimum value is 1.
       *
       * @defaultValue 1
       */
      successThreshold?: number;
      /**
       * Specifies an action involving a TCP port.
       *
       * TCP hooks not yet supported
       */
      tcpSocket?: TCPSocketAction;
      /**
       * Number of seconds after which the probe times out.
       *
       * Defaults to 1 second. Minimum value is 1.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes}
       *
       * @defaultValue 1
       */
      timeoutSeconds?: number;
  }/** @public */
  export declare interface ResourceRequirements {
      /**
       * Limits describes the maximum amount of compute resources allowed.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/}
       */
      limits?: {
          [key: string]: any;
      };
      /**
       * Describes the minimum amount of compute resources required.
       *
       * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
       * otherwise to an implementation-defined value.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/}
       */
      requests?: {
          [key: string]: any;
      };
  }/** @public */
  export declare type Handler = {
      exec: ExecAction;
  } | {
      httpGet: HTTPGetAction;
  } | {
      tcpSocket: TCPSocketAction;
  };/** @public */
  export declare interface Lifecycle {
      /**
       * PostStart is called immediately after a container is created.
       *
       * If the handler fails, the container is terminated and restarted according to its restart policy.
       * Other management of the container blocks until the hook completes.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks}
       */
      postStart: Handler;
      /**
       * Called immediately before a container is terminated due to an API request or management event such as liveness/startup probe failure, preemption, resource contention, etc.
       *
       * The handler is not called if the container crashes or exits.
       * The reason for termination is passed to the handler.
       * The Pod's termination grace period countdown begins before the PreStop hooked is executed.
       * Regardless of the outcome of the handler, the container will eventually terminate within the Pod's termination grace period.
       * Other management of the container blocks until the hook completes or until the termination grace period is reached.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks}
       */
      preStop: Handler;
  }/** @public */
  export declare interface VolumeDevice {
      /** The path inside of the container that the device will be mapped to. */
      devicePath: string;
      /** name must match the name of a persistentVolumeClaim in the pod */
      name: string;
  }/**
   * Resource spec for a Kubernetes container.
   * See the Kubernetes
   * {@link https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#container-v1-core | API docs }
   * for more details.
   * @public
   */
  export declare interface ContainerSpec {
      /**
       * Arguments to the entrypoint.
       *
       * The docker image's CMD is used if this is not provided.
       * Variable references $(VAR_NAME) are expanded using the container's environment.
       * If a variable cannot be resolved, the reference in the input string will be unchanged.
       * The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME).
       * Escaped references will never be expanded, regardless of whether the variable exists or not.
       * Cannot be updated.
       * More info: {@link https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell}
       */
      args?: string[];
      /**
       * Entrypoint array.
       *
       * Not executed within a shell.
       * The docker image's ENTRYPOINT is used if this is not provided.
       * Variable references $(VAR_NAME) are expanded using the container's environment.
       * If a variable cannot be resolved, the reference in the input string will be unchanged.
       * The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME).
       * Escaped references will never be expanded, regardless of whether the variable exists or not.
       * Cannot be updated.
       * More info: {@link https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell}
       */
      command?: string[];
      /**
       * List of environment variables to set in the container. Cannot be updated.
       */
      env?: EnvVar[];
      /**
       * List of sources to populate environment variables in the container.
       *
       * The keys defined within a source must be a C_IDENTIFIER.
       * All invalid keys will be reported as an event when the container is starting.
       * When a key exists in multiple sources, the value associated with the last source will take precedence.
       * Values defined by an Env with a duplicate key will take precedence. Cannot be updated.
       */
      envFrom?: EnvFromSource[];
      /**
       * Docker image name.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/containers/images}
       *
       * This field is optional to allow higher level config management to default or override container
       * images in workload controllers like Deployments and StatefulSets.
       */
      image?: string;
      /**
       * Image pull policy.
       *
       * One of Always, Never, IfNotPresent.
       * Defaults to Always if :latest tag is specified,
       * or IfNotPresent otherwise.
       * Cannot be updated.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/containers/images#updating-images}
       */
      imagePullPolicy?: "Always" | "Never" | "IfNotPresent";
      /**
       * List of sources to populate environment variables in the container.
       *
       * The keys defined within a source must be a C_IDENTIFIER.
       * All invalid keys will be reported as an event when the container is starting.
       * When a key exists in multiple sources, the value associated with the last source will take precedence.
       * Values defined by an Env with a duplicate key will take precedence. Cannot be updated.
       */
      lifecycle?: Lifecycle;
      /**
       * Periodic probe of container liveness.
       *
       * Container will be restarted if the probe fails.
       * Cannot be updated.
       * More info: {@link https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes}
       */
      livenessProbe?: Probe;
      /**
       * Name of the container specified as a DNS_LABEL.
       *
       * Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated.
       */
      name: string;
      /**
       * List of ports to expose from the container.
       *
       * Exposing a port here gives the system additional information about the network connections a container uses,
       * but is primarily informational.
       * Not specifying a port here DOES NOT prevent that port from being exposed.
       * Any port which is listening on the default "0.0.0.0" address inside a container will be accessible from
       * the network.
       * Cannot be updated.
       */
      ports?: ContainerPort[];
      /**
       * Periodic probe of container service readiness.
       *
       * Container will be removed from service endpoints if the probe fails.
       * Cannot be updated.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes}
       */
      readinessProbe?: Probe;
      /**
       * Compute Resources required by this container.
       *
       * Cannot be updated.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/}
       */
      resources?: ResourceRequirements;
      /**
       * Security options the pod should run with.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/policy/security-context/}
       * More info: {@link https://kubernetes.io/docs/tasks/configure-pod-container/security-context/}
       */
      securityContext?: PodSecurityContext;
      /**
       * Indicates that the Pod has successfully initialized.
       *
       * If specified, no other probes are executed until this completes successfully.
       * If this probe fails, the Pod will be restarted, just as if the livenessProbe failed.
       * This can be used to provide different probe parameters at the beginning of a Pod's lifecycle,
       * when it might take a long time to load data or warm a cache, than during steady-state operation.
       *
       * This cannot be updated.
       * This is a beta feature enabled by the StartupProbe feature flag.
       * More info: {@link https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes}
       */
      startupProbe?: Probe;
      /**
       * Whether this container should allocate a buffer for stdin in the container runtime.
       *
       * If this is not set, reads from stdin in the container will always result in EOF. Default is false.
       */
      stdin?: boolean;
      /**
       * Whether the container runtime should close the stdin channel after it has been opened by a single attach.
       *
       * When stdin is true the stdin stream will remain open across multiple attach sessions.
       * If stdinOnce is set to true, stdin is opened on container start,
       * is empty until the first client attaches to stdin,
       * and then remains open and accepts data until the client disconnects,
       * at which time stdin is closed and remains closed until the container is restarted.
       * If this flag is false, a container processes that reads from stdin will never receive an EOF. Default is false
       */
      stdinOnce?: boolean;
      /**
       * Path at which the file to which the container's termination message will be written is mounted into the container's filesystem.
       *
       * Message written is intended to be brief final status, such as an assertion failure message.
       * Will be truncated by the node if greater than 4096 bytes.
       * The total message length across all containers will be limited to 12kb.
       * Defaults to /dev/termination-log. Cannot be updated.
       */
      terminationMessagePath?: string;
      /**
       * Indicate how the termination message should be populated.
       *
       * File will use the contents of terminationMessagePath to populate the container status
       * message on both success and failure. FallbackToLogsOnError will use the last chunk of
       * container log output if the termination message file is empty and the container exited
       * with an error.
       * The log output is limited to 2048 bytes or 80 lines, whichever is smaller.
       * Defaults to File.
       * Cannot be updated.
       *
       * @defaultValue File
       */
      terminationMessagePolicy?: "File" | "FallbackToLogsOnError";
      /**
       * Whether this container should allocate a TTY for itself, also requires 'stdin' to be true.
       *
       * @defaultValue false
       */
      tty?: boolean;
      /**
       * volumeDevices is the list of block devices to be used by the container.
       */
      volumeDevices?: VolumeDevice[];
      /** volumeDevices is the list of block devices to be used by the container. */
      volumeMounts?: VolumeMount[];
      /**
       * Container's working directory.
       *
       * If not specified, the container runtime's default will be used,
       * which might be configured in the container image.
       * Cannot be updated.
       */
      workingDir?: string;
  }/**
   * Props for the Kubernetes-specific {@link k8s.K8sContainer} component.
   * @public
   */
  export declare interface K8sContainerProps extends ContainerSpec {
  }/** @public */
  export declare interface ContainerPort {
      /**
       * Number of port to expose on the pod's IP address.
       * @remarks
       * This must be a valid integer port number, `0 < x < 65536`.
       */
      containerPort: number;
      /** What host IP to bind the external port to. */
      hostIP?: string;
      /**
       * Number of port to expose on the host.
       * @remarks
       * If specified, this must be a valid integer port number,
       * `0 < x < 65536`. If HostNetwork is specified,
       * this must match ContainerPort. Most containers do not need this.
       */
      hostPort?: number;
      /**
       * A unique-within-pod name for the container
       * @remarks
       * If specified, this must be an IANA_SVC_NAME and unique within the pod.
       * Each named port in a pod must have a unique name. Name for the port
       * that can be referred to by services.
       */
      name?: string;
      /** Protocol for port. Must be UDP or TCP. Defaults to "TCP". */
      protocol?: string;
  }/** @public */
  export declare type EnvVar = EnvVarSimple | EnvVarFrom;/** @public */
  export declare interface EnvVarSimple {
      /** Name of the environment variable. Must be a C_IDENTIFIER. */
      name: string;
      /**
       * Variable references $(VAR_NAME) are expanded using the previous defined
       * environment variables in the container and any service environment
       * variables. If a variable cannot be resolved, the reference in the input
       * string will be unchanged. The $(VAR_NAME) syntax can be escaped with a
       * double $$, ie: $$(VAR_NAME). Escaped references will never be expanded,
       * regardless of whether the variable exists or not. Defaults to "".
       */
      value: string;
  }/** @public */
  export declare interface EnvVarFrom {
      /** Source for the environment variable's value. Cannot be used if value is not empty. */
      valueFrom?: any;
  }/**
   * See {@link k8s.k8sContainerProps}.
   * @public
   */
  export declare type FromContainerProps = ReplaceT<ContainerProps, {
      image: string;
  }> & BuiltinProps;/**
   * Kubernetes-specific container.
   * @public
   */
  export declare class K8sContainer extends PrimitiveComponent<K8sContainerProps> {
      static defaultProps: {
          imagePullPolicy: string;
      };
      validate(): undefined;
  }/**
   * Props for {@link k8s.Container}.
   * @public
   */
  export declare interface ContainerProps extends SFCDeclProps<ContainerProps> {
      /**
       * Additional {@link k8s.K8sContainerProps}-specific props that should be
       * added to the instantiated {@link k8s.K8sContainer}.
       */
      k8sContainerProps?: Partial<K8sContainerProps>;
  }/**
   * Spec for {@link k8s.DaemonSet} for use in {@link k8s.Resource}
   *
   * @public
   */
  export declare type DaemonSetSpec = Exclude<DaemonSetProps, ResourceBase> & {
      template: PodTemplateSpec;
  };/**
   * Component for Kubernetes DaemonSet
   *
   * @public
   */
  export declare class DaemonSet extends DeferredComponent<DaemonSetProps> {
      static defaultProps: {
          metadata: {};
          minReadySeconds: number;
          revisionHistoryLimit: number;
          updateStrategy: {
              type: string;
              rollingUpdate: {
                  maxUnavailable: number;
              };
          };
      };
      constructor(props: DaemonSetProps);
      build(helpers: BuildHelpers): Adapt.JSX.Element;
      status(_observe: ObserveForStatus, buildData: BuildData): Promise<Adapt.Status | undefined>;
  }/** @internal */
  const daemonSetResourceInfo: {
      kind: string;
      deployedWhen: typeof deployedWhen;
      statusQuery: (props: ResourcePropsWithConfig, observe: ObserveForStatus, buildData: BuildData) => Promise<any>;
  };/** @public */
  export declare interface DeploymentUpdateStrategyRecreate {
      type: "Recreate";
  }/** @public */
  export declare interface RollingUpdateDeployment {
      /**
       * The maximum number of pods that can be scheduled above the desired number of pods.
       *
       * Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
       * This can not be 0 if MaxUnavailable is 0.
       * Absolute number is calculated from percentage by rounding up.
       * Defaults to 25%.
       *
       * @example
       * When this is set to 30%, the new ReplicaSet can be scaled up immediately when the rolling update starts,
       * such that the total number of old and new pods do not exceed 130% of desired pods. Once old pods have been
       * killed, new ReplicaSet can be scaled up further, ensuring that total number of pods running at any time
       * during the update is at most 130% of desired pods.
       */
      maxSurge?: number | string;
      /**
       * The maximum number of pods that can be unavailable during the update.
       *
       * Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
       * Absolute number is calculated from percentage by rounding down.
       * This can not be 0 if MaxSurge is 0. Defaults to 25%.
       *
       * @example
       * When this is set to 30%, the old ReplicaSet can be scaled down to 70% of desired pods
       * immediately when the rolling update starts. Once new pods are ready, old ReplicaSet
       * can be scaled down further, followed by scaling up the new ReplicaSet, ensuring that
       * the total number of pods available at all times during the update is at least 70% of
       * desired pods.
       */
      maxUnavailable?: number | string;
  }/**
   * Spec for {@link k8s.Deployment} for use in {@link k8s.Resource}
   *
   * @public
   */
  export declare type DeploymentSpec = Exclude<DeploymentProps, ResourceBase> & {
      template: PodTemplateSpec;
  };/**
   * Props for {@link k8s.Deployment}
   *
   * @public
   */
  export declare interface DeploymentProps extends WithChildren {
      /** Information about the k8s cluster (ip address, auth info, etc.) */
      config: ClusterInfo;
      /** k8s metadata */
      metadata: Metadata;
      /**
       * The minimum number of seconds for which a newly created pod should
       * be ready without any of its container crashing, for it to be considered
       * available. Defaults to 0 (pod will be considered available as soon as it is ready).
       */
      minReadySeconds: number;
      /** Indicates that the deployment is paused */
      paused: boolean;
      /**
       * The maximum time in seconds for a deployment to make progress before it is considered to be failed.
       *
       * The deployment controller will continue to process failed deployments and a condition with a
       * ProgressDeadlineExceeded reason will be surfaced in the deployment status. Note that progress
       * will not be estimated during the time a deployment is paused. Defaults to 600s.
       */
      progressDeadlineSeconds: number;
      /**
       * Number of desired pods.
       *
       * Defaults to 1. 0 is not allowed.
       *
       * @defaultValue 1
       */
      replicas: number;
      /**
       * The number of old ReplicaSets to retain to allow rollback.
       *
       * This is a pointer to distinguish between explicit zero and not specified. Defaults to 10.
       *
       * @defaultValue 10
       */
      revisionHistoryLimit: number;
      /**
       * Label selector for pods.
       *
       * Existing ReplicaSets whose pods are selected by this will be the ones affected by this deployment.
       * It must match the pod template's labels.
       *
       * @remarks
       *
       * With Adapt, this is optional.  If not specified, adapt will pick a selector that will work with the pods
       * it creates as part of this {@link k8s.Deployment}
       */
      selector?: LabelSelector;
      /**
       * An deployment strategy to use to replace existing pods with new ones
       */
      strategy: DeploymentUpdateStrategy;
  }/**
   * Component for Kubernetes Deployment
   *
   * @public
   */
  export declare class Deployment extends DeferredComponent<DeploymentProps> {
      static defaultProps: {
          metadata: {};
          paused: boolean;
          replicas: number;
          progressDeadlineSeconds: number;
          minReadySeconds: number;
          revisionHistoryLimit: number;
          strategy: {
              type: string;
              rollingUpdate: {
                  maxSurge: string;
                  maxUnavailable: string;
              };
          };
      };
      constructor(props: DeploymentProps);
      build(helpers: BuildHelpers): Adapt.JSX.Element | null;
      deployedWhen: () => true | Adapt.Waiting;
      status(_observe: ObserveForStatus, buildData: BuildData): Promise<Adapt.Status | undefined>;
  }/** @internal */
  const deploymentResourceInfo: {
      kind: string;
      deployedWhen: typeof deployedWhen;
      statusQuery: (props: ResourcePropsWithConfig, observe: ObserveForStatus, buildData: BuildData) => Promise<any>;
  };/**
   * Type assertion to see if an element is both a {@link k8s.Resource | Resource}
   * and a {@link @adpt/core#FinalElement | FinalElement}
   *
   * @param e - element to test
   * @returns `true` if e is both a FinalElement and a {@link k8s.Resource | Resource}, `false` otherwise
   *
   * @public
   */
  export declare function isResourceFinalElement(e: AdaptElement): e is FinalDomElement<ResourceProps & Adapt.BuiltinProps>;/**
   * Tests whether a ResourceProps is for a template object
   *
   * @public
   */
  export declare function isResourcePropsWithConfig(x: ResourceProps & Partial<BuiltinProps>): x is ResourcePropsWithConfig & Partial<BuiltinProps>;/**
   * Tests to see if an object is a {@link k8s.Resource} element
   * @param x - object to test
   * @returns true if object is an AdaptElement of type {@link k8s.Resource}
   *
   * @public
   */
  export declare function isResource(x: any): x is AdaptElement<ResourceProps>;/**
   * Primitive Component recognized by the k8s plugin to represent resources
   * @public
   */
  export declare class Resource extends Action<ResourceProps> {
      defaultProps: {
          apiVersion: "v1";
          con: false;
      };
      manifest_: Manifest;
      constructor(props: ResourceProps);
      validate(): "Resource elements cannot have children" | undefined;
      shouldAct(op: ChangeType, ctx: ActionContext): Promise<ShouldAct>;
      action(op: ChangeType, ctx: ActionContext): Promise<void>;
      deployedWhen: (goalStatus: GoalStatus, helpers: DeployHelpers) => Promise<true | Adapt.Waiting | Adapt.Waiting[]>;
      status(observe: ObserveForStatus, buildData: BuildData): Promise<any>;
      private mountedElement;
      private manifest;
  }/** @internal */
  export declare function makePodManifest(props: PodProps & BuiltinProps, data: {
      volumes?: Volume[];
      serviceAccountName?: string;
  }): {
      kind: string;
      metadata: Metadata;
      spec: PodSpec;
  };/**
   * Tests whether x is a Pod element
   *
   * @param x - value to test
   * @returns `true` if x is a Pod element, false otherwise
   *
   * @public
   */
  export declare function isPod(x: any): x is AdaptElement<PodProps>;/** @public */
  export declare interface NodeSelectorRequirement {
      /** The label key that the selector applies to. */
      key: string;
      /**
       * Represents a key's relationship to a set of values.
       *
       * Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
       */
      operator: "In" | "NotIn" | "Exists" | "DoesNotExist" | "Gt" | "Lt";
      /**
       * Values for operator
       *
       * If the operator is In or NotIn, the values array must be non-empty.
       * If the operator is Exists or DoesNotExist, the values array must be empty.
       * If the operator is Gt or Lt, the values array must have a single element,
       * which will be interpreted as an integer.
       * This array is replaced during a strategic merge patch.
       */
      values: string[];
  }/** @public */
  export declare interface NodeSelectorTerm {
      /** A list of node selector requirements by node's labels. */
      matchExpressions?: NodeSelectorRequirement[];
      /** A list of node selector requirements by node's fields. */
      matchFields?: NodeSelectorRequirement[];
  }/** @public */
  export declare interface PreferredSchedulingTerm {
      /**
       * A node selector term, associated with the corresponding weight.
       */
      preference: NodeSelectorTerm;
      /** Weight associated with matching the corresponding nodeSelectorTerm, in the range 1-100. */
      weight: number;
  }/** @public */
  export declare interface NodeSelector {
      /** A list of node selector terms. The terms are ORed */
      nodeSelectorTerms: NodeSelectorTerm[];
  }/** @public */
  export declare interface NodeAffinity {
      /** The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding "weight" to the sum if the node matches the corresponding matchExpressions; the node(s) with the highest sum are the most preferred. */
      preferredDuringSchedulingIgnoredDuringExecution?: PreferredSchedulingTerm[];
      /** If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to an update), the system may or may not try to eventually evict the pod from its node. */
      requiredDuringSchedulingIgnoredDuringExecution?: NodeSelector;
  }/** @public */
  export declare interface PodAffinityTerm {
      /**
       * Label query over a set of resources, in this case pods.
       */
      labelSelector: LabelSelector;
      /** Specifies which namespaces the labelSelector applies to (matches against); null or empty list means "this pod's namespace" */
      namespaces?: string[];
      /** This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed. */
      topologyKey: string;
  }/** @public */
  export declare interface WeightedPodAffinityTerm {
      /** A pod affinity term, associated with the corresponding weight. */
      podAffinityTerm: PodAffinityTerm;
      /**
       * weight associated with matching the corresponding podAffinityTerm, in the range 1-100.
       */
      weight: number;
  }/** @public */
  export declare interface PodAffinity {
      /**
       * The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions.
       *
       * The node that is most preferred is the one with the greatest sum of weights,
       * i.e. for each node that meets all of the scheduling requirements (resource request,
       * requiredDuringScheduling affinity expressions, etc.), compute a sum by iterating
       * through the elements of this field and adding "weight" to the sum if the node has pods
       * which matches the corresponding podAffinityTerm; the node(s) with the highest sum are the most preferred.
       */
      preferredDuringSchedulingIgnoredDuringExecution: WeightedPodAffinityTerm[];
      /**
       * If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node.
       *
       * If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system may or may not try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each podAffinityTerm are intersected, i.e. all terms must be satisfied.
       */
      requiredDuringSchedulingIgnoredDuringExecution: PodAffinityTerm[];
  }/** @public */
  export declare interface PodAntiAffinity {
      /** The scheduler will prefer to schedule pods to nodes that satisfy the anti-affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling anti-affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the node(s) with the highest sum are the most preferred. */
      preferredDuringSchedulingIgnoredDuringExecution: WeightedPodAffinityTerm[];
      /** If the anti-affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the anti-affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system may or may not try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each podAffinityTerm are intersected, i.e. all terms must be satisfied. */
      requiredDuringSchedulingIgnoredDuringExecution: PodAffinity;
  }/** @public */
  export declare interface Affinity {
      /** Describes node affinity scheduling rules for the pod. */
      nodeAffinity: NodeAffinity;
      /** Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)). */
      podAffinity: PodAffinity;
      /** PodAntiAffinity	Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)). */
      podAntiAffinity: PodAntiAffinity;
  }/** @public */
  export declare interface PodDNSConfigOption {
      name: string;
      value?: string;
  }/** @public */
  export declare interface PodDNSConfig {
      /**
       * A list of DNS name server IP addresses.
       *
       * This will be appended to the base nameservers generated from DNSPolicy. Duplicated nameservers will be removed.
       */
      nameservers: string[];
      /**
       * A list of DNS resolver options.
       *
       * This will be merged with the base options generated from DNSPolicy.
       * Duplicated entries will be removed.
       * Resolution options given in Options will override those that appear in the base DNSPolicy.
       */
      options: PodDNSConfigOption[];
      /**
       * A list of DNS search domains for host-name lookup.
       *
       * This will be appended to the base search paths generated from DNSPolicy. Duplicated search paths will be removed.
       */
      searches: string[];
  }/** @public */
  export declare interface PodReadinessGate {
      /** Refers to a condition in the pod's condition list with matching type. */
      conditionType: string;
  }/** @public */
  export declare interface SELinuxOptions {
      /** SELinux level label that applies to the container. */
      level: string;
      /** SELinux role label that applies to the container. */
      role: string;
      /** SELinux type label that applies to the container. */
      type: string;
      /** SELinux user label that applies to the container */
      user: string;
  }/** @public */
  export declare interface SeccompProfile {
      /**
       * Indicates a profile defined in a file on the node should be used.
       *
       * The profile must be preconfigured on the node to work.
       * Must be a descending path, relative to the kubelet's configured seccomp profile location.
       * Must only be set if type is "Localhost".
       */
      localhostProfile?: string;
      /**
       * Indicates which kind of seccomp profile will be applied.
       *
       * Valid options are:
       * * Localhost - a profile defined in a file on the node should be used.
       * * RuntimeDefault - the container runtime default profile should be used.
       * * Unconfined - no profile should be applied.
       */
      type: "Localhost" | "RuntimeDefault" | "Unconfined";
  }/** @public */
  export declare interface Sysctl {
      name: string;
      value: string;
  }/** @public */
  export declare interface WindowsSecurityContextOptions {
      /**
       * The GMSA admission webhook ({@link https://github.com/kubernetes-sigs/windows-gmsa}) inlines the contents of the GMSA credential spec named by the GMSACredentialSpecName field.
       */
      gmsaCredentialSpec?: string;
      /**
       * GMSACredentialSpecName is the name of the GMSA credential spec to use.
       */
      gmsaCredentialSpecName?: string;
      /**
       * The UserName in Windows to run the entrypoint of the container process.
       *
       * Defaults to the user specified in image metadata if unspecified. May also be set in PodSecurityContext.
       * If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
       */
      runAsUserName?: string;
  }/** @public */
  export declare interface PodSecurityContext {
      /**
       * A special supplemental group that applies to all containers in a pod.
       *
       * Some volume types allow the Kubelet to change the ownership of that volume to be owned by the pod:
       *
       * 1. The owning GID will be the FSGroup
       * 2. The setgid bit is set (new files created in the volume will be owned by FSGroup)
       * 3. The permission bits are OR'd with rw-rw----
       *
       * If unset, the Kubelet will not modify the ownership and permissions of any volume.
       */
      fsGroup?: number;
      /**
       * Defines behavior of changing ownership and permission of the volume before being exposed inside Pod.
       *
       * This field will only apply to volume types which support fsGroup based ownership(and permissions).
       * It will have no effect on ephemeral volume types such as: secret, configmaps and emptydir.
       * Valid values are "OnRootMismatch" and "Always". If not specified defaults to "Always".
       *
       * @defaultValue Always
       */
      fsGroupChangePolicy?: "OnRootMismatch" | "Always";
      /**
       * The GID to run the entrypoint of the container process.
       *
       * Uses runtime default if unset. May also be set in SecurityContext.
       * If set in both SecurityContext and PodSecurityContext, the value specified in
       * SecurityContext takes precedence for that container.
       */
      runAsGroup?: number;
      /**
       * Indicates that the container must run as a non-root user.
       *
       * If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and
       * fail to start the container if it does. If unset or false, no such validation will be performed.
       * May also be set in SecurityContext.
       * If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
       */
      runAsNonRoot?: boolean;
      /**
       * The UID to run the entrypoint of the container process.
       *
       * Defaults to user specified in image metadata if unspecified.
       * May also be set in SecurityContext.
       * If set in both SecurityContext and PodSecurityContext, the value specified in
       * SecurityContext takes precedence for that container.
       */
      runAsUser?: number;
      /**
       * The SELinux context to be applied to all containers.
       *
       * If unspecified, the container runtime will allocate a random SELinux context for each container.
       * May also be set in SecurityContext.
       * If set in both SecurityContext and PodSecurityContext, the value specified in
       * SecurityContext takes precedence for that container.
       */
      seLinuxOptions?: SELinuxOptions;
      /**
       * The seccomp options to use by the containers in this pod.
       */
      seccompProfile?: SeccompProfile;
      /**
       * 	A list of groups applied to the first process run in each container, in addition to the container's primary GID.
       *
       *  If unspecified, no groups will be added to any container.
       */
      supplementalGroups?: number[];
      /**
       * Sysctls hold a list of namespaced sysctls used for the pod.
       *
       * Pods with unsupported sysctls (by the container runtime) might fail to launch.
       */
      sysctls?: Sysctl[];
      /**
       * The Windows specific settings applied to all containers.
       *
       * If unspecified, the options within a container's SecurityContext will be used.
       * If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
       */
      windowsOptions: WindowsSecurityContextOptions;
  }/** @public */
  export declare interface Toleration {
      /**
       * Indicates the taint effect to match.
       *
       * Empty means match all taint effects.
       * When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
       */
      effect?: "NoSchedule" | "PreferNoSchedule" | "NoExecute";
      /**
       * The taint key that the toleration applies to.
       *
       * Empty means match all taint keys.
       * If the key is empty, operator must be Exists;
       * this combination means to match all values and all keys.
       */
      key?: string;
      /**
       * Represents a key's relationship to the value.
       *
       * Valid operators are Exists and Equal.
       * Defaults to Equal.
       * Exists is equivalent to wildcard for value, so that a pod can tolerate all taints of a particular category.
       *
       * @defaultValue Equal
       */
      operator?: "Exists" | "Equal";
      /**
       * Represents the period of time the toleration (which must be of effect NoExecute, otherwise this field is ignored) tolerates the taint.
       *
       * By default, it is not set, which means tolerate the taint forever (do not evict).
       * Zero and negative values will be treated as 0 (evict immediately) by the system.
       */
      tolerationSeconds?: number;
      /**
       * Value is the taint value the toleration matches to.
       *
       * If the operator is Exists, the value should be empty, otherwise just a regular string.
       */
      value?: string;
  }/** @public */
  export declare interface TopologySpreadConstraint {
      /**
       * Used to find matching pods.
       *
       * Pods that match this label selector are counted to determine the
       * number of pods in their corresponding topology domain.
       */
      labelSelector: LabelSelector;
      /**
       * Describes the degree to which pods may be unevenly distributed.
       *
       * When `whenUnsatisfiable=DoNotSchedule`, it is the maximum permitted
       * difference between the number of matching pods in the target topology
       * and the global minimum.
       * For example, in a 3-zone cluster, MaxSkew is set to 1, and pods with
       * the same labelSelector spread as 1/1/0: | zone1 | zone2 | zone3 | | P | P | |
       * - if MaxSkew is 1, incoming pod can only be scheduled to zone3 to become 1/1/1;
       *   scheduling it onto zone1(zone2) would make the ActualSkew(2-0) on zone1(zone2) violate MaxSkew(1).
       * - if MaxSkew is 2, incoming pod can be scheduled onto any zone.
       * When `whenUnsatisfiable=ScheduleAnyway`, it is used to give higher precedence to topologies that satisfy it.
       * It's a required field. Default value is 1 and 0 is not allowed.
       *
       * @example
       *
       * @defaultValue 1
       */
      maxSkew: number;
      /**
       * The key of node labels.
       *
       * Nodes that have a label with this key and identical values are considered to be in the same topology.
       * We consider each \<key, value\> as a "bucket", and try to put balanced number of pods into each bucket.
       * It's a required field.
       */
      topologyKey: string;
      /**
       * Indicates how to deal with a pod if it doesn't satisfy the spread constraint.
       *
       * - DoNotSchedule (default) tells the scheduler not to schedule it.
       * - ScheduleAnyway tells the scheduler to schedule the pod in any location,
       *   but giving higher precedence to topologies that would help reduce the skew.
       *
       * A constraint is considered "Unsatisfiable" for an incoming pod if and only if every possible
       * node assigment for that pod would violate "MaxSkew" on some topology.
       * For example, in a 3-zone cluster, MaxSkew is set to 1, and pods with the same labelSelector
       * spread as 3/1/1: | zone1 | zone2 | zone3 | | P P P | P | P | If WhenUnsatisfiable is set to DoNotSchedule,
       * incoming pod can only be scheduled to zone2(zone3) to become 3/2/1(3/1/2)
       * as ActualSkew(2-1) on zone2(zone3) satisfies MaxSkew(1).
       * In other words, the cluster can still be imbalanced, but scheduler won't make it
       * *more* imbalanced.
       *
       * It's a required field.
       */
      whenUnsatisfiable: string;
  }/** @public */
  export declare interface KeyToPath {
      /** The key to project. */
      key: string;
      /**
       * mode bits to use on this file,
       * Must be a value between 0 and 0777.
       * If not specified, the volume defaultMode will be used.
       * This might be in conflict with other options that affect the file mode, like fsGroup,
       * and the result can be other mode bits set.
       */
      mode?: number;
      /**
       * The relative path of the file to map the key to.
       *
       * May not be an absolute path. May not contain the path element '..'. May not start with the string '..'.
       */
      path: string;
  }/** @public */
  export declare interface ConfigMapVolumeSource {
      /**
       * mode bits to use on created files by default.
       *
       * Must be a value between 0 and 0777. Defaults to 0644.
       * Directories within the path are not affected by this setting.
       * This might be in conflict with other options that affect the file mode,
       * like fsGroup, and the result can be other mode bits set.
       */
      defaultMode?: number;
      /**
       * If unspecified, each key-value pair in the Data field of the referenced ConfigMap will be projected into the volume as a file whose name is the key and content is the value.
       *
       * If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present.
       * If a key is specified which is not present in the ConfigMap, the volume setup will error unless it is marked optional.
       * Paths must be relative and may not contain the '..' path or start with '..'.
       */
      items?: KeyToPath[];
      /**
       * Name of the referent.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names}
       */
      name: string | Handle;
      /** Specify whether the ConfigMap or its keys must be defined */
      optional?: boolean;
  }/** @public */
  export declare interface SecretVolumeSource {
      /**
       * mode bits to use on created files by default.
       *
       * Must be a value between 0 and 0777. Defaults to 0644.
       * Directories within the path are not affected by this setting.
       * This might be in conflict with other options that affect the file mode,
       * like fsGroup, and the result can be other mode bits set.
       */
      defaultMode?: number;
      /**
       * If unspecified, each key-value pair in the Data field of the referenced Secret will be projected into the volume as a file whose name is the key and content is the value.
       *
       * If specified, the listed keys will be projected into the specified paths,
       * and unlisted keys will not be present. If a key is specified which is not
       * present in the Secret, the volume setup will error unless it is marked optional.
       *
       * Paths must be relative and may not contain the '..' path or start with '..'.
       */
      items?: KeyToPath[];
      /** Specify whether the Secret or its keys must be defined */
      optional?: boolean;
      /**
       * Name of the secret in the pod's namespace to use.
       *
       *  More info: {@link https://kubernetes.io/docs/concepts/storage/volumes#secret}
       */
      secretName: string | Handle;
  }/** @public */
  export declare interface EmptyDirVolumeSource {
      /**
       * What type of storage medium should back this directory.
       *
       * The default is "" which means to use the node's default medium.
       * Must be an empty string (default) or Memory.
       * More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
       */
      medium: string;
      /**
       * Total amount of local storage required for this EmptyDir volume.
       *
       * The size limit is also applicable for memory medium.
       * The maximum usage on memory medium EmptyDir would be the minimum
       * value between the SizeLimit specified here and the sum of memory limits of all containers in a pod.
       * The default is nil which means that the limit is undefined.
       * More info: {@link http://kubernetes.io/docs/user-guide/volumes#emptydir}
       */
      sizeLimit: string;
  }/**
   * Volumes for {@link k8s.PodProps}
   *
   * @public
   */
  export declare interface Volume {
      /**
       * Volume's name.
       *
       * Must be a DNS_LABEL and unique within the pod.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names}
       */
      name: string;
      /**
       * Represents a configMap that should populate this volume
       */
      configMap?: ConfigMapVolumeSource;
      /**
       * EmptyDir represents a temporary directory that shares a pod's lifetime.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/storage/volumes#emptydir}
       *
       */
      emptyDir?: EmptyDirVolumeSource;
      /**
       * Represents a secret that should populate this volume.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/storage/volumes#secret}
       */
      secret?: SecretVolumeSource;
      /** Other k8s volume kinds not typed yet for \@adpt/cloud */
      [key: string]: any;
  }/**
   * Props for the {@link k8s.Pod} component
   *
   * @public
   */
  export declare interface PodProps extends WithChildren {
      /**
       *  True is this is a template for use in a controller, false otherwise
       *  @defaultValue false
       */
      isTemplate: boolean;
      /** Information about the k8s cluster (ip address, auth info, etc.) */
      config?: ClusterInfo;
      /** k8s metadata */
      metadata: Metadata;
      /**
       * Optional duration in seconds the pod may be active on the node relative to StartTime before the system will actively try to mark it failed and kill associated containers.
       *
       * Value must be a positive integer.
       */
      activeDeadlineSeconds?: number;
      /** If specified, the pod's scheduling constraints */
      affinity?: Affinity;
      /** AutomountServiceAccountToken indicates whether a service account token should be automatically mounted. */
      automountServiceAccountToken?: boolean;
      /**
       *  Specifies the DNS parameters of a pod.
       *
       *  Parameters specified here will be merged to the generated DNS configuration based on DNSPolicy.
       */
      dnsConfig?: PodDNSConfig;
      /**
       * Set DNS policy for the pod.
       *
       * Valid values are 'ClusterFirstWithHostNet', 'ClusterFirst', 'Default' or 'None'.
       * DNS parameters given in DNSConfig will be merged with the policy selected with DNSPolicy.
       * To have DNS options set along with hostNetwork, you have to specify DNS policy explicitly
       * to 'ClusterFirstWithHostNet'.
       *
       * @defaultValue ClusterFirst
       */
      dnsPolicy: "ClusterFirstWithHostNet" | "ClusterFirst" | "Default" | "None";
      /**
       * Indicates whether information about services should be injected into pod's environment variables matching the syntax of Docker links.
       *
       * @defaultValue true
       */
      enableServiceLinks: boolean;
      /**
       * An optional list of hosts and IPs that will be injected into the pod's hosts file if specified.
       *
       * This is only valid for non-hostNetwork pods.
       */
      hostAliases?: HostAlias[];
      /**
       * Use the host's ipc namespace.
       * @defaultValue false
       */
      hostIPC: boolean;
      /**
       * Host networking requested for this pod.
       *
       * Use the host's network namespace.
       * If this option is set, the ports that will be used must be specified. Default to false.
       */
      hostNetwork?: boolean;
      /**
       * Use the host's pid namespace.
       * @defaultValue false
       */
      hostPID: boolean;
      /**
       * Specifies the hostname of the Pod.
       *
       * If not specified, the pod's hostname will be set to a system-defined value.
       */
      hostname?: string;
      /**
       * List of references to secrets in the same namespace to use for pulling any of the images used by this PodSpec.
       *
       * If specified, these secrets will be passed to individual puller implementations for them to use.
       * For example, in the case of docker, only DockerConfig type secrets are honored.
       * More info: {@link https://kubernetes.io/docs/concepts/containers/images#specifying-imagepullsecrets-on-a-pod}
       */
      imagePullSecrets?: LocalObjectReference[];
      /**
       * A request to schedule this pod onto a specific node.
       *
       * If it is non-empty, the scheduler simply schedules this pod onto that node,
       * assuming that it fits resource requirements.
       */
      nodeName?: string;
      /**
       * A selector which must be true for the pod to fit on a node.
       *
       * Selector which must match a node's labels for the pod to be scheduled on that node.
       * More info: {@link https://kubernetes.io/docs/concepts/configuration/assign-pod-node/}
       */
      nodeSelector?: {
          [label: string]: boolean | string;
      };
      /**
       * Overhead represents the resource overhead associated with running a pod for a given RuntimeClass.
       *
       * This field will be autopopulated at admission time by the RuntimeClass admission controller.
       * If the RuntimeClass admission controller is enabled, overhead must not be set in Pod create requests.
       * The RuntimeClass admission controller will reject Pod create requests which have the overhead already set.
       * If RuntimeClass is configured and selected in the PodSpec, Overhead will be set to the value defined in
       * the corresponding RuntimeClass, otherwise it will remain unset and treated as zero.
       *
       * More info: {@link https://git.k8s.io/enhancements/keps/sig-node/20190226-pod-overhead.md}
       *
       * This field is alpha-level as of Kubernetes v1.16, and is only honored by servers that enable
       * the PodOverhead feature.
       * @alpha
       */
      overhead?: unknown;
      /**
       * PreemptionPolicy is the Policy for preempting pods with lower priority.
       *
       * This field is beta-level, gated by the NonPreemptingPriority feature-gate.
       *
       * @defaultValue PreemptLowerPriority
       * @beta
       */
      preemptionPolicy?: "Never" | "PreemptLowerPriority";
      /**
       * The priority various system components use this field to find the priority of the pod.
       *
       * When Priority Admission Controller is enabled, it prevents users from setting this field.
       * The admission controller populates this field from PriorityClassName.
       * The higher the value, the higher the priority.
       */
      priority?: number;
      /**
       * If specified, indicates the pod's priority.
       *
       * "system-node-critical" and "system-cluster-critical" are two special keywords which indicate the highest
       * priorities with the former being the highest priority. Any other name must be defined by creating a PriorityClass
       * object with that name. If not specified, the pod priority will be default or zero if there is no default.
       */
      priorityClassName?: string;
      /**
       *  If specified, all readiness gates will be evaluated for pod readiness.
       *
       *  A pod is ready when all its containers are ready AND all conditions specified
       *  in the readiness gates have status equal to "True"
       *
       *  More info: {@link https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#pod-readiness-gate}
       */
      readinessGates?: PodReadinessGate[];
      /**
       * Restart policy for all containers within the pod.
       *
       * One of Always, OnFailure, Never. Default to Always.
       * More info: {@link https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy}
       *
       * @defaultValue Always
       */
      restartPolicy: "Always" | "OnFailure" | "Never";
      /**
       * Refers to a RuntimeClass object in the node.k8s.io group, which should be used to run this pod.
       *
       * If no RuntimeClass resource matches the named class, the pod will not be run.
       * If unset or empty, the "legacy" RuntimeClass will be used, which is an implicit
       * class with an empty definition that uses the default runtime handler.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/containers/runtime-class/}
       *
       * This is a beta feature as of Kubernetes v1.14.
       */
      runtimeClassName?: string;
      /**
       *  If specified, the pod will be dispatched by specified scheduler.
       *  If not specified, the pod will be dispatched by default scheduler.
       */
      schedulerName?: string;
      /**
       * SecurityContext holds pod-level security attributes and common container settings.
       * See type description for default values of each field.
       *
       * @defaultValue \{\}
       */
      securityContext: PodSecurityContext;
      /**
       * ServiceAccountName is the name of the ServiceAccount to use to run this pod.
       * More info: {@link https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/}
       */
      serviceAccountName?: string | Handle;
      /**
       * If true the pod's hostname will be configured as the pod's FQDN, rather than the leaf name (the default).
       * In Linux containers, this means setting the FQDN in the hostname field of the kernel
       * (the nodename field of struct utsname).
       * In Windows containers, this means setting the registry value of hostname for the registry key
       * HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters to FQDN.
       * If a pod does not have FQDN, this has no effect.
       *
       * @defaultValue false
       */
      setHostnameAsFQDN?: boolean;
      /**
       * Share a single process namespace between all of the containers in a pod.
       * When this is set containers will be able to view and signal processes from other containers in the same pod,
       * and the first process in each container will not be assigned PID 1.
       * HostPID and ShareProcessNamespace cannot both be set.
       *
       * @defaultValue false
       */
      shareProcessNamespace: boolean;
      /**
       *  If specified, the fully qualified Pod hostname will be "\<hostname\>.\<subdomain\>.\<pod namespace\>.svc.\<cluster domain\>".
       *  If not specified, the pod will not have a domainname at all.
       */
      subdomain?: string;
      /**
       * Optional duration in seconds the pod needs to terminate gracefully.
       *
       * May be decreased in delete request. Value must be non-negative integer.
       * The value zero indicates delete immediately. If this value is nil, the default
       * grace period will be used instead. The grace period is the duration in seconds
       * after the processes running in the pod are sent a termination signal and the time
       * when the processes are forcibly halted with a kill signal. Set this value longer
       * than the expected cleanup time for your process. Defaults to 30 seconds.
       */
      terminationGracePeriodSeconds?: number;
      /** If specified, the pod's tolerations. */
      tolerations?: Toleration[];
      /**
       *  TopologySpreadConstraints describes how a group of pods ought to spread across topology domains.
       *
       *  Scheduler will schedule pods in a way which abides by the constraints. All topologySpreadConstraints are ANDed.
       */
      topologySpreadConstraints?: TopologySpreadConstraint[];
      /**
       * List of volumes that can be mounted by containers belonging to the pod.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/storage/volumes}
       */
      volumes?: Volume[];
  }/**
   * Component for Kubernetes Pods
   *
   * @public
   */
  export declare class Pod extends DeferredComponent<PodProps, ResolvedVolumes & ResolvedServiceAccountName> {
      static defaultProps: {
          isTemplate: boolean;
          metadata: {};
          dnsPolicy: string;
          enableServiceLinks: boolean;
          hostIPC: boolean;
          hostPID: boolean;
          restartPolicy: string;
          securityContext: {};
          shareProcessNamespace: boolean;
          terminationGracePeriodSeconds: number;
      };
      initialState(): {};
      build(helpers: BuildHelpers): Adapt.JSX.Element | null;
      status(_observe: ObserveForStatus, buildData: BuildData): Promise<Adapt.Status | undefined>;
  }/**
   * Spec for for Kubernetes Pods
   *
   * @public
   */
  export declare interface PodSpec extends Omit<PodProps, "config" | "metadata" | "isTemplate"> {
      containers: ContainerSpec[];
      terminationGracePeriodSeconds?: number;
  }/** @internal */
  const podResourceInfo: {
      kind: string;
      deployedWhen: typeof deployedWhen;
      statusQuery: (props: ResourcePropsWithConfig, observe: ObserveForStatus, buildData: BuildData) => Promise<any>;
  };/**
   * k8s Secret resource
   *
   * @param propsIn - props for Secret as specifed in {@link k8s.SecretProps}
   *
   * @public
   */
  export declare function Secret(propsIn: SFCDeclProps<SecretProps, typeof defaultProps>): Adapt.JSX.Element;/** @internal */
  const secretResourceInfo: {
      kind: string;
      deployedWhen: () => true;
      statusQuery: (props: ResourcePropsWithConfig, observe: ObserveForStatus, buildData: BuildData) => Promise<any>;
      makeManifest: (manifest: Manifest, elem: AdaptElement<ResourceProps>, _deployID: string) => {
          data: {
              [key: string]: string;
          } | undefined;
          stringData: {
              [key: string]: string;
          } | undefined;
          type: string | undefined;
          apiVersion: string; /**
           * stringData allows specifying non-binary secret data in string form.
           *
           * It is provided as a write-only convenience method. All keys and values are merged into the data field on write,
           * overwriting any existing values. It is never output when reading from the API.
           */
          kind: string;
          metadata: import("./manifest_support").MetadataInRequest;
          spec?: import("./DaemonSet").DaemonSetSpec | import("./common").CRSpec | import("./Pod").PodSpec | import("./Service").ServiceSpec | import("./Deployment").DeploymentSpec | undefined;
      };
  };/**
   * Convert {@link NetworkService} props to {@link k8s.Service} props
   * @param abstractProps - props to convert
   * @returns Kubernetes spec corresponding to `abstractProps`
   *
   * @internal
   */
  export declare function k8sServiceProps(abstractProps: NetworkServiceProps & BuiltinProps): Omit<ServiceProps, keyof ResourceBase>;/**
   * Native Kubernetes Service resource
   *
   * @remarks
   *
   * Implements the {@link NetworkServiceInstance} interface.
   *
   * @public
   */
  export declare function Service(propsIn: SFCDeclProps<ServiceProps, typeof defaultProps>): Adapt.JSX.Element;/** @public */
  export declare interface ServiceProps extends ServiceSpec {
      /** Legal configuration loaded from kubeconfig */
      config: ClusterInfo;
      metadata?: Metadata;
      selector?: Handle | EndpointSelector;
  }/** @public */
  export declare interface ServiceSpec {
      /**
       * Cluster IP for a {@link k8s.Service}
       *
       * @remarks
       * `clusterIP` is the IP address of the service and is usually assigned
       * randomly by the master. If an address is specified manually and is not
       * in use by others, it will be allocated to the service; otherwise,
       * creation of the service will fail. This field can not be changed through
       * updates. Valid values are "None", empty string (""), or a valid IP
       * address. "None" can be specified for headless services when proxying is
       * not required. Only applies to types ClusterIP, NodePort, and
       * LoadBalancer. Ignored if type is ExternalName.
       *
       * For more information, see the
       * {@link https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies |
       * Kubernetes documentation}.
       */
      clusterIP?: string;
      /**
       * A list of IP addresses for which nodes in the cluster
       * will also accept traffic for this service.
       *
       * @remarks
       * These IPs are not managed by
       * Kubernetes. The user is responsible for ensuring that traffic arrives at
       * a node with this IP. A common example is external load balancers that are
       * not part of the Kubernetes system.
       */
      externalIPs?: string[];
      /**
       * The external reference that kubedns or equivalent
       * will return as a CNAME record for this service.
       *
       * @remarks
       * No proxying will be involved. Must be a
       * {@link https://tools.ietf.org/html/rfc1123 | valid RFC-1123 hostname}
       * and requires Type to be ExternalName.
       */
      externalName?: string;
      /**
       * Denotes if this Service desires to route
       * external traffic to node-local or cluster-wide endpoints.
       *
       * @remarks
       * "Local" preserves the client source IP and avoids a second hop for
       * LoadBalancer and Nodeport type services, but risks potentially
       * imbalanced traffic spreading. "Cluster" obscures the client source IP
       * and may cause a second hop to another node, but should have good overall
       * load-spreading.
       */
      externalTrafficPolicy?: string;
      /**
       * Specifies the healthcheck nodePort for the service.
       *
       * @remarks
       * If not specified, HealthCheckNodePort is created by the service
       * api backend with the allocated nodePort. Will use user-specified nodePort
       * value if specified by the client. Only affects when Type is set to
       * LoadBalancer and ExternalTrafficPolicy is set to Local.
       */
      healthCheckNodePort?: number;
      /**
       * Only applies to Service Type: LoadBalancer. LoadBalancer will
       * get created with the IP specified in this field.
       *
       * @remarks
       * This feature depends on
       * whether the underlying cloud provider supports specifying the loadBalancerIP
       * when a load balancer is created. This field will be ignored if the
       * cloud provider does not support the feature.
       */
      loadBalancerIP?: string;
      /**
       * If specified and supported by the platform, this will
       * restrict traffic through the cloud provider load balancer
       * to the specified client IPs.
       *
       * @remarks
       * This field will be ignored if the cloud provider
       * does not support the feature.
       *
       * For more information, see the
       * {@link https://v1-17.docs.kubernetes.io/docs/tasks/access-application-cluster/configure-cloud-provider-firewall/ |
       * Kubernetes documentation}.
       */
      loadBalancerSourceRanges?: string[];
      /**
       * The list of ports that are exposed by this service.
       *
       * @remarks
       * For more information, see the
       * {@link https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies |
       * Kubernetes documentation}.
       */
      ports?: ServicePort[];
      /**
       * When set to true, indicates that
       * DNS implementations must publish the notReadyAddresses of subsets for the
       * Endpoints associated with the Service.
       *
       * @remarks
       * The default value is false. The
       * primary use case for setting this field is to use a StatefulSet's Headless
       * Service to propagate SRV records for its Pods without respect to their
       * readiness for purpose of peer discovery.
       */
      publishNotReadyAddresses?: boolean;
      /**
       * Route service traffic to pods with label keys and values
       * matching this selector.
       *
       * @remarks
       * If empty or not present, the service is assumed to
       * have an external process managing its endpoints, which Kubernetes will not
       * modify. Only applies to types ClusterIP, NodePort, and LoadBalancer.
       * Ignored if type is ExternalName.
       *
       * For more information, see the
       * {@link https://kubernetes.io/docs/concepts/services-networking/service/ |
       * Kubernetes documentation}.
       */
      selector?: EndpointSelector | object;
      /**
       * Used to maintain session affinity.
       *
       * @remarks
       * Possible values are:
       *
       * - `"ClientIP"`: Enables client IP based session affinity.
       *
       * - `"None"`: Disables session affinity.
       *
       * For more information, see the
       * {@link https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies |
       * Kubernetes documentation}.
       * @defaultValue `"None"`
       */
      sessionAffinity?: string;
      /**
       * Determines how the Service is exposed.
       *
       * @remarks
       * Valid options are:
       *
       * - `"ExternalName"`: maps to the specified externalName.
       *
       * - `"ClusterIP"`: allocates a cluster-internal IP address for load
       * balancing to endpoints. Endpoints are determined by the selector or if
       * that is not specified, by manual construction of an Endpoints object. If
       * clusterIP is "None", no virtual IP is allocated and the endpoints are
       * published as a set of endpoints rather than a stable IP.
       *
       * - `"NodePort"`: Builds on ClusterIP and allocates a port on every node
       * which routes to the clusterIP.
       *
       * - `"LoadBalancer"`: Builds on NodePort and creates an external load
       * balancer (if supported in the current cloud) which routes to the
       * clusterIP.
       *
       * For more information, see the
       * {@link https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services---service-types |
       * Kubernetes documentation}.
       * @defaultValue `"ClusterIP"`
       */
      type?: string;
  }/** @public */
  export declare interface ServicePort {
      /**
       * The name of this port within the service.
       *
       * @remarks
       * This must be a DNS_LABEL.
       * All ports within a ServiceSpec must have unique names.This maps to the
       * Name' field in EndpointPort objects. Optional if only one ServicePort is
       * defined on this service.
       */
      name?: string;
      /**
       * The port on each node on which this service is exposed when
       * type=NodePort or LoadBalancer.
       *
       * @remarks
       * Usually assigned by the system. If
       * specified, it will be allocated to the service if unused or else creation
       * of the service will fail.
       *
       * For more information, see the
       * {@link https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport |
       * Kubernetes documentation}.
       * @defaultValue Automatically allocates a port if the ServiceType of this
       * Service requires one.
       */
      nodePort?: number;
      /** The port that will be exposed by this service. */
      port?: number;
      /** The IP protocol for this port.Supports "TCP" and "UDP".Default is TCP. */
      protocol?: string;
      /**
       * Number or name of the port to access on the pods targeted by the
       * service.
       *
       * @remarks
       * Number must be in the range 1 to 65535. Name must be an
       * IANA_SVC_NAME. If this is a string, it will be looked up as a named port
       * in the target Pod's container ports. If this is not specified, the value
       * of the 'port' field is used (an identity map). This field is ignored for
       * services with clusterIP = None, and should be omitted or set equal to the
       * 'port' field.
       *
       * For more information, see the
       * {@link https://kubernetes.io/docs/concepts/services-networking/service/#defining-a-service |
       * Kubernetes documentation}.
       */
      targetPort?: number | string;
  }/** @internal */
  const serviceResourceInfo: {
      kind: string;
      deployedWhen: typeof deployedWhen;
      statusQuery: (props: ResourcePropsWithConfig, observe: ObserveForStatus, buildData: BuildData) => Promise<any>;
  };/**
   * k8s ServiceAccount resource
   *
   * @param propsIn - props for ServiceAccount as specifed in {@link k8s.ServiceAccountProps}
   *
   * @public
   */
  export declare function ServiceAccount(propsIn: SFCDeclProps<ServiceAccountProps, typeof defaultProps>): Adapt.JSX.Element;/** @public */
  export declare function isServiceAccountProps(p: ResourceProps): p is ResourceProps & ResourceServiceAccount;/** @internal */
  const serviceAccountResourceInfo: {
      kind: string;
      deployedWhen: () => true;
      statusQuery: (props: ResourcePropsWithConfig, observe: ObserveForStatus, buildData: BuildData) => Promise<any>;
      makeManifest: (manifest: Manifest, elem: AdaptElement<ResourceProps>, _deployID: string) => {
          automountServiceAccountToken: boolean | undefined;
          imagePullSecrets: {
              name: string;
          }[] | undefined;
          secrets: ObjectReference[] | undefined;
          apiVersion: string;
          kind: string;
          metadata: import("./manifest_support").MetadataInRequest;
          spec?: import("./DaemonSet").DaemonSetSpec | import("./common").CRSpec | import("./Pod").PodSpec | import("./Service").ServiceSpec | import("./Deployment").DeploymentSpec | undefined;
      };
  };/**
   * Props for {@link k8s.ServiceDeployment}
   *
   * @public
   */
  export declare interface ServiceDeploymentProps<T extends AllowableComponentProps = DeploymentProps> extends ServiceProps {
      config: ClusterInfo;
      serviceProps?: Partial<ServiceProps>;
      component: ComponentType<T>;
      componentProps: T;
      podProps?: Partial<PodProps>;
      containerProps?: Partial<OmitT<K8sContainerProps, "image">>;
  }/**
   * A component for mapping a group of abstract {@link Container}s and
   * {@link NetworkService}s to Kubernetes {@link k8s.Pod}s and
   * {@link k8s.K8sContainer}s.
   *
   * @remarks
   * This component is intended to be used to replace {@link Container} and
   * {@link NetworkService} components that are grouped together, as the
   * only children of a common parent in a pattern that looks like this:
   *
   * ```tsx
   * <Service>
   *   <Container ... />
   *   <Container ... />
   *   <NetworkService ... />
   * </Service>
   * ```
   *
   * `ServiceDeployment` would map those abstract components into corresponding
   * k8s components like this:
   * ```tsx
   * <Group>
   *   <docker.RegistryDockerImage ... /> //If props.config specifies a registry
   *   <k8s.Deployment ... >
   *     <Pod isTemplate>
   *       <k8s.K8sContainer ... />
   *     </Pod>
   *   </k8s.Deployment>
   *   <docker.RegistryDockerImage ... /> //If props.config specifies a registry
   *   <k8s.Deployment ... >
   *     <Pod isTemplate>
   *       <k8s.K8sContainer ... />
   *     </Pod>
   *   </k8s.Pod>
   *   <k8s.Service ... />
   * </Group>
   * ```
   * An example style rule to do this is:
   * ```tsx
   * {Adapt.rule((matchedProps) => {
   *     const { handle, ...remainingProps } = matchedProps;
   *     return <ServiceDeployment config={kubeconfig} {...remainingProps} />;
   * })}
   * ```
   * `ServiceDeployment` also requires the `config` prop which specifies
   * connection and authentication information for the Kubernetes cluster on
   * which these objects should be created.
   *
   * @public
   */
  export declare class ServiceDeployment<T extends AllowableComponentProps> extends DeferredComponent<ServiceDeploymentProps<T>> {
      static defaultProps: {
          component: typeof Deployment;
          componentProps: {
              replicas: number;
          };
      };
      build(helpers: BuildHelpers): Adapt.JSX.Element;
  }/** @public */
  export declare function computeNamespaceFromMetadata(metadata?: Metadata): string;/** @public */
  export declare function isLabelSelector(x: any): x is LabelSelector;/**
   * Kubernetes Kind
   *
   * @public
   */
  export declare type Kind = string;/** @public */
  export declare interface CRSpec {
      [key: string]: any;
  }/** @public */
  export declare type Spec = DaemonSetSpec | DeploymentSpec | PodSpec | ServiceSpec | CRSpec;/** @public */
  export declare interface Metadata {
      namespace?: string;
      labels?: {
          [key: string]: string;
      };
      annotations?: {
          [key: string]: string;
      };
  }/** @public */
  export declare type ResourceProps = {
      key: string;
  } & (ResourceClusterRole | ResourceClusterRoleBinding | ResourceDaemonSet | ResourcePod | ResourceService | ResourceServiceAccount | ResourceConfigMap | ResourceSecret | ResourceCR);/** @public */
  export declare type ResourcePropsWithConfig = ResourceProps & {
      config: ClusterInfo;
  };/** @public */
  export declare interface ResourceInfo {
      kind: Kind;
      statusQuery?: (props: ResourceProps, observe: ObserveForStatus, buildData: BuildData) => unknown | Promise<unknown>;
      specsEqual(actual: Spec, element: Spec): boolean;
  }/**
   * Holds the information needed to connect, authenticate, and run code in a kuberenetes cluster
   *
   * @public
   */
  export declare interface ClusterInfo {
      /** Javascript object formed by parsing a valid kubeconfig file */
      kubeconfig: Kubeconfig;
      /**
       * Registry to which Docker images used by the cluster in `kubeconfig` should be pushed and pulled
       *
       * @remarks
       * If `registryPrefix` is a string, it is assumed that the cluster can pull from the same string
       * that outsiders can push to.
       *
       * If `registryPrefix` is of the form `{ external: string, internal: string }` then the `external`
       * string will be used to push images, and the `internal` string will be used to pull images.
       *
       * Note(manishv)
       * This is a bit of a hack to allow one hostname or IP address to push images from outside
       * a particular environment (say k8s) and a different URL for that environment to pull
       * images.
       *
       * A good example of this is a k3s-dind (k3s docker-in-docker) instance of kubernetes where
       * a private registry is running on a docker network attached to the k3s-dind instance, but where we
       * want to push {@link docker.LocalDockerImage} built images to that registry.  Since
       * {@link docker.LocalDockerImage | LocalDockerImage} is outside the k3s-dind environment, it must
       * use a host accessible network to push to the registry.  However, since the k3s-dind instance sees
       * the registry from within Docker, it must use a different address to pull the images for use.
       *
       * Once network scopes are fully supported, this interface will change to whatever is appropriate.  It
       * is best if you can arrange to have the same URL or registry string work for all access regardless
       * of which network the registry, Adapt host, and ultimate container running environment uses.
       *
       */
      registryPrefix?: string | DockerSplitRegistryInfo;
  }/** @public */
  export declare interface ResourceBase {
      /**
       * config to connect to the k8s cluster
       *
       * required if isTemplate is false
       */
      config?: ClusterInfo;
      /**
       * Specifies whether this resource is just a template for use in a controller
       */
      isTemplate?: boolean;
      apiVersion?: string;
      kind: Kind;
      metadata?: Metadata;
  }/**
   * @public
   */
  export declare interface PolicyRule {
      /**
       * APIGroups is the name of the APIGroup that contains the resources.
       *
       * If multiple API groups are specified, any action requested against one
       * of the enumerated resources in any API group will be allowed.
       */
      apiGroups?: string[];
      /**
       * NonResourceURLs is a set of partial urls that a user should have access to.
       *
       * *s are allowed, but only as the full, final step in the path.
       * Since non-resource URLs are not namespaced, this field is only applicable
       * for ClusterRoles referenced from a ClusterRoleBinding.
       * Rules can either apply to API resources (such as "pods" or "secrets") or
       * non-resource URL paths (such as "/api"), but not both.
       */
      nonResourceURLs?: string[];
      /**
       * ResourceNames is an optional white list of names that the rule applies to.
       *
       * An empty set means that everything is allowed.
       */
      resourceNames?: string[];
      /**
       * Resources is a list of resources this rule applies to.
       *
       * ResourceAll represents all resources.
       */
      resources: string[];
      /**
       * Verbs is a list of Verbs that apply to ALL the ResourceKinds and
       * AttributeRestrictions contained in this rule.
       *
       * VerbAll represents all kinds.
       */
      verbs: string[];
  }/**
   * AggregationRule for {@link k8s.ClusterRole}
   *
   * @public
   */
  export declare interface AggregationRule {
      /**
       * ClusterRoleSelectors holds a list of selectors which will be used to
       * find ClusterRoles and create the rules.
       *
       * If any of the selectors match, then the ClusterRole's permissions will be added
       */
      clusterRoleSelector: LabelSelector;
  }/** @public */
  export declare interface ResourceClusterRole extends ResourceBase {
      apiVersion: "rbac.authorization.k8s.io/v1";
      kind: "ClusterRole";
      aggregationRule?: AggregationRule;
      rules?: PolicyRule[];
  }/**
   * RoleRef for {@link k8s.ResourceClusterRoleBinding}
   *
   * @public
   */
  export declare interface RoleRef {
      /** apiGroup is the group for the resource being referenced */
      apiGroup: string;
      /** kind is the type of resource being referenced */
      kind: string;
      /** Name is the name of resource being referenced */
      name: string;
  }/**
   * Subject for {@link k8s.ResourceClusterRoleBinding}
   *
   * @public
   */
  export declare interface Subject {
      /** apiGroup is the group for the object being referenced */
      apiGroup: string;
      /** kind is the type of object being referenced */
      kind: string;
      /**
       * Name of the object being referenced.
       */
      name: string;
      /**
       * Namespace of the referenced object.
       *
       * If the object kind is non-namespace, such as "User" or "Group", and this value
       * is not empty the Authorizer should report an error.
       */
      namespace?: string;
  }/** @public */
  export declare interface ResourceClusterRoleBinding extends ResourceBase {
      apiVersion: "rbac.authorization.k8s.io/v1";
      kind: "ClusterRoleBinding";
      roleRef: RoleRef;
      subjects: Subject[];
  }/** @public */
  export declare interface ResourceDaemonSet extends ResourceBase {
      apiVersion: "apps/v1";
      kind: "DaemonSet";
      spec: DaemonSetSpec;
  }/** @public */
  export declare interface ResourcePod extends ResourceBase {
      kind: "Pod";
      spec: PodSpec;
  }/** @public */
  export declare interface ResourceService extends ResourceBase {
      kind: "Service";
      spec: ServiceSpec;
  }/** @public */
  export declare interface ResourceServiceAccount extends ResourceBase {
      kind: "ServiceAccount";
      automountServiceAccountToken?: boolean;
      imagePullSecrets?: {
          name: string;
      }[];
      secrets?: ObjectReference[];
  }/** @public */
  export declare interface ResourceConfigMap extends ResourceBase {
      kind: "ConfigMap";
      binaryData?: {
          [key: string]: string;
      };
      data?: {
          [key: string]: string;
      };
      /** @beta */
      immutable?: boolean;
  }/** @public */
  export declare interface ResourceSecret extends ResourceBase {
      kind: "Secret";
      data?: {
          [key: string]: string;
      };
      stringData?: {
          [key: string]: string;
      };
      type?: string;
  }/** @public */
  export declare interface ResourceCR extends ResourceBase {
      kind: string;
      spec: CRSpec;
  }/** @public */
  export declare interface Kubeconfig {
      apiVersion?: "v1";
      kind: "Config";
      "current-context": string;
      contexts: {
          name: string;
          context: {
              cluster: string;
              user: string;
          };
      }[];
      clusters: {
          name: string;
          cluster: {
              "certificate-authority-data": string;
              server: string;
          };
      }[];
      preferences?: unknown;
      users: {
          name: string;
          user: {
              "client-certificate-data"?: string;
              "client-key-data"?: string;
              "username"?: string;
              "password"?: string;
          };
      }[];
  }/** @public */
  export declare interface LabelSelector {
      /**
       * matchExpressions is a list of label selector requirements. The requirements are ANDed.
       */
      matchExpressions?: LabelSelectorRequirement[];
      /**
       * matchLabels is a map of `{key,value}`pairs. A single `{key,value}` in the matchLabels map
       * is equivalent to an element of matchExpressions, whose key field is "key", the operator
       * is "In", and the values array contains only "value". The requirements are ANDed.
       */
      matchLabels?: {
          [key: string]: string;
      };
  }/** @public */
  export declare interface LocalObjectReference {
      /**
       * Name of the referent.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names}
       */
      name: string;
  }/**
   * PodTemplateSpec from k8s API
   *
   * @public
   */
  export declare interface PodTemplateSpec {
      /**
       * Standard object's metadata.
       * More Info: {@link https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata}
       */
      metadata: Metadata;
      /**
       * Specification of the desired behavior of the pod.
       * More Info: {@link https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status}
       */
      spec: PodSpec;
  }/**
   * ObjectReference from k8s API
   *
   * @public
   */
  export declare interface ObjectReference {
      /**
       * If referring to a piece of an object instead of an entire object,
       * this string should contain a valid JSON/Go field access statement,
       * such as desiredState.manifest.containers[2].
       *
       * For example, if the object reference is to a container within a pod,
       * this would take on a value like: "spec.containers\{name\}" (where "name"
       * refers to the name of the container that triggered the event) or if no
       * container name is specified "spec.containers[2]"
       * (container with index 2 in this pod).
       * This syntax is chosen only to have some well-defined way of referencing a
       * part of an object.
       */
      fieldPath: string;
      /**
       * Name of the referent.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names}
       *
       */
      name: string;
      /**
       * Namespace of the referent.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/}
       */
      namespace: string;
      /**
       * Specific resourceVersion to which this reference is made, if any.
       *
       * More info: {@link https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency}
       */
      resourceVersion: string;
      /**
       * UID of the referent.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids}
       */
      uid: string;
  }/**
   * Make a {@link k8s.ClusterInfo} object suitable for use with k8s resources
   *
   * @remarks
   *
   * This function will take a set of options and generate a {@link k8s.ClusterInfo}
   * object that contains the kubeconfig, registryPrefix for private images, and any other
   * relevant information for the cluster
   *
   * See {@link k8s.MakeClusterInfoOptions} for information on how the information
   * is computed.
   *
   * @returns A {@link k8s.ClusterInfo} object.
   *
   * @public
   */
  export declare function makeClusterInfo(options: MakeClusterInfoOptions): Promise<ClusterInfo>;/** @internal */
  export declare function isResourcePodTemplate(x: any): x is AdaptElement<ResourcePod>;/**
   * Hook that allows a prop to be either an array of handle to k8s resources and values
   *
   * @param initial - initial value of the prop, before the handles are be resolved
   * @param notReady - is a marker value to indicate that a handle's value isn't available yet
   * @param kinds - an array of legal k8s Kinds that a prop handle can point to
   * @param thisResourceName - the name of the resource using the hook, for error messages
   * @param propName - the name of the prop being resolved, again for error messages
   *
   * @returns A two element array, the first element is the current value, the second the update function
   *
   * This hook will start by returning the initial value and an update function that updates
   * the value the hook returns.  The update function takes 2 arguments - the prop value which
   * is an array with a mix of values and handles to be resolved, and a function that receives
   * the elements that any handles point to along with that elements props.  This function
   * can be passed by the caller of update to resolve handles as appropriate for the component.
   *
   * For example, {@link k8s.ClusterRoleBinding} uses this hook to resolve the subjects prop,
   * which is an array of other objects (typically {@link ServiceAccount}) that a particular
   * {@link k8s.ClusterRole} should point to.  When ClusterRoleBinding calls the update method,
   * it passes a function that will convert a {@link k8s.Resource} element of Kind `ServiceAccount`
   * to the underlying `Subject` object that kubernetes expects, namely
   * `{ apiGroup: "", kind: "ServiceAccount", name: resourceIdToName(elem, deployID), namespace: <element namespace> }`
   *
   * @example
   * ```
   * function MyResource({ serviceAccountNames }: { serviceAccountNames: (string | Handle)[]}) {
   *   const { deployID } = useBuildHelpers();
   *   const [ resolvedServiceAccountNames, updateSANs] = useResources({
   *      initial: [],
   *      notReady: null,
   *      kinds: ["ServiceAccount"],
   *      thisResourceName: "MyResources",
   *      propName: "serviceAccountNames",
   *   });
   *
   *   updateSANs(serviceAccountNames, (e, props) => {
   *      return {
   *        apiGroup: (e.metadata.apiVersion?.split("/")[0]) || "",
   *        name: resourceElementToName(e, deployID),
   *        namespace: props.metadata.namespace,
   *      }
   *   });
   *
   *   return null;
   * }
   * ```
   *
   * @beta
   */
  export declare function useResources<ValT, NotReadyT>({ initial, notReady, kinds, thisResourceName, propName, }: {
      initial: ValT[];
      notReady: NotReadyT;
      kinds: string[];
      thisResourceName: string;
      propName: string;
  }): [
      (ValT | NotReadyT)[],
      (props: (ValT | Handle)[], f: (e: AdaptMountedElement, props: ResourceProps) => Promise<ValT> | ValT) => void
  ];/**
   * Hook to allow conversion of a prop that could be a value or a handle
   *
   * This function behaves similarly to {@link k8s.useResources}, but works for
   * a prop that is either a Handle or a single value instead of an array of
   * Handles and values.
   *
   * See {@link k8s.useResources} for more detailed documentation.
   *
   * @beta
   */
  export declare function useResource<ValT, NotReadyT>(opts: {
      initial: ValT | NotReadyT;
      notReady: NotReadyT;
      kinds: string[];
      thisResourceName: string;
      propName: string;
  }): [
      ValT | NotReadyT,
      (prop: ValT | Handle, f: (e: AdaptMountedElement, props: ResourceProps) => Promise<ValT> | ValT) => void
  ];/**
   * Options for {@link k8s.makeClusterInfo}
   *
   * @public
   */
  export declare interface MakeClusterInfoOptions {
      /**
       * A Javascript Object representing a valid kubeconfig, or a YAML string, or a path to a kubeconfig file.
       *
       * @remarks
       * If this is a Javascript object, it will be treated like a parsed kubeconfig.  If this is a string,
       * {@link k8s.makeClusterInfo} will first attempt to parse it as JSON.  If that fails, it will attempt
       * to parse it as YAML.  If that fails it will treat the string as a path of configs (like with the `KUBECONFIG`
       * environment variable).
       *
       * If kubeconfig is missing {@link k8s.makeClusterInfo} will use the `KUBECONFIG` environment variable to build
       * a suitable config using `kubectl config view --flatten` and return that as the kubeconfig in the resulting
       * {@link k8s.ClusterInfo}
       */
      kubeconfig?: Kubeconfig | string;
      /**
       * URL to the docker registry that this cluster uses to pull private images.
       *
       * @remarks
       * This is identical to the `registryPrefix` field in {@link k8s.ClusterInfo}.  It will
       * be returned verbatim in the resulting {@link k8s.ClusterInfo} object.
       */
      registryPrefix?: string | DockerSplitRegistryInfo;
  }/**
   * k8s ClusterRole resource
   *
   * @param propsIn - props for ServiceAccount as specifed in {@link k8s.ClusterRoleProps}
   *
   * @public
   */
  export declare function ClusterRole(propsIn: SFCDeclProps<ClusterRoleProps, typeof defaultProps>): Adapt.JSX.Element;/** @public */
  export declare function isClusterRoleProps(props: ResourceProps): props is ResourceProps & ResourceClusterRole;/** @internal */
  const clusterRoleResourceInfo: {
      kind: string;
      deployedWhen: () => true;
      statusQuery: (props: ResourcePropsWithConfig, observe: ObserveForStatus, buildData: BuildData) => Promise<any>;
      makeManifest: (manifest: Manifest, elem: AdaptElement<ResourceProps>, _deployID: string) => {
          aggregationRule: AggregationRule | undefined;
          rules: PolicyRule[] | undefined;
          apiVersion: string;
          kind: string;
          metadata: import("./manifest_support").MetadataInRequest;
          spec?: import("./DaemonSet").DaemonSetSpec | import("./common").CRSpec | import("./Pod").PodSpec | import("./Service").ServiceSpec | import("./Deployment").DeploymentSpec | undefined;
      };
  };/**
   * k8s ClusterRoleBinding resource
   *
   * @param propsIn - props for ServiceAccount as specifed in {@link k8s.ClusterRoleBindingProps}
   *
   * @public
   */
  export declare function ClusterRoleBinding(propsIn: SFCDeclProps<ClusterRoleBindingProps, typeof defaultProps>): Adapt.JSX.Element | null;/** @internal */
  const clusterRoleBindingResourceInfo: {
      kind: string;
      deployedWhen: () => true;
      statusQuery: (props: ResourcePropsWithConfig, observe: ObserveForStatus, buildData: BuildData) => Promise<any>;
      makeManifest: (manifest: Manifest, elem: AdaptElement<ResourceProps>, _deployID: string) => {
          roleRef: RoleRef;
          subjects: Subject[];
          apiVersion: string;
          kind: string;
          metadata: import("./manifest_support").MetadataInRequest;
          spec?: import("./DaemonSet").DaemonSetSpec | import("./common").CRSpec | import("./Pod").PodSpec | import("./Service").ServiceSpec | import("./Deployment").DeploymentSpec | undefined;
      };
  };/**
   * k8s ConfigMap resource
   *
   * @param propsIn - props for ConfigMap as specifed in {@link k8s.ConfigMapProps}
   *
   * @public
   */
  export declare function ConfigMap(propsIn: SFCDeclProps<ConfigMapProps, typeof defaultProps>): Adapt.JSX.Element;/** @internal */
  const configMapResourceInfo: {
      kind: string;
      deployedWhen: () => true;
      statusQuery: (props: ResourcePropsWithConfig, observe: ObserveForStatus, buildData: BuildData) => Promise<any>;
      makeManifest: (manifest: Manifest, elem: AdaptElement<ResourceProps>, _deployID: string) => {
          data: {
              [key: string]: string;
          } | undefined;
          binaryData: {
              [key: string]: string;
          } | undefined;
          immutable: boolean | undefined;
          apiVersion: string;
          kind: string;
          metadata: import("./manifest_support").MetadataInRequest;
          spec?: import("./DaemonSet").DaemonSetSpec | import("./common").CRSpec | import("./Pod").PodSpec | import("./Service").ServiceSpec | import("./Deployment").DeploymentSpec | undefined;
      };
  };/**
   * Low level utility function to translate from the abstract {@link Container}
   * component props ({@link ContainerProps}) to {@link k8s.K8sContainerProps}
   * to be used in a {@link k8s.K8sContainer}.
   * @remarks
   * Note: The `image` property in the passed in {@link ContainerProps} must
   * be a `string`, not a `Handle`.
   * In most cases, it is preferable to use the {@link k8s.Container} component
   * instead, which is designed specifically to deal with this issue.
   *
   * @param abstractProps - The abstract {@link ContainerProps} to translate from.
   * @param k8sProps - Props that are specific to the {@link k8s.K8sContainer}
   *     component that should be merged into the resulting returned
   *     {@link k8s.K8sContainerProps} object.
   * @public
   */
  export declare function k8sContainerProps(abstractProps: FromContainerProps, k8sProps?: Partial<K8sContainerProps>): K8sContainerProps;/**
   * Tests whether an element is a {@link k8s.K8sContainer} element
   * @param x - element to test
   * @returns `true` if element is a {@link k8s.K8sContainer}, `false` otherwise
   *
   * @remarks
   * Acts as a TypeScript type assertion that will assert that `x` is `AdaptElement<K8sContainerProps>`
   *
   * @public
   */
  export declare function isK8sContainerElement(x: AdaptElement): x is AdaptElement<K8sContainerProps>;/**
   * Component that implements the abstract {@link Container} interface and
   * translates to a Kubernetes-specific {@link k8s.K8sContainer}.
   * @public
   */
  export declare function Container(props: ContainerProps): Adapt.JSX.Element | null;/** @public */
  export declare interface VolumeMount {
      /**
       * Path within the container at which the volume should be mounted.
       *
       * Must not contain ':'.
       */
      mountPath: string;
      /**
       * mountPropagation determines how mounts are propagated from the host to container and the other way around.
       *
       * When not set, MountPropagationNone is used. This field is beta in 1.10.
       *
       * @defaultValue MountPropagationNone
       */
      mountPropagation?: string;
      /** This must match the Name of a Volume. */
      name: string;
      /**
       * Mounted read-only if true, read-write otherwise (false or unspecified).
       *
       * @defaultValue false
       */
      readOnly?: boolean;
      /**
       * Path within the volume from which the container's volume should be mounted.
       *
       * Defaults to "" (volume's root).
       *
       * @defaultValue ""
       */
      subPath?: string;
      /**
       * Expanded path within the volume from which the container's volume should be mounted.
       *
       * Behaves similarly to SubPath but environment variable references $(VAR_NAME)
       * are expanded using the container's environment.
       *
       * Defaults to "" (volume's root).
       *
       * SubPathExpr and SubPath are mutually exclusive.
       *
       * @defaultValue ""
       */
      subPathExpr?: string;
  }/** @public */
  export declare interface ConfigMapEnvSource {
      /**
       * Name of the referent.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names}
       */
      name?: string;
      /**
       * Specify whether the ConfigMap must be defined
       */
      optional?: boolean;
  }/** @public */
  export declare interface SecretEnvSource {
      /**
       * Name of the referent.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names}
       */
      name?: string;
      /**
       * Specify whether the Secret must be defined
       */
      optional?: boolean;
  }/** @public */
  export declare interface EnvFromSource {
      /** The ConfigMap to select from */
      configMapRef?: ConfigMapEnvSource;
      /** An optional identifier to prepend to each key in the ConfigMap. Must be a C_IDENTIFIER. */
      prefix?: string;
      /** SecretEnvSource	The Secret to select from */
      secretRef?: SecretEnvSource;
  }/** @public */
  export declare interface ExecAction {
      /**
       * Command is the command line to execute inside the container.
       *
       * The working directory for the command is root ('/') in the container's filesystem.
       * The command is simply exec'd, it is not run inside a shell,
       * so traditional shell instructions ('|', etc) won't work.
       * To use a shell, you need to explicitly call out to that shell.
       *
       * Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
       */
      command: string[];
  }/** @public */
  export declare interface HTTPGetAction {
      /**
       * Host name to connect to, defaults to the pod IP.
       *
       * You probably want to set "Host" in httpHeaders instead.
       */
      host?: string;
      /** Custom headers to set in the request. HTTP allows repeated headers. */
      httpHeaders?: {
          name: string;
          value: string;
      }[];
      /** Path to access on the HTTP server. */
      path: string;
      /**
       * Name or number of the port to access on the container.
       *
       * Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
       */
      port: number | string;
      /**
       * Scheme to use for connecting to the host.
       *
       * @defaultValue HTTP.
       */
      scheme?: string;
  }/** @public */
  export declare interface TCPSocketAction {
      /** Host name to connect to, defaults to the pod IP. */
      host?: string;
      /**
       * Number or name of the port to access on the container.
       *
       * Number must be in the range 1 to 65535.
       * Name must be an IANA_SVC_NAME.
       */
      port: string | number;
  }/** @public */
  export declare interface Probe {
      /**
       * Exec specifies the action to take.
       *
       * Only one of exec, httpGet, or tcpSocket should be specified
       */
      exec?: ExecAction;
      /**
       * Minimum consecutive failures for the probe to be considered failed after having succeeded.
       *
       * Defaults to 3. Minimum value is 1.
       *
       * @defaultValue 3
       */
      failureThreshold?: number;
      /** Specifies the http request to perform. */
      httpGet?: HTTPGetAction;
      /**
       *  Seconds after the container has started before liveness probes are initiated.
       *  More info: {@link https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes}
       */
      initialDelaySeconds?: number;
      /** How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. */
      periodSeconds?: number;
      /**
       * Minimum consecutive successes for the probe to be considered successful after having failed.
       *
       * Must be 1 for liveness and startup. Minimum value is 1.
       *
       * @defaultValue 1
       */
      successThreshold?: number;
      /**
       * Specifies an action involving a TCP port.
       *
       * TCP hooks not yet supported
       */
      tcpSocket?: TCPSocketAction;
      /**
       * Number of seconds after which the probe times out.
       *
       * Defaults to 1 second. Minimum value is 1.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes}
       *
       * @defaultValue 1
       */
      timeoutSeconds?: number;
  }/** @public */
  export declare interface ResourceRequirements {
      /**
       * Limits describes the maximum amount of compute resources allowed.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/}
       */
      limits?: {
          [key: string]: any;
      };
      /**
       * Describes the minimum amount of compute resources required.
       *
       * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
       * otherwise to an implementation-defined value.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/}
       */
      requests?: {
          [key: string]: any;
      };
  }/** @public */
  export declare type Handler = {
      exec: ExecAction;
  } | {
      httpGet: HTTPGetAction;
  } | {
      tcpSocket: TCPSocketAction;
  };/** @public */
  export declare interface Lifecycle {
      /**
       * PostStart is called immediately after a container is created.
       *
       * If the handler fails, the container is terminated and restarted according to its restart policy.
       * Other management of the container blocks until the hook completes.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks}
       */
      postStart: Handler;
      /**
       * Called immediately before a container is terminated due to an API request or management event such as liveness/startup probe failure, preemption, resource contention, etc.
       *
       * The handler is not called if the container crashes or exits.
       * The reason for termination is passed to the handler.
       * The Pod's termination grace period countdown begins before the PreStop hooked is executed.
       * Regardless of the outcome of the handler, the container will eventually terminate within the Pod's termination grace period.
       * Other management of the container blocks until the hook completes or until the termination grace period is reached.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks}
       */
      preStop: Handler;
  }/** @public */
  export declare interface VolumeDevice {
      /** The path inside of the container that the device will be mapped to. */
      devicePath: string;
      /** name must match the name of a persistentVolumeClaim in the pod */
      name: string;
  }/**
   * Resource spec for a Kubernetes container.
   * See the Kubernetes
   * {@link https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#container-v1-core | API docs }
   * for more details.
   * @public
   */
  export declare interface ContainerSpec {
      /**
       * Arguments to the entrypoint.
       *
       * The docker image's CMD is used if this is not provided.
       * Variable references $(VAR_NAME) are expanded using the container's environment.
       * If a variable cannot be resolved, the reference in the input string will be unchanged.
       * The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME).
       * Escaped references will never be expanded, regardless of whether the variable exists or not.
       * Cannot be updated.
       * More info: {@link https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell}
       */
      args?: string[];
      /**
       * Entrypoint array.
       *
       * Not executed within a shell.
       * The docker image's ENTRYPOINT is used if this is not provided.
       * Variable references $(VAR_NAME) are expanded using the container's environment.
       * If a variable cannot be resolved, the reference in the input string will be unchanged.
       * The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME).
       * Escaped references will never be expanded, regardless of whether the variable exists or not.
       * Cannot be updated.
       * More info: {@link https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell}
       */
      command?: string[];
      /**
       * List of environment variables to set in the container. Cannot be updated.
       */
      env?: EnvVar[];
      /**
       * List of sources to populate environment variables in the container.
       *
       * The keys defined within a source must be a C_IDENTIFIER.
       * All invalid keys will be reported as an event when the container is starting.
       * When a key exists in multiple sources, the value associated with the last source will take precedence.
       * Values defined by an Env with a duplicate key will take precedence. Cannot be updated.
       */
      envFrom?: EnvFromSource[];
      /**
       * Docker image name.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/containers/images}
       *
       * This field is optional to allow higher level config management to default or override container
       * images in workload controllers like Deployments and StatefulSets.
       */
      image?: string;
      /**
       * Image pull policy.
       *
       * One of Always, Never, IfNotPresent.
       * Defaults to Always if :latest tag is specified,
       * or IfNotPresent otherwise.
       * Cannot be updated.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/containers/images#updating-images}
       */
      imagePullPolicy?: "Always" | "Never" | "IfNotPresent";
      /**
       * List of sources to populate environment variables in the container.
       *
       * The keys defined within a source must be a C_IDENTIFIER.
       * All invalid keys will be reported as an event when the container is starting.
       * When a key exists in multiple sources, the value associated with the last source will take precedence.
       * Values defined by an Env with a duplicate key will take precedence. Cannot be updated.
       */
      lifecycle?: Lifecycle;
      /**
       * Periodic probe of container liveness.
       *
       * Container will be restarted if the probe fails.
       * Cannot be updated.
       * More info: {@link https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes}
       */
      livenessProbe?: Probe;
      /**
       * Name of the container specified as a DNS_LABEL.
       *
       * Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated.
       */
      name: string;
      /**
       * List of ports to expose from the container.
       *
       * Exposing a port here gives the system additional information about the network connections a container uses,
       * but is primarily informational.
       * Not specifying a port here DOES NOT prevent that port from being exposed.
       * Any port which is listening on the default "0.0.0.0" address inside a container will be accessible from
       * the network.
       * Cannot be updated.
       */
      ports?: ContainerPort[];
      /**
       * Periodic probe of container service readiness.
       *
       * Container will be removed from service endpoints if the probe fails.
       * Cannot be updated.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes}
       */
      readinessProbe?: Probe;
      /**
       * Compute Resources required by this container.
       *
       * Cannot be updated.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/}
       */
      resources?: ResourceRequirements;
      /**
       * Security options the pod should run with.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/policy/security-context/}
       * More info: {@link https://kubernetes.io/docs/tasks/configure-pod-container/security-context/}
       */
      securityContext?: PodSecurityContext;
      /**
       * Indicates that the Pod has successfully initialized.
       *
       * If specified, no other probes are executed until this completes successfully.
       * If this probe fails, the Pod will be restarted, just as if the livenessProbe failed.
       * This can be used to provide different probe parameters at the beginning of a Pod's lifecycle,
       * when it might take a long time to load data or warm a cache, than during steady-state operation.
       *
       * This cannot be updated.
       * This is a beta feature enabled by the StartupProbe feature flag.
       * More info: {@link https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes}
       */
      startupProbe?: Probe;
      /**
       * Whether this container should allocate a buffer for stdin in the container runtime.
       *
       * If this is not set, reads from stdin in the container will always result in EOF. Default is false.
       */
      stdin?: boolean;
      /**
       * Whether the container runtime should close the stdin channel after it has been opened by a single attach.
       *
       * When stdin is true the stdin stream will remain open across multiple attach sessions.
       * If stdinOnce is set to true, stdin is opened on container start,
       * is empty until the first client attaches to stdin,
       * and then remains open and accepts data until the client disconnects,
       * at which time stdin is closed and remains closed until the container is restarted.
       * If this flag is false, a container processes that reads from stdin will never receive an EOF. Default is false
       */
      stdinOnce?: boolean;
      /**
       * Path at which the file to which the container's termination message will be written is mounted into the container's filesystem.
       *
       * Message written is intended to be brief final status, such as an assertion failure message.
       * Will be truncated by the node if greater than 4096 bytes.
       * The total message length across all containers will be limited to 12kb.
       * Defaults to /dev/termination-log. Cannot be updated.
       */
      terminationMessagePath?: string;
      /**
       * Indicate how the termination message should be populated.
       *
       * File will use the contents of terminationMessagePath to populate the container status
       * message on both success and failure. FallbackToLogsOnError will use the last chunk of
       * container log output if the termination message file is empty and the container exited
       * with an error.
       * The log output is limited to 2048 bytes or 80 lines, whichever is smaller.
       * Defaults to File.
       * Cannot be updated.
       *
       * @defaultValue File
       */
      terminationMessagePolicy?: "File" | "FallbackToLogsOnError";
      /**
       * Whether this container should allocate a TTY for itself, also requires 'stdin' to be true.
       *
       * @defaultValue false
       */
      tty?: boolean;
      /**
       * volumeDevices is the list of block devices to be used by the container.
       */
      volumeDevices?: VolumeDevice[];
      /** volumeDevices is the list of block devices to be used by the container. */
      volumeMounts?: VolumeMount[];
      /**
       * Container's working directory.
       *
       * If not specified, the container runtime's default will be used,
       * which might be configured in the container image.
       * Cannot be updated.
       */
      workingDir?: string;
  }/**
   * Props for the Kubernetes-specific {@link k8s.K8sContainer} component.
   * @public
   */
  export declare interface K8sContainerProps extends ContainerSpec {
  }/** @public */
  export declare interface ContainerPort {
      /**
       * Number of port to expose on the pod's IP address.
       * @remarks
       * This must be a valid integer port number, `0 < x < 65536`.
       */
      containerPort: number;
      /** What host IP to bind the external port to. */
      hostIP?: string;
      /**
       * Number of port to expose on the host.
       * @remarks
       * If specified, this must be a valid integer port number,
       * `0 < x < 65536`. If HostNetwork is specified,
       * this must match ContainerPort. Most containers do not need this.
       */
      hostPort?: number;
      /**
       * A unique-within-pod name for the container
       * @remarks
       * If specified, this must be an IANA_SVC_NAME and unique within the pod.
       * Each named port in a pod must have a unique name. Name for the port
       * that can be referred to by services.
       */
      name?: string;
      /** Protocol for port. Must be UDP or TCP. Defaults to "TCP". */
      protocol?: string;
  }/** @public */
  export declare type EnvVar = EnvVarSimple | EnvVarFrom;/** @public */
  export declare interface EnvVarSimple {
      /** Name of the environment variable. Must be a C_IDENTIFIER. */
      name: string;
      /**
       * Variable references $(VAR_NAME) are expanded using the previous defined
       * environment variables in the container and any service environment
       * variables. If a variable cannot be resolved, the reference in the input
       * string will be unchanged. The $(VAR_NAME) syntax can be escaped with a
       * double $$, ie: $$(VAR_NAME). Escaped references will never be expanded,
       * regardless of whether the variable exists or not. Defaults to "".
       */
      value: string;
  }/** @public */
  export declare interface EnvVarFrom {
      /** Source for the environment variable's value. Cannot be used if value is not empty. */
      valueFrom?: any;
  }/**
   * See {@link k8s.k8sContainerProps}.
   * @public
   */
  export declare type FromContainerProps = ReplaceT<ContainerProps, {
      image: string;
  }> & BuiltinProps;/**
   * Kubernetes-specific container.
   * @public
   */
  export declare class K8sContainer extends PrimitiveComponent<K8sContainerProps> {
      static defaultProps: {
          imagePullPolicy: string;
      };
      validate(): undefined;
  }/**
   * Props for {@link k8s.Container}.
   * @public
   */
  export declare interface ContainerProps extends SFCDeclProps<ContainerProps> {
      /**
       * Additional {@link k8s.K8sContainerProps}-specific props that should be
       * added to the instantiated {@link k8s.K8sContainer}.
       */
      k8sContainerProps?: Partial<K8sContainerProps>;
  }/**
   * Spec for {@link k8s.DaemonSet} for use in {@link k8s.Resource}
   *
   * @public
   */
  export declare type DaemonSetSpec = Exclude<DaemonSetProps, ResourceBase> & {
      template: PodTemplateSpec;
  };/**
   * Component for Kubernetes DaemonSet
   *
   * @public
   */
  export declare class DaemonSet extends DeferredComponent<DaemonSetProps> {
      static defaultProps: {
          metadata: {};
          minReadySeconds: number;
          revisionHistoryLimit: number;
          updateStrategy: {
              type: string;
              rollingUpdate: {
                  maxUnavailable: number;
              };
          };
      };
      constructor(props: DaemonSetProps);
      build(helpers: BuildHelpers): Adapt.JSX.Element;
      status(_observe: ObserveForStatus, buildData: BuildData): Promise<Adapt.Status | undefined>;
  }/** @internal */
  const daemonSetResourceInfo: {
      kind: string;
      deployedWhen: typeof deployedWhen;
      statusQuery: (props: ResourcePropsWithConfig, observe: ObserveForStatus, buildData: BuildData) => Promise<any>;
  };/** @public */
  export declare interface DeploymentUpdateStrategyRecreate {
      type: "Recreate";
  }/** @public */
  export declare interface RollingUpdateDeployment {
      /**
       * The maximum number of pods that can be scheduled above the desired number of pods.
       *
       * Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
       * This can not be 0 if MaxUnavailable is 0.
       * Absolute number is calculated from percentage by rounding up.
       * Defaults to 25%.
       *
       * @example
       * When this is set to 30%, the new ReplicaSet can be scaled up immediately when the rolling update starts,
       * such that the total number of old and new pods do not exceed 130% of desired pods. Once old pods have been
       * killed, new ReplicaSet can be scaled up further, ensuring that total number of pods running at any time
       * during the update is at most 130% of desired pods.
       */
      maxSurge?: number | string;
      /**
       * The maximum number of pods that can be unavailable during the update.
       *
       * Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
       * Absolute number is calculated from percentage by rounding down.
       * This can not be 0 if MaxSurge is 0. Defaults to 25%.
       *
       * @example
       * When this is set to 30%, the old ReplicaSet can be scaled down to 70% of desired pods
       * immediately when the rolling update starts. Once new pods are ready, old ReplicaSet
       * can be scaled down further, followed by scaling up the new ReplicaSet, ensuring that
       * the total number of pods available at all times during the update is at least 70% of
       * desired pods.
       */
      maxUnavailable?: number | string;
  }/**
   * Spec for {@link k8s.Deployment} for use in {@link k8s.Resource}
   *
   * @public
   */
  export declare type DeploymentSpec = Exclude<DeploymentProps, ResourceBase> & {
      template: PodTemplateSpec;
  };/**
   * Props for {@link k8s.Deployment}
   *
   * @public
   */
  export declare interface DeploymentProps extends WithChildren {
      /** Information about the k8s cluster (ip address, auth info, etc.) */
      config: ClusterInfo;
      /** k8s metadata */
      metadata: Metadata;
      /**
       * The minimum number of seconds for which a newly created pod should
       * be ready without any of its container crashing, for it to be considered
       * available. Defaults to 0 (pod will be considered available as soon as it is ready).
       */
      minReadySeconds: number;
      /** Indicates that the deployment is paused */
      paused: boolean;
      /**
       * The maximum time in seconds for a deployment to make progress before it is considered to be failed.
       *
       * The deployment controller will continue to process failed deployments and a condition with a
       * ProgressDeadlineExceeded reason will be surfaced in the deployment status. Note that progress
       * will not be estimated during the time a deployment is paused. Defaults to 600s.
       */
      progressDeadlineSeconds: number;
      /**
       * Number of desired pods.
       *
       * Defaults to 1. 0 is not allowed.
       *
       * @defaultValue 1
       */
      replicas: number;
      /**
       * The number of old ReplicaSets to retain to allow rollback.
       *
       * This is a pointer to distinguish between explicit zero and not specified. Defaults to 10.
       *
       * @defaultValue 10
       */
      revisionHistoryLimit: number;
      /**
       * Label selector for pods.
       *
       * Existing ReplicaSets whose pods are selected by this will be the ones affected by this deployment.
       * It must match the pod template's labels.
       *
       * @remarks
       *
       * With Adapt, this is optional.  If not specified, adapt will pick a selector that will work with the pods
       * it creates as part of this {@link k8s.Deployment}
       */
      selector?: LabelSelector;
      /**
       * An deployment strategy to use to replace existing pods with new ones
       */
      strategy: DeploymentUpdateStrategy;
  }/**
   * Component for Kubernetes Deployment
   *
   * @public
   */
  export declare class Deployment extends DeferredComponent<DeploymentProps> {
      static defaultProps: {
          metadata: {};
          paused: boolean;
          replicas: number;
          progressDeadlineSeconds: number;
          minReadySeconds: number;
          revisionHistoryLimit: number;
          strategy: {
              type: string;
              rollingUpdate: {
                  maxSurge: string;
                  maxUnavailable: string;
              };
          };
      };
      constructor(props: DeploymentProps);
      build(helpers: BuildHelpers): Adapt.JSX.Element | null;
      deployedWhen: () => true | Adapt.Waiting;
      status(_observe: ObserveForStatus, buildData: BuildData): Promise<Adapt.Status | undefined>;
  }/** @internal */
  const deploymentResourceInfo: {
      kind: string;
      deployedWhen: typeof deployedWhen;
      statusQuery: (props: ResourcePropsWithConfig, observe: ObserveForStatus, buildData: BuildData) => Promise<any>;
  };/**
   * Type assertion to see if an element is both a {@link k8s.Resource | Resource}
   * and a {@link @adpt/core#FinalElement | FinalElement}
   *
   * @param e - element to test
   * @returns `true` if e is both a FinalElement and a {@link k8s.Resource | Resource}, `false` otherwise
   *
   * @public
   */
  export declare function isResourceFinalElement(e: AdaptElement): e is FinalDomElement<ResourceProps & Adapt.BuiltinProps>;/**
   * Tests whether a ResourceProps is for a template object
   *
   * @public
   */
  export declare function isResourcePropsWithConfig(x: ResourceProps & Partial<BuiltinProps>): x is ResourcePropsWithConfig & Partial<BuiltinProps>;/**
   * Tests to see if an object is a {@link k8s.Resource} element
   * @param x - object to test
   * @returns true if object is an AdaptElement of type {@link k8s.Resource}
   *
   * @public
   */
  export declare function isResource(x: any): x is AdaptElement<ResourceProps>;/**
   * Primitive Component recognized by the k8s plugin to represent resources
   * @public
   */
  export declare class Resource extends Action<ResourceProps> {
      defaultProps: {
          apiVersion: "v1";
          con: false;
      };
      manifest_: Manifest;
      constructor(props: ResourceProps);
      validate(): "Resource elements cannot have children" | undefined;
      shouldAct(op: ChangeType, ctx: ActionContext): Promise<ShouldAct>;
      action(op: ChangeType, ctx: ActionContext): Promise<void>;
      deployedWhen: (goalStatus: GoalStatus, helpers: DeployHelpers) => Promise<true | Adapt.Waiting | Adapt.Waiting[]>;
      status(observe: ObserveForStatus, buildData: BuildData): Promise<any>;
      private mountedElement;
      private manifest;
  }/** @internal */
  export declare function makePodManifest(props: PodProps & BuiltinProps, data: {
      volumes?: Volume[];
      serviceAccountName?: string;
  }): {
      kind: string;
      metadata: Metadata;
      spec: PodSpec;
  };/**
   * Tests whether x is a Pod element
   *
   * @param x - value to test
   * @returns `true` if x is a Pod element, false otherwise
   *
   * @public
   */
  export declare function isPod(x: any): x is AdaptElement<PodProps>;/** @public */
  export declare interface NodeSelectorRequirement {
      /** The label key that the selector applies to. */
      key: string;
      /**
       * Represents a key's relationship to a set of values.
       *
       * Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
       */
      operator: "In" | "NotIn" | "Exists" | "DoesNotExist" | "Gt" | "Lt";
      /**
       * Values for operator
       *
       * If the operator is In or NotIn, the values array must be non-empty.
       * If the operator is Exists or DoesNotExist, the values array must be empty.
       * If the operator is Gt or Lt, the values array must have a single element,
       * which will be interpreted as an integer.
       * This array is replaced during a strategic merge patch.
       */
      values: string[];
  }/** @public */
  export declare interface NodeSelectorTerm {
      /** A list of node selector requirements by node's labels. */
      matchExpressions?: NodeSelectorRequirement[];
      /** A list of node selector requirements by node's fields. */
      matchFields?: NodeSelectorRequirement[];
  }/** @public */
  export declare interface PreferredSchedulingTerm {
      /**
       * A node selector term, associated with the corresponding weight.
       */
      preference: NodeSelectorTerm;
      /** Weight associated with matching the corresponding nodeSelectorTerm, in the range 1-100. */
      weight: number;
  }/** @public */
  export declare interface NodeSelector {
      /** A list of node selector terms. The terms are ORed */
      nodeSelectorTerms: NodeSelectorTerm[];
  }/** @public */
  export declare interface NodeAffinity {
      /** The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding "weight" to the sum if the node matches the corresponding matchExpressions; the node(s) with the highest sum are the most preferred. */
      preferredDuringSchedulingIgnoredDuringExecution?: PreferredSchedulingTerm[];
      /** If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to an update), the system may or may not try to eventually evict the pod from its node. */
      requiredDuringSchedulingIgnoredDuringExecution?: NodeSelector;
  }/** @public */
  export declare interface PodAffinityTerm {
      /**
       * Label query over a set of resources, in this case pods.
       */
      labelSelector: LabelSelector;
      /** Specifies which namespaces the labelSelector applies to (matches against); null or empty list means "this pod's namespace" */
      namespaces?: string[];
      /** This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed. */
      topologyKey: string;
  }/** @public */
  export declare interface WeightedPodAffinityTerm {
      /** A pod affinity term, associated with the corresponding weight. */
      podAffinityTerm: PodAffinityTerm;
      /**
       * weight associated with matching the corresponding podAffinityTerm, in the range 1-100.
       */
      weight: number;
  }/** @public */
  export declare interface PodAffinity {
      /**
       * The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions.
       *
       * The node that is most preferred is the one with the greatest sum of weights,
       * i.e. for each node that meets all of the scheduling requirements (resource request,
       * requiredDuringScheduling affinity expressions, etc.), compute a sum by iterating
       * through the elements of this field and adding "weight" to the sum if the node has pods
       * which matches the corresponding podAffinityTerm; the node(s) with the highest sum are the most preferred.
       */
      preferredDuringSchedulingIgnoredDuringExecution: WeightedPodAffinityTerm[];
      /**
       * If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node.
       *
       * If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system may or may not try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each podAffinityTerm are intersected, i.e. all terms must be satisfied.
       */
      requiredDuringSchedulingIgnoredDuringExecution: PodAffinityTerm[];
  }/** @public */
  export declare interface PodAntiAffinity {
      /** The scheduler will prefer to schedule pods to nodes that satisfy the anti-affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling anti-affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the node(s) with the highest sum are the most preferred. */
      preferredDuringSchedulingIgnoredDuringExecution: WeightedPodAffinityTerm[];
      /** If the anti-affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the anti-affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system may or may not try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each podAffinityTerm are intersected, i.e. all terms must be satisfied. */
      requiredDuringSchedulingIgnoredDuringExecution: PodAffinity;
  }/** @public */
  export declare interface Affinity {
      /** Describes node affinity scheduling rules for the pod. */
      nodeAffinity: NodeAffinity;
      /** Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)). */
      podAffinity: PodAffinity;
      /** PodAntiAffinity	Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)). */
      podAntiAffinity: PodAntiAffinity;
  }/** @public */
  export declare interface PodDNSConfigOption {
      name: string;
      value?: string;
  }/** @public */
  export declare interface PodDNSConfig {
      /**
       * A list of DNS name server IP addresses.
       *
       * This will be appended to the base nameservers generated from DNSPolicy. Duplicated nameservers will be removed.
       */
      nameservers: string[];
      /**
       * A list of DNS resolver options.
       *
       * This will be merged with the base options generated from DNSPolicy.
       * Duplicated entries will be removed.
       * Resolution options given in Options will override those that appear in the base DNSPolicy.
       */
      options: PodDNSConfigOption[];
      /**
       * A list of DNS search domains for host-name lookup.
       *
       * This will be appended to the base search paths generated from DNSPolicy. Duplicated search paths will be removed.
       */
      searches: string[];
  }/** @public */
  export declare interface PodReadinessGate {
      /** Refers to a condition in the pod's condition list with matching type. */
      conditionType: string;
  }/** @public */
  export declare interface SELinuxOptions {
      /** SELinux level label that applies to the container. */
      level: string;
      /** SELinux role label that applies to the container. */
      role: string;
      /** SELinux type label that applies to the container. */
      type: string;
      /** SELinux user label that applies to the container */
      user: string;
  }/** @public */
  export declare interface SeccompProfile {
      /**
       * Indicates a profile defined in a file on the node should be used.
       *
       * The profile must be preconfigured on the node to work.
       * Must be a descending path, relative to the kubelet's configured seccomp profile location.
       * Must only be set if type is "Localhost".
       */
      localhostProfile?: string;
      /**
       * Indicates which kind of seccomp profile will be applied.
       *
       * Valid options are:
       * * Localhost - a profile defined in a file on the node should be used.
       * * RuntimeDefault - the container runtime default profile should be used.
       * * Unconfined - no profile should be applied.
       */
      type: "Localhost" | "RuntimeDefault" | "Unconfined";
  }/** @public */
  export declare interface Sysctl {
      name: string;
      value: string;
  }/** @public */
  export declare interface WindowsSecurityContextOptions {
      /**
       * The GMSA admission webhook ({@link https://github.com/kubernetes-sigs/windows-gmsa}) inlines the contents of the GMSA credential spec named by the GMSACredentialSpecName field.
       */
      gmsaCredentialSpec?: string;
      /**
       * GMSACredentialSpecName is the name of the GMSA credential spec to use.
       */
      gmsaCredentialSpecName?: string;
      /**
       * The UserName in Windows to run the entrypoint of the container process.
       *
       * Defaults to the user specified in image metadata if unspecified. May also be set in PodSecurityContext.
       * If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
       */
      runAsUserName?: string;
  }/** @public */
  export declare interface PodSecurityContext {
      /**
       * A special supplemental group that applies to all containers in a pod.
       *
       * Some volume types allow the Kubelet to change the ownership of that volume to be owned by the pod:
       *
       * 1. The owning GID will be the FSGroup
       * 2. The setgid bit is set (new files created in the volume will be owned by FSGroup)
       * 3. The permission bits are OR'd with rw-rw----
       *
       * If unset, the Kubelet will not modify the ownership and permissions of any volume.
       */
      fsGroup?: number;
      /**
       * Defines behavior of changing ownership and permission of the volume before being exposed inside Pod.
       *
       * This field will only apply to volume types which support fsGroup based ownership(and permissions).
       * It will have no effect on ephemeral volume types such as: secret, configmaps and emptydir.
       * Valid values are "OnRootMismatch" and "Always". If not specified defaults to "Always".
       *
       * @defaultValue Always
       */
      fsGroupChangePolicy?: "OnRootMismatch" | "Always";
      /**
       * The GID to run the entrypoint of the container process.
       *
       * Uses runtime default if unset. May also be set in SecurityContext.
       * If set in both SecurityContext and PodSecurityContext, the value specified in
       * SecurityContext takes precedence for that container.
       */
      runAsGroup?: number;
      /**
       * Indicates that the container must run as a non-root user.
       *
       * If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and
       * fail to start the container if it does. If unset or false, no such validation will be performed.
       * May also be set in SecurityContext.
       * If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
       */
      runAsNonRoot?: boolean;
      /**
       * The UID to run the entrypoint of the container process.
       *
       * Defaults to user specified in image metadata if unspecified.
       * May also be set in SecurityContext.
       * If set in both SecurityContext and PodSecurityContext, the value specified in
       * SecurityContext takes precedence for that container.
       */
      runAsUser?: number;
      /**
       * The SELinux context to be applied to all containers.
       *
       * If unspecified, the container runtime will allocate a random SELinux context for each container.
       * May also be set in SecurityContext.
       * If set in both SecurityContext and PodSecurityContext, the value specified in
       * SecurityContext takes precedence for that container.
       */
      seLinuxOptions?: SELinuxOptions;
      /**
       * The seccomp options to use by the containers in this pod.
       */
      seccompProfile?: SeccompProfile;
      /**
       * 	A list of groups applied to the first process run in each container, in addition to the container's primary GID.
       *
       *  If unspecified, no groups will be added to any container.
       */
      supplementalGroups?: number[];
      /**
       * Sysctls hold a list of namespaced sysctls used for the pod.
       *
       * Pods with unsupported sysctls (by the container runtime) might fail to launch.
       */
      sysctls?: Sysctl[];
      /**
       * The Windows specific settings applied to all containers.
       *
       * If unspecified, the options within a container's SecurityContext will be used.
       * If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
       */
      windowsOptions: WindowsSecurityContextOptions;
  }/** @public */
  export declare interface Toleration {
      /**
       * Indicates the taint effect to match.
       *
       * Empty means match all taint effects.
       * When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
       */
      effect?: "NoSchedule" | "PreferNoSchedule" | "NoExecute";
      /**
       * The taint key that the toleration applies to.
       *
       * Empty means match all taint keys.
       * If the key is empty, operator must be Exists;
       * this combination means to match all values and all keys.
       */
      key?: string;
      /**
       * Represents a key's relationship to the value.
       *
       * Valid operators are Exists and Equal.
       * Defaults to Equal.
       * Exists is equivalent to wildcard for value, so that a pod can tolerate all taints of a particular category.
       *
       * @defaultValue Equal
       */
      operator?: "Exists" | "Equal";
      /**
       * Represents the period of time the toleration (which must be of effect NoExecute, otherwise this field is ignored) tolerates the taint.
       *
       * By default, it is not set, which means tolerate the taint forever (do not evict).
       * Zero and negative values will be treated as 0 (evict immediately) by the system.
       */
      tolerationSeconds?: number;
      /**
       * Value is the taint value the toleration matches to.
       *
       * If the operator is Exists, the value should be empty, otherwise just a regular string.
       */
      value?: string;
  }/** @public */
  export declare interface TopologySpreadConstraint {
      /**
       * Used to find matching pods.
       *
       * Pods that match this label selector are counted to determine the
       * number of pods in their corresponding topology domain.
       */
      labelSelector: LabelSelector;
      /**
       * Describes the degree to which pods may be unevenly distributed.
       *
       * When `whenUnsatisfiable=DoNotSchedule`, it is the maximum permitted
       * difference between the number of matching pods in the target topology
       * and the global minimum.
       * For example, in a 3-zone cluster, MaxSkew is set to 1, and pods with
       * the same labelSelector spread as 1/1/0: | zone1 | zone2 | zone3 | | P | P | |
       * - if MaxSkew is 1, incoming pod can only be scheduled to zone3 to become 1/1/1;
       *   scheduling it onto zone1(zone2) would make the ActualSkew(2-0) on zone1(zone2) violate MaxSkew(1).
       * - if MaxSkew is 2, incoming pod can be scheduled onto any zone.
       * When `whenUnsatisfiable=ScheduleAnyway`, it is used to give higher precedence to topologies that satisfy it.
       * It's a required field. Default value is 1 and 0 is not allowed.
       *
       * @example
       *
       * @defaultValue 1
       */
      maxSkew: number;
      /**
       * The key of node labels.
       *
       * Nodes that have a label with this key and identical values are considered to be in the same topology.
       * We consider each \<key, value\> as a "bucket", and try to put balanced number of pods into each bucket.
       * It's a required field.
       */
      topologyKey: string;
      /**
       * Indicates how to deal with a pod if it doesn't satisfy the spread constraint.
       *
       * - DoNotSchedule (default) tells the scheduler not to schedule it.
       * - ScheduleAnyway tells the scheduler to schedule the pod in any location,
       *   but giving higher precedence to topologies that would help reduce the skew.
       *
       * A constraint is considered "Unsatisfiable" for an incoming pod if and only if every possible
       * node assigment for that pod would violate "MaxSkew" on some topology.
       * For example, in a 3-zone cluster, MaxSkew is set to 1, and pods with the same labelSelector
       * spread as 3/1/1: | zone1 | zone2 | zone3 | | P P P | P | P | If WhenUnsatisfiable is set to DoNotSchedule,
       * incoming pod can only be scheduled to zone2(zone3) to become 3/2/1(3/1/2)
       * as ActualSkew(2-1) on zone2(zone3) satisfies MaxSkew(1).
       * In other words, the cluster can still be imbalanced, but scheduler won't make it
       * *more* imbalanced.
       *
       * It's a required field.
       */
      whenUnsatisfiable: string;
  }/** @public */
  export declare interface KeyToPath {
      /** The key to project. */
      key: string;
      /**
       * mode bits to use on this file,
       * Must be a value between 0 and 0777.
       * If not specified, the volume defaultMode will be used.
       * This might be in conflict with other options that affect the file mode, like fsGroup,
       * and the result can be other mode bits set.
       */
      mode?: number;
      /**
       * The relative path of the file to map the key to.
       *
       * May not be an absolute path. May not contain the path element '..'. May not start with the string '..'.
       */
      path: string;
  }/** @public */
  export declare interface ConfigMapVolumeSource {
      /**
       * mode bits to use on created files by default.
       *
       * Must be a value between 0 and 0777. Defaults to 0644.
       * Directories within the path are not affected by this setting.
       * This might be in conflict with other options that affect the file mode,
       * like fsGroup, and the result can be other mode bits set.
       */
      defaultMode?: number;
      /**
       * If unspecified, each key-value pair in the Data field of the referenced ConfigMap will be projected into the volume as a file whose name is the key and content is the value.
       *
       * If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present.
       * If a key is specified which is not present in the ConfigMap, the volume setup will error unless it is marked optional.
       * Paths must be relative and may not contain the '..' path or start with '..'.
       */
      items?: KeyToPath[];
      /**
       * Name of the referent.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names}
       */
      name: string | Handle;
      /** Specify whether the ConfigMap or its keys must be defined */
      optional?: boolean;
  }/** @public */
  export declare interface SecretVolumeSource {
      /**
       * mode bits to use on created files by default.
       *
       * Must be a value between 0 and 0777. Defaults to 0644.
       * Directories within the path are not affected by this setting.
       * This might be in conflict with other options that affect the file mode,
       * like fsGroup, and the result can be other mode bits set.
       */
      defaultMode?: number;
      /**
       * If unspecified, each key-value pair in the Data field of the referenced Secret will be projected into the volume as a file whose name is the key and content is the value.
       *
       * If specified, the listed keys will be projected into the specified paths,
       * and unlisted keys will not be present. If a key is specified which is not
       * present in the Secret, the volume setup will error unless it is marked optional.
       *
       * Paths must be relative and may not contain the '..' path or start with '..'.
       */
      items?: KeyToPath[];
      /** Specify whether the Secret or its keys must be defined */
      optional?: boolean;
      /**
       * Name of the secret in the pod's namespace to use.
       *
       *  More info: {@link https://kubernetes.io/docs/concepts/storage/volumes#secret}
       */
      secretName: string | Handle;
  }/** @public */
  export declare interface EmptyDirVolumeSource {
      /**
       * What type of storage medium should back this directory.
       *
       * The default is "" which means to use the node's default medium.
       * Must be an empty string (default) or Memory.
       * More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
       */
      medium: string;
      /**
       * Total amount of local storage required for this EmptyDir volume.
       *
       * The size limit is also applicable for memory medium.
       * The maximum usage on memory medium EmptyDir would be the minimum
       * value between the SizeLimit specified here and the sum of memory limits of all containers in a pod.
       * The default is nil which means that the limit is undefined.
       * More info: {@link http://kubernetes.io/docs/user-guide/volumes#emptydir}
       */
      sizeLimit: string;
  }/**
   * Volumes for {@link k8s.PodProps}
   *
   * @public
   */
  export declare interface Volume {
      /**
       * Volume's name.
       *
       * Must be a DNS_LABEL and unique within the pod.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names}
       */
      name: string;
      /**
       * Represents a configMap that should populate this volume
       */
      configMap?: ConfigMapVolumeSource;
      /**
       * EmptyDir represents a temporary directory that shares a pod's lifetime.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/storage/volumes#emptydir}
       *
       */
      emptyDir?: EmptyDirVolumeSource;
      /**
       * Represents a secret that should populate this volume.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/storage/volumes#secret}
       */
      secret?: SecretVolumeSource;
      /** Other k8s volume kinds not typed yet for \@adpt/cloud */
      [key: string]: any;
  }/**
   * Props for the {@link k8s.Pod} component
   *
   * @public
   */
  export declare interface PodProps extends WithChildren {
      /**
       *  True is this is a template for use in a controller, false otherwise
       *  @defaultValue false
       */
      isTemplate: boolean;
      /** Information about the k8s cluster (ip address, auth info, etc.) */
      config?: ClusterInfo;
      /** k8s metadata */
      metadata: Metadata;
      /**
       * Optional duration in seconds the pod may be active on the node relative to StartTime before the system will actively try to mark it failed and kill associated containers.
       *
       * Value must be a positive integer.
       */
      activeDeadlineSeconds?: number;
      /** If specified, the pod's scheduling constraints */
      affinity?: Affinity;
      /** AutomountServiceAccountToken indicates whether a service account token should be automatically mounted. */
      automountServiceAccountToken?: boolean;
      /**
       *  Specifies the DNS parameters of a pod.
       *
       *  Parameters specified here will be merged to the generated DNS configuration based on DNSPolicy.
       */
      dnsConfig?: PodDNSConfig;
      /**
       * Set DNS policy for the pod.
       *
       * Valid values are 'ClusterFirstWithHostNet', 'ClusterFirst', 'Default' or 'None'.
       * DNS parameters given in DNSConfig will be merged with the policy selected with DNSPolicy.
       * To have DNS options set along with hostNetwork, you have to specify DNS policy explicitly
       * to 'ClusterFirstWithHostNet'.
       *
       * @defaultValue ClusterFirst
       */
      dnsPolicy: "ClusterFirstWithHostNet" | "ClusterFirst" | "Default" | "None";
      /**
       * Indicates whether information about services should be injected into pod's environment variables matching the syntax of Docker links.
       *
       * @defaultValue true
       */
      enableServiceLinks: boolean;
      /**
       * An optional list of hosts and IPs that will be injected into the pod's hosts file if specified.
       *
       * This is only valid for non-hostNetwork pods.
       */
      hostAliases?: HostAlias[];
      /**
       * Use the host's ipc namespace.
       * @defaultValue false
       */
      hostIPC: boolean;
      /**
       * Host networking requested for this pod.
       *
       * Use the host's network namespace.
       * If this option is set, the ports that will be used must be specified. Default to false.
       */
      hostNetwork?: boolean;
      /**
       * Use the host's pid namespace.
       * @defaultValue false
       */
      hostPID: boolean;
      /**
       * Specifies the hostname of the Pod.
       *
       * If not specified, the pod's hostname will be set to a system-defined value.
       */
      hostname?: string;
      /**
       * List of references to secrets in the same namespace to use for pulling any of the images used by this PodSpec.
       *
       * If specified, these secrets will be passed to individual puller implementations for them to use.
       * For example, in the case of docker, only DockerConfig type secrets are honored.
       * More info: {@link https://kubernetes.io/docs/concepts/containers/images#specifying-imagepullsecrets-on-a-pod}
       */
      imagePullSecrets?: LocalObjectReference[];
      /**
       * A request to schedule this pod onto a specific node.
       *
       * If it is non-empty, the scheduler simply schedules this pod onto that node,
       * assuming that it fits resource requirements.
       */
      nodeName?: string;
      /**
       * A selector which must be true for the pod to fit on a node.
       *
       * Selector which must match a node's labels for the pod to be scheduled on that node.
       * More info: {@link https://kubernetes.io/docs/concepts/configuration/assign-pod-node/}
       */
      nodeSelector?: {
          [label: string]: boolean | string;
      };
      /**
       * Overhead represents the resource overhead associated with running a pod for a given RuntimeClass.
       *
       * This field will be autopopulated at admission time by the RuntimeClass admission controller.
       * If the RuntimeClass admission controller is enabled, overhead must not be set in Pod create requests.
       * The RuntimeClass admission controller will reject Pod create requests which have the overhead already set.
       * If RuntimeClass is configured and selected in the PodSpec, Overhead will be set to the value defined in
       * the corresponding RuntimeClass, otherwise it will remain unset and treated as zero.
       *
       * More info: {@link https://git.k8s.io/enhancements/keps/sig-node/20190226-pod-overhead.md}
       *
       * This field is alpha-level as of Kubernetes v1.16, and is only honored by servers that enable
       * the PodOverhead feature.
       * @alpha
       */
      overhead?: unknown;
      /**
       * PreemptionPolicy is the Policy for preempting pods with lower priority.
       *
       * This field is beta-level, gated by the NonPreemptingPriority feature-gate.
       *
       * @defaultValue PreemptLowerPriority
       * @beta
       */
      preemptionPolicy?: "Never" | "PreemptLowerPriority";
      /**
       * The priority various system components use this field to find the priority of the pod.
       *
       * When Priority Admission Controller is enabled, it prevents users from setting this field.
       * The admission controller populates this field from PriorityClassName.
       * The higher the value, the higher the priority.
       */
      priority?: number;
      /**
       * If specified, indicates the pod's priority.
       *
       * "system-node-critical" and "system-cluster-critical" are two special keywords which indicate the highest
       * priorities with the former being the highest priority. Any other name must be defined by creating a PriorityClass
       * object with that name. If not specified, the pod priority will be default or zero if there is no default.
       */
      priorityClassName?: string;
      /**
       *  If specified, all readiness gates will be evaluated for pod readiness.
       *
       *  A pod is ready when all its containers are ready AND all conditions specified
       *  in the readiness gates have status equal to "True"
       *
       *  More info: {@link https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#pod-readiness-gate}
       */
      readinessGates?: PodReadinessGate[];
      /**
       * Restart policy for all containers within the pod.
       *
       * One of Always, OnFailure, Never. Default to Always.
       * More info: {@link https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy}
       *
       * @defaultValue Always
       */
      restartPolicy: "Always" | "OnFailure" | "Never";
      /**
       * Refers to a RuntimeClass object in the node.k8s.io group, which should be used to run this pod.
       *
       * If no RuntimeClass resource matches the named class, the pod will not be run.
       * If unset or empty, the "legacy" RuntimeClass will be used, which is an implicit
       * class with an empty definition that uses the default runtime handler.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/containers/runtime-class/}
       *
       * This is a beta feature as of Kubernetes v1.14.
       */
      runtimeClassName?: string;
      /**
       *  If specified, the pod will be dispatched by specified scheduler.
       *  If not specified, the pod will be dispatched by default scheduler.
       */
      schedulerName?: string;
      /**
       * SecurityContext holds pod-level security attributes and common container settings.
       * See type description for default values of each field.
       *
       * @defaultValue \{\}
       */
      securityContext: PodSecurityContext;
      /**
       * ServiceAccountName is the name of the ServiceAccount to use to run this pod.
       * More info: {@link https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/}
       */
      serviceAccountName?: string | Handle;
      /**
       * If true the pod's hostname will be configured as the pod's FQDN, rather than the leaf name (the default).
       * In Linux containers, this means setting the FQDN in the hostname field of the kernel
       * (the nodename field of struct utsname).
       * In Windows containers, this means setting the registry value of hostname for the registry key
       * HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters to FQDN.
       * If a pod does not have FQDN, this has no effect.
       *
       * @defaultValue false
       */
      setHostnameAsFQDN?: boolean;
      /**
       * Share a single process namespace between all of the containers in a pod.
       * When this is set containers will be able to view and signal processes from other containers in the same pod,
       * and the first process in each container will not be assigned PID 1.
       * HostPID and ShareProcessNamespace cannot both be set.
       *
       * @defaultValue false
       */
      shareProcessNamespace: boolean;
      /**
       *  If specified, the fully qualified Pod hostname will be "\<hostname\>.\<subdomain\>.\<pod namespace\>.svc.\<cluster domain\>".
       *  If not specified, the pod will not have a domainname at all.
       */
      subdomain?: string;
      /**
       * Optional duration in seconds the pod needs to terminate gracefully.
       *
       * May be decreased in delete request. Value must be non-negative integer.
       * The value zero indicates delete immediately. If this value is nil, the default
       * grace period will be used instead. The grace period is the duration in seconds
       * after the processes running in the pod are sent a termination signal and the time
       * when the processes are forcibly halted with a kill signal. Set this value longer
       * than the expected cleanup time for your process. Defaults to 30 seconds.
       */
      terminationGracePeriodSeconds?: number;
      /** If specified, the pod's tolerations. */
      tolerations?: Toleration[];
      /**
       *  TopologySpreadConstraints describes how a group of pods ought to spread across topology domains.
       *
       *  Scheduler will schedule pods in a way which abides by the constraints. All topologySpreadConstraints are ANDed.
       */
      topologySpreadConstraints?: TopologySpreadConstraint[];
      /**
       * List of volumes that can be mounted by containers belonging to the pod.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/storage/volumes}
       */
      volumes?: Volume[];
  }/**
   * Component for Kubernetes Pods
   *
   * @public
   */
  export declare class Pod extends DeferredComponent<PodProps, ResolvedVolumes & ResolvedServiceAccountName> {
      static defaultProps: {
          isTemplate: boolean;
          metadata: {};
          dnsPolicy: string;
          enableServiceLinks: boolean;
          hostIPC: boolean;
          hostPID: boolean;
          restartPolicy: string;
          securityContext: {};
          shareProcessNamespace: boolean;
          terminationGracePeriodSeconds: number;
      };
      initialState(): {};
      build(helpers: BuildHelpers): Adapt.JSX.Element | null;
      status(_observe: ObserveForStatus, buildData: BuildData): Promise<Adapt.Status | undefined>;
  }/**
   * Spec for for Kubernetes Pods
   *
   * @public
   */
  export declare interface PodSpec extends Omit<PodProps, "config" | "metadata" | "isTemplate"> {
      containers: ContainerSpec[];
      terminationGracePeriodSeconds?: number;
  }/** @internal */
  const podResourceInfo: {
      kind: string;
      deployedWhen: typeof deployedWhen;
      statusQuery: (props: ResourcePropsWithConfig, observe: ObserveForStatus, buildData: BuildData) => Promise<any>;
  };/**
   * k8s Secret resource
   *
   * @param propsIn - props for Secret as specifed in {@link k8s.SecretProps}
   *
   * @public
   */
  export declare function Secret(propsIn: SFCDeclProps<SecretProps, typeof defaultProps>): Adapt.JSX.Element;/** @internal */
  const secretResourceInfo: {
      kind: string;
      deployedWhen: () => true;
      statusQuery: (props: ResourcePropsWithConfig, observe: ObserveForStatus, buildData: BuildData) => Promise<any>;
      makeManifest: (manifest: Manifest, elem: AdaptElement<ResourceProps>, _deployID: string) => {
          data: {
              [key: string]: string;
          } | undefined;
          stringData: {
              [key: string]: string;
          } | undefined;
          type: string | undefined;
          apiVersion: string; /**
           * stringData allows specifying non-binary secret data in string form.
           *
           * It is provided as a write-only convenience method. All keys and values are merged into the data field on write,
           * overwriting any existing values. It is never output when reading from the API.
           */
          kind: string;
          metadata: import("./manifest_support").MetadataInRequest;
          spec?: import("./DaemonSet").DaemonSetSpec | import("./common").CRSpec | import("./Pod").PodSpec | import("./Service").ServiceSpec | import("./Deployment").DeploymentSpec | undefined;
      };
  };/**
   * Convert {@link NetworkService} props to {@link k8s.Service} props
   * @param abstractProps - props to convert
   * @returns Kubernetes spec corresponding to `abstractProps`
   *
   * @internal
   */
  export declare function k8sServiceProps(abstractProps: NetworkServiceProps & BuiltinProps): Omit<ServiceProps, keyof ResourceBase>;/**
   * Native Kubernetes Service resource
   *
   * @remarks
   *
   * Implements the {@link NetworkServiceInstance} interface.
   *
   * @public
   */
  export declare function Service(propsIn: SFCDeclProps<ServiceProps, typeof defaultProps>): Adapt.JSX.Element;/** @public */
  export declare interface ServiceProps extends ServiceSpec {
      /** Legal configuration loaded from kubeconfig */
      config: ClusterInfo;
      metadata?: Metadata;
      selector?: Handle | EndpointSelector;
  }/** @public */
  export declare interface ServiceSpec {
      /**
       * Cluster IP for a {@link k8s.Service}
       *
       * @remarks
       * `clusterIP` is the IP address of the service and is usually assigned
       * randomly by the master. If an address is specified manually and is not
       * in use by others, it will be allocated to the service; otherwise,
       * creation of the service will fail. This field can not be changed through
       * updates. Valid values are "None", empty string (""), or a valid IP
       * address. "None" can be specified for headless services when proxying is
       * not required. Only applies to types ClusterIP, NodePort, and
       * LoadBalancer. Ignored if type is ExternalName.
       *
       * For more information, see the
       * {@link https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies |
       * Kubernetes documentation}.
       */
      clusterIP?: string;
      /**
       * A list of IP addresses for which nodes in the cluster
       * will also accept traffic for this service.
       *
       * @remarks
       * These IPs are not managed by
       * Kubernetes. The user is responsible for ensuring that traffic arrives at
       * a node with this IP. A common example is external load balancers that are
       * not part of the Kubernetes system.
       */
      externalIPs?: string[];
      /**
       * The external reference that kubedns or equivalent
       * will return as a CNAME record for this service.
       *
       * @remarks
       * No proxying will be involved. Must be a
       * {@link https://tools.ietf.org/html/rfc1123 | valid RFC-1123 hostname}
       * and requires Type to be ExternalName.
       */
      externalName?: string;
      /**
       * Denotes if this Service desires to route
       * external traffic to node-local or cluster-wide endpoints.
       *
       * @remarks
       * "Local" preserves the client source IP and avoids a second hop for
       * LoadBalancer and Nodeport type services, but risks potentially
       * imbalanced traffic spreading. "Cluster" obscures the client source IP
       * and may cause a second hop to another node, but should have good overall
       * load-spreading.
       */
      externalTrafficPolicy?: string;
      /**
       * Specifies the healthcheck nodePort for the service.
       *
       * @remarks
       * If not specified, HealthCheckNodePort is created by the service
       * api backend with the allocated nodePort. Will use user-specified nodePort
       * value if specified by the client. Only affects when Type is set to
       * LoadBalancer and ExternalTrafficPolicy is set to Local.
       */
      healthCheckNodePort?: number;
      /**
       * Only applies to Service Type: LoadBalancer. LoadBalancer will
       * get created with the IP specified in this field.
       *
       * @remarks
       * This feature depends on
       * whether the underlying cloud provider supports specifying the loadBalancerIP
       * when a load balancer is created. This field will be ignored if the
       * cloud provider does not support the feature.
       */
      loadBalancerIP?: string;
      /**
       * If specified and supported by the platform, this will
       * restrict traffic through the cloud provider load balancer
       * to the specified client IPs.
       *
       * @remarks
       * This field will be ignored if the cloud provider
       * does not support the feature.
       *
       * For more information, see the
       * {@link https://v1-17.docs.kubernetes.io/docs/tasks/access-application-cluster/configure-cloud-provider-firewall/ |
       * Kubernetes documentation}.
       */
      loadBalancerSourceRanges?: string[];
      /**
       * The list of ports that are exposed by this service.
       *
       * @remarks
       * For more information, see the
       * {@link https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies |
       * Kubernetes documentation}.
       */
      ports?: ServicePort[];
      /**
       * When set to true, indicates that
       * DNS implementations must publish the notReadyAddresses of subsets for the
       * Endpoints associated with the Service.
       *
       * @remarks
       * The default value is false. The
       * primary use case for setting this field is to use a StatefulSet's Headless
       * Service to propagate SRV records for its Pods without respect to their
       * readiness for purpose of peer discovery.
       */
      publishNotReadyAddresses?: boolean;
      /**
       * Route service traffic to pods with label keys and values
       * matching this selector.
       *
       * @remarks
       * If empty or not present, the service is assumed to
       * have an external process managing its endpoints, which Kubernetes will not
       * modify. Only applies to types ClusterIP, NodePort, and LoadBalancer.
       * Ignored if type is ExternalName.
       *
       * For more information, see the
       * {@link https://kubernetes.io/docs/concepts/services-networking/service/ |
       * Kubernetes documentation}.
       */
      selector?: EndpointSelector | object;
      /**
       * Used to maintain session affinity.
       *
       * @remarks
       * Possible values are:
       *
       * - `"ClientIP"`: Enables client IP based session affinity.
       *
       * - `"None"`: Disables session affinity.
       *
       * For more information, see the
       * {@link https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies |
       * Kubernetes documentation}.
       * @defaultValue `"None"`
       */
      sessionAffinity?: string;
      /**
       * Determines how the Service is exposed.
       *
       * @remarks
       * Valid options are:
       *
       * - `"ExternalName"`: maps to the specified externalName.
       *
       * - `"ClusterIP"`: allocates a cluster-internal IP address for load
       * balancing to endpoints. Endpoints are determined by the selector or if
       * that is not specified, by manual construction of an Endpoints object. If
       * clusterIP is "None", no virtual IP is allocated and the endpoints are
       * published as a set of endpoints rather than a stable IP.
       *
       * - `"NodePort"`: Builds on ClusterIP and allocates a port on every node
       * which routes to the clusterIP.
       *
       * - `"LoadBalancer"`: Builds on NodePort and creates an external load
       * balancer (if supported in the current cloud) which routes to the
       * clusterIP.
       *
       * For more information, see the
       * {@link https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services---service-types |
       * Kubernetes documentation}.
       * @defaultValue `"ClusterIP"`
       */
      type?: string;
  }/** @public */
  export declare interface ServicePort {
      /**
       * The name of this port within the service.
       *
       * @remarks
       * This must be a DNS_LABEL.
       * All ports within a ServiceSpec must have unique names.This maps to the
       * Name' field in EndpointPort objects. Optional if only one ServicePort is
       * defined on this service.
       */
      name?: string;
      /**
       * The port on each node on which this service is exposed when
       * type=NodePort or LoadBalancer.
       *
       * @remarks
       * Usually assigned by the system. If
       * specified, it will be allocated to the service if unused or else creation
       * of the service will fail.
       *
       * For more information, see the
       * {@link https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport |
       * Kubernetes documentation}.
       * @defaultValue Automatically allocates a port if the ServiceType of this
       * Service requires one.
       */
      nodePort?: number;
      /** The port that will be exposed by this service. */
      port?: number;
      /** The IP protocol for this port.Supports "TCP" and "UDP".Default is TCP. */
      protocol?: string;
      /**
       * Number or name of the port to access on the pods targeted by the
       * service.
       *
       * @remarks
       * Number must be in the range 1 to 65535. Name must be an
       * IANA_SVC_NAME. If this is a string, it will be looked up as a named port
       * in the target Pod's container ports. If this is not specified, the value
       * of the 'port' field is used (an identity map). This field is ignored for
       * services with clusterIP = None, and should be omitted or set equal to the
       * 'port' field.
       *
       * For more information, see the
       * {@link https://kubernetes.io/docs/concepts/services-networking/service/#defining-a-service |
       * Kubernetes documentation}.
       */
      targetPort?: number | string;
  }/** @internal */
  const serviceResourceInfo: {
      kind: string;
      deployedWhen: typeof deployedWhen;
      statusQuery: (props: ResourcePropsWithConfig, observe: ObserveForStatus, buildData: BuildData) => Promise<any>;
  };/**
   * k8s ServiceAccount resource
   *
   * @param propsIn - props for ServiceAccount as specifed in {@link k8s.ServiceAccountProps}
   *
   * @public
   */
  export declare function ServiceAccount(propsIn: SFCDeclProps<ServiceAccountProps, typeof defaultProps>): Adapt.JSX.Element;/** @public */
  export declare function isServiceAccountProps(p: ResourceProps): p is ResourceProps & ResourceServiceAccount;/** @internal */
  const serviceAccountResourceInfo: {
      kind: string;
      deployedWhen: () => true;
      statusQuery: (props: ResourcePropsWithConfig, observe: ObserveForStatus, buildData: BuildData) => Promise<any>;
      makeManifest: (manifest: Manifest, elem: AdaptElement<ResourceProps>, _deployID: string) => {
          automountServiceAccountToken: boolean | undefined;
          imagePullSecrets: {
              name: string;
          }[] | undefined;
          secrets: ObjectReference[] | undefined;
          apiVersion: string;
          kind: string;
          metadata: import("./manifest_support").MetadataInRequest;
          spec?: import("./DaemonSet").DaemonSetSpec | import("./common").CRSpec | import("./Pod").PodSpec | import("./Service").ServiceSpec | import("./Deployment").DeploymentSpec | undefined;
      };
  };/**
   * Props for {@link k8s.ServiceDeployment}
   *
   * @public
   */
  export declare interface ServiceDeploymentProps<T extends AllowableComponentProps = DeploymentProps> extends ServiceProps {
      config: ClusterInfo;
      serviceProps?: Partial<ServiceProps>;
      component: ComponentType<T>;
      componentProps: T;
      podProps?: Partial<PodProps>;
      containerProps?: Partial<OmitT<K8sContainerProps, "image">>;
  }/**
   * A component for mapping a group of abstract {@link Container}s and
   * {@link NetworkService}s to Kubernetes {@link k8s.Pod}s and
   * {@link k8s.K8sContainer}s.
   *
   * @remarks
   * This component is intended to be used to replace {@link Container} and
   * {@link NetworkService} components that are grouped together, as the
   * only children of a common parent in a pattern that looks like this:
   *
   * ```tsx
   * <Service>
   *   <Container ... />
   *   <Container ... />
   *   <NetworkService ... />
   * </Service>
   * ```
   *
   * `ServiceDeployment` would map those abstract components into corresponding
   * k8s components like this:
   * ```tsx
   * <Group>
   *   <docker.RegistryDockerImage ... /> //If props.config specifies a registry
   *   <k8s.Deployment ... >
   *     <Pod isTemplate>
   *       <k8s.K8sContainer ... />
   *     </Pod>
   *   </k8s.Deployment>
   *   <docker.RegistryDockerImage ... /> //If props.config specifies a registry
   *   <k8s.Deployment ... >
   *     <Pod isTemplate>
   *       <k8s.K8sContainer ... />
   *     </Pod>
   *   </k8s.Pod>
   *   <k8s.Service ... />
   * </Group>
   * ```
   * An example style rule to do this is:
   * ```tsx
   * {Adapt.rule((matchedProps) => {
   *     const { handle, ...remainingProps } = matchedProps;
   *     return <ServiceDeployment config={kubeconfig} {...remainingProps} />;
   * })}
   * ```
   * `ServiceDeployment` also requires the `config` prop which specifies
   * connection and authentication information for the Kubernetes cluster on
   * which these objects should be created.
   *
   * @public
   */
  export declare class ServiceDeployment<T extends AllowableComponentProps> extends DeferredComponent<ServiceDeploymentProps<T>> {
      static defaultProps: {
          component: typeof Deployment;
          componentProps: {
              replicas: number;
          };
      };
      build(helpers: BuildHelpers): Adapt.JSX.Element;
  }/** @public */
  export declare function computeNamespaceFromMetadata(metadata?: Metadata): string;/** @public */
  export declare function isLabelSelector(x: any): x is LabelSelector;/**
   * Kubernetes Kind
   *
   * @public
   */
  export declare type Kind = string;/** @public */
  export declare interface CRSpec {
      [key: string]: any;
  }/** @public */
  export declare type Spec = DaemonSetSpec | DeploymentSpec | PodSpec | ServiceSpec | CRSpec;/** @public */
  export declare interface Metadata {
      namespace?: string;
      labels?: {
          [key: string]: string;
      };
      annotations?: {
          [key: string]: string;
      };
  }/** @public */
  export declare type ResourceProps = {
      key: string;
  } & (ResourceClusterRole | ResourceClusterRoleBinding | ResourceDaemonSet | ResourcePod | ResourceService | ResourceServiceAccount | ResourceConfigMap | ResourceSecret | ResourceCR);/** @public */
  export declare type ResourcePropsWithConfig = ResourceProps & {
      config: ClusterInfo;
  };/** @public */
  export declare interface ResourceInfo {
      kind: Kind;
      statusQuery?: (props: ResourceProps, observe: ObserveForStatus, buildData: BuildData) => unknown | Promise<unknown>;
      specsEqual(actual: Spec, element: Spec): boolean;
  }/**
   * Holds the information needed to connect, authenticate, and run code in a kuberenetes cluster
   *
   * @public
   */
  export declare interface ClusterInfo {
      /** Javascript object formed by parsing a valid kubeconfig file */
      kubeconfig: Kubeconfig;
      /**
       * Registry to which Docker images used by the cluster in `kubeconfig` should be pushed and pulled
       *
       * @remarks
       * If `registryPrefix` is a string, it is assumed that the cluster can pull from the same string
       * that outsiders can push to.
       *
       * If `registryPrefix` is of the form `{ external: string, internal: string }` then the `external`
       * string will be used to push images, and the `internal` string will be used to pull images.
       *
       * Note(manishv)
       * This is a bit of a hack to allow one hostname or IP address to push images from outside
       * a particular environment (say k8s) and a different URL for that environment to pull
       * images.
       *
       * A good example of this is a k3s-dind (k3s docker-in-docker) instance of kubernetes where
       * a private registry is running on a docker network attached to the k3s-dind instance, but where we
       * want to push {@link docker.LocalDockerImage} built images to that registry.  Since
       * {@link docker.LocalDockerImage | LocalDockerImage} is outside the k3s-dind environment, it must
       * use a host accessible network to push to the registry.  However, since the k3s-dind instance sees
       * the registry from within Docker, it must use a different address to pull the images for use.
       *
       * Once network scopes are fully supported, this interface will change to whatever is appropriate.  It
       * is best if you can arrange to have the same URL or registry string work for all access regardless
       * of which network the registry, Adapt host, and ultimate container running environment uses.
       *
       */
      registryPrefix?: string | DockerSplitRegistryInfo;
  }/** @public */
  export declare interface ResourceBase {
      /**
       * config to connect to the k8s cluster
       *
       * required if isTemplate is false
       */
      config?: ClusterInfo;
      /**
       * Specifies whether this resource is just a template for use in a controller
       */
      isTemplate?: boolean;
      apiVersion?: string;
      kind: Kind;
      metadata?: Metadata;
  }/**
   * @public
   */
  export declare interface PolicyRule {
      /**
       * APIGroups is the name of the APIGroup that contains the resources.
       *
       * If multiple API groups are specified, any action requested against one
       * of the enumerated resources in any API group will be allowed.
       */
      apiGroups?: string[];
      /**
       * NonResourceURLs is a set of partial urls that a user should have access to.
       *
       * *s are allowed, but only as the full, final step in the path.
       * Since non-resource URLs are not namespaced, this field is only applicable
       * for ClusterRoles referenced from a ClusterRoleBinding.
       * Rules can either apply to API resources (such as "pods" or "secrets") or
       * non-resource URL paths (such as "/api"), but not both.
       */
      nonResourceURLs?: string[];
      /**
       * ResourceNames is an optional white list of names that the rule applies to.
       *
       * An empty set means that everything is allowed.
       */
      resourceNames?: string[];
      /**
       * Resources is a list of resources this rule applies to.
       *
       * ResourceAll represents all resources.
       */
      resources: string[];
      /**
       * Verbs is a list of Verbs that apply to ALL the ResourceKinds and
       * AttributeRestrictions contained in this rule.
       *
       * VerbAll represents all kinds.
       */
      verbs: string[];
  }/**
   * AggregationRule for {@link k8s.ClusterRole}
   *
   * @public
   */
  export declare interface AggregationRule {
      /**
       * ClusterRoleSelectors holds a list of selectors which will be used to
       * find ClusterRoles and create the rules.
       *
       * If any of the selectors match, then the ClusterRole's permissions will be added
       */
      clusterRoleSelector: LabelSelector;
  }/** @public */
  export declare interface ResourceClusterRole extends ResourceBase {
      apiVersion: "rbac.authorization.k8s.io/v1";
      kind: "ClusterRole";
      aggregationRule?: AggregationRule;
      rules?: PolicyRule[];
  }/**
   * RoleRef for {@link k8s.ResourceClusterRoleBinding}
   *
   * @public
   */
  export declare interface RoleRef {
      /** apiGroup is the group for the resource being referenced */
      apiGroup: string;
      /** kind is the type of resource being referenced */
      kind: string;
      /** Name is the name of resource being referenced */
      name: string;
  }/**
   * Subject for {@link k8s.ResourceClusterRoleBinding}
   *
   * @public
   */
  export declare interface Subject {
      /** apiGroup is the group for the object being referenced */
      apiGroup: string;
      /** kind is the type of object being referenced */
      kind: string;
      /**
       * Name of the object being referenced.
       */
      name: string;
      /**
       * Namespace of the referenced object.
       *
       * If the object kind is non-namespace, such as "User" or "Group", and this value
       * is not empty the Authorizer should report an error.
       */
      namespace?: string;
  }/** @public */
  export declare interface ResourceClusterRoleBinding extends ResourceBase {
      apiVersion: "rbac.authorization.k8s.io/v1";
      kind: "ClusterRoleBinding";
      roleRef: RoleRef;
      subjects: Subject[];
  }/** @public */
  export declare interface ResourceDaemonSet extends ResourceBase {
      apiVersion: "apps/v1";
      kind: "DaemonSet";
      spec: DaemonSetSpec;
  }/** @public */
  export declare interface ResourcePod extends ResourceBase {
      kind: "Pod";
      spec: PodSpec;
  }/** @public */
  export declare interface ResourceService extends ResourceBase {
      kind: "Service";
      spec: ServiceSpec;
  }/** @public */
  export declare interface ResourceServiceAccount extends ResourceBase {
      kind: "ServiceAccount";
      automountServiceAccountToken?: boolean;
      imagePullSecrets?: {
          name: string;
      }[];
      secrets?: ObjectReference[];
  }/** @public */
  export declare interface ResourceConfigMap extends ResourceBase {
      kind: "ConfigMap";
      binaryData?: {
          [key: string]: string;
      };
      data?: {
          [key: string]: string;
      };
      /** @beta */
      immutable?: boolean;
  }/** @public */
  export declare interface ResourceSecret extends ResourceBase {
      kind: "Secret";
      data?: {
          [key: string]: string;
      };
      stringData?: {
          [key: string]: string;
      };
      type?: string;
  }/** @public */
  export declare interface ResourceCR extends ResourceBase {
      kind: string;
      spec: CRSpec;
  }/** @public */
  export declare interface Kubeconfig {
      apiVersion?: "v1";
      kind: "Config";
      "current-context": string;
      contexts: {
          name: string;
          context: {
              cluster: string;
              user: string;
          };
      }[];
      clusters: {
          name: string;
          cluster: {
              "certificate-authority-data": string;
              server: string;
          };
      }[];
      preferences?: unknown;
      users: {
          name: string;
          user: {
              "client-certificate-data"?: string;
              "client-key-data"?: string;
              "username"?: string;
              "password"?: string;
          };
      }[];
  }/** @public */
  export declare interface LabelSelector {
      /**
       * matchExpressions is a list of label selector requirements. The requirements are ANDed.
       */
      matchExpressions?: LabelSelectorRequirement[];
      /**
       * matchLabels is a map of `{key,value}`pairs. A single `{key,value}` in the matchLabels map
       * is equivalent to an element of matchExpressions, whose key field is "key", the operator
       * is "In", and the values array contains only "value". The requirements are ANDed.
       */
      matchLabels?: {
          [key: string]: string;
      };
  }/** @public */
  export declare interface LocalObjectReference {
      /**
       * Name of the referent.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names}
       */
      name: string;
  }/**
   * PodTemplateSpec from k8s API
   *
   * @public
   */
  export declare interface PodTemplateSpec {
      /**
       * Standard object's metadata.
       * More Info: {@link https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata}
       */
      metadata: Metadata;
      /**
       * Specification of the desired behavior of the pod.
       * More Info: {@link https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status}
       */
      spec: PodSpec;
  }/**
   * ObjectReference from k8s API
   *
   * @public
   */
  export declare interface ObjectReference {
      /**
       * If referring to a piece of an object instead of an entire object,
       * this string should contain a valid JSON/Go field access statement,
       * such as desiredState.manifest.containers[2].
       *
       * For example, if the object reference is to a container within a pod,
       * this would take on a value like: "spec.containers\{name\}" (where "name"
       * refers to the name of the container that triggered the event) or if no
       * container name is specified "spec.containers[2]"
       * (container with index 2 in this pod).
       * This syntax is chosen only to have some well-defined way of referencing a
       * part of an object.
       */
      fieldPath: string;
      /**
       * Name of the referent.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names}
       *
       */
      name: string;
      /**
       * Namespace of the referent.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/}
       */
      namespace: string;
      /**
       * Specific resourceVersion to which this reference is made, if any.
       *
       * More info: {@link https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency}
       */
      resourceVersion: string;
      /**
       * UID of the referent.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids}
       */
      uid: string;
  }/**
   * Make a {@link k8s.ClusterInfo} object suitable for use with k8s resources
   *
   * @remarks
   *
   * This function will take a set of options and generate a {@link k8s.ClusterInfo}
   * object that contains the kubeconfig, registryPrefix for private images, and any other
   * relevant information for the cluster
   *
   * See {@link k8s.MakeClusterInfoOptions} for information on how the information
   * is computed.
   *
   * @returns A {@link k8s.ClusterInfo} object.
   *
   * @public
   */
  export declare function makeClusterInfo(options: MakeClusterInfoOptions): Promise<ClusterInfo>;/** @internal */
  export declare function isResourcePodTemplate(x: any): x is AdaptElement<ResourcePod>;/**
   * Hook that allows a prop to be either an array of handle to k8s resources and values
   *
   * @param initial - initial value of the prop, before the handles are be resolved
   * @param notReady - is a marker value to indicate that a handle's value isn't available yet
   * @param kinds - an array of legal k8s Kinds that a prop handle can point to
   * @param thisResourceName - the name of the resource using the hook, for error messages
   * @param propName - the name of the prop being resolved, again for error messages
   *
   * @returns A two element array, the first element is the current value, the second the update function
   *
   * This hook will start by returning the initial value and an update function that updates
   * the value the hook returns.  The update function takes 2 arguments - the prop value which
   * is an array with a mix of values and handles to be resolved, and a function that receives
   * the elements that any handles point to along with that elements props.  This function
   * can be passed by the caller of update to resolve handles as appropriate for the component.
   *
   * For example, {@link k8s.ClusterRoleBinding} uses this hook to resolve the subjects prop,
   * which is an array of other objects (typically {@link ServiceAccount}) that a particular
   * {@link k8s.ClusterRole} should point to.  When ClusterRoleBinding calls the update method,
   * it passes a function that will convert a {@link k8s.Resource} element of Kind `ServiceAccount`
   * to the underlying `Subject` object that kubernetes expects, namely
   * `{ apiGroup: "", kind: "ServiceAccount", name: resourceIdToName(elem, deployID), namespace: <element namespace> }`
   *
   * @example
   * ```
   * function MyResource({ serviceAccountNames }: { serviceAccountNames: (string | Handle)[]}) {
   *   const { deployID } = useBuildHelpers();
   *   const [ resolvedServiceAccountNames, updateSANs] = useResources({
   *      initial: [],
   *      notReady: null,
   *      kinds: ["ServiceAccount"],
   *      thisResourceName: "MyResources",
   *      propName: "serviceAccountNames",
   *   });
   *
   *   updateSANs(serviceAccountNames, (e, props) => {
   *      return {
   *        apiGroup: (e.metadata.apiVersion?.split("/")[0]) || "",
   *        name: resourceElementToName(e, deployID),
   *        namespace: props.metadata.namespace,
   *      }
   *   });
   *
   *   return null;
   * }
   * ```
   *
   * @beta
   */
  export declare function useResources<ValT, NotReadyT>({ initial, notReady, kinds, thisResourceName, propName, }: {
      initial: ValT[];
      notReady: NotReadyT;
      kinds: string[];
      thisResourceName: string;
      propName: string;
  }): [
      (ValT | NotReadyT)[],
      (props: (ValT | Handle)[], f: (e: AdaptMountedElement, props: ResourceProps) => Promise<ValT> | ValT) => void
  ];/**
   * Hook to allow conversion of a prop that could be a value or a handle
   *
   * This function behaves similarly to {@link k8s.useResources}, but works for
   * a prop that is either a Handle or a single value instead of an array of
   * Handles and values.
   *
   * See {@link k8s.useResources} for more detailed documentation.
   *
   * @beta
   */
  export declare function useResource<ValT, NotReadyT>(opts: {
      initial: ValT | NotReadyT;
      notReady: NotReadyT;
      kinds: string[];
      thisResourceName: string;
      propName: string;
  }): [
      ValT | NotReadyT,
      (prop: ValT | Handle, f: (e: AdaptMountedElement, props: ResourceProps) => Promise<ValT> | ValT) => void
  ];/**
   * Options for {@link k8s.makeClusterInfo}
   *
   * @public
   */
  export declare interface MakeClusterInfoOptions {
      /**
       * A Javascript Object representing a valid kubeconfig, or a YAML string, or a path to a kubeconfig file.
       *
       * @remarks
       * If this is a Javascript object, it will be treated like a parsed kubeconfig.  If this is a string,
       * {@link k8s.makeClusterInfo} will first attempt to parse it as JSON.  If that fails, it will attempt
       * to parse it as YAML.  If that fails it will treat the string as a path of configs (like with the `KUBECONFIG`
       * environment variable).
       *
       * If kubeconfig is missing {@link k8s.makeClusterInfo} will use the `KUBECONFIG` environment variable to build
       * a suitable config using `kubectl config view --flatten` and return that as the kubeconfig in the resulting
       * {@link k8s.ClusterInfo}
       */
      kubeconfig?: Kubeconfig | string;
      /**
       * URL to the docker registry that this cluster uses to pull private images.
       *
       * @remarks
       * This is identical to the `registryPrefix` field in {@link k8s.ClusterInfo}.  It will
       * be returned verbatim in the resulting {@link k8s.ClusterInfo} object.
       */
      registryPrefix?: string | DockerSplitRegistryInfo;
  }/**
   * k8s ClusterRole resource
   *
   * @param propsIn - props for ServiceAccount as specifed in {@link k8s.ClusterRoleProps}
   *
   * @public
   */
  export declare function ClusterRole(propsIn: SFCDeclProps<ClusterRoleProps, typeof defaultProps>): Adapt.JSX.Element;/** @public */
  export declare function isClusterRoleProps(props: ResourceProps): props is ResourceProps & ResourceClusterRole;/** @internal */
  const clusterRoleResourceInfo: {
      kind: string;
      deployedWhen: () => true;
      statusQuery: (props: ResourcePropsWithConfig, observe: ObserveForStatus, buildData: BuildData) => Promise<any>;
      makeManifest: (manifest: Manifest, elem: AdaptElement<ResourceProps>, _deployID: string) => {
          aggregationRule: AggregationRule | undefined;
          rules: PolicyRule[] | undefined;
          apiVersion: string;
          kind: string;
          metadata: import("./manifest_support").MetadataInRequest;
          spec?: import("./DaemonSet").DaemonSetSpec | import("./common").CRSpec | import("./Pod").PodSpec | import("./Service").ServiceSpec | import("./Deployment").DeploymentSpec | undefined;
      };
  };/**
   * k8s ClusterRoleBinding resource
   *
   * @param propsIn - props for ServiceAccount as specifed in {@link k8s.ClusterRoleBindingProps}
   *
   * @public
   */
  export declare function ClusterRoleBinding(propsIn: SFCDeclProps<ClusterRoleBindingProps, typeof defaultProps>): Adapt.JSX.Element | null;/** @internal */
  const clusterRoleBindingResourceInfo: {
      kind: string;
      deployedWhen: () => true;
      statusQuery: (props: ResourcePropsWithConfig, observe: ObserveForStatus, buildData: BuildData) => Promise<any>;
      makeManifest: (manifest: Manifest, elem: AdaptElement<ResourceProps>, _deployID: string) => {
          roleRef: RoleRef;
          subjects: Subject[];
          apiVersion: string;
          kind: string;
          metadata: import("./manifest_support").MetadataInRequest;
          spec?: import("./DaemonSet").DaemonSetSpec | import("./common").CRSpec | import("./Pod").PodSpec | import("./Service").ServiceSpec | import("./Deployment").DeploymentSpec | undefined;
      };
  };/**
   * k8s ConfigMap resource
   *
   * @param propsIn - props for ConfigMap as specifed in {@link k8s.ConfigMapProps}
   *
   * @public
   */
  export declare function ConfigMap(propsIn: SFCDeclProps<ConfigMapProps, typeof defaultProps>): Adapt.JSX.Element;/** @internal */
  const configMapResourceInfo: {
      kind: string;
      deployedWhen: () => true;
      statusQuery: (props: ResourcePropsWithConfig, observe: ObserveForStatus, buildData: BuildData) => Promise<any>;
      makeManifest: (manifest: Manifest, elem: AdaptElement<ResourceProps>, _deployID: string) => {
          data: {
              [key: string]: string;
          } | undefined;
          binaryData: {
              [key: string]: string;
          } | undefined;
          immutable: boolean | undefined;
          apiVersion: string;
          kind: string;
          metadata: import("./manifest_support").MetadataInRequest;
          spec?: import("./DaemonSet").DaemonSetSpec | import("./common").CRSpec | import("./Pod").PodSpec | import("./Service").ServiceSpec | import("./Deployment").DeploymentSpec | undefined;
      };
  };/**
   * Low level utility function to translate from the abstract {@link Container}
   * component props ({@link ContainerProps}) to {@link k8s.K8sContainerProps}
   * to be used in a {@link k8s.K8sContainer}.
   * @remarks
   * Note: The `image` property in the passed in {@link ContainerProps} must
   * be a `string`, not a `Handle`.
   * In most cases, it is preferable to use the {@link k8s.Container} component
   * instead, which is designed specifically to deal with this issue.
   *
   * @param abstractProps - The abstract {@link ContainerProps} to translate from.
   * @param k8sProps - Props that are specific to the {@link k8s.K8sContainer}
   *     component that should be merged into the resulting returned
   *     {@link k8s.K8sContainerProps} object.
   * @public
   */
  export declare function k8sContainerProps(abstractProps: FromContainerProps, k8sProps?: Partial<K8sContainerProps>): K8sContainerProps;/**
   * Tests whether an element is a {@link k8s.K8sContainer} element
   * @param x - element to test
   * @returns `true` if element is a {@link k8s.K8sContainer}, `false` otherwise
   *
   * @remarks
   * Acts as a TypeScript type assertion that will assert that `x` is `AdaptElement<K8sContainerProps>`
   *
   * @public
   */
  export declare function isK8sContainerElement(x: AdaptElement): x is AdaptElement<K8sContainerProps>;/**
   * Component that implements the abstract {@link Container} interface and
   * translates to a Kubernetes-specific {@link k8s.K8sContainer}.
   * @public
   */
  export declare function Container(props: ContainerProps): Adapt.JSX.Element | null;/** @public */
  export declare interface VolumeMount {
      /**
       * Path within the container at which the volume should be mounted.
       *
       * Must not contain ':'.
       */
      mountPath: string;
      /**
       * mountPropagation determines how mounts are propagated from the host to container and the other way around.
       *
       * When not set, MountPropagationNone is used. This field is beta in 1.10.
       *
       * @defaultValue MountPropagationNone
       */
      mountPropagation?: string;
      /** This must match the Name of a Volume. */
      name: string;
      /**
       * Mounted read-only if true, read-write otherwise (false or unspecified).
       *
       * @defaultValue false
       */
      readOnly?: boolean;
      /**
       * Path within the volume from which the container's volume should be mounted.
       *
       * Defaults to "" (volume's root).
       *
       * @defaultValue ""
       */
      subPath?: string;
      /**
       * Expanded path within the volume from which the container's volume should be mounted.
       *
       * Behaves similarly to SubPath but environment variable references $(VAR_NAME)
       * are expanded using the container's environment.
       *
       * Defaults to "" (volume's root).
       *
       * SubPathExpr and SubPath are mutually exclusive.
       *
       * @defaultValue ""
       */
      subPathExpr?: string;
  }/** @public */
  export declare interface ConfigMapEnvSource {
      /**
       * Name of the referent.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names}
       */
      name?: string;
      /**
       * Specify whether the ConfigMap must be defined
       */
      optional?: boolean;
  }/** @public */
  export declare interface SecretEnvSource {
      /**
       * Name of the referent.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names}
       */
      name?: string;
      /**
       * Specify whether the Secret must be defined
       */
      optional?: boolean;
  }/** @public */
  export declare interface EnvFromSource {
      /** The ConfigMap to select from */
      configMapRef?: ConfigMapEnvSource;
      /** An optional identifier to prepend to each key in the ConfigMap. Must be a C_IDENTIFIER. */
      prefix?: string;
      /** SecretEnvSource	The Secret to select from */
      secretRef?: SecretEnvSource;
  }/** @public */
  export declare interface ExecAction {
      /**
       * Command is the command line to execute inside the container.
       *
       * The working directory for the command is root ('/') in the container's filesystem.
       * The command is simply exec'd, it is not run inside a shell,
       * so traditional shell instructions ('|', etc) won't work.
       * To use a shell, you need to explicitly call out to that shell.
       *
       * Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
       */
      command: string[];
  }/** @public */
  export declare interface HTTPGetAction {
      /**
       * Host name to connect to, defaults to the pod IP.
       *
       * You probably want to set "Host" in httpHeaders instead.
       */
      host?: string;
      /** Custom headers to set in the request. HTTP allows repeated headers. */
      httpHeaders?: {
          name: string;
          value: string;
      }[];
      /** Path to access on the HTTP server. */
      path: string;
      /**
       * Name or number of the port to access on the container.
       *
       * Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
       */
      port: number | string;
      /**
       * Scheme to use for connecting to the host.
       *
       * @defaultValue HTTP.
       */
      scheme?: string;
  }/** @public */
  export declare interface TCPSocketAction {
      /** Host name to connect to, defaults to the pod IP. */
      host?: string;
      /**
       * Number or name of the port to access on the container.
       *
       * Number must be in the range 1 to 65535.
       * Name must be an IANA_SVC_NAME.
       */
      port: string | number;
  }/** @public */
  export declare interface Probe {
      /**
       * Exec specifies the action to take.
       *
       * Only one of exec, httpGet, or tcpSocket should be specified
       */
      exec?: ExecAction;
      /**
       * Minimum consecutive failures for the probe to be considered failed after having succeeded.
       *
       * Defaults to 3. Minimum value is 1.
       *
       * @defaultValue 3
       */
      failureThreshold?: number;
      /** Specifies the http request to perform. */
      httpGet?: HTTPGetAction;
      /**
       *  Seconds after the container has started before liveness probes are initiated.
       *  More info: {@link https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes}
       */
      initialDelaySeconds?: number;
      /** How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. */
      periodSeconds?: number;
      /**
       * Minimum consecutive successes for the probe to be considered successful after having failed.
       *
       * Must be 1 for liveness and startup. Minimum value is 1.
       *
       * @defaultValue 1
       */
      successThreshold?: number;
      /**
       * Specifies an action involving a TCP port.
       *
       * TCP hooks not yet supported
       */
      tcpSocket?: TCPSocketAction;
      /**
       * Number of seconds after which the probe times out.
       *
       * Defaults to 1 second. Minimum value is 1.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes}
       *
       * @defaultValue 1
       */
      timeoutSeconds?: number;
  }/** @public */
  export declare interface ResourceRequirements {
      /**
       * Limits describes the maximum amount of compute resources allowed.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/}
       */
      limits?: {
          [key: string]: any;
      };
      /**
       * Describes the minimum amount of compute resources required.
       *
       * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
       * otherwise to an implementation-defined value.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/}
       */
      requests?: {
          [key: string]: any;
      };
  }/** @public */
  export declare type Handler = {
      exec: ExecAction;
  } | {
      httpGet: HTTPGetAction;
  } | {
      tcpSocket: TCPSocketAction;
  };/** @public */
  export declare interface Lifecycle {
      /**
       * PostStart is called immediately after a container is created.
       *
       * If the handler fails, the container is terminated and restarted according to its restart policy.
       * Other management of the container blocks until the hook completes.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks}
       */
      postStart: Handler;
      /**
       * Called immediately before a container is terminated due to an API request or management event such as liveness/startup probe failure, preemption, resource contention, etc.
       *
       * The handler is not called if the container crashes or exits.
       * The reason for termination is passed to the handler.
       * The Pod's termination grace period countdown begins before the PreStop hooked is executed.
       * Regardless of the outcome of the handler, the container will eventually terminate within the Pod's termination grace period.
       * Other management of the container blocks until the hook completes or until the termination grace period is reached.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks}
       */
      preStop: Handler;
  }/** @public */
  export declare interface VolumeDevice {
      /** The path inside of the container that the device will be mapped to. */
      devicePath: string;
      /** name must match the name of a persistentVolumeClaim in the pod */
      name: string;
  }/**
   * Resource spec for a Kubernetes container.
   * See the Kubernetes
   * {@link https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#container-v1-core | API docs }
   * for more details.
   * @public
   */
  export declare interface ContainerSpec {
      /**
       * Arguments to the entrypoint.
       *
       * The docker image's CMD is used if this is not provided.
       * Variable references $(VAR_NAME) are expanded using the container's environment.
       * If a variable cannot be resolved, the reference in the input string will be unchanged.
       * The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME).
       * Escaped references will never be expanded, regardless of whether the variable exists or not.
       * Cannot be updated.
       * More info: {@link https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell}
       */
      args?: string[];
      /**
       * Entrypoint array.
       *
       * Not executed within a shell.
       * The docker image's ENTRYPOINT is used if this is not provided.
       * Variable references $(VAR_NAME) are expanded using the container's environment.
       * If a variable cannot be resolved, the reference in the input string will be unchanged.
       * The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME).
       * Escaped references will never be expanded, regardless of whether the variable exists or not.
       * Cannot be updated.
       * More info: {@link https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell}
       */
      command?: string[];
      /**
       * List of environment variables to set in the container. Cannot be updated.
       */
      env?: EnvVar[];
      /**
       * List of sources to populate environment variables in the container.
       *
       * The keys defined within a source must be a C_IDENTIFIER.
       * All invalid keys will be reported as an event when the container is starting.
       * When a key exists in multiple sources, the value associated with the last source will take precedence.
       * Values defined by an Env with a duplicate key will take precedence. Cannot be updated.
       */
      envFrom?: EnvFromSource[];
      /**
       * Docker image name.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/containers/images}
       *
       * This field is optional to allow higher level config management to default or override container
       * images in workload controllers like Deployments and StatefulSets.
       */
      image?: string;
      /**
       * Image pull policy.
       *
       * One of Always, Never, IfNotPresent.
       * Defaults to Always if :latest tag is specified,
       * or IfNotPresent otherwise.
       * Cannot be updated.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/containers/images#updating-images}
       */
      imagePullPolicy?: "Always" | "Never" | "IfNotPresent";
      /**
       * List of sources to populate environment variables in the container.
       *
       * The keys defined within a source must be a C_IDENTIFIER.
       * All invalid keys will be reported as an event when the container is starting.
       * When a key exists in multiple sources, the value associated with the last source will take precedence.
       * Values defined by an Env with a duplicate key will take precedence. Cannot be updated.
       */
      lifecycle?: Lifecycle;
      /**
       * Periodic probe of container liveness.
       *
       * Container will be restarted if the probe fails.
       * Cannot be updated.
       * More info: {@link https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes}
       */
      livenessProbe?: Probe;
      /**
       * Name of the container specified as a DNS_LABEL.
       *
       * Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated.
       */
      name: string;
      /**
       * List of ports to expose from the container.
       *
       * Exposing a port here gives the system additional information about the network connections a container uses,
       * but is primarily informational.
       * Not specifying a port here DOES NOT prevent that port from being exposed.
       * Any port which is listening on the default "0.0.0.0" address inside a container will be accessible from
       * the network.
       * Cannot be updated.
       */
      ports?: ContainerPort[];
      /**
       * Periodic probe of container service readiness.
       *
       * Container will be removed from service endpoints if the probe fails.
       * Cannot be updated.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes}
       */
      readinessProbe?: Probe;
      /**
       * Compute Resources required by this container.
       *
       * Cannot be updated.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/}
       */
      resources?: ResourceRequirements;
      /**
       * Security options the pod should run with.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/policy/security-context/}
       * More info: {@link https://kubernetes.io/docs/tasks/configure-pod-container/security-context/}
       */
      securityContext?: PodSecurityContext;
      /**
       * Indicates that the Pod has successfully initialized.
       *
       * If specified, no other probes are executed until this completes successfully.
       * If this probe fails, the Pod will be restarted, just as if the livenessProbe failed.
       * This can be used to provide different probe parameters at the beginning of a Pod's lifecycle,
       * when it might take a long time to load data or warm a cache, than during steady-state operation.
       *
       * This cannot be updated.
       * This is a beta feature enabled by the StartupProbe feature flag.
       * More info: {@link https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes}
       */
      startupProbe?: Probe;
      /**
       * Whether this container should allocate a buffer for stdin in the container runtime.
       *
       * If this is not set, reads from stdin in the container will always result in EOF. Default is false.
       */
      stdin?: boolean;
      /**
       * Whether the container runtime should close the stdin channel after it has been opened by a single attach.
       *
       * When stdin is true the stdin stream will remain open across multiple attach sessions.
       * If stdinOnce is set to true, stdin is opened on container start,
       * is empty until the first client attaches to stdin,
       * and then remains open and accepts data until the client disconnects,
       * at which time stdin is closed and remains closed until the container is restarted.
       * If this flag is false, a container processes that reads from stdin will never receive an EOF. Default is false
       */
      stdinOnce?: boolean;
      /**
       * Path at which the file to which the container's termination message will be written is mounted into the container's filesystem.
       *
       * Message written is intended to be brief final status, such as an assertion failure message.
       * Will be truncated by the node if greater than 4096 bytes.
       * The total message length across all containers will be limited to 12kb.
       * Defaults to /dev/termination-log. Cannot be updated.
       */
      terminationMessagePath?: string;
      /**
       * Indicate how the termination message should be populated.
       *
       * File will use the contents of terminationMessagePath to populate the container status
       * message on both success and failure. FallbackToLogsOnError will use the last chunk of
       * container log output if the termination message file is empty and the container exited
       * with an error.
       * The log output is limited to 2048 bytes or 80 lines, whichever is smaller.
       * Defaults to File.
       * Cannot be updated.
       *
       * @defaultValue File
       */
      terminationMessagePolicy?: "File" | "FallbackToLogsOnError";
      /**
       * Whether this container should allocate a TTY for itself, also requires 'stdin' to be true.
       *
       * @defaultValue false
       */
      tty?: boolean;
      /**
       * volumeDevices is the list of block devices to be used by the container.
       */
      volumeDevices?: VolumeDevice[];
      /** volumeDevices is the list of block devices to be used by the container. */
      volumeMounts?: VolumeMount[];
      /**
       * Container's working directory.
       *
       * If not specified, the container runtime's default will be used,
       * which might be configured in the container image.
       * Cannot be updated.
       */
      workingDir?: string;
  }/**
   * Props for the Kubernetes-specific {@link k8s.K8sContainer} component.
   * @public
   */
  export declare interface K8sContainerProps extends ContainerSpec {
  }/** @public */
  export declare interface ContainerPort {
      /**
       * Number of port to expose on the pod's IP address.
       * @remarks
       * This must be a valid integer port number, `0 < x < 65536`.
       */
      containerPort: number;
      /** What host IP to bind the external port to. */
      hostIP?: string;
      /**
       * Number of port to expose on the host.
       * @remarks
       * If specified, this must be a valid integer port number,
       * `0 < x < 65536`. If HostNetwork is specified,
       * this must match ContainerPort. Most containers do not need this.
       */
      hostPort?: number;
      /**
       * A unique-within-pod name for the container
       * @remarks
       * If specified, this must be an IANA_SVC_NAME and unique within the pod.
       * Each named port in a pod must have a unique name. Name for the port
       * that can be referred to by services.
       */
      name?: string;
      /** Protocol for port. Must be UDP or TCP. Defaults to "TCP". */
      protocol?: string;
  }/** @public */
  export declare type EnvVar = EnvVarSimple | EnvVarFrom;/** @public */
  export declare interface EnvVarSimple {
      /** Name of the environment variable. Must be a C_IDENTIFIER. */
      name: string;
      /**
       * Variable references $(VAR_NAME) are expanded using the previous defined
       * environment variables in the container and any service environment
       * variables. If a variable cannot be resolved, the reference in the input
       * string will be unchanged. The $(VAR_NAME) syntax can be escaped with a
       * double $$, ie: $$(VAR_NAME). Escaped references will never be expanded,
       * regardless of whether the variable exists or not. Defaults to "".
       */
      value: string;
  }/** @public */
  export declare interface EnvVarFrom {
      /** Source for the environment variable's value. Cannot be used if value is not empty. */
      valueFrom?: any;
  }/**
   * See {@link k8s.k8sContainerProps}.
   * @public
   */
  export declare type FromContainerProps = ReplaceT<ContainerProps, {
      image: string;
  }> & BuiltinProps;/**
   * Kubernetes-specific container.
   * @public
   */
  export declare class K8sContainer extends PrimitiveComponent<K8sContainerProps> {
      static defaultProps: {
          imagePullPolicy: string;
      };
      validate(): undefined;
  }/**
   * Props for {@link k8s.Container}.
   * @public
   */
  export declare interface ContainerProps extends SFCDeclProps<ContainerProps> {
      /**
       * Additional {@link k8s.K8sContainerProps}-specific props that should be
       * added to the instantiated {@link k8s.K8sContainer}.
       */
      k8sContainerProps?: Partial<K8sContainerProps>;
  }/**
   * Spec for {@link k8s.DaemonSet} for use in {@link k8s.Resource}
   *
   * @public
   */
  export declare type DaemonSetSpec = Exclude<DaemonSetProps, ResourceBase> & {
      template: PodTemplateSpec;
  };/**
   * Component for Kubernetes DaemonSet
   *
   * @public
   */
  export declare class DaemonSet extends DeferredComponent<DaemonSetProps> {
      static defaultProps: {
          metadata: {};
          minReadySeconds: number;
          revisionHistoryLimit: number;
          updateStrategy: {
              type: string;
              rollingUpdate: {
                  maxUnavailable: number;
              };
          };
      };
      constructor(props: DaemonSetProps);
      build(helpers: BuildHelpers): Adapt.JSX.Element;
      status(_observe: ObserveForStatus, buildData: BuildData): Promise<Adapt.Status | undefined>;
  }/** @internal */
  const daemonSetResourceInfo: {
      kind: string;
      deployedWhen: typeof deployedWhen;
      statusQuery: (props: ResourcePropsWithConfig, observe: ObserveForStatus, buildData: BuildData) => Promise<any>;
  };/** @public */
  export declare interface DeploymentUpdateStrategyRecreate {
      type: "Recreate";
  }/** @public */
  export declare interface RollingUpdateDeployment {
      /**
       * The maximum number of pods that can be scheduled above the desired number of pods.
       *
       * Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
       * This can not be 0 if MaxUnavailable is 0.
       * Absolute number is calculated from percentage by rounding up.
       * Defaults to 25%.
       *
       * @example
       * When this is set to 30%, the new ReplicaSet can be scaled up immediately when the rolling update starts,
       * such that the total number of old and new pods do not exceed 130% of desired pods. Once old pods have been
       * killed, new ReplicaSet can be scaled up further, ensuring that total number of pods running at any time
       * during the update is at most 130% of desired pods.
       */
      maxSurge?: number | string;
      /**
       * The maximum number of pods that can be unavailable during the update.
       *
       * Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
       * Absolute number is calculated from percentage by rounding down.
       * This can not be 0 if MaxSurge is 0. Defaults to 25%.
       *
       * @example
       * When this is set to 30%, the old ReplicaSet can be scaled down to 70% of desired pods
       * immediately when the rolling update starts. Once new pods are ready, old ReplicaSet
       * can be scaled down further, followed by scaling up the new ReplicaSet, ensuring that
       * the total number of pods available at all times during the update is at least 70% of
       * desired pods.
       */
      maxUnavailable?: number | string;
  }/**
   * Spec for {@link k8s.Deployment} for use in {@link k8s.Resource}
   *
   * @public
   */
  export declare type DeploymentSpec = Exclude<DeploymentProps, ResourceBase> & {
      template: PodTemplateSpec;
  };/**
   * Props for {@link k8s.Deployment}
   *
   * @public
   */
  export declare interface DeploymentProps extends WithChildren {
      /** Information about the k8s cluster (ip address, auth info, etc.) */
      config: ClusterInfo;
      /** k8s metadata */
      metadata: Metadata;
      /**
       * The minimum number of seconds for which a newly created pod should
       * be ready without any of its container crashing, for it to be considered
       * available. Defaults to 0 (pod will be considered available as soon as it is ready).
       */
      minReadySeconds: number;
      /** Indicates that the deployment is paused */
      paused: boolean;
      /**
       * The maximum time in seconds for a deployment to make progress before it is considered to be failed.
       *
       * The deployment controller will continue to process failed deployments and a condition with a
       * ProgressDeadlineExceeded reason will be surfaced in the deployment status. Note that progress
       * will not be estimated during the time a deployment is paused. Defaults to 600s.
       */
      progressDeadlineSeconds: number;
      /**
       * Number of desired pods.
       *
       * Defaults to 1. 0 is not allowed.
       *
       * @defaultValue 1
       */
      replicas: number;
      /**
       * The number of old ReplicaSets to retain to allow rollback.
       *
       * This is a pointer to distinguish between explicit zero and not specified. Defaults to 10.
       *
       * @defaultValue 10
       */
      revisionHistoryLimit: number;
      /**
       * Label selector for pods.
       *
       * Existing ReplicaSets whose pods are selected by this will be the ones affected by this deployment.
       * It must match the pod template's labels.
       *
       * @remarks
       *
       * With Adapt, this is optional.  If not specified, adapt will pick a selector that will work with the pods
       * it creates as part of this {@link k8s.Deployment}
       */
      selector?: LabelSelector;
      /**
       * An deployment strategy to use to replace existing pods with new ones
       */
      strategy: DeploymentUpdateStrategy;
  }/**
   * Component for Kubernetes Deployment
   *
   * @public
   */
  export declare class Deployment extends DeferredComponent<DeploymentProps> {
      static defaultProps: {
          metadata: {};
          paused: boolean;
          replicas: number;
          progressDeadlineSeconds: number;
          minReadySeconds: number;
          revisionHistoryLimit: number;
          strategy: {
              type: string;
              rollingUpdate: {
                  maxSurge: string;
                  maxUnavailable: string;
              };
          };
      };
      constructor(props: DeploymentProps);
      build(helpers: BuildHelpers): Adapt.JSX.Element | null;
      deployedWhen: () => true | Adapt.Waiting;
      status(_observe: ObserveForStatus, buildData: BuildData): Promise<Adapt.Status | undefined>;
  }/** @internal */
  const deploymentResourceInfo: {
      kind: string;
      deployedWhen: typeof deployedWhen;
      statusQuery: (props: ResourcePropsWithConfig, observe: ObserveForStatus, buildData: BuildData) => Promise<any>;
  };/**
   * Type assertion to see if an element is both a {@link k8s.Resource | Resource}
   * and a {@link @adpt/core#FinalElement | FinalElement}
   *
   * @param e - element to test
   * @returns `true` if e is both a FinalElement and a {@link k8s.Resource | Resource}, `false` otherwise
   *
   * @public
   */
  export declare function isResourceFinalElement(e: AdaptElement): e is FinalDomElement<ResourceProps & Adapt.BuiltinProps>;/**
   * Tests whether a ResourceProps is for a template object
   *
   * @public
   */
  export declare function isResourcePropsWithConfig(x: ResourceProps & Partial<BuiltinProps>): x is ResourcePropsWithConfig & Partial<BuiltinProps>;/**
   * Tests to see if an object is a {@link k8s.Resource} element
   * @param x - object to test
   * @returns true if object is an AdaptElement of type {@link k8s.Resource}
   *
   * @public
   */
  export declare function isResource(x: any): x is AdaptElement<ResourceProps>;/**
   * Primitive Component recognized by the k8s plugin to represent resources
   * @public
   */
  export declare class Resource extends Action<ResourceProps> {
      defaultProps: {
          apiVersion: "v1";
          con: false;
      };
      manifest_: Manifest;
      constructor(props: ResourceProps);
      validate(): "Resource elements cannot have children" | undefined;
      shouldAct(op: ChangeType, ctx: ActionContext): Promise<ShouldAct>;
      action(op: ChangeType, ctx: ActionContext): Promise<void>;
      deployedWhen: (goalStatus: GoalStatus, helpers: DeployHelpers) => Promise<true | Adapt.Waiting | Adapt.Waiting[]>;
      status(observe: ObserveForStatus, buildData: BuildData): Promise<any>;
      private mountedElement;
      private manifest;
  }/** @internal */
  export declare function makePodManifest(props: PodProps & BuiltinProps, data: {
      volumes?: Volume[];
      serviceAccountName?: string;
  }): {
      kind: string;
      metadata: Metadata;
      spec: PodSpec;
  };/**
   * Tests whether x is a Pod element
   *
   * @param x - value to test
   * @returns `true` if x is a Pod element, false otherwise
   *
   * @public
   */
  export declare function isPod(x: any): x is AdaptElement<PodProps>;/** @public */
  export declare interface NodeSelectorRequirement {
      /** The label key that the selector applies to. */
      key: string;
      /**
       * Represents a key's relationship to a set of values.
       *
       * Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
       */
      operator: "In" | "NotIn" | "Exists" | "DoesNotExist" | "Gt" | "Lt";
      /**
       * Values for operator
       *
       * If the operator is In or NotIn, the values array must be non-empty.
       * If the operator is Exists or DoesNotExist, the values array must be empty.
       * If the operator is Gt or Lt, the values array must have a single element,
       * which will be interpreted as an integer.
       * This array is replaced during a strategic merge patch.
       */
      values: string[];
  }/** @public */
  export declare interface NodeSelectorTerm {
      /** A list of node selector requirements by node's labels. */
      matchExpressions?: NodeSelectorRequirement[];
      /** A list of node selector requirements by node's fields. */
      matchFields?: NodeSelectorRequirement[];
  }/** @public */
  export declare interface PreferredSchedulingTerm {
      /**
       * A node selector term, associated with the corresponding weight.
       */
      preference: NodeSelectorTerm;
      /** Weight associated with matching the corresponding nodeSelectorTerm, in the range 1-100. */
      weight: number;
  }/** @public */
  export declare interface NodeSelector {
      /** A list of node selector terms. The terms are ORed */
      nodeSelectorTerms: NodeSelectorTerm[];
  }/** @public */
  export declare interface NodeAffinity {
      /** The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding "weight" to the sum if the node matches the corresponding matchExpressions; the node(s) with the highest sum are the most preferred. */
      preferredDuringSchedulingIgnoredDuringExecution?: PreferredSchedulingTerm[];
      /** If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to an update), the system may or may not try to eventually evict the pod from its node. */
      requiredDuringSchedulingIgnoredDuringExecution?: NodeSelector;
  }/** @public */
  export declare interface PodAffinityTerm {
      /**
       * Label query over a set of resources, in this case pods.
       */
      labelSelector: LabelSelector;
      /** Specifies which namespaces the labelSelector applies to (matches against); null or empty list means "this pod's namespace" */
      namespaces?: string[];
      /** This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed. */
      topologyKey: string;
  }/** @public */
  export declare interface WeightedPodAffinityTerm {
      /** A pod affinity term, associated with the corresponding weight. */
      podAffinityTerm: PodAffinityTerm;
      /**
       * weight associated with matching the corresponding podAffinityTerm, in the range 1-100.
       */
      weight: number;
  }/** @public */
  export declare interface PodAffinity {
      /**
       * The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions.
       *
       * The node that is most preferred is the one with the greatest sum of weights,
       * i.e. for each node that meets all of the scheduling requirements (resource request,
       * requiredDuringScheduling affinity expressions, etc.), compute a sum by iterating
       * through the elements of this field and adding "weight" to the sum if the node has pods
       * which matches the corresponding podAffinityTerm; the node(s) with the highest sum are the most preferred.
       */
      preferredDuringSchedulingIgnoredDuringExecution: WeightedPodAffinityTerm[];
      /**
       * If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node.
       *
       * If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system may or may not try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each podAffinityTerm are intersected, i.e. all terms must be satisfied.
       */
      requiredDuringSchedulingIgnoredDuringExecution: PodAffinityTerm[];
  }/** @public */
  export declare interface PodAntiAffinity {
      /** The scheduler will prefer to schedule pods to nodes that satisfy the anti-affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling anti-affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the node(s) with the highest sum are the most preferred. */
      preferredDuringSchedulingIgnoredDuringExecution: WeightedPodAffinityTerm[];
      /** If the anti-affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the anti-affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system may or may not try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each podAffinityTerm are intersected, i.e. all terms must be satisfied. */
      requiredDuringSchedulingIgnoredDuringExecution: PodAffinity;
  }/** @public */
  export declare interface Affinity {
      /** Describes node affinity scheduling rules for the pod. */
      nodeAffinity: NodeAffinity;
      /** Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)). */
      podAffinity: PodAffinity;
      /** PodAntiAffinity	Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)). */
      podAntiAffinity: PodAntiAffinity;
  }/** @public */
  export declare interface PodDNSConfigOption {
      name: string;
      value?: string;
  }/** @public */
  export declare interface PodDNSConfig {
      /**
       * A list of DNS name server IP addresses.
       *
       * This will be appended to the base nameservers generated from DNSPolicy. Duplicated nameservers will be removed.
       */
      nameservers: string[];
      /**
       * A list of DNS resolver options.
       *
       * This will be merged with the base options generated from DNSPolicy.
       * Duplicated entries will be removed.
       * Resolution options given in Options will override those that appear in the base DNSPolicy.
       */
      options: PodDNSConfigOption[];
      /**
       * A list of DNS search domains for host-name lookup.
       *
       * This will be appended to the base search paths generated from DNSPolicy. Duplicated search paths will be removed.
       */
      searches: string[];
  }/** @public */
  export declare interface PodReadinessGate {
      /** Refers to a condition in the pod's condition list with matching type. */
      conditionType: string;
  }/** @public */
  export declare interface SELinuxOptions {
      /** SELinux level label that applies to the container. */
      level: string;
      /** SELinux role label that applies to the container. */
      role: string;
      /** SELinux type label that applies to the container. */
      type: string;
      /** SELinux user label that applies to the container */
      user: string;
  }/** @public */
  export declare interface SeccompProfile {
      /**
       * Indicates a profile defined in a file on the node should be used.
       *
       * The profile must be preconfigured on the node to work.
       * Must be a descending path, relative to the kubelet's configured seccomp profile location.
       * Must only be set if type is "Localhost".
       */
      localhostProfile?: string;
      /**
       * Indicates which kind of seccomp profile will be applied.
       *
       * Valid options are:
       * * Localhost - a profile defined in a file on the node should be used.
       * * RuntimeDefault - the container runtime default profile should be used.
       * * Unconfined - no profile should be applied.
       */
      type: "Localhost" | "RuntimeDefault" | "Unconfined";
  }/** @public */
  export declare interface Sysctl {
      name: string;
      value: string;
  }/** @public */
  export declare interface WindowsSecurityContextOptions {
      /**
       * The GMSA admission webhook ({@link https://github.com/kubernetes-sigs/windows-gmsa}) inlines the contents of the GMSA credential spec named by the GMSACredentialSpecName field.
       */
      gmsaCredentialSpec?: string;
      /**
       * GMSACredentialSpecName is the name of the GMSA credential spec to use.
       */
      gmsaCredentialSpecName?: string;
      /**
       * The UserName in Windows to run the entrypoint of the container process.
       *
       * Defaults to the user specified in image metadata if unspecified. May also be set in PodSecurityContext.
       * If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
       */
      runAsUserName?: string;
  }/** @public */
  export declare interface PodSecurityContext {
      /**
       * A special supplemental group that applies to all containers in a pod.
       *
       * Some volume types allow the Kubelet to change the ownership of that volume to be owned by the pod:
       *
       * 1. The owning GID will be the FSGroup
       * 2. The setgid bit is set (new files created in the volume will be owned by FSGroup)
       * 3. The permission bits are OR'd with rw-rw----
       *
       * If unset, the Kubelet will not modify the ownership and permissions of any volume.
       */
      fsGroup?: number;
      /**
       * Defines behavior of changing ownership and permission of the volume before being exposed inside Pod.
       *
       * This field will only apply to volume types which support fsGroup based ownership(and permissions).
       * It will have no effect on ephemeral volume types such as: secret, configmaps and emptydir.
       * Valid values are "OnRootMismatch" and "Always". If not specified defaults to "Always".
       *
       * @defaultValue Always
       */
      fsGroupChangePolicy?: "OnRootMismatch" | "Always";
      /**
       * The GID to run the entrypoint of the container process.
       *
       * Uses runtime default if unset. May also be set in SecurityContext.
       * If set in both SecurityContext and PodSecurityContext, the value specified in
       * SecurityContext takes precedence for that container.
       */
      runAsGroup?: number;
      /**
       * Indicates that the container must run as a non-root user.
       *
       * If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and
       * fail to start the container if it does. If unset or false, no such validation will be performed.
       * May also be set in SecurityContext.
       * If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
       */
      runAsNonRoot?: boolean;
      /**
       * The UID to run the entrypoint of the container process.
       *
       * Defaults to user specified in image metadata if unspecified.
       * May also be set in SecurityContext.
       * If set in both SecurityContext and PodSecurityContext, the value specified in
       * SecurityContext takes precedence for that container.
       */
      runAsUser?: number;
      /**
       * The SELinux context to be applied to all containers.
       *
       * If unspecified, the container runtime will allocate a random SELinux context for each container.
       * May also be set in SecurityContext.
       * If set in both SecurityContext and PodSecurityContext, the value specified in
       * SecurityContext takes precedence for that container.
       */
      seLinuxOptions?: SELinuxOptions;
      /**
       * The seccomp options to use by the containers in this pod.
       */
      seccompProfile?: SeccompProfile;
      /**
       * 	A list of groups applied to the first process run in each container, in addition to the container's primary GID.
       *
       *  If unspecified, no groups will be added to any container.
       */
      supplementalGroups?: number[];
      /**
       * Sysctls hold a list of namespaced sysctls used for the pod.
       *
       * Pods with unsupported sysctls (by the container runtime) might fail to launch.
       */
      sysctls?: Sysctl[];
      /**
       * The Windows specific settings applied to all containers.
       *
       * If unspecified, the options within a container's SecurityContext will be used.
       * If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
       */
      windowsOptions: WindowsSecurityContextOptions;
  }/** @public */
  export declare interface Toleration {
      /**
       * Indicates the taint effect to match.
       *
       * Empty means match all taint effects.
       * When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
       */
      effect?: "NoSchedule" | "PreferNoSchedule" | "NoExecute";
      /**
       * The taint key that the toleration applies to.
       *
       * Empty means match all taint keys.
       * If the key is empty, operator must be Exists;
       * this combination means to match all values and all keys.
       */
      key?: string;
      /**
       * Represents a key's relationship to the value.
       *
       * Valid operators are Exists and Equal.
       * Defaults to Equal.
       * Exists is equivalent to wildcard for value, so that a pod can tolerate all taints of a particular category.
       *
       * @defaultValue Equal
       */
      operator?: "Exists" | "Equal";
      /**
       * Represents the period of time the toleration (which must be of effect NoExecute, otherwise this field is ignored) tolerates the taint.
       *
       * By default, it is not set, which means tolerate the taint forever (do not evict).
       * Zero and negative values will be treated as 0 (evict immediately) by the system.
       */
      tolerationSeconds?: number;
      /**
       * Value is the taint value the toleration matches to.
       *
       * If the operator is Exists, the value should be empty, otherwise just a regular string.
       */
      value?: string;
  }/** @public */
  export declare interface TopologySpreadConstraint {
      /**
       * Used to find matching pods.
       *
       * Pods that match this label selector are counted to determine the
       * number of pods in their corresponding topology domain.
       */
      labelSelector: LabelSelector;
      /**
       * Describes the degree to which pods may be unevenly distributed.
       *
       * When `whenUnsatisfiable=DoNotSchedule`, it is the maximum permitted
       * difference between the number of matching pods in the target topology
       * and the global minimum.
       * For example, in a 3-zone cluster, MaxSkew is set to 1, and pods with
       * the same labelSelector spread as 1/1/0: | zone1 | zone2 | zone3 | | P | P | |
       * - if MaxSkew is 1, incoming pod can only be scheduled to zone3 to become 1/1/1;
       *   scheduling it onto zone1(zone2) would make the ActualSkew(2-0) on zone1(zone2) violate MaxSkew(1).
       * - if MaxSkew is 2, incoming pod can be scheduled onto any zone.
       * When `whenUnsatisfiable=ScheduleAnyway`, it is used to give higher precedence to topologies that satisfy it.
       * It's a required field. Default value is 1 and 0 is not allowed.
       *
       * @example
       *
       * @defaultValue 1
       */
      maxSkew: number;
      /**
       * The key of node labels.
       *
       * Nodes that have a label with this key and identical values are considered to be in the same topology.
       * We consider each \<key, value\> as a "bucket", and try to put balanced number of pods into each bucket.
       * It's a required field.
       */
      topologyKey: string;
      /**
       * Indicates how to deal with a pod if it doesn't satisfy the spread constraint.
       *
       * - DoNotSchedule (default) tells the scheduler not to schedule it.
       * - ScheduleAnyway tells the scheduler to schedule the pod in any location,
       *   but giving higher precedence to topologies that would help reduce the skew.
       *
       * A constraint is considered "Unsatisfiable" for an incoming pod if and only if every possible
       * node assigment for that pod would violate "MaxSkew" on some topology.
       * For example, in a 3-zone cluster, MaxSkew is set to 1, and pods with the same labelSelector
       * spread as 3/1/1: | zone1 | zone2 | zone3 | | P P P | P | P | If WhenUnsatisfiable is set to DoNotSchedule,
       * incoming pod can only be scheduled to zone2(zone3) to become 3/2/1(3/1/2)
       * as ActualSkew(2-1) on zone2(zone3) satisfies MaxSkew(1).
       * In other words, the cluster can still be imbalanced, but scheduler won't make it
       * *more* imbalanced.
       *
       * It's a required field.
       */
      whenUnsatisfiable: string;
  }/** @public */
  export declare interface KeyToPath {
      /** The key to project. */
      key: string;
      /**
       * mode bits to use on this file,
       * Must be a value between 0 and 0777.
       * If not specified, the volume defaultMode will be used.
       * This might be in conflict with other options that affect the file mode, like fsGroup,
       * and the result can be other mode bits set.
       */
      mode?: number;
      /**
       * The relative path of the file to map the key to.
       *
       * May not be an absolute path. May not contain the path element '..'. May not start with the string '..'.
       */
      path: string;
  }/** @public */
  export declare interface ConfigMapVolumeSource {
      /**
       * mode bits to use on created files by default.
       *
       * Must be a value between 0 and 0777. Defaults to 0644.
       * Directories within the path are not affected by this setting.
       * This might be in conflict with other options that affect the file mode,
       * like fsGroup, and the result can be other mode bits set.
       */
      defaultMode?: number;
      /**
       * If unspecified, each key-value pair in the Data field of the referenced ConfigMap will be projected into the volume as a file whose name is the key and content is the value.
       *
       * If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present.
       * If a key is specified which is not present in the ConfigMap, the volume setup will error unless it is marked optional.
       * Paths must be relative and may not contain the '..' path or start with '..'.
       */
      items?: KeyToPath[];
      /**
       * Name of the referent.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names}
       */
      name: string | Handle;
      /** Specify whether the ConfigMap or its keys must be defined */
      optional?: boolean;
  }/** @public */
  export declare interface SecretVolumeSource {
      /**
       * mode bits to use on created files by default.
       *
       * Must be a value between 0 and 0777. Defaults to 0644.
       * Directories within the path are not affected by this setting.
       * This might be in conflict with other options that affect the file mode,
       * like fsGroup, and the result can be other mode bits set.
       */
      defaultMode?: number;
      /**
       * If unspecified, each key-value pair in the Data field of the referenced Secret will be projected into the volume as a file whose name is the key and content is the value.
       *
       * If specified, the listed keys will be projected into the specified paths,
       * and unlisted keys will not be present. If a key is specified which is not
       * present in the Secret, the volume setup will error unless it is marked optional.
       *
       * Paths must be relative and may not contain the '..' path or start with '..'.
       */
      items?: KeyToPath[];
      /** Specify whether the Secret or its keys must be defined */
      optional?: boolean;
      /**
       * Name of the secret in the pod's namespace to use.
       *
       *  More info: {@link https://kubernetes.io/docs/concepts/storage/volumes#secret}
       */
      secretName: string | Handle;
  }/** @public */
  export declare interface EmptyDirVolumeSource {
      /**
       * What type of storage medium should back this directory.
       *
       * The default is "" which means to use the node's default medium.
       * Must be an empty string (default) or Memory.
       * More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
       */
      medium: string;
      /**
       * Total amount of local storage required for this EmptyDir volume.
       *
       * The size limit is also applicable for memory medium.
       * The maximum usage on memory medium EmptyDir would be the minimum
       * value between the SizeLimit specified here and the sum of memory limits of all containers in a pod.
       * The default is nil which means that the limit is undefined.
       * More info: {@link http://kubernetes.io/docs/user-guide/volumes#emptydir}
       */
      sizeLimit: string;
  }/**
   * Volumes for {@link k8s.PodProps}
   *
   * @public
   */
  export declare interface Volume {
      /**
       * Volume's name.
       *
       * Must be a DNS_LABEL and unique within the pod.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names}
       */
      name: string;
      /**
       * Represents a configMap that should populate this volume
       */
      configMap?: ConfigMapVolumeSource;
      /**
       * EmptyDir represents a temporary directory that shares a pod's lifetime.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/storage/volumes#emptydir}
       *
       */
      emptyDir?: EmptyDirVolumeSource;
      /**
       * Represents a secret that should populate this volume.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/storage/volumes#secret}
       */
      secret?: SecretVolumeSource;
      /** Other k8s volume kinds not typed yet for \@adpt/cloud */
      [key: string]: any;
  }/**
   * Props for the {@link k8s.Pod} component
   *
   * @public
   */
  export declare interface PodProps extends WithChildren {
      /**
       *  True is this is a template for use in a controller, false otherwise
       *  @defaultValue false
       */
      isTemplate: boolean;
      /** Information about the k8s cluster (ip address, auth info, etc.) */
      config?: ClusterInfo;
      /** k8s metadata */
      metadata: Metadata;
      /**
       * Optional duration in seconds the pod may be active on the node relative to StartTime before the system will actively try to mark it failed and kill associated containers.
       *
       * Value must be a positive integer.
       */
      activeDeadlineSeconds?: number;
      /** If specified, the pod's scheduling constraints */
      affinity?: Affinity;
      /** AutomountServiceAccountToken indicates whether a service account token should be automatically mounted. */
      automountServiceAccountToken?: boolean;
      /**
       *  Specifies the DNS parameters of a pod.
       *
       *  Parameters specified here will be merged to the generated DNS configuration based on DNSPolicy.
       */
      dnsConfig?: PodDNSConfig;
      /**
       * Set DNS policy for the pod.
       *
       * Valid values are 'ClusterFirstWithHostNet', 'ClusterFirst', 'Default' or 'None'.
       * DNS parameters given in DNSConfig will be merged with the policy selected with DNSPolicy.
       * To have DNS options set along with hostNetwork, you have to specify DNS policy explicitly
       * to 'ClusterFirstWithHostNet'.
       *
       * @defaultValue ClusterFirst
       */
      dnsPolicy: "ClusterFirstWithHostNet" | "ClusterFirst" | "Default" | "None";
      /**
       * Indicates whether information about services should be injected into pod's environment variables matching the syntax of Docker links.
       *
       * @defaultValue true
       */
      enableServiceLinks: boolean;
      /**
       * An optional list of hosts and IPs that will be injected into the pod's hosts file if specified.
       *
       * This is only valid for non-hostNetwork pods.
       */
      hostAliases?: HostAlias[];
      /**
       * Use the host's ipc namespace.
       * @defaultValue false
       */
      hostIPC: boolean;
      /**
       * Host networking requested for this pod.
       *
       * Use the host's network namespace.
       * If this option is set, the ports that will be used must be specified. Default to false.
       */
      hostNetwork?: boolean;
      /**
       * Use the host's pid namespace.
       * @defaultValue false
       */
      hostPID: boolean;
      /**
       * Specifies the hostname of the Pod.
       *
       * If not specified, the pod's hostname will be set to a system-defined value.
       */
      hostname?: string;
      /**
       * List of references to secrets in the same namespace to use for pulling any of the images used by this PodSpec.
       *
       * If specified, these secrets will be passed to individual puller implementations for them to use.
       * For example, in the case of docker, only DockerConfig type secrets are honored.
       * More info: {@link https://kubernetes.io/docs/concepts/containers/images#specifying-imagepullsecrets-on-a-pod}
       */
      imagePullSecrets?: LocalObjectReference[];
      /**
       * A request to schedule this pod onto a specific node.
       *
       * If it is non-empty, the scheduler simply schedules this pod onto that node,
       * assuming that it fits resource requirements.
       */
      nodeName?: string;
      /**
       * A selector which must be true for the pod to fit on a node.
       *
       * Selector which must match a node's labels for the pod to be scheduled on that node.
       * More info: {@link https://kubernetes.io/docs/concepts/configuration/assign-pod-node/}
       */
      nodeSelector?: {
          [label: string]: boolean | string;
      };
      /**
       * Overhead represents the resource overhead associated with running a pod for a given RuntimeClass.
       *
       * This field will be autopopulated at admission time by the RuntimeClass admission controller.
       * If the RuntimeClass admission controller is enabled, overhead must not be set in Pod create requests.
       * The RuntimeClass admission controller will reject Pod create requests which have the overhead already set.
       * If RuntimeClass is configured and selected in the PodSpec, Overhead will be set to the value defined in
       * the corresponding RuntimeClass, otherwise it will remain unset and treated as zero.
       *
       * More info: {@link https://git.k8s.io/enhancements/keps/sig-node/20190226-pod-overhead.md}
       *
       * This field is alpha-level as of Kubernetes v1.16, and is only honored by servers that enable
       * the PodOverhead feature.
       * @alpha
       */
      overhead?: unknown;
      /**
       * PreemptionPolicy is the Policy for preempting pods with lower priority.
       *
       * This field is beta-level, gated by the NonPreemptingPriority feature-gate.
       *
       * @defaultValue PreemptLowerPriority
       * @beta
       */
      preemptionPolicy?: "Never" | "PreemptLowerPriority";
      /**
       * The priority various system components use this field to find the priority of the pod.
       *
       * When Priority Admission Controller is enabled, it prevents users from setting this field.
       * The admission controller populates this field from PriorityClassName.
       * The higher the value, the higher the priority.
       */
      priority?: number;
      /**
       * If specified, indicates the pod's priority.
       *
       * "system-node-critical" and "system-cluster-critical" are two special keywords which indicate the highest
       * priorities with the former being the highest priority. Any other name must be defined by creating a PriorityClass
       * object with that name. If not specified, the pod priority will be default or zero if there is no default.
       */
      priorityClassName?: string;
      /**
       *  If specified, all readiness gates will be evaluated for pod readiness.
       *
       *  A pod is ready when all its containers are ready AND all conditions specified
       *  in the readiness gates have status equal to "True"
       *
       *  More info: {@link https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#pod-readiness-gate}
       */
      readinessGates?: PodReadinessGate[];
      /**
       * Restart policy for all containers within the pod.
       *
       * One of Always, OnFailure, Never. Default to Always.
       * More info: {@link https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy}
       *
       * @defaultValue Always
       */
      restartPolicy: "Always" | "OnFailure" | "Never";
      /**
       * Refers to a RuntimeClass object in the node.k8s.io group, which should be used to run this pod.
       *
       * If no RuntimeClass resource matches the named class, the pod will not be run.
       * If unset or empty, the "legacy" RuntimeClass will be used, which is an implicit
       * class with an empty definition that uses the default runtime handler.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/containers/runtime-class/}
       *
       * This is a beta feature as of Kubernetes v1.14.
       */
      runtimeClassName?: string;
      /**
       *  If specified, the pod will be dispatched by specified scheduler.
       *  If not specified, the pod will be dispatched by default scheduler.
       */
      schedulerName?: string;
      /**
       * SecurityContext holds pod-level security attributes and common container settings.
       * See type description for default values of each field.
       *
       * @defaultValue \{\}
       */
      securityContext: PodSecurityContext;
      /**
       * ServiceAccountName is the name of the ServiceAccount to use to run this pod.
       * More info: {@link https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/}
       */
      serviceAccountName?: string | Handle;
      /**
       * If true the pod's hostname will be configured as the pod's FQDN, rather than the leaf name (the default).
       * In Linux containers, this means setting the FQDN in the hostname field of the kernel
       * (the nodename field of struct utsname).
       * In Windows containers, this means setting the registry value of hostname for the registry key
       * HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters to FQDN.
       * If a pod does not have FQDN, this has no effect.
       *
       * @defaultValue false
       */
      setHostnameAsFQDN?: boolean;
      /**
       * Share a single process namespace between all of the containers in a pod.
       * When this is set containers will be able to view and signal processes from other containers in the same pod,
       * and the first process in each container will not be assigned PID 1.
       * HostPID and ShareProcessNamespace cannot both be set.
       *
       * @defaultValue false
       */
      shareProcessNamespace: boolean;
      /**
       *  If specified, the fully qualified Pod hostname will be "\<hostname\>.\<subdomain\>.\<pod namespace\>.svc.\<cluster domain\>".
       *  If not specified, the pod will not have a domainname at all.
       */
      subdomain?: string;
      /**
       * Optional duration in seconds the pod needs to terminate gracefully.
       *
       * May be decreased in delete request. Value must be non-negative integer.
       * The value zero indicates delete immediately. If this value is nil, the default
       * grace period will be used instead. The grace period is the duration in seconds
       * after the processes running in the pod are sent a termination signal and the time
       * when the processes are forcibly halted with a kill signal. Set this value longer
       * than the expected cleanup time for your process. Defaults to 30 seconds.
       */
      terminationGracePeriodSeconds?: number;
      /** If specified, the pod's tolerations. */
      tolerations?: Toleration[];
      /**
       *  TopologySpreadConstraints describes how a group of pods ought to spread across topology domains.
       *
       *  Scheduler will schedule pods in a way which abides by the constraints. All topologySpreadConstraints are ANDed.
       */
      topologySpreadConstraints?: TopologySpreadConstraint[];
      /**
       * List of volumes that can be mounted by containers belonging to the pod.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/storage/volumes}
       */
      volumes?: Volume[];
  }/**
   * Component for Kubernetes Pods
   *
   * @public
   */
  export declare class Pod extends DeferredComponent<PodProps, ResolvedVolumes & ResolvedServiceAccountName> {
      static defaultProps: {
          isTemplate: boolean;
          metadata: {};
          dnsPolicy: string;
          enableServiceLinks: boolean;
          hostIPC: boolean;
          hostPID: boolean;
          restartPolicy: string;
          securityContext: {};
          shareProcessNamespace: boolean;
          terminationGracePeriodSeconds: number;
      };
      initialState(): {};
      build(helpers: BuildHelpers): Adapt.JSX.Element | null;
      status(_observe: ObserveForStatus, buildData: BuildData): Promise<Adapt.Status | undefined>;
  }/**
   * Spec for for Kubernetes Pods
   *
   * @public
   */
  export declare interface PodSpec extends Omit<PodProps, "config" | "metadata" | "isTemplate"> {
      containers: ContainerSpec[];
      terminationGracePeriodSeconds?: number;
  }/** @internal */
  const podResourceInfo: {
      kind: string;
      deployedWhen: typeof deployedWhen;
      statusQuery: (props: ResourcePropsWithConfig, observe: ObserveForStatus, buildData: BuildData) => Promise<any>;
  };/**
   * k8s Secret resource
   *
   * @param propsIn - props for Secret as specifed in {@link k8s.SecretProps}
   *
   * @public
   */
  export declare function Secret(propsIn: SFCDeclProps<SecretProps, typeof defaultProps>): Adapt.JSX.Element;/** @internal */
  const secretResourceInfo: {
      kind: string;
      deployedWhen: () => true;
      statusQuery: (props: ResourcePropsWithConfig, observe: ObserveForStatus, buildData: BuildData) => Promise<any>;
      makeManifest: (manifest: Manifest, elem: AdaptElement<ResourceProps>, _deployID: string) => {
          data: {
              [key: string]: string;
          } | undefined;
          stringData: {
              [key: string]: string;
          } | undefined;
          type: string | undefined;
          apiVersion: string; /**
           * stringData allows specifying non-binary secret data in string form.
           *
           * It is provided as a write-only convenience method. All keys and values are merged into the data field on write,
           * overwriting any existing values. It is never output when reading from the API.
           */
          kind: string;
          metadata: import("./manifest_support").MetadataInRequest;
          spec?: import("./DaemonSet").DaemonSetSpec | import("./common").CRSpec | import("./Pod").PodSpec | import("./Service").ServiceSpec | import("./Deployment").DeploymentSpec | undefined;
      };
  };/**
   * Convert {@link NetworkService} props to {@link k8s.Service} props
   * @param abstractProps - props to convert
   * @returns Kubernetes spec corresponding to `abstractProps`
   *
   * @internal
   */
  export declare function k8sServiceProps(abstractProps: NetworkServiceProps & BuiltinProps): Omit<ServiceProps, keyof ResourceBase>;/**
   * Native Kubernetes Service resource
   *
   * @remarks
   *
   * Implements the {@link NetworkServiceInstance} interface.
   *
   * @public
   */
  export declare function Service(propsIn: SFCDeclProps<ServiceProps, typeof defaultProps>): Adapt.JSX.Element;/** @public */
  export declare interface ServiceProps extends ServiceSpec {
      /** Legal configuration loaded from kubeconfig */
      config: ClusterInfo;
      metadata?: Metadata;
      selector?: Handle | EndpointSelector;
  }/** @public */
  export declare interface ServiceSpec {
      /**
       * Cluster IP for a {@link k8s.Service}
       *
       * @remarks
       * `clusterIP` is the IP address of the service and is usually assigned
       * randomly by the master. If an address is specified manually and is not
       * in use by others, it will be allocated to the service; otherwise,
       * creation of the service will fail. This field can not be changed through
       * updates. Valid values are "None", empty string (""), or a valid IP
       * address. "None" can be specified for headless services when proxying is
       * not required. Only applies to types ClusterIP, NodePort, and
       * LoadBalancer. Ignored if type is ExternalName.
       *
       * For more information, see the
       * {@link https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies |
       * Kubernetes documentation}.
       */
      clusterIP?: string;
      /**
       * A list of IP addresses for which nodes in the cluster
       * will also accept traffic for this service.
       *
       * @remarks
       * These IPs are not managed by
       * Kubernetes. The user is responsible for ensuring that traffic arrives at
       * a node with this IP. A common example is external load balancers that are
       * not part of the Kubernetes system.
       */
      externalIPs?: string[];
      /**
       * The external reference that kubedns or equivalent
       * will return as a CNAME record for this service.
       *
       * @remarks
       * No proxying will be involved. Must be a
       * {@link https://tools.ietf.org/html/rfc1123 | valid RFC-1123 hostname}
       * and requires Type to be ExternalName.
       */
      externalName?: string;
      /**
       * Denotes if this Service desires to route
       * external traffic to node-local or cluster-wide endpoints.
       *
       * @remarks
       * "Local" preserves the client source IP and avoids a second hop for
       * LoadBalancer and Nodeport type services, but risks potentially
       * imbalanced traffic spreading. "Cluster" obscures the client source IP
       * and may cause a second hop to another node, but should have good overall
       * load-spreading.
       */
      externalTrafficPolicy?: string;
      /**
       * Specifies the healthcheck nodePort for the service.
       *
       * @remarks
       * If not specified, HealthCheckNodePort is created by the service
       * api backend with the allocated nodePort. Will use user-specified nodePort
       * value if specified by the client. Only affects when Type is set to
       * LoadBalancer and ExternalTrafficPolicy is set to Local.
       */
      healthCheckNodePort?: number;
      /**
       * Only applies to Service Type: LoadBalancer. LoadBalancer will
       * get created with the IP specified in this field.
       *
       * @remarks
       * This feature depends on
       * whether the underlying cloud provider supports specifying the loadBalancerIP
       * when a load balancer is created. This field will be ignored if the
       * cloud provider does not support the feature.
       */
      loadBalancerIP?: string;
      /**
       * If specified and supported by the platform, this will
       * restrict traffic through the cloud provider load balancer
       * to the specified client IPs.
       *
       * @remarks
       * This field will be ignored if the cloud provider
       * does not support the feature.
       *
       * For more information, see the
       * {@link https://v1-17.docs.kubernetes.io/docs/tasks/access-application-cluster/configure-cloud-provider-firewall/ |
       * Kubernetes documentation}.
       */
      loadBalancerSourceRanges?: string[];
      /**
       * The list of ports that are exposed by this service.
       *
       * @remarks
       * For more information, see the
       * {@link https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies |
       * Kubernetes documentation}.
       */
      ports?: ServicePort[];
      /**
       * When set to true, indicates that
       * DNS implementations must publish the notReadyAddresses of subsets for the
       * Endpoints associated with the Service.
       *
       * @remarks
       * The default value is false. The
       * primary use case for setting this field is to use a StatefulSet's Headless
       * Service to propagate SRV records for its Pods without respect to their
       * readiness for purpose of peer discovery.
       */
      publishNotReadyAddresses?: boolean;
      /**
       * Route service traffic to pods with label keys and values
       * matching this selector.
       *
       * @remarks
       * If empty or not present, the service is assumed to
       * have an external process managing its endpoints, which Kubernetes will not
       * modify. Only applies to types ClusterIP, NodePort, and LoadBalancer.
       * Ignored if type is ExternalName.
       *
       * For more information, see the
       * {@link https://kubernetes.io/docs/concepts/services-networking/service/ |
       * Kubernetes documentation}.
       */
      selector?: EndpointSelector | object;
      /**
       * Used to maintain session affinity.
       *
       * @remarks
       * Possible values are:
       *
       * - `"ClientIP"`: Enables client IP based session affinity.
       *
       * - `"None"`: Disables session affinity.
       *
       * For more information, see the
       * {@link https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies |
       * Kubernetes documentation}.
       * @defaultValue `"None"`
       */
      sessionAffinity?: string;
      /**
       * Determines how the Service is exposed.
       *
       * @remarks
       * Valid options are:
       *
       * - `"ExternalName"`: maps to the specified externalName.
       *
       * - `"ClusterIP"`: allocates a cluster-internal IP address for load
       * balancing to endpoints. Endpoints are determined by the selector or if
       * that is not specified, by manual construction of an Endpoints object. If
       * clusterIP is "None", no virtual IP is allocated and the endpoints are
       * published as a set of endpoints rather than a stable IP.
       *
       * - `"NodePort"`: Builds on ClusterIP and allocates a port on every node
       * which routes to the clusterIP.
       *
       * - `"LoadBalancer"`: Builds on NodePort and creates an external load
       * balancer (if supported in the current cloud) which routes to the
       * clusterIP.
       *
       * For more information, see the
       * {@link https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services---service-types |
       * Kubernetes documentation}.
       * @defaultValue `"ClusterIP"`
       */
      type?: string;
  }/** @public */
  export declare interface ServicePort {
      /**
       * The name of this port within the service.
       *
       * @remarks
       * This must be a DNS_LABEL.
       * All ports within a ServiceSpec must have unique names.This maps to the
       * Name' field in EndpointPort objects. Optional if only one ServicePort is
       * defined on this service.
       */
      name?: string;
      /**
       * The port on each node on which this service is exposed when
       * type=NodePort or LoadBalancer.
       *
       * @remarks
       * Usually assigned by the system. If
       * specified, it will be allocated to the service if unused or else creation
       * of the service will fail.
       *
       * For more information, see the
       * {@link https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport |
       * Kubernetes documentation}.
       * @defaultValue Automatically allocates a port if the ServiceType of this
       * Service requires one.
       */
      nodePort?: number;
      /** The port that will be exposed by this service. */
      port?: number;
      /** The IP protocol for this port.Supports "TCP" and "UDP".Default is TCP. */
      protocol?: string;
      /**
       * Number or name of the port to access on the pods targeted by the
       * service.
       *
       * @remarks
       * Number must be in the range 1 to 65535. Name must be an
       * IANA_SVC_NAME. If this is a string, it will be looked up as a named port
       * in the target Pod's container ports. If this is not specified, the value
       * of the 'port' field is used (an identity map). This field is ignored for
       * services with clusterIP = None, and should be omitted or set equal to the
       * 'port' field.
       *
       * For more information, see the
       * {@link https://kubernetes.io/docs/concepts/services-networking/service/#defining-a-service |
       * Kubernetes documentation}.
       */
      targetPort?: number | string;
  }/** @internal */
  const serviceResourceInfo: {
      kind: string;
      deployedWhen: typeof deployedWhen;
      statusQuery: (props: ResourcePropsWithConfig, observe: ObserveForStatus, buildData: BuildData) => Promise<any>;
  };/**
   * k8s ServiceAccount resource
   *
   * @param propsIn - props for ServiceAccount as specifed in {@link k8s.ServiceAccountProps}
   *
   * @public
   */
  export declare function ServiceAccount(propsIn: SFCDeclProps<ServiceAccountProps, typeof defaultProps>): Adapt.JSX.Element;/** @public */
  export declare function isServiceAccountProps(p: ResourceProps): p is ResourceProps & ResourceServiceAccount;/** @internal */
  const serviceAccountResourceInfo: {
      kind: string;
      deployedWhen: () => true;
      statusQuery: (props: ResourcePropsWithConfig, observe: ObserveForStatus, buildData: BuildData) => Promise<any>;
      makeManifest: (manifest: Manifest, elem: AdaptElement<ResourceProps>, _deployID: string) => {
          automountServiceAccountToken: boolean | undefined;
          imagePullSecrets: {
              name: string;
          }[] | undefined;
          secrets: ObjectReference[] | undefined;
          apiVersion: string;
          kind: string;
          metadata: import("./manifest_support").MetadataInRequest;
          spec?: import("./DaemonSet").DaemonSetSpec | import("./common").CRSpec | import("./Pod").PodSpec | import("./Service").ServiceSpec | import("./Deployment").DeploymentSpec | undefined;
      };
  };/**
   * Props for {@link k8s.ServiceDeployment}
   *
   * @public
   */
  export declare interface ServiceDeploymentProps<T extends AllowableComponentProps = DeploymentProps> extends ServiceProps {
      config: ClusterInfo;
      serviceProps?: Partial<ServiceProps>;
      component: ComponentType<T>;
      componentProps: T;
      podProps?: Partial<PodProps>;
      containerProps?: Partial<OmitT<K8sContainerProps, "image">>;
  }/**
   * A component for mapping a group of abstract {@link Container}s and
   * {@link NetworkService}s to Kubernetes {@link k8s.Pod}s and
   * {@link k8s.K8sContainer}s.
   *
   * @remarks
   * This component is intended to be used to replace {@link Container} and
   * {@link NetworkService} components that are grouped together, as the
   * only children of a common parent in a pattern that looks like this:
   *
   * ```tsx
   * <Service>
   *   <Container ... />
   *   <Container ... />
   *   <NetworkService ... />
   * </Service>
   * ```
   *
   * `ServiceDeployment` would map those abstract components into corresponding
   * k8s components like this:
   * ```tsx
   * <Group>
   *   <docker.RegistryDockerImage ... /> //If props.config specifies a registry
   *   <k8s.Deployment ... >
   *     <Pod isTemplate>
   *       <k8s.K8sContainer ... />
   *     </Pod>
   *   </k8s.Deployment>
   *   <docker.RegistryDockerImage ... /> //If props.config specifies a registry
   *   <k8s.Deployment ... >
   *     <Pod isTemplate>
   *       <k8s.K8sContainer ... />
   *     </Pod>
   *   </k8s.Pod>
   *   <k8s.Service ... />
   * </Group>
   * ```
   * An example style rule to do this is:
   * ```tsx
   * {Adapt.rule((matchedProps) => {
   *     const { handle, ...remainingProps } = matchedProps;
   *     return <ServiceDeployment config={kubeconfig} {...remainingProps} />;
   * })}
   * ```
   * `ServiceDeployment` also requires the `config` prop which specifies
   * connection and authentication information for the Kubernetes cluster on
   * which these objects should be created.
   *
   * @public
   */
  export declare class ServiceDeployment<T extends AllowableComponentProps> extends DeferredComponent<ServiceDeploymentProps<T>> {
      static defaultProps: {
          component: typeof Deployment;
          componentProps: {
              replicas: number;
          };
      };
      build(helpers: BuildHelpers): Adapt.JSX.Element;
  }/** @public */
  export declare function computeNamespaceFromMetadata(metadata?: Metadata): string;/** @public */
  export declare function isLabelSelector(x: any): x is LabelSelector;/**
   * Kubernetes Kind
   *
   * @public
   */
  export declare type Kind = string;/** @public */
  export declare interface CRSpec {
      [key: string]: any;
  }/** @public */
  export declare type Spec = DaemonSetSpec | DeploymentSpec | PodSpec | ServiceSpec | CRSpec;/** @public */
  export declare interface Metadata {
      namespace?: string;
      labels?: {
          [key: string]: string;
      };
      annotations?: {
          [key: string]: string;
      };
  }/** @public */
  export declare type ResourceProps = {
      key: string;
  } & (ResourceClusterRole | ResourceClusterRoleBinding | ResourceDaemonSet | ResourcePod | ResourceService | ResourceServiceAccount | ResourceConfigMap | ResourceSecret | ResourceCR);/** @public */
  export declare type ResourcePropsWithConfig = ResourceProps & {
      config: ClusterInfo;
  };/** @public */
  export declare interface ResourceInfo {
      kind: Kind;
      statusQuery?: (props: ResourceProps, observe: ObserveForStatus, buildData: BuildData) => unknown | Promise<unknown>;
      specsEqual(actual: Spec, element: Spec): boolean;
  }/**
   * Holds the information needed to connect, authenticate, and run code in a kuberenetes cluster
   *
   * @public
   */
  export declare interface ClusterInfo {
      /** Javascript object formed by parsing a valid kubeconfig file */
      kubeconfig: Kubeconfig;
      /**
       * Registry to which Docker images used by the cluster in `kubeconfig` should be pushed and pulled
       *
       * @remarks
       * If `registryPrefix` is a string, it is assumed that the cluster can pull from the same string
       * that outsiders can push to.
       *
       * If `registryPrefix` is of the form `{ external: string, internal: string }` then the `external`
       * string will be used to push images, and the `internal` string will be used to pull images.
       *
       * Note(manishv)
       * This is a bit of a hack to allow one hostname or IP address to push images from outside
       * a particular environment (say k8s) and a different URL for that environment to pull
       * images.
       *
       * A good example of this is a k3s-dind (k3s docker-in-docker) instance of kubernetes where
       * a private registry is running on a docker network attached to the k3s-dind instance, but where we
       * want to push {@link docker.LocalDockerImage} built images to that registry.  Since
       * {@link docker.LocalDockerImage | LocalDockerImage} is outside the k3s-dind environment, it must
       * use a host accessible network to push to the registry.  However, since the k3s-dind instance sees
       * the registry from within Docker, it must use a different address to pull the images for use.
       *
       * Once network scopes are fully supported, this interface will change to whatever is appropriate.  It
       * is best if you can arrange to have the same URL or registry string work for all access regardless
       * of which network the registry, Adapt host, and ultimate container running environment uses.
       *
       */
      registryPrefix?: string | DockerSplitRegistryInfo;
  }/** @public */
  export declare interface ResourceBase {
      /**
       * config to connect to the k8s cluster
       *
       * required if isTemplate is false
       */
      config?: ClusterInfo;
      /**
       * Specifies whether this resource is just a template for use in a controller
       */
      isTemplate?: boolean;
      apiVersion?: string;
      kind: Kind;
      metadata?: Metadata;
  }/**
   * @public
   */
  export declare interface PolicyRule {
      /**
       * APIGroups is the name of the APIGroup that contains the resources.
       *
       * If multiple API groups are specified, any action requested against one
       * of the enumerated resources in any API group will be allowed.
       */
      apiGroups?: string[];
      /**
       * NonResourceURLs is a set of partial urls that a user should have access to.
       *
       * *s are allowed, but only as the full, final step in the path.
       * Since non-resource URLs are not namespaced, this field is only applicable
       * for ClusterRoles referenced from a ClusterRoleBinding.
       * Rules can either apply to API resources (such as "pods" or "secrets") or
       * non-resource URL paths (such as "/api"), but not both.
       */
      nonResourceURLs?: string[];
      /**
       * ResourceNames is an optional white list of names that the rule applies to.
       *
       * An empty set means that everything is allowed.
       */
      resourceNames?: string[];
      /**
       * Resources is a list of resources this rule applies to.
       *
       * ResourceAll represents all resources.
       */
      resources: string[];
      /**
       * Verbs is a list of Verbs that apply to ALL the ResourceKinds and
       * AttributeRestrictions contained in this rule.
       *
       * VerbAll represents all kinds.
       */
      verbs: string[];
  }/**
   * AggregationRule for {@link k8s.ClusterRole}
   *
   * @public
   */
  export declare interface AggregationRule {
      /**
       * ClusterRoleSelectors holds a list of selectors which will be used to
       * find ClusterRoles and create the rules.
       *
       * If any of the selectors match, then the ClusterRole's permissions will be added
       */
      clusterRoleSelector: LabelSelector;
  }/** @public */
  export declare interface ResourceClusterRole extends ResourceBase {
      apiVersion: "rbac.authorization.k8s.io/v1";
      kind: "ClusterRole";
      aggregationRule?: AggregationRule;
      rules?: PolicyRule[];
  }/**
   * RoleRef for {@link k8s.ResourceClusterRoleBinding}
   *
   * @public
   */
  export declare interface RoleRef {
      /** apiGroup is the group for the resource being referenced */
      apiGroup: string;
      /** kind is the type of resource being referenced */
      kind: string;
      /** Name is the name of resource being referenced */
      name: string;
  }/**
   * Subject for {@link k8s.ResourceClusterRoleBinding}
   *
   * @public
   */
  export declare interface Subject {
      /** apiGroup is the group for the object being referenced */
      apiGroup: string;
      /** kind is the type of object being referenced */
      kind: string;
      /**
       * Name of the object being referenced.
       */
      name: string;
      /**
       * Namespace of the referenced object.
       *
       * If the object kind is non-namespace, such as "User" or "Group", and this value
       * is not empty the Authorizer should report an error.
       */
      namespace?: string;
  }/** @public */
  export declare interface ResourceClusterRoleBinding extends ResourceBase {
      apiVersion: "rbac.authorization.k8s.io/v1";
      kind: "ClusterRoleBinding";
      roleRef: RoleRef;
      subjects: Subject[];
  }/** @public */
  export declare interface ResourceDaemonSet extends ResourceBase {
      apiVersion: "apps/v1";
      kind: "DaemonSet";
      spec: DaemonSetSpec;
  }/** @public */
  export declare interface ResourcePod extends ResourceBase {
      kind: "Pod";
      spec: PodSpec;
  }/** @public */
  export declare interface ResourceService extends ResourceBase {
      kind: "Service";
      spec: ServiceSpec;
  }/** @public */
  export declare interface ResourceServiceAccount extends ResourceBase {
      kind: "ServiceAccount";
      automountServiceAccountToken?: boolean;
      imagePullSecrets?: {
          name: string;
      }[];
      secrets?: ObjectReference[];
  }/** @public */
  export declare interface ResourceConfigMap extends ResourceBase {
      kind: "ConfigMap";
      binaryData?: {
          [key: string]: string;
      };
      data?: {
          [key: string]: string;
      };
      /** @beta */
      immutable?: boolean;
  }/** @public */
  export declare interface ResourceSecret extends ResourceBase {
      kind: "Secret";
      data?: {
          [key: string]: string;
      };
      stringData?: {
          [key: string]: string;
      };
      type?: string;
  }/** @public */
  export declare interface ResourceCR extends ResourceBase {
      kind: string;
      spec: CRSpec;
  }/** @public */
  export declare interface Kubeconfig {
      apiVersion?: "v1";
      kind: "Config";
      "current-context": string;
      contexts: {
          name: string;
          context: {
              cluster: string;
              user: string;
          };
      }[];
      clusters: {
          name: string;
          cluster: {
              "certificate-authority-data": string;
              server: string;
          };
      }[];
      preferences?: unknown;
      users: {
          name: string;
          user: {
              "client-certificate-data"?: string;
              "client-key-data"?: string;
              "username"?: string;
              "password"?: string;
          };
      }[];
  }/** @public */
  export declare interface LabelSelector {
      /**
       * matchExpressions is a list of label selector requirements. The requirements are ANDed.
       */
      matchExpressions?: LabelSelectorRequirement[];
      /**
       * matchLabels is a map of `{key,value}`pairs. A single `{key,value}` in the matchLabels map
       * is equivalent to an element of matchExpressions, whose key field is "key", the operator
       * is "In", and the values array contains only "value". The requirements are ANDed.
       */
      matchLabels?: {
          [key: string]: string;
      };
  }/** @public */
  export declare interface LocalObjectReference {
      /**
       * Name of the referent.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names}
       */
      name: string;
  }/**
   * PodTemplateSpec from k8s API
   *
   * @public
   */
  export declare interface PodTemplateSpec {
      /**
       * Standard object's metadata.
       * More Info: {@link https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata}
       */
      metadata: Metadata;
      /**
       * Specification of the desired behavior of the pod.
       * More Info: {@link https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status}
       */
      spec: PodSpec;
  }/**
   * ObjectReference from k8s API
   *
   * @public
   */
  export declare interface ObjectReference {
      /**
       * If referring to a piece of an object instead of an entire object,
       * this string should contain a valid JSON/Go field access statement,
       * such as desiredState.manifest.containers[2].
       *
       * For example, if the object reference is to a container within a pod,
       * this would take on a value like: "spec.containers\{name\}" (where "name"
       * refers to the name of the container that triggered the event) or if no
       * container name is specified "spec.containers[2]"
       * (container with index 2 in this pod).
       * This syntax is chosen only to have some well-defined way of referencing a
       * part of an object.
       */
      fieldPath: string;
      /**
       * Name of the referent.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names}
       *
       */
      name: string;
      /**
       * Namespace of the referent.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/}
       */
      namespace: string;
      /**
       * Specific resourceVersion to which this reference is made, if any.
       *
       * More info: {@link https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency}
       */
      resourceVersion: string;
      /**
       * UID of the referent.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids}
       */
      uid: string;
  }/**
   * Make a {@link k8s.ClusterInfo} object suitable for use with k8s resources
   *
   * @remarks
   *
   * This function will take a set of options and generate a {@link k8s.ClusterInfo}
   * object that contains the kubeconfig, registryPrefix for private images, and any other
   * relevant information for the cluster
   *
   * See {@link k8s.MakeClusterInfoOptions} for information on how the information
   * is computed.
   *
   * @returns A {@link k8s.ClusterInfo} object.
   *
   * @public
   */
  export declare function makeClusterInfo(options: MakeClusterInfoOptions): Promise<ClusterInfo>;/** @internal */
  export declare function isResourcePodTemplate(x: any): x is AdaptElement<ResourcePod>;/**
   * Hook that allows a prop to be either an array of handle to k8s resources and values
   *
   * @param initial - initial value of the prop, before the handles are be resolved
   * @param notReady - is a marker value to indicate that a handle's value isn't available yet
   * @param kinds - an array of legal k8s Kinds that a prop handle can point to
   * @param thisResourceName - the name of the resource using the hook, for error messages
   * @param propName - the name of the prop being resolved, again for error messages
   *
   * @returns A two element array, the first element is the current value, the second the update function
   *
   * This hook will start by returning the initial value and an update function that updates
   * the value the hook returns.  The update function takes 2 arguments - the prop value which
   * is an array with a mix of values and handles to be resolved, and a function that receives
   * the elements that any handles point to along with that elements props.  This function
   * can be passed by the caller of update to resolve handles as appropriate for the component.
   *
   * For example, {@link k8s.ClusterRoleBinding} uses this hook to resolve the subjects prop,
   * which is an array of other objects (typically {@link ServiceAccount}) that a particular
   * {@link k8s.ClusterRole} should point to.  When ClusterRoleBinding calls the update method,
   * it passes a function that will convert a {@link k8s.Resource} element of Kind `ServiceAccount`
   * to the underlying `Subject` object that kubernetes expects, namely
   * `{ apiGroup: "", kind: "ServiceAccount", name: resourceIdToName(elem, deployID), namespace: <element namespace> }`
   *
   * @example
   * ```
   * function MyResource({ serviceAccountNames }: { serviceAccountNames: (string | Handle)[]}) {
   *   const { deployID } = useBuildHelpers();
   *   const [ resolvedServiceAccountNames, updateSANs] = useResources({
   *      initial: [],
   *      notReady: null,
   *      kinds: ["ServiceAccount"],
   *      thisResourceName: "MyResources",
   *      propName: "serviceAccountNames",
   *   });
   *
   *   updateSANs(serviceAccountNames, (e, props) => {
   *      return {
   *        apiGroup: (e.metadata.apiVersion?.split("/")[0]) || "",
   *        name: resourceElementToName(e, deployID),
   *        namespace: props.metadata.namespace,
   *      }
   *   });
   *
   *   return null;
   * }
   * ```
   *
   * @beta
   */
  export declare function useResources<ValT, NotReadyT>({ initial, notReady, kinds, thisResourceName, propName, }: {
      initial: ValT[];
      notReady: NotReadyT;
      kinds: string[];
      thisResourceName: string;
      propName: string;
  }): [
      (ValT | NotReadyT)[],
      (props: (ValT | Handle)[], f: (e: AdaptMountedElement, props: ResourceProps) => Promise<ValT> | ValT) => void
  ];/**
   * Hook to allow conversion of a prop that could be a value or a handle
   *
   * This function behaves similarly to {@link k8s.useResources}, but works for
   * a prop that is either a Handle or a single value instead of an array of
   * Handles and values.
   *
   * See {@link k8s.useResources} for more detailed documentation.
   *
   * @beta
   */
  export declare function useResource<ValT, NotReadyT>(opts: {
      initial: ValT | NotReadyT;
      notReady: NotReadyT;
      kinds: string[];
      thisResourceName: string;
      propName: string;
  }): [
      ValT | NotReadyT,
      (prop: ValT | Handle, f: (e: AdaptMountedElement, props: ResourceProps) => Promise<ValT> | ValT) => void
  ];/**
   * Options for {@link k8s.makeClusterInfo}
   *
   * @public
   */
  export declare interface MakeClusterInfoOptions {
      /**
       * A Javascript Object representing a valid kubeconfig, or a YAML string, or a path to a kubeconfig file.
       *
       * @remarks
       * If this is a Javascript object, it will be treated like a parsed kubeconfig.  If this is a string,
       * {@link k8s.makeClusterInfo} will first attempt to parse it as JSON.  If that fails, it will attempt
       * to parse it as YAML.  If that fails it will treat the string as a path of configs (like with the `KUBECONFIG`
       * environment variable).
       *
       * If kubeconfig is missing {@link k8s.makeClusterInfo} will use the `KUBECONFIG` environment variable to build
       * a suitable config using `kubectl config view --flatten` and return that as the kubeconfig in the resulting
       * {@link k8s.ClusterInfo}
       */
      kubeconfig?: Kubeconfig | string;
      /**
       * URL to the docker registry that this cluster uses to pull private images.
       *
       * @remarks
       * This is identical to the `registryPrefix` field in {@link k8s.ClusterInfo}.  It will
       * be returned verbatim in the resulting {@link k8s.ClusterInfo} object.
       */
      registryPrefix?: string | DockerSplitRegistryInfo;
  }/**
   * k8s ClusterRole resource
   *
   * @param propsIn - props for ServiceAccount as specifed in {@link k8s.ClusterRoleProps}
   *
   * @public
   */
  export declare function ClusterRole(propsIn: SFCDeclProps<ClusterRoleProps, typeof defaultProps>): Adapt.JSX.Element;/** @public */
  export declare function isClusterRoleProps(props: ResourceProps): props is ResourceProps & ResourceClusterRole;/** @internal */
  const clusterRoleResourceInfo: {
      kind: string;
      deployedWhen: () => true;
      statusQuery: (props: ResourcePropsWithConfig, observe: ObserveForStatus, buildData: BuildData) => Promise<any>;
      makeManifest: (manifest: Manifest, elem: AdaptElement<ResourceProps>, _deployID: string) => {
          aggregationRule: AggregationRule | undefined;
          rules: PolicyRule[] | undefined;
          apiVersion: string;
          kind: string;
          metadata: import("./manifest_support").MetadataInRequest;
          spec?: import("./DaemonSet").DaemonSetSpec | import("./common").CRSpec | import("./Pod").PodSpec | import("./Service").ServiceSpec | import("./Deployment").DeploymentSpec | undefined;
      };
  };/**
   * k8s ClusterRoleBinding resource
   *
   * @param propsIn - props for ServiceAccount as specifed in {@link k8s.ClusterRoleBindingProps}
   *
   * @public
   */
  export declare function ClusterRoleBinding(propsIn: SFCDeclProps<ClusterRoleBindingProps, typeof defaultProps>): Adapt.JSX.Element | null;/** @internal */
  const clusterRoleBindingResourceInfo: {
      kind: string;
      deployedWhen: () => true;
      statusQuery: (props: ResourcePropsWithConfig, observe: ObserveForStatus, buildData: BuildData) => Promise<any>;
      makeManifest: (manifest: Manifest, elem: AdaptElement<ResourceProps>, _deployID: string) => {
          roleRef: RoleRef;
          subjects: Subject[];
          apiVersion: string;
          kind: string;
          metadata: import("./manifest_support").MetadataInRequest;
          spec?: import("./DaemonSet").DaemonSetSpec | import("./common").CRSpec | import("./Pod").PodSpec | import("./Service").ServiceSpec | import("./Deployment").DeploymentSpec | undefined;
      };
  };/**
   * k8s ConfigMap resource
   *
   * @param propsIn - props for ConfigMap as specifed in {@link k8s.ConfigMapProps}
   *
   * @public
   */
  export declare function ConfigMap(propsIn: SFCDeclProps<ConfigMapProps, typeof defaultProps>): Adapt.JSX.Element;/** @internal */
  const configMapResourceInfo: {
      kind: string;
      deployedWhen: () => true;
      statusQuery: (props: ResourcePropsWithConfig, observe: ObserveForStatus, buildData: BuildData) => Promise<any>;
      makeManifest: (manifest: Manifest, elem: AdaptElement<ResourceProps>, _deployID: string) => {
          data: {
              [key: string]: string;
          } | undefined;
          binaryData: {
              [key: string]: string;
          } | undefined;
          immutable: boolean | undefined;
          apiVersion: string;
          kind: string;
          metadata: import("./manifest_support").MetadataInRequest;
          spec?: import("./DaemonSet").DaemonSetSpec | import("./common").CRSpec | import("./Pod").PodSpec | import("./Service").ServiceSpec | import("./Deployment").DeploymentSpec | undefined;
      };
  };/**
   * Low level utility function to translate from the abstract {@link Container}
   * component props ({@link ContainerProps}) to {@link k8s.K8sContainerProps}
   * to be used in a {@link k8s.K8sContainer}.
   * @remarks
   * Note: The `image` property in the passed in {@link ContainerProps} must
   * be a `string`, not a `Handle`.
   * In most cases, it is preferable to use the {@link k8s.Container} component
   * instead, which is designed specifically to deal with this issue.
   *
   * @param abstractProps - The abstract {@link ContainerProps} to translate from.
   * @param k8sProps - Props that are specific to the {@link k8s.K8sContainer}
   *     component that should be merged into the resulting returned
   *     {@link k8s.K8sContainerProps} object.
   * @public
   */
  export declare function k8sContainerProps(abstractProps: FromContainerProps, k8sProps?: Partial<K8sContainerProps>): K8sContainerProps;/**
   * Tests whether an element is a {@link k8s.K8sContainer} element
   * @param x - element to test
   * @returns `true` if element is a {@link k8s.K8sContainer}, `false` otherwise
   *
   * @remarks
   * Acts as a TypeScript type assertion that will assert that `x` is `AdaptElement<K8sContainerProps>`
   *
   * @public
   */
  export declare function isK8sContainerElement(x: AdaptElement): x is AdaptElement<K8sContainerProps>;/**
   * Component that implements the abstract {@link Container} interface and
   * translates to a Kubernetes-specific {@link k8s.K8sContainer}.
   * @public
   */
  export declare function Container(props: ContainerProps): Adapt.JSX.Element | null;/** @public */
  export declare interface VolumeMount {
      /**
       * Path within the container at which the volume should be mounted.
       *
       * Must not contain ':'.
       */
      mountPath: string;
      /**
       * mountPropagation determines how mounts are propagated from the host to container and the other way around.
       *
       * When not set, MountPropagationNone is used. This field is beta in 1.10.
       *
       * @defaultValue MountPropagationNone
       */
      mountPropagation?: string;
      /** This must match the Name of a Volume. */
      name: string;
      /**
       * Mounted read-only if true, read-write otherwise (false or unspecified).
       *
       * @defaultValue false
       */
      readOnly?: boolean;
      /**
       * Path within the volume from which the container's volume should be mounted.
       *
       * Defaults to "" (volume's root).
       *
       * @defaultValue ""
       */
      subPath?: string;
      /**
       * Expanded path within the volume from which the container's volume should be mounted.
       *
       * Behaves similarly to SubPath but environment variable references $(VAR_NAME)
       * are expanded using the container's environment.
       *
       * Defaults to "" (volume's root).
       *
       * SubPathExpr and SubPath are mutually exclusive.
       *
       * @defaultValue ""
       */
      subPathExpr?: string;
  }/** @public */
  export declare interface ConfigMapEnvSource {
      /**
       * Name of the referent.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names}
       */
      name?: string;
      /**
       * Specify whether the ConfigMap must be defined
       */
      optional?: boolean;
  }/** @public */
  export declare interface SecretEnvSource {
      /**
       * Name of the referent.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names}
       */
      name?: string;
      /**
       * Specify whether the Secret must be defined
       */
      optional?: boolean;
  }/** @public */
  export declare interface EnvFromSource {
      /** The ConfigMap to select from */
      configMapRef?: ConfigMapEnvSource;
      /** An optional identifier to prepend to each key in the ConfigMap. Must be a C_IDENTIFIER. */
      prefix?: string;
      /** SecretEnvSource	The Secret to select from */
      secretRef?: SecretEnvSource;
  }/** @public */
  export declare interface ExecAction {
      /**
       * Command is the command line to execute inside the container.
       *
       * The working directory for the command is root ('/') in the container's filesystem.
       * The command is simply exec'd, it is not run inside a shell,
       * so traditional shell instructions ('|', etc) won't work.
       * To use a shell, you need to explicitly call out to that shell.
       *
       * Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
       */
      command: string[];
  }/** @public */
  export declare interface HTTPGetAction {
      /**
       * Host name to connect to, defaults to the pod IP.
       *
       * You probably want to set "Host" in httpHeaders instead.
       */
      host?: string;
      /** Custom headers to set in the request. HTTP allows repeated headers. */
      httpHeaders?: {
          name: string;
          value: string;
      }[];
      /** Path to access on the HTTP server. */
      path: string;
      /**
       * Name or number of the port to access on the container.
       *
       * Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
       */
      port: number | string;
      /**
       * Scheme to use for connecting to the host.
       *
       * @defaultValue HTTP.
       */
      scheme?: string;
  }/** @public */
  export declare interface TCPSocketAction {
      /** Host name to connect to, defaults to the pod IP. */
      host?: string;
      /**
       * Number or name of the port to access on the container.
       *
       * Number must be in the range 1 to 65535.
       * Name must be an IANA_SVC_NAME.
       */
      port: string | number;
  }/** @public */
  export declare interface Probe {
      /**
       * Exec specifies the action to take.
       *
       * Only one of exec, httpGet, or tcpSocket should be specified
       */
      exec?: ExecAction;
      /**
       * Minimum consecutive failures for the probe to be considered failed after having succeeded.
       *
       * Defaults to 3. Minimum value is 1.
       *
       * @defaultValue 3
       */
      failureThreshold?: number;
      /** Specifies the http request to perform. */
      httpGet?: HTTPGetAction;
      /**
       *  Seconds after the container has started before liveness probes are initiated.
       *  More info: {@link https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes}
       */
      initialDelaySeconds?: number;
      /** How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. */
      periodSeconds?: number;
      /**
       * Minimum consecutive successes for the probe to be considered successful after having failed.
       *
       * Must be 1 for liveness and startup. Minimum value is 1.
       *
       * @defaultValue 1
       */
      successThreshold?: number;
      /**
       * Specifies an action involving a TCP port.
       *
       * TCP hooks not yet supported
       */
      tcpSocket?: TCPSocketAction;
      /**
       * Number of seconds after which the probe times out.
       *
       * Defaults to 1 second. Minimum value is 1.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes}
       *
       * @defaultValue 1
       */
      timeoutSeconds?: number;
  }/** @public */
  export declare interface ResourceRequirements {
      /**
       * Limits describes the maximum amount of compute resources allowed.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/}
       */
      limits?: {
          [key: string]: any;
      };
      /**
       * Describes the minimum amount of compute resources required.
       *
       * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
       * otherwise to an implementation-defined value.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/}
       */
      requests?: {
          [key: string]: any;
      };
  }/** @public */
  export declare type Handler = {
      exec: ExecAction;
  } | {
      httpGet: HTTPGetAction;
  } | {
      tcpSocket: TCPSocketAction;
  };/** @public */
  export declare interface Lifecycle {
      /**
       * PostStart is called immediately after a container is created.
       *
       * If the handler fails, the container is terminated and restarted according to its restart policy.
       * Other management of the container blocks until the hook completes.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks}
       */
      postStart: Handler;
      /**
       * Called immediately before a container is terminated due to an API request or management event such as liveness/startup probe failure, preemption, resource contention, etc.
       *
       * The handler is not called if the container crashes or exits.
       * The reason for termination is passed to the handler.
       * The Pod's termination grace period countdown begins before the PreStop hooked is executed.
       * Regardless of the outcome of the handler, the container will eventually terminate within the Pod's termination grace period.
       * Other management of the container blocks until the hook completes or until the termination grace period is reached.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks}
       */
      preStop: Handler;
  }/** @public */
  export declare interface VolumeDevice {
      /** The path inside of the container that the device will be mapped to. */
      devicePath: string;
      /** name must match the name of a persistentVolumeClaim in the pod */
      name: string;
  }/**
   * Resource spec for a Kubernetes container.
   * See the Kubernetes
   * {@link https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#container-v1-core | API docs }
   * for more details.
   * @public
   */
  export declare interface ContainerSpec {
      /**
       * Arguments to the entrypoint.
       *
       * The docker image's CMD is used if this is not provided.
       * Variable references $(VAR_NAME) are expanded using the container's environment.
       * If a variable cannot be resolved, the reference in the input string will be unchanged.
       * The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME).
       * Escaped references will never be expanded, regardless of whether the variable exists or not.
       * Cannot be updated.
       * More info: {@link https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell}
       */
      args?: string[];
      /**
       * Entrypoint array.
       *
       * Not executed within a shell.
       * The docker image's ENTRYPOINT is used if this is not provided.
       * Variable references $(VAR_NAME) are expanded using the container's environment.
       * If a variable cannot be resolved, the reference in the input string will be unchanged.
       * The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME).
       * Escaped references will never be expanded, regardless of whether the variable exists or not.
       * Cannot be updated.
       * More info: {@link https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell}
       */
      command?: string[];
      /**
       * List of environment variables to set in the container. Cannot be updated.
       */
      env?: EnvVar[];
      /**
       * List of sources to populate environment variables in the container.
       *
       * The keys defined within a source must be a C_IDENTIFIER.
       * All invalid keys will be reported as an event when the container is starting.
       * When a key exists in multiple sources, the value associated with the last source will take precedence.
       * Values defined by an Env with a duplicate key will take precedence. Cannot be updated.
       */
      envFrom?: EnvFromSource[];
      /**
       * Docker image name.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/containers/images}
       *
       * This field is optional to allow higher level config management to default or override container
       * images in workload controllers like Deployments and StatefulSets.
       */
      image?: string;
      /**
       * Image pull policy.
       *
       * One of Always, Never, IfNotPresent.
       * Defaults to Always if :latest tag is specified,
       * or IfNotPresent otherwise.
       * Cannot be updated.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/containers/images#updating-images}
       */
      imagePullPolicy?: "Always" | "Never" | "IfNotPresent";
      /**
       * List of sources to populate environment variables in the container.
       *
       * The keys defined within a source must be a C_IDENTIFIER.
       * All invalid keys will be reported as an event when the container is starting.
       * When a key exists in multiple sources, the value associated with the last source will take precedence.
       * Values defined by an Env with a duplicate key will take precedence. Cannot be updated.
       */
      lifecycle?: Lifecycle;
      /**
       * Periodic probe of container liveness.
       *
       * Container will be restarted if the probe fails.
       * Cannot be updated.
       * More info: {@link https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes}
       */
      livenessProbe?: Probe;
      /**
       * Name of the container specified as a DNS_LABEL.
       *
       * Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated.
       */
      name: string;
      /**
       * List of ports to expose from the container.
       *
       * Exposing a port here gives the system additional information about the network connections a container uses,
       * but is primarily informational.
       * Not specifying a port here DOES NOT prevent that port from being exposed.
       * Any port which is listening on the default "0.0.0.0" address inside a container will be accessible from
       * the network.
       * Cannot be updated.
       */
      ports?: ContainerPort[];
      /**
       * Periodic probe of container service readiness.
       *
       * Container will be removed from service endpoints if the probe fails.
       * Cannot be updated.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes}
       */
      readinessProbe?: Probe;
      /**
       * Compute Resources required by this container.
       *
       * Cannot be updated.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/}
       */
      resources?: ResourceRequirements;
      /**
       * Security options the pod should run with.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/policy/security-context/}
       * More info: {@link https://kubernetes.io/docs/tasks/configure-pod-container/security-context/}
       */
      securityContext?: PodSecurityContext;
      /**
       * Indicates that the Pod has successfully initialized.
       *
       * If specified, no other probes are executed until this completes successfully.
       * If this probe fails, the Pod will be restarted, just as if the livenessProbe failed.
       * This can be used to provide different probe parameters at the beginning of a Pod's lifecycle,
       * when it might take a long time to load data or warm a cache, than during steady-state operation.
       *
       * This cannot be updated.
       * This is a beta feature enabled by the StartupProbe feature flag.
       * More info: {@link https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes}
       */
      startupProbe?: Probe;
      /**
       * Whether this container should allocate a buffer for stdin in the container runtime.
       *
       * If this is not set, reads from stdin in the container will always result in EOF. Default is false.
       */
      stdin?: boolean;
      /**
       * Whether the container runtime should close the stdin channel after it has been opened by a single attach.
       *
       * When stdin is true the stdin stream will remain open across multiple attach sessions.
       * If stdinOnce is set to true, stdin is opened on container start,
       * is empty until the first client attaches to stdin,
       * and then remains open and accepts data until the client disconnects,
       * at which time stdin is closed and remains closed until the container is restarted.
       * If this flag is false, a container processes that reads from stdin will never receive an EOF. Default is false
       */
      stdinOnce?: boolean;
      /**
       * Path at which the file to which the container's termination message will be written is mounted into the container's filesystem.
       *
       * Message written is intended to be brief final status, such as an assertion failure message.
       * Will be truncated by the node if greater than 4096 bytes.
       * The total message length across all containers will be limited to 12kb.
       * Defaults to /dev/termination-log. Cannot be updated.
       */
      terminationMessagePath?: string;
      /**
       * Indicate how the termination message should be populated.
       *
       * File will use the contents of terminationMessagePath to populate the container status
       * message on both success and failure. FallbackToLogsOnError will use the last chunk of
       * container log output if the termination message file is empty and the container exited
       * with an error.
       * The log output is limited to 2048 bytes or 80 lines, whichever is smaller.
       * Defaults to File.
       * Cannot be updated.
       *
       * @defaultValue File
       */
      terminationMessagePolicy?: "File" | "FallbackToLogsOnError";
      /**
       * Whether this container should allocate a TTY for itself, also requires 'stdin' to be true.
       *
       * @defaultValue false
       */
      tty?: boolean;
      /**
       * volumeDevices is the list of block devices to be used by the container.
       */
      volumeDevices?: VolumeDevice[];
      /** volumeDevices is the list of block devices to be used by the container. */
      volumeMounts?: VolumeMount[];
      /**
       * Container's working directory.
       *
       * If not specified, the container runtime's default will be used,
       * which might be configured in the container image.
       * Cannot be updated.
       */
      workingDir?: string;
  }/**
   * Props for the Kubernetes-specific {@link k8s.K8sContainer} component.
   * @public
   */
  export declare interface K8sContainerProps extends ContainerSpec {
  }/** @public */
  export declare interface ContainerPort {
      /**
       * Number of port to expose on the pod's IP address.
       * @remarks
       * This must be a valid integer port number, `0 < x < 65536`.
       */
      containerPort: number;
      /** What host IP to bind the external port to. */
      hostIP?: string;
      /**
       * Number of port to expose on the host.
       * @remarks
       * If specified, this must be a valid integer port number,
       * `0 < x < 65536`. If HostNetwork is specified,
       * this must match ContainerPort. Most containers do not need this.
       */
      hostPort?: number;
      /**
       * A unique-within-pod name for the container
       * @remarks
       * If specified, this must be an IANA_SVC_NAME and unique within the pod.
       * Each named port in a pod must have a unique name. Name for the port
       * that can be referred to by services.
       */
      name?: string;
      /** Protocol for port. Must be UDP or TCP. Defaults to "TCP". */
      protocol?: string;
  }/** @public */
  export declare type EnvVar = EnvVarSimple | EnvVarFrom;/** @public */
  export declare interface EnvVarSimple {
      /** Name of the environment variable. Must be a C_IDENTIFIER. */
      name: string;
      /**
       * Variable references $(VAR_NAME) are expanded using the previous defined
       * environment variables in the container and any service environment
       * variables. If a variable cannot be resolved, the reference in the input
       * string will be unchanged. The $(VAR_NAME) syntax can be escaped with a
       * double $$, ie: $$(VAR_NAME). Escaped references will never be expanded,
       * regardless of whether the variable exists or not. Defaults to "".
       */
      value: string;
  }/** @public */
  export declare interface EnvVarFrom {
      /** Source for the environment variable's value. Cannot be used if value is not empty. */
      valueFrom?: any;
  }/**
   * See {@link k8s.k8sContainerProps}.
   * @public
   */
  export declare type FromContainerProps = ReplaceT<ContainerProps, {
      image: string;
  }> & BuiltinProps;/**
   * Kubernetes-specific container.
   * @public
   */
  export declare class K8sContainer extends PrimitiveComponent<K8sContainerProps> {
      static defaultProps: {
          imagePullPolicy: string;
      };
      validate(): undefined;
  }/**
   * Props for {@link k8s.Container}.
   * @public
   */
  export declare interface ContainerProps extends SFCDeclProps<ContainerProps> {
      /**
       * Additional {@link k8s.K8sContainerProps}-specific props that should be
       * added to the instantiated {@link k8s.K8sContainer}.
       */
      k8sContainerProps?: Partial<K8sContainerProps>;
  }/**
   * Spec for {@link k8s.DaemonSet} for use in {@link k8s.Resource}
   *
   * @public
   */
  export declare type DaemonSetSpec = Exclude<DaemonSetProps, ResourceBase> & {
      template: PodTemplateSpec;
  };/**
   * Component for Kubernetes DaemonSet
   *
   * @public
   */
  export declare class DaemonSet extends DeferredComponent<DaemonSetProps> {
      static defaultProps: {
          metadata: {};
          minReadySeconds: number;
          revisionHistoryLimit: number;
          updateStrategy: {
              type: string;
              rollingUpdate: {
                  maxUnavailable: number;
              };
          };
      };
      constructor(props: DaemonSetProps);
      build(helpers: BuildHelpers): Adapt.JSX.Element;
      status(_observe: ObserveForStatus, buildData: BuildData): Promise<Adapt.Status | undefined>;
  }/** @internal */
  const daemonSetResourceInfo: {
      kind: string;
      deployedWhen: typeof deployedWhen;
      statusQuery: (props: ResourcePropsWithConfig, observe: ObserveForStatus, buildData: BuildData) => Promise<any>;
  };/** @public */
  export declare interface DeploymentUpdateStrategyRecreate {
      type: "Recreate";
  }/** @public */
  export declare interface RollingUpdateDeployment {
      /**
       * The maximum number of pods that can be scheduled above the desired number of pods.
       *
       * Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
       * This can not be 0 if MaxUnavailable is 0.
       * Absolute number is calculated from percentage by rounding up.
       * Defaults to 25%.
       *
       * @example
       * When this is set to 30%, the new ReplicaSet can be scaled up immediately when the rolling update starts,
       * such that the total number of old and new pods do not exceed 130% of desired pods. Once old pods have been
       * killed, new ReplicaSet can be scaled up further, ensuring that total number of pods running at any time
       * during the update is at most 130% of desired pods.
       */
      maxSurge?: number | string;
      /**
       * The maximum number of pods that can be unavailable during the update.
       *
       * Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
       * Absolute number is calculated from percentage by rounding down.
       * This can not be 0 if MaxSurge is 0. Defaults to 25%.
       *
       * @example
       * When this is set to 30%, the old ReplicaSet can be scaled down to 70% of desired pods
       * immediately when the rolling update starts. Once new pods are ready, old ReplicaSet
       * can be scaled down further, followed by scaling up the new ReplicaSet, ensuring that
       * the total number of pods available at all times during the update is at least 70% of
       * desired pods.
       */
      maxUnavailable?: number | string;
  }/**
   * Spec for {@link k8s.Deployment} for use in {@link k8s.Resource}
   *
   * @public
   */
  export declare type DeploymentSpec = Exclude<DeploymentProps, ResourceBase> & {
      template: PodTemplateSpec;
  };/**
   * Props for {@link k8s.Deployment}
   *
   * @public
   */
  export declare interface DeploymentProps extends WithChildren {
      /** Information about the k8s cluster (ip address, auth info, etc.) */
      config: ClusterInfo;
      /** k8s metadata */
      metadata: Metadata;
      /**
       * The minimum number of seconds for which a newly created pod should
       * be ready without any of its container crashing, for it to be considered
       * available. Defaults to 0 (pod will be considered available as soon as it is ready).
       */
      minReadySeconds: number;
      /** Indicates that the deployment is paused */
      paused: boolean;
      /**
       * The maximum time in seconds for a deployment to make progress before it is considered to be failed.
       *
       * The deployment controller will continue to process failed deployments and a condition with a
       * ProgressDeadlineExceeded reason will be surfaced in the deployment status. Note that progress
       * will not be estimated during the time a deployment is paused. Defaults to 600s.
       */
      progressDeadlineSeconds: number;
      /**
       * Number of desired pods.
       *
       * Defaults to 1. 0 is not allowed.
       *
       * @defaultValue 1
       */
      replicas: number;
      /**
       * The number of old ReplicaSets to retain to allow rollback.
       *
       * This is a pointer to distinguish between explicit zero and not specified. Defaults to 10.
       *
       * @defaultValue 10
       */
      revisionHistoryLimit: number;
      /**
       * Label selector for pods.
       *
       * Existing ReplicaSets whose pods are selected by this will be the ones affected by this deployment.
       * It must match the pod template's labels.
       *
       * @remarks
       *
       * With Adapt, this is optional.  If not specified, adapt will pick a selector that will work with the pods
       * it creates as part of this {@link k8s.Deployment}
       */
      selector?: LabelSelector;
      /**
       * An deployment strategy to use to replace existing pods with new ones
       */
      strategy: DeploymentUpdateStrategy;
  }/**
   * Component for Kubernetes Deployment
   *
   * @public
   */
  export declare class Deployment extends DeferredComponent<DeploymentProps> {
      static defaultProps: {
          metadata: {};
          paused: boolean;
          replicas: number;
          progressDeadlineSeconds: number;
          minReadySeconds: number;
          revisionHistoryLimit: number;
          strategy: {
              type: string;
              rollingUpdate: {
                  maxSurge: string;
                  maxUnavailable: string;
              };
          };
      };
      constructor(props: DeploymentProps);
      build(helpers: BuildHelpers): Adapt.JSX.Element | null;
      deployedWhen: () => true | Adapt.Waiting;
      status(_observe: ObserveForStatus, buildData: BuildData): Promise<Adapt.Status | undefined>;
  }/** @internal */
  const deploymentResourceInfo: {
      kind: string;
      deployedWhen: typeof deployedWhen;
      statusQuery: (props: ResourcePropsWithConfig, observe: ObserveForStatus, buildData: BuildData) => Promise<any>;
  };/**
   * Type assertion to see if an element is both a {@link k8s.Resource | Resource}
   * and a {@link @adpt/core#FinalElement | FinalElement}
   *
   * @param e - element to test
   * @returns `true` if e is both a FinalElement and a {@link k8s.Resource | Resource}, `false` otherwise
   *
   * @public
   */
  export declare function isResourceFinalElement(e: AdaptElement): e is FinalDomElement<ResourceProps & Adapt.BuiltinProps>;/**
   * Tests whether a ResourceProps is for a template object
   *
   * @public
   */
  export declare function isResourcePropsWithConfig(x: ResourceProps & Partial<BuiltinProps>): x is ResourcePropsWithConfig & Partial<BuiltinProps>;/**
   * Tests to see if an object is a {@link k8s.Resource} element
   * @param x - object to test
   * @returns true if object is an AdaptElement of type {@link k8s.Resource}
   *
   * @public
   */
  export declare function isResource(x: any): x is AdaptElement<ResourceProps>;/**
   * Primitive Component recognized by the k8s plugin to represent resources
   * @public
   */
  export declare class Resource extends Action<ResourceProps> {
      defaultProps: {
          apiVersion: "v1";
          con: false;
      };
      manifest_: Manifest;
      constructor(props: ResourceProps);
      validate(): "Resource elements cannot have children" | undefined;
      shouldAct(op: ChangeType, ctx: ActionContext): Promise<ShouldAct>;
      action(op: ChangeType, ctx: ActionContext): Promise<void>;
      deployedWhen: (goalStatus: GoalStatus, helpers: DeployHelpers) => Promise<true | Adapt.Waiting | Adapt.Waiting[]>;
      status(observe: ObserveForStatus, buildData: BuildData): Promise<any>;
      private mountedElement;
      private manifest;
  }/** @internal */
  export declare function makePodManifest(props: PodProps & BuiltinProps, data: {
      volumes?: Volume[];
      serviceAccountName?: string;
  }): {
      kind: string;
      metadata: Metadata;
      spec: PodSpec;
  };/**
   * Tests whether x is a Pod element
   *
   * @param x - value to test
   * @returns `true` if x is a Pod element, false otherwise
   *
   * @public
   */
  export declare function isPod(x: any): x is AdaptElement<PodProps>;/** @public */
  export declare interface NodeSelectorRequirement {
      /** The label key that the selector applies to. */
      key: string;
      /**
       * Represents a key's relationship to a set of values.
       *
       * Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
       */
      operator: "In" | "NotIn" | "Exists" | "DoesNotExist" | "Gt" | "Lt";
      /**
       * Values for operator
       *
       * If the operator is In or NotIn, the values array must be non-empty.
       * If the operator is Exists or DoesNotExist, the values array must be empty.
       * If the operator is Gt or Lt, the values array must have a single element,
       * which will be interpreted as an integer.
       * This array is replaced during a strategic merge patch.
       */
      values: string[];
  }/** @public */
  export declare interface NodeSelectorTerm {
      /** A list of node selector requirements by node's labels. */
      matchExpressions?: NodeSelectorRequirement[];
      /** A list of node selector requirements by node's fields. */
      matchFields?: NodeSelectorRequirement[];
  }/** @public */
  export declare interface PreferredSchedulingTerm {
      /**
       * A node selector term, associated with the corresponding weight.
       */
      preference: NodeSelectorTerm;
      /** Weight associated with matching the corresponding nodeSelectorTerm, in the range 1-100. */
      weight: number;
  }/** @public */
  export declare interface NodeSelector {
      /** A list of node selector terms. The terms are ORed */
      nodeSelectorTerms: NodeSelectorTerm[];
  }/** @public */
  export declare interface NodeAffinity {
      /** The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding "weight" to the sum if the node matches the corresponding matchExpressions; the node(s) with the highest sum are the most preferred. */
      preferredDuringSchedulingIgnoredDuringExecution?: PreferredSchedulingTerm[];
      /** If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to an update), the system may or may not try to eventually evict the pod from its node. */
      requiredDuringSchedulingIgnoredDuringExecution?: NodeSelector;
  }/** @public */
  export declare interface PodAffinityTerm {
      /**
       * Label query over a set of resources, in this case pods.
       */
      labelSelector: LabelSelector;
      /** Specifies which namespaces the labelSelector applies to (matches against); null or empty list means "this pod's namespace" */
      namespaces?: string[];
      /** This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed. */
      topologyKey: string;
  }/** @public */
  export declare interface WeightedPodAffinityTerm {
      /** A pod affinity term, associated with the corresponding weight. */
      podAffinityTerm: PodAffinityTerm;
      /**
       * weight associated with matching the corresponding podAffinityTerm, in the range 1-100.
       */
      weight: number;
  }/** @public */
  export declare interface PodAffinity {
      /**
       * The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions.
       *
       * The node that is most preferred is the one with the greatest sum of weights,
       * i.e. for each node that meets all of the scheduling requirements (resource request,
       * requiredDuringScheduling affinity expressions, etc.), compute a sum by iterating
       * through the elements of this field and adding "weight" to the sum if the node has pods
       * which matches the corresponding podAffinityTerm; the node(s) with the highest sum are the most preferred.
       */
      preferredDuringSchedulingIgnoredDuringExecution: WeightedPodAffinityTerm[];
      /**
       * If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node.
       *
       * If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system may or may not try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each podAffinityTerm are intersected, i.e. all terms must be satisfied.
       */
      requiredDuringSchedulingIgnoredDuringExecution: PodAffinityTerm[];
  }/** @public */
  export declare interface PodAntiAffinity {
      /** The scheduler will prefer to schedule pods to nodes that satisfy the anti-affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling anti-affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the node(s) with the highest sum are the most preferred. */
      preferredDuringSchedulingIgnoredDuringExecution: WeightedPodAffinityTerm[];
      /** If the anti-affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the anti-affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system may or may not try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each podAffinityTerm are intersected, i.e. all terms must be satisfied. */
      requiredDuringSchedulingIgnoredDuringExecution: PodAffinity;
  }/** @public */
  export declare interface Affinity {
      /** Describes node affinity scheduling rules for the pod. */
      nodeAffinity: NodeAffinity;
      /** Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)). */
      podAffinity: PodAffinity;
      /** PodAntiAffinity	Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)). */
      podAntiAffinity: PodAntiAffinity;
  }/** @public */
  export declare interface PodDNSConfigOption {
      name: string;
      value?: string;
  }/** @public */
  export declare interface PodDNSConfig {
      /**
       * A list of DNS name server IP addresses.
       *
       * This will be appended to the base nameservers generated from DNSPolicy. Duplicated nameservers will be removed.
       */
      nameservers: string[];
      /**
       * A list of DNS resolver options.
       *
       * This will be merged with the base options generated from DNSPolicy.
       * Duplicated entries will be removed.
       * Resolution options given in Options will override those that appear in the base DNSPolicy.
       */
      options: PodDNSConfigOption[];
      /**
       * A list of DNS search domains for host-name lookup.
       *
       * This will be appended to the base search paths generated from DNSPolicy. Duplicated search paths will be removed.
       */
      searches: string[];
  }/** @public */
  export declare interface PodReadinessGate {
      /** Refers to a condition in the pod's condition list with matching type. */
      conditionType: string;
  }/** @public */
  export declare interface SELinuxOptions {
      /** SELinux level label that applies to the container. */
      level: string;
      /** SELinux role label that applies to the container. */
      role: string;
      /** SELinux type label that applies to the container. */
      type: string;
      /** SELinux user label that applies to the container */
      user: string;
  }/** @public */
  export declare interface SeccompProfile {
      /**
       * Indicates a profile defined in a file on the node should be used.
       *
       * The profile must be preconfigured on the node to work.
       * Must be a descending path, relative to the kubelet's configured seccomp profile location.
       * Must only be set if type is "Localhost".
       */
      localhostProfile?: string;
      /**
       * Indicates which kind of seccomp profile will be applied.
       *
       * Valid options are:
       * * Localhost - a profile defined in a file on the node should be used.
       * * RuntimeDefault - the container runtime default profile should be used.
       * * Unconfined - no profile should be applied.
       */
      type: "Localhost" | "RuntimeDefault" | "Unconfined";
  }/** @public */
  export declare interface Sysctl {
      name: string;
      value: string;
  }/** @public */
  export declare interface WindowsSecurityContextOptions {
      /**
       * The GMSA admission webhook ({@link https://github.com/kubernetes-sigs/windows-gmsa}) inlines the contents of the GMSA credential spec named by the GMSACredentialSpecName field.
       */
      gmsaCredentialSpec?: string;
      /**
       * GMSACredentialSpecName is the name of the GMSA credential spec to use.
       */
      gmsaCredentialSpecName?: string;
      /**
       * The UserName in Windows to run the entrypoint of the container process.
       *
       * Defaults to the user specified in image metadata if unspecified. May also be set in PodSecurityContext.
       * If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
       */
      runAsUserName?: string;
  }/** @public */
  export declare interface PodSecurityContext {
      /**
       * A special supplemental group that applies to all containers in a pod.
       *
       * Some volume types allow the Kubelet to change the ownership of that volume to be owned by the pod:
       *
       * 1. The owning GID will be the FSGroup
       * 2. The setgid bit is set (new files created in the volume will be owned by FSGroup)
       * 3. The permission bits are OR'd with rw-rw----
       *
       * If unset, the Kubelet will not modify the ownership and permissions of any volume.
       */
      fsGroup?: number;
      /**
       * Defines behavior of changing ownership and permission of the volume before being exposed inside Pod.
       *
       * This field will only apply to volume types which support fsGroup based ownership(and permissions).
       * It will have no effect on ephemeral volume types such as: secret, configmaps and emptydir.
       * Valid values are "OnRootMismatch" and "Always". If not specified defaults to "Always".
       *
       * @defaultValue Always
       */
      fsGroupChangePolicy?: "OnRootMismatch" | "Always";
      /**
       * The GID to run the entrypoint of the container process.
       *
       * Uses runtime default if unset. May also be set in SecurityContext.
       * If set in both SecurityContext and PodSecurityContext, the value specified in
       * SecurityContext takes precedence for that container.
       */
      runAsGroup?: number;
      /**
       * Indicates that the container must run as a non-root user.
       *
       * If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and
       * fail to start the container if it does. If unset or false, no such validation will be performed.
       * May also be set in SecurityContext.
       * If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
       */
      runAsNonRoot?: boolean;
      /**
       * The UID to run the entrypoint of the container process.
       *
       * Defaults to user specified in image metadata if unspecified.
       * May also be set in SecurityContext.
       * If set in both SecurityContext and PodSecurityContext, the value specified in
       * SecurityContext takes precedence for that container.
       */
      runAsUser?: number;
      /**
       * The SELinux context to be applied to all containers.
       *
       * If unspecified, the container runtime will allocate a random SELinux context for each container.
       * May also be set in SecurityContext.
       * If set in both SecurityContext and PodSecurityContext, the value specified in
       * SecurityContext takes precedence for that container.
       */
      seLinuxOptions?: SELinuxOptions;
      /**
       * The seccomp options to use by the containers in this pod.
       */
      seccompProfile?: SeccompProfile;
      /**
       * 	A list of groups applied to the first process run in each container, in addition to the container's primary GID.
       *
       *  If unspecified, no groups will be added to any container.
       */
      supplementalGroups?: number[];
      /**
       * Sysctls hold a list of namespaced sysctls used for the pod.
       *
       * Pods with unsupported sysctls (by the container runtime) might fail to launch.
       */
      sysctls?: Sysctl[];
      /**
       * The Windows specific settings applied to all containers.
       *
       * If unspecified, the options within a container's SecurityContext will be used.
       * If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
       */
      windowsOptions: WindowsSecurityContextOptions;
  }/** @public */
  export declare interface Toleration {
      /**
       * Indicates the taint effect to match.
       *
       * Empty means match all taint effects.
       * When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
       */
      effect?: "NoSchedule" | "PreferNoSchedule" | "NoExecute";
      /**
       * The taint key that the toleration applies to.
       *
       * Empty means match all taint keys.
       * If the key is empty, operator must be Exists;
       * this combination means to match all values and all keys.
       */
      key?: string;
      /**
       * Represents a key's relationship to the value.
       *
       * Valid operators are Exists and Equal.
       * Defaults to Equal.
       * Exists is equivalent to wildcard for value, so that a pod can tolerate all taints of a particular category.
       *
       * @defaultValue Equal
       */
      operator?: "Exists" | "Equal";
      /**
       * Represents the period of time the toleration (which must be of effect NoExecute, otherwise this field is ignored) tolerates the taint.
       *
       * By default, it is not set, which means tolerate the taint forever (do not evict).
       * Zero and negative values will be treated as 0 (evict immediately) by the system.
       */
      tolerationSeconds?: number;
      /**
       * Value is the taint value the toleration matches to.
       *
       * If the operator is Exists, the value should be empty, otherwise just a regular string.
       */
      value?: string;
  }/** @public */
  export declare interface TopologySpreadConstraint {
      /**
       * Used to find matching pods.
       *
       * Pods that match this label selector are counted to determine the
       * number of pods in their corresponding topology domain.
       */
      labelSelector: LabelSelector;
      /**
       * Describes the degree to which pods may be unevenly distributed.
       *
       * When `whenUnsatisfiable=DoNotSchedule`, it is the maximum permitted
       * difference between the number of matching pods in the target topology
       * and the global minimum.
       * For example, in a 3-zone cluster, MaxSkew is set to 1, and pods with
       * the same labelSelector spread as 1/1/0: | zone1 | zone2 | zone3 | | P | P | |
       * - if MaxSkew is 1, incoming pod can only be scheduled to zone3 to become 1/1/1;
       *   scheduling it onto zone1(zone2) would make the ActualSkew(2-0) on zone1(zone2) violate MaxSkew(1).
       * - if MaxSkew is 2, incoming pod can be scheduled onto any zone.
       * When `whenUnsatisfiable=ScheduleAnyway`, it is used to give higher precedence to topologies that satisfy it.
       * It's a required field. Default value is 1 and 0 is not allowed.
       *
       * @example
       *
       * @defaultValue 1
       */
      maxSkew: number;
      /**
       * The key of node labels.
       *
       * Nodes that have a label with this key and identical values are considered to be in the same topology.
       * We consider each \<key, value\> as a "bucket", and try to put balanced number of pods into each bucket.
       * It's a required field.
       */
      topologyKey: string;
      /**
       * Indicates how to deal with a pod if it doesn't satisfy the spread constraint.
       *
       * - DoNotSchedule (default) tells the scheduler not to schedule it.
       * - ScheduleAnyway tells the scheduler to schedule the pod in any location,
       *   but giving higher precedence to topologies that would help reduce the skew.
       *
       * A constraint is considered "Unsatisfiable" for an incoming pod if and only if every possible
       * node assigment for that pod would violate "MaxSkew" on some topology.
       * For example, in a 3-zone cluster, MaxSkew is set to 1, and pods with the same labelSelector
       * spread as 3/1/1: | zone1 | zone2 | zone3 | | P P P | P | P | If WhenUnsatisfiable is set to DoNotSchedule,
       * incoming pod can only be scheduled to zone2(zone3) to become 3/2/1(3/1/2)
       * as ActualSkew(2-1) on zone2(zone3) satisfies MaxSkew(1).
       * In other words, the cluster can still be imbalanced, but scheduler won't make it
       * *more* imbalanced.
       *
       * It's a required field.
       */
      whenUnsatisfiable: string;
  }/** @public */
  export declare interface KeyToPath {
      /** The key to project. */
      key: string;
      /**
       * mode bits to use on this file,
       * Must be a value between 0 and 0777.
       * If not specified, the volume defaultMode will be used.
       * This might be in conflict with other options that affect the file mode, like fsGroup,
       * and the result can be other mode bits set.
       */
      mode?: number;
      /**
       * The relative path of the file to map the key to.
       *
       * May not be an absolute path. May not contain the path element '..'. May not start with the string '..'.
       */
      path: string;
  }/** @public */
  export declare interface ConfigMapVolumeSource {
      /**
       * mode bits to use on created files by default.
       *
       * Must be a value between 0 and 0777. Defaults to 0644.
       * Directories within the path are not affected by this setting.
       * This might be in conflict with other options that affect the file mode,
       * like fsGroup, and the result can be other mode bits set.
       */
      defaultMode?: number;
      /**
       * If unspecified, each key-value pair in the Data field of the referenced ConfigMap will be projected into the volume as a file whose name is the key and content is the value.
       *
       * If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present.
       * If a key is specified which is not present in the ConfigMap, the volume setup will error unless it is marked optional.
       * Paths must be relative and may not contain the '..' path or start with '..'.
       */
      items?: KeyToPath[];
      /**
       * Name of the referent.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names}
       */
      name: string | Handle;
      /** Specify whether the ConfigMap or its keys must be defined */
      optional?: boolean;
  }/** @public */
  export declare interface SecretVolumeSource {
      /**
       * mode bits to use on created files by default.
       *
       * Must be a value between 0 and 0777. Defaults to 0644.
       * Directories within the path are not affected by this setting.
       * This might be in conflict with other options that affect the file mode,
       * like fsGroup, and the result can be other mode bits set.
       */
      defaultMode?: number;
      /**
       * If unspecified, each key-value pair in the Data field of the referenced Secret will be projected into the volume as a file whose name is the key and content is the value.
       *
       * If specified, the listed keys will be projected into the specified paths,
       * and unlisted keys will not be present. If a key is specified which is not
       * present in the Secret, the volume setup will error unless it is marked optional.
       *
       * Paths must be relative and may not contain the '..' path or start with '..'.
       */
      items?: KeyToPath[];
      /** Specify whether the Secret or its keys must be defined */
      optional?: boolean;
      /**
       * Name of the secret in the pod's namespace to use.
       *
       *  More info: {@link https://kubernetes.io/docs/concepts/storage/volumes#secret}
       */
      secretName: string | Handle;
  }/** @public */
  export declare interface EmptyDirVolumeSource {
      /**
       * What type of storage medium should back this directory.
       *
       * The default is "" which means to use the node's default medium.
       * Must be an empty string (default) or Memory.
       * More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
       */
      medium: string;
      /**
       * Total amount of local storage required for this EmptyDir volume.
       *
       * The size limit is also applicable for memory medium.
       * The maximum usage on memory medium EmptyDir would be the minimum
       * value between the SizeLimit specified here and the sum of memory limits of all containers in a pod.
       * The default is nil which means that the limit is undefined.
       * More info: {@link http://kubernetes.io/docs/user-guide/volumes#emptydir}
       */
      sizeLimit: string;
  }/**
   * Volumes for {@link k8s.PodProps}
   *
   * @public
   */
  export declare interface Volume {
      /**
       * Volume's name.
       *
       * Must be a DNS_LABEL and unique within the pod.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names}
       */
      name: string;
      /**
       * Represents a configMap that should populate this volume
       */
      configMap?: ConfigMapVolumeSource;
      /**
       * EmptyDir represents a temporary directory that shares a pod's lifetime.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/storage/volumes#emptydir}
       *
       */
      emptyDir?: EmptyDirVolumeSource;
      /**
       * Represents a secret that should populate this volume.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/storage/volumes#secret}
       */
      secret?: SecretVolumeSource;
      /** Other k8s volume kinds not typed yet for \@adpt/cloud */
      [key: string]: any;
  }/**
   * Props for the {@link k8s.Pod} component
   *
   * @public
   */
  export declare interface PodProps extends WithChildren {
      /**
       *  True is this is a template for use in a controller, false otherwise
       *  @defaultValue false
       */
      isTemplate: boolean;
      /** Information about the k8s cluster (ip address, auth info, etc.) */
      config?: ClusterInfo;
      /** k8s metadata */
      metadata: Metadata;
      /**
       * Optional duration in seconds the pod may be active on the node relative to StartTime before the system will actively try to mark it failed and kill associated containers.
       *
       * Value must be a positive integer.
       */
      activeDeadlineSeconds?: number;
      /** If specified, the pod's scheduling constraints */
      affinity?: Affinity;
      /** AutomountServiceAccountToken indicates whether a service account token should be automatically mounted. */
      automountServiceAccountToken?: boolean;
      /**
       *  Specifies the DNS parameters of a pod.
       *
       *  Parameters specified here will be merged to the generated DNS configuration based on DNSPolicy.
       */
      dnsConfig?: PodDNSConfig;
      /**
       * Set DNS policy for the pod.
       *
       * Valid values are 'ClusterFirstWithHostNet', 'ClusterFirst', 'Default' or 'None'.
       * DNS parameters given in DNSConfig will be merged with the policy selected with DNSPolicy.
       * To have DNS options set along with hostNetwork, you have to specify DNS policy explicitly
       * to 'ClusterFirstWithHostNet'.
       *
       * @defaultValue ClusterFirst
       */
      dnsPolicy: "ClusterFirstWithHostNet" | "ClusterFirst" | "Default" | "None";
      /**
       * Indicates whether information about services should be injected into pod's environment variables matching the syntax of Docker links.
       *
       * @defaultValue true
       */
      enableServiceLinks: boolean;
      /**
       * An optional list of hosts and IPs that will be injected into the pod's hosts file if specified.
       *
       * This is only valid for non-hostNetwork pods.
       */
      hostAliases?: HostAlias[];
      /**
       * Use the host's ipc namespace.
       * @defaultValue false
       */
      hostIPC: boolean;
      /**
       * Host networking requested for this pod.
       *
       * Use the host's network namespace.
       * If this option is set, the ports that will be used must be specified. Default to false.
       */
      hostNetwork?: boolean;
      /**
       * Use the host's pid namespace.
       * @defaultValue false
       */
      hostPID: boolean;
      /**
       * Specifies the hostname of the Pod.
       *
       * If not specified, the pod's hostname will be set to a system-defined value.
       */
      hostname?: string;
      /**
       * List of references to secrets in the same namespace to use for pulling any of the images used by this PodSpec.
       *
       * If specified, these secrets will be passed to individual puller implementations for them to use.
       * For example, in the case of docker, only DockerConfig type secrets are honored.
       * More info: {@link https://kubernetes.io/docs/concepts/containers/images#specifying-imagepullsecrets-on-a-pod}
       */
      imagePullSecrets?: LocalObjectReference[];
      /**
       * A request to schedule this pod onto a specific node.
       *
       * If it is non-empty, the scheduler simply schedules this pod onto that node,
       * assuming that it fits resource requirements.
       */
      nodeName?: string;
      /**
       * A selector which must be true for the pod to fit on a node.
       *
       * Selector which must match a node's labels for the pod to be scheduled on that node.
       * More info: {@link https://kubernetes.io/docs/concepts/configuration/assign-pod-node/}
       */
      nodeSelector?: {
          [label: string]: boolean | string;
      };
      /**
       * Overhead represents the resource overhead associated with running a pod for a given RuntimeClass.
       *
       * This field will be autopopulated at admission time by the RuntimeClass admission controller.
       * If the RuntimeClass admission controller is enabled, overhead must not be set in Pod create requests.
       * The RuntimeClass admission controller will reject Pod create requests which have the overhead already set.
       * If RuntimeClass is configured and selected in the PodSpec, Overhead will be set to the value defined in
       * the corresponding RuntimeClass, otherwise it will remain unset and treated as zero.
       *
       * More info: {@link https://git.k8s.io/enhancements/keps/sig-node/20190226-pod-overhead.md}
       *
       * This field is alpha-level as of Kubernetes v1.16, and is only honored by servers that enable
       * the PodOverhead feature.
       * @alpha
       */
      overhead?: unknown;
      /**
       * PreemptionPolicy is the Policy for preempting pods with lower priority.
       *
       * This field is beta-level, gated by the NonPreemptingPriority feature-gate.
       *
       * @defaultValue PreemptLowerPriority
       * @beta
       */
      preemptionPolicy?: "Never" | "PreemptLowerPriority";
      /**
       * The priority various system components use this field to find the priority of the pod.
       *
       * When Priority Admission Controller is enabled, it prevents users from setting this field.
       * The admission controller populates this field from PriorityClassName.
       * The higher the value, the higher the priority.
       */
      priority?: number;
      /**
       * If specified, indicates the pod's priority.
       *
       * "system-node-critical" and "system-cluster-critical" are two special keywords which indicate the highest
       * priorities with the former being the highest priority. Any other name must be defined by creating a PriorityClass
       * object with that name. If not specified, the pod priority will be default or zero if there is no default.
       */
      priorityClassName?: string;
      /**
       *  If specified, all readiness gates will be evaluated for pod readiness.
       *
       *  A pod is ready when all its containers are ready AND all conditions specified
       *  in the readiness gates have status equal to "True"
       *
       *  More info: {@link https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#pod-readiness-gate}
       */
      readinessGates?: PodReadinessGate[];
      /**
       * Restart policy for all containers within the pod.
       *
       * One of Always, OnFailure, Never. Default to Always.
       * More info: {@link https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy}
       *
       * @defaultValue Always
       */
      restartPolicy: "Always" | "OnFailure" | "Never";
      /**
       * Refers to a RuntimeClass object in the node.k8s.io group, which should be used to run this pod.
       *
       * If no RuntimeClass resource matches the named class, the pod will not be run.
       * If unset or empty, the "legacy" RuntimeClass will be used, which is an implicit
       * class with an empty definition that uses the default runtime handler.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/containers/runtime-class/}
       *
       * This is a beta feature as of Kubernetes v1.14.
       */
      runtimeClassName?: string;
      /**
       *  If specified, the pod will be dispatched by specified scheduler.
       *  If not specified, the pod will be dispatched by default scheduler.
       */
      schedulerName?: string;
      /**
       * SecurityContext holds pod-level security attributes and common container settings.
       * See type description for default values of each field.
       *
       * @defaultValue \{\}
       */
      securityContext: PodSecurityContext;
      /**
       * ServiceAccountName is the name of the ServiceAccount to use to run this pod.
       * More info: {@link https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/}
       */
      serviceAccountName?: string | Handle;
      /**
       * If true the pod's hostname will be configured as the pod's FQDN, rather than the leaf name (the default).
       * In Linux containers, this means setting the FQDN in the hostname field of the kernel
       * (the nodename field of struct utsname).
       * In Windows containers, this means setting the registry value of hostname for the registry key
       * HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters to FQDN.
       * If a pod does not have FQDN, this has no effect.
       *
       * @defaultValue false
       */
      setHostnameAsFQDN?: boolean;
      /**
       * Share a single process namespace between all of the containers in a pod.
       * When this is set containers will be able to view and signal processes from other containers in the same pod,
       * and the first process in each container will not be assigned PID 1.
       * HostPID and ShareProcessNamespace cannot both be set.
       *
       * @defaultValue false
       */
      shareProcessNamespace: boolean;
      /**
       *  If specified, the fully qualified Pod hostname will be "\<hostname\>.\<subdomain\>.\<pod namespace\>.svc.\<cluster domain\>".
       *  If not specified, the pod will not have a domainname at all.
       */
      subdomain?: string;
      /**
       * Optional duration in seconds the pod needs to terminate gracefully.
       *
       * May be decreased in delete request. Value must be non-negative integer.
       * The value zero indicates delete immediately. If this value is nil, the default
       * grace period will be used instead. The grace period is the duration in seconds
       * after the processes running in the pod are sent a termination signal and the time
       * when the processes are forcibly halted with a kill signal. Set this value longer
       * than the expected cleanup time for your process. Defaults to 30 seconds.
       */
      terminationGracePeriodSeconds?: number;
      /** If specified, the pod's tolerations. */
      tolerations?: Toleration[];
      /**
       *  TopologySpreadConstraints describes how a group of pods ought to spread across topology domains.
       *
       *  Scheduler will schedule pods in a way which abides by the constraints. All topologySpreadConstraints are ANDed.
       */
      topologySpreadConstraints?: TopologySpreadConstraint[];
      /**
       * List of volumes that can be mounted by containers belonging to the pod.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/storage/volumes}
       */
      volumes?: Volume[];
  }/**
   * Component for Kubernetes Pods
   *
   * @public
   */
  export declare class Pod extends DeferredComponent<PodProps, ResolvedVolumes & ResolvedServiceAccountName> {
      static defaultProps: {
          isTemplate: boolean;
          metadata: {};
          dnsPolicy: string;
          enableServiceLinks: boolean;
          hostIPC: boolean;
          hostPID: boolean;
          restartPolicy: string;
          securityContext: {};
          shareProcessNamespace: boolean;
          terminationGracePeriodSeconds: number;
      };
      initialState(): {};
      build(helpers: BuildHelpers): Adapt.JSX.Element | null;
      status(_observe: ObserveForStatus, buildData: BuildData): Promise<Adapt.Status | undefined>;
  }/**
   * Spec for for Kubernetes Pods
   *
   * @public
   */
  export declare interface PodSpec extends Omit<PodProps, "config" | "metadata" | "isTemplate"> {
      containers: ContainerSpec[];
      terminationGracePeriodSeconds?: number;
  }/** @internal */
  const podResourceInfo: {
      kind: string;
      deployedWhen: typeof deployedWhen;
      statusQuery: (props: ResourcePropsWithConfig, observe: ObserveForStatus, buildData: BuildData) => Promise<any>;
  };/**
   * k8s Secret resource
   *
   * @param propsIn - props for Secret as specifed in {@link k8s.SecretProps}
   *
   * @public
   */
  export declare function Secret(propsIn: SFCDeclProps<SecretProps, typeof defaultProps>): Adapt.JSX.Element;/** @internal */
  const secretResourceInfo: {
      kind: string;
      deployedWhen: () => true;
      statusQuery: (props: ResourcePropsWithConfig, observe: ObserveForStatus, buildData: BuildData) => Promise<any>;
      makeManifest: (manifest: Manifest, elem: AdaptElement<ResourceProps>, _deployID: string) => {
          data: {
              [key: string]: string;
          } | undefined;
          stringData: {
              [key: string]: string;
          } | undefined;
          type: string | undefined;
          apiVersion: string; /**
           * stringData allows specifying non-binary secret data in string form.
           *
           * It is provided as a write-only convenience method. All keys and values are merged into the data field on write,
           * overwriting any existing values. It is never output when reading from the API.
           */
          kind: string;
          metadata: import("./manifest_support").MetadataInRequest;
          spec?: import("./DaemonSet").DaemonSetSpec | import("./common").CRSpec | import("./Pod").PodSpec | import("./Service").ServiceSpec | import("./Deployment").DeploymentSpec | undefined;
      };
  };/**
   * Convert {@link NetworkService} props to {@link k8s.Service} props
   * @param abstractProps - props to convert
   * @returns Kubernetes spec corresponding to `abstractProps`
   *
   * @internal
   */
  export declare function k8sServiceProps(abstractProps: NetworkServiceProps & BuiltinProps): Omit<ServiceProps, keyof ResourceBase>;/**
   * Native Kubernetes Service resource
   *
   * @remarks
   *
   * Implements the {@link NetworkServiceInstance} interface.
   *
   * @public
   */
  export declare function Service(propsIn: SFCDeclProps<ServiceProps, typeof defaultProps>): Adapt.JSX.Element;/** @public */
  export declare interface ServiceProps extends ServiceSpec {
      /** Legal configuration loaded from kubeconfig */
      config: ClusterInfo;
      metadata?: Metadata;
      selector?: Handle | EndpointSelector;
  }/** @public */
  export declare interface ServiceSpec {
      /**
       * Cluster IP for a {@link k8s.Service}
       *
       * @remarks
       * `clusterIP` is the IP address of the service and is usually assigned
       * randomly by the master. If an address is specified manually and is not
       * in use by others, it will be allocated to the service; otherwise,
       * creation of the service will fail. This field can not be changed through
       * updates. Valid values are "None", empty string (""), or a valid IP
       * address. "None" can be specified for headless services when proxying is
       * not required. Only applies to types ClusterIP, NodePort, and
       * LoadBalancer. Ignored if type is ExternalName.
       *
       * For more information, see the
       * {@link https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies |
       * Kubernetes documentation}.
       */
      clusterIP?: string;
      /**
       * A list of IP addresses for which nodes in the cluster
       * will also accept traffic for this service.
       *
       * @remarks
       * These IPs are not managed by
       * Kubernetes. The user is responsible for ensuring that traffic arrives at
       * a node with this IP. A common example is external load balancers that are
       * not part of the Kubernetes system.
       */
      externalIPs?: string[];
      /**
       * The external reference that kubedns or equivalent
       * will return as a CNAME record for this service.
       *
       * @remarks
       * No proxying will be involved. Must be a
       * {@link https://tools.ietf.org/html/rfc1123 | valid RFC-1123 hostname}
       * and requires Type to be ExternalName.
       */
      externalName?: string;
      /**
       * Denotes if this Service desires to route
       * external traffic to node-local or cluster-wide endpoints.
       *
       * @remarks
       * "Local" preserves the client source IP and avoids a second hop for
       * LoadBalancer and Nodeport type services, but risks potentially
       * imbalanced traffic spreading. "Cluster" obscures the client source IP
       * and may cause a second hop to another node, but should have good overall
       * load-spreading.
       */
      externalTrafficPolicy?: string;
      /**
       * Specifies the healthcheck nodePort for the service.
       *
       * @remarks
       * If not specified, HealthCheckNodePort is created by the service
       * api backend with the allocated nodePort. Will use user-specified nodePort
       * value if specified by the client. Only affects when Type is set to
       * LoadBalancer and ExternalTrafficPolicy is set to Local.
       */
      healthCheckNodePort?: number;
      /**
       * Only applies to Service Type: LoadBalancer. LoadBalancer will
       * get created with the IP specified in this field.
       *
       * @remarks
       * This feature depends on
       * whether the underlying cloud provider supports specifying the loadBalancerIP
       * when a load balancer is created. This field will be ignored if the
       * cloud provider does not support the feature.
       */
      loadBalancerIP?: string;
      /**
       * If specified and supported by the platform, this will
       * restrict traffic through the cloud provider load balancer
       * to the specified client IPs.
       *
       * @remarks
       * This field will be ignored if the cloud provider
       * does not support the feature.
       *
       * For more information, see the
       * {@link https://v1-17.docs.kubernetes.io/docs/tasks/access-application-cluster/configure-cloud-provider-firewall/ |
       * Kubernetes documentation}.
       */
      loadBalancerSourceRanges?: string[];
      /**
       * The list of ports that are exposed by this service.
       *
       * @remarks
       * For more information, see the
       * {@link https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies |
       * Kubernetes documentation}.
       */
      ports?: ServicePort[];
      /**
       * When set to true, indicates that
       * DNS implementations must publish the notReadyAddresses of subsets for the
       * Endpoints associated with the Service.
       *
       * @remarks
       * The default value is false. The
       * primary use case for setting this field is to use a StatefulSet's Headless
       * Service to propagate SRV records for its Pods without respect to their
       * readiness for purpose of peer discovery.
       */
      publishNotReadyAddresses?: boolean;
      /**
       * Route service traffic to pods with label keys and values
       * matching this selector.
       *
       * @remarks
       * If empty or not present, the service is assumed to
       * have an external process managing its endpoints, which Kubernetes will not
       * modify. Only applies to types ClusterIP, NodePort, and LoadBalancer.
       * Ignored if type is ExternalName.
       *
       * For more information, see the
       * {@link https://kubernetes.io/docs/concepts/services-networking/service/ |
       * Kubernetes documentation}.
       */
      selector?: EndpointSelector | object;
      /**
       * Used to maintain session affinity.
       *
       * @remarks
       * Possible values are:
       *
       * - `"ClientIP"`: Enables client IP based session affinity.
       *
       * - `"None"`: Disables session affinity.
       *
       * For more information, see the
       * {@link https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies |
       * Kubernetes documentation}.
       * @defaultValue `"None"`
       */
      sessionAffinity?: string;
      /**
       * Determines how the Service is exposed.
       *
       * @remarks
       * Valid options are:
       *
       * - `"ExternalName"`: maps to the specified externalName.
       *
       * - `"ClusterIP"`: allocates a cluster-internal IP address for load
       * balancing to endpoints. Endpoints are determined by the selector or if
       * that is not specified, by manual construction of an Endpoints object. If
       * clusterIP is "None", no virtual IP is allocated and the endpoints are
       * published as a set of endpoints rather than a stable IP.
       *
       * - `"NodePort"`: Builds on ClusterIP and allocates a port on every node
       * which routes to the clusterIP.
       *
       * - `"LoadBalancer"`: Builds on NodePort and creates an external load
       * balancer (if supported in the current cloud) which routes to the
       * clusterIP.
       *
       * For more information, see the
       * {@link https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services---service-types |
       * Kubernetes documentation}.
       * @defaultValue `"ClusterIP"`
       */
      type?: string;
  }/** @public */
  export declare interface ServicePort {
      /**
       * The name of this port within the service.
       *
       * @remarks
       * This must be a DNS_LABEL.
       * All ports within a ServiceSpec must have unique names.This maps to the
       * Name' field in EndpointPort objects. Optional if only one ServicePort is
       * defined on this service.
       */
      name?: string;
      /**
       * The port on each node on which this service is exposed when
       * type=NodePort or LoadBalancer.
       *
       * @remarks
       * Usually assigned by the system. If
       * specified, it will be allocated to the service if unused or else creation
       * of the service will fail.
       *
       * For more information, see the
       * {@link https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport |
       * Kubernetes documentation}.
       * @defaultValue Automatically allocates a port if the ServiceType of this
       * Service requires one.
       */
      nodePort?: number;
      /** The port that will be exposed by this service. */
      port?: number;
      /** The IP protocol for this port.Supports "TCP" and "UDP".Default is TCP. */
      protocol?: string;
      /**
       * Number or name of the port to access on the pods targeted by the
       * service.
       *
       * @remarks
       * Number must be in the range 1 to 65535. Name must be an
       * IANA_SVC_NAME. If this is a string, it will be looked up as a named port
       * in the target Pod's container ports. If this is not specified, the value
       * of the 'port' field is used (an identity map). This field is ignored for
       * services with clusterIP = None, and should be omitted or set equal to the
       * 'port' field.
       *
       * For more information, see the
       * {@link https://kubernetes.io/docs/concepts/services-networking/service/#defining-a-service |
       * Kubernetes documentation}.
       */
      targetPort?: number | string;
  }/** @internal */
  const serviceResourceInfo: {
      kind: string;
      deployedWhen: typeof deployedWhen;
      statusQuery: (props: ResourcePropsWithConfig, observe: ObserveForStatus, buildData: BuildData) => Promise<any>;
  };/**
   * k8s ServiceAccount resource
   *
   * @param propsIn - props for ServiceAccount as specifed in {@link k8s.ServiceAccountProps}
   *
   * @public
   */
  export declare function ServiceAccount(propsIn: SFCDeclProps<ServiceAccountProps, typeof defaultProps>): Adapt.JSX.Element;/** @public */
  export declare function isServiceAccountProps(p: ResourceProps): p is ResourceProps & ResourceServiceAccount;/** @internal */
  const serviceAccountResourceInfo: {
      kind: string;
      deployedWhen: () => true;
      statusQuery: (props: ResourcePropsWithConfig, observe: ObserveForStatus, buildData: BuildData) => Promise<any>;
      makeManifest: (manifest: Manifest, elem: AdaptElement<ResourceProps>, _deployID: string) => {
          automountServiceAccountToken: boolean | undefined;
          imagePullSecrets: {
              name: string;
          }[] | undefined;
          secrets: ObjectReference[] | undefined;
          apiVersion: string;
          kind: string;
          metadata: import("./manifest_support").MetadataInRequest;
          spec?: import("./DaemonSet").DaemonSetSpec | import("./common").CRSpec | import("./Pod").PodSpec | import("./Service").ServiceSpec | import("./Deployment").DeploymentSpec | undefined;
      };
  };/**
   * Props for {@link k8s.ServiceDeployment}
   *
   * @public
   */
  export declare interface ServiceDeploymentProps<T extends AllowableComponentProps = DeploymentProps> extends ServiceProps {
      config: ClusterInfo;
      serviceProps?: Partial<ServiceProps>;
      component: ComponentType<T>;
      componentProps: T;
      podProps?: Partial<PodProps>;
      containerProps?: Partial<OmitT<K8sContainerProps, "image">>;
  }/**
   * A component for mapping a group of abstract {@link Container}s and
   * {@link NetworkService}s to Kubernetes {@link k8s.Pod}s and
   * {@link k8s.K8sContainer}s.
   *
   * @remarks
   * This component is intended to be used to replace {@link Container} and
   * {@link NetworkService} components that are grouped together, as the
   * only children of a common parent in a pattern that looks like this:
   *
   * ```tsx
   * <Service>
   *   <Container ... />
   *   <Container ... />
   *   <NetworkService ... />
   * </Service>
   * ```
   *
   * `ServiceDeployment` would map those abstract components into corresponding
   * k8s components like this:
   * ```tsx
   * <Group>
   *   <docker.RegistryDockerImage ... /> //If props.config specifies a registry
   *   <k8s.Deployment ... >
   *     <Pod isTemplate>
   *       <k8s.K8sContainer ... />
   *     </Pod>
   *   </k8s.Deployment>
   *   <docker.RegistryDockerImage ... /> //If props.config specifies a registry
   *   <k8s.Deployment ... >
   *     <Pod isTemplate>
   *       <k8s.K8sContainer ... />
   *     </Pod>
   *   </k8s.Pod>
   *   <k8s.Service ... />
   * </Group>
   * ```
   * An example style rule to do this is:
   * ```tsx
   * {Adapt.rule((matchedProps) => {
   *     const { handle, ...remainingProps } = matchedProps;
   *     return <ServiceDeployment config={kubeconfig} {...remainingProps} />;
   * })}
   * ```
   * `ServiceDeployment` also requires the `config` prop which specifies
   * connection and authentication information for the Kubernetes cluster on
   * which these objects should be created.
   *
   * @public
   */
  export declare class ServiceDeployment<T extends AllowableComponentProps> extends DeferredComponent<ServiceDeploymentProps<T>> {
      static defaultProps: {
          component: typeof Deployment;
          componentProps: {
              replicas: number;
          };
      };
      build(helpers: BuildHelpers): Adapt.JSX.Element;
  }/** @public */
  export declare function computeNamespaceFromMetadata(metadata?: Metadata): string;/** @public */
  export declare function isLabelSelector(x: any): x is LabelSelector;/**
   * Kubernetes Kind
   *
   * @public
   */
  export declare type Kind = string;/** @public */
  export declare interface CRSpec {
      [key: string]: any;
  }/** @public */
  export declare type Spec = DaemonSetSpec | DeploymentSpec | PodSpec | ServiceSpec | CRSpec;/** @public */
  export declare interface Metadata {
      namespace?: string;
      labels?: {
          [key: string]: string;
      };
      annotations?: {
          [key: string]: string;
      };
  }/** @public */
  export declare type ResourceProps = {
      key: string;
  } & (ResourceClusterRole | ResourceClusterRoleBinding | ResourceDaemonSet | ResourcePod | ResourceService | ResourceServiceAccount | ResourceConfigMap | ResourceSecret | ResourceCR);/** @public */
  export declare type ResourcePropsWithConfig = ResourceProps & {
      config: ClusterInfo;
  };/** @public */
  export declare interface ResourceInfo {
      kind: Kind;
      statusQuery?: (props: ResourceProps, observe: ObserveForStatus, buildData: BuildData) => unknown | Promise<unknown>;
      specsEqual(actual: Spec, element: Spec): boolean;
  }/**
   * Holds the information needed to connect, authenticate, and run code in a kuberenetes cluster
   *
   * @public
   */
  export declare interface ClusterInfo {
      /** Javascript object formed by parsing a valid kubeconfig file */
      kubeconfig: Kubeconfig;
      /**
       * Registry to which Docker images used by the cluster in `kubeconfig` should be pushed and pulled
       *
       * @remarks
       * If `registryPrefix` is a string, it is assumed that the cluster can pull from the same string
       * that outsiders can push to.
       *
       * If `registryPrefix` is of the form `{ external: string, internal: string }` then the `external`
       * string will be used to push images, and the `internal` string will be used to pull images.
       *
       * Note(manishv)
       * This is a bit of a hack to allow one hostname or IP address to push images from outside
       * a particular environment (say k8s) and a different URL for that environment to pull
       * images.
       *
       * A good example of this is a k3s-dind (k3s docker-in-docker) instance of kubernetes where
       * a private registry is running on a docker network attached to the k3s-dind instance, but where we
       * want to push {@link docker.LocalDockerImage} built images to that registry.  Since
       * {@link docker.LocalDockerImage | LocalDockerImage} is outside the k3s-dind environment, it must
       * use a host accessible network to push to the registry.  However, since the k3s-dind instance sees
       * the registry from within Docker, it must use a different address to pull the images for use.
       *
       * Once network scopes are fully supported, this interface will change to whatever is appropriate.  It
       * is best if you can arrange to have the same URL or registry string work for all access regardless
       * of which network the registry, Adapt host, and ultimate container running environment uses.
       *
       */
      registryPrefix?: string | DockerSplitRegistryInfo;
  }/** @public */
  export declare interface ResourceBase {
      /**
       * config to connect to the k8s cluster
       *
       * required if isTemplate is false
       */
      config?: ClusterInfo;
      /**
       * Specifies whether this resource is just a template for use in a controller
       */
      isTemplate?: boolean;
      apiVersion?: string;
      kind: Kind;
      metadata?: Metadata;
  }/**
   * @public
   */
  export declare interface PolicyRule {
      /**
       * APIGroups is the name of the APIGroup that contains the resources.
       *
       * If multiple API groups are specified, any action requested against one
       * of the enumerated resources in any API group will be allowed.
       */
      apiGroups?: string[];
      /**
       * NonResourceURLs is a set of partial urls that a user should have access to.
       *
       * *s are allowed, but only as the full, final step in the path.
       * Since non-resource URLs are not namespaced, this field is only applicable
       * for ClusterRoles referenced from a ClusterRoleBinding.
       * Rules can either apply to API resources (such as "pods" or "secrets") or
       * non-resource URL paths (such as "/api"), but not both.
       */
      nonResourceURLs?: string[];
      /**
       * ResourceNames is an optional white list of names that the rule applies to.
       *
       * An empty set means that everything is allowed.
       */
      resourceNames?: string[];
      /**
       * Resources is a list of resources this rule applies to.
       *
       * ResourceAll represents all resources.
       */
      resources: string[];
      /**
       * Verbs is a list of Verbs that apply to ALL the ResourceKinds and
       * AttributeRestrictions contained in this rule.
       *
       * VerbAll represents all kinds.
       */
      verbs: string[];
  }/**
   * AggregationRule for {@link k8s.ClusterRole}
   *
   * @public
   */
  export declare interface AggregationRule {
      /**
       * ClusterRoleSelectors holds a list of selectors which will be used to
       * find ClusterRoles and create the rules.
       *
       * If any of the selectors match, then the ClusterRole's permissions will be added
       */
      clusterRoleSelector: LabelSelector;
  }/** @public */
  export declare interface ResourceClusterRole extends ResourceBase {
      apiVersion: "rbac.authorization.k8s.io/v1";
      kind: "ClusterRole";
      aggregationRule?: AggregationRule;
      rules?: PolicyRule[];
  }/**
   * RoleRef for {@link k8s.ResourceClusterRoleBinding}
   *
   * @public
   */
  export declare interface RoleRef {
      /** apiGroup is the group for the resource being referenced */
      apiGroup: string;
      /** kind is the type of resource being referenced */
      kind: string;
      /** Name is the name of resource being referenced */
      name: string;
  }/**
   * Subject for {@link k8s.ResourceClusterRoleBinding}
   *
   * @public
   */
  export declare interface Subject {
      /** apiGroup is the group for the object being referenced */
      apiGroup: string;
      /** kind is the type of object being referenced */
      kind: string;
      /**
       * Name of the object being referenced.
       */
      name: string;
      /**
       * Namespace of the referenced object.
       *
       * If the object kind is non-namespace, such as "User" or "Group", and this value
       * is not empty the Authorizer should report an error.
       */
      namespace?: string;
  }/** @public */
  export declare interface ResourceClusterRoleBinding extends ResourceBase {
      apiVersion: "rbac.authorization.k8s.io/v1";
      kind: "ClusterRoleBinding";
      roleRef: RoleRef;
      subjects: Subject[];
  }/** @public */
  export declare interface ResourceDaemonSet extends ResourceBase {
      apiVersion: "apps/v1";
      kind: "DaemonSet";
      spec: DaemonSetSpec;
  }/** @public */
  export declare interface ResourcePod extends ResourceBase {
      kind: "Pod";
      spec: PodSpec;
  }/** @public */
  export declare interface ResourceService extends ResourceBase {
      kind: "Service";
      spec: ServiceSpec;
  }/** @public */
  export declare interface ResourceServiceAccount extends ResourceBase {
      kind: "ServiceAccount";
      automountServiceAccountToken?: boolean;
      imagePullSecrets?: {
          name: string;
      }[];
      secrets?: ObjectReference[];
  }/** @public */
  export declare interface ResourceConfigMap extends ResourceBase {
      kind: "ConfigMap";
      binaryData?: {
          [key: string]: string;
      };
      data?: {
          [key: string]: string;
      };
      /** @beta */
      immutable?: boolean;
  }/** @public */
  export declare interface ResourceSecret extends ResourceBase {
      kind: "Secret";
      data?: {
          [key: string]: string;
      };
      stringData?: {
          [key: string]: string;
      };
      type?: string;
  }/** @public */
  export declare interface ResourceCR extends ResourceBase {
      kind: string;
      spec: CRSpec;
  }/** @public */
  export declare interface Kubeconfig {
      apiVersion?: "v1";
      kind: "Config";
      "current-context": string;
      contexts: {
          name: string;
          context: {
              cluster: string;
              user: string;
          };
      }[];
      clusters: {
          name: string;
          cluster: {
              "certificate-authority-data": string;
              server: string;
          };
      }[];
      preferences?: unknown;
      users: {
          name: string;
          user: {
              "client-certificate-data"?: string;
              "client-key-data"?: string;
              "username"?: string;
              "password"?: string;
          };
      }[];
  }/** @public */
  export declare interface LabelSelector {
      /**
       * matchExpressions is a list of label selector requirements. The requirements are ANDed.
       */
      matchExpressions?: LabelSelectorRequirement[];
      /**
       * matchLabels is a map of `{key,value}`pairs. A single `{key,value}` in the matchLabels map
       * is equivalent to an element of matchExpressions, whose key field is "key", the operator
       * is "In", and the values array contains only "value". The requirements are ANDed.
       */
      matchLabels?: {
          [key: string]: string;
      };
  }/** @public */
  export declare interface LocalObjectReference {
      /**
       * Name of the referent.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names}
       */
      name: string;
  }/**
   * PodTemplateSpec from k8s API
   *
   * @public
   */
  export declare interface PodTemplateSpec {
      /**
       * Standard object's metadata.
       * More Info: {@link https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata}
       */
      metadata: Metadata;
      /**
       * Specification of the desired behavior of the pod.
       * More Info: {@link https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status}
       */
      spec: PodSpec;
  }/**
   * ObjectReference from k8s API
   *
   * @public
   */
  export declare interface ObjectReference {
      /**
       * If referring to a piece of an object instead of an entire object,
       * this string should contain a valid JSON/Go field access statement,
       * such as desiredState.manifest.containers[2].
       *
       * For example, if the object reference is to a container within a pod,
       * this would take on a value like: "spec.containers\{name\}" (where "name"
       * refers to the name of the container that triggered the event) or if no
       * container name is specified "spec.containers[2]"
       * (container with index 2 in this pod).
       * This syntax is chosen only to have some well-defined way of referencing a
       * part of an object.
       */
      fieldPath: string;
      /**
       * Name of the referent.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names}
       *
       */
      name: string;
      /**
       * Namespace of the referent.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/}
       */
      namespace: string;
      /**
       * Specific resourceVersion to which this reference is made, if any.
       *
       * More info: {@link https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency}
       */
      resourceVersion: string;
      /**
       * UID of the referent.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids}
       */
      uid: string;
  }/**
   * Make a {@link k8s.ClusterInfo} object suitable for use with k8s resources
   *
   * @remarks
   *
   * This function will take a set of options and generate a {@link k8s.ClusterInfo}
   * object that contains the kubeconfig, registryPrefix for private images, and any other
   * relevant information for the cluster
   *
   * See {@link k8s.MakeClusterInfoOptions} for information on how the information
   * is computed.
   *
   * @returns A {@link k8s.ClusterInfo} object.
   *
   * @public
   */
  export declare function makeClusterInfo(options: MakeClusterInfoOptions): Promise<ClusterInfo>;/** @internal */
  export declare function isResourcePodTemplate(x: any): x is AdaptElement<ResourcePod>;/**
   * Hook that allows a prop to be either an array of handle to k8s resources and values
   *
   * @param initial - initial value of the prop, before the handles are be resolved
   * @param notReady - is a marker value to indicate that a handle's value isn't available yet
   * @param kinds - an array of legal k8s Kinds that a prop handle can point to
   * @param thisResourceName - the name of the resource using the hook, for error messages
   * @param propName - the name of the prop being resolved, again for error messages
   *
   * @returns A two element array, the first element is the current value, the second the update function
   *
   * This hook will start by returning the initial value and an update function that updates
   * the value the hook returns.  The update function takes 2 arguments - the prop value which
   * is an array with a mix of values and handles to be resolved, and a function that receives
   * the elements that any handles point to along with that elements props.  This function
   * can be passed by the caller of update to resolve handles as appropriate for the component.
   *
   * For example, {@link k8s.ClusterRoleBinding} uses this hook to resolve the subjects prop,
   * which is an array of other objects (typically {@link ServiceAccount}) that a particular
   * {@link k8s.ClusterRole} should point to.  When ClusterRoleBinding calls the update method,
   * it passes a function that will convert a {@link k8s.Resource} element of Kind `ServiceAccount`
   * to the underlying `Subject` object that kubernetes expects, namely
   * `{ apiGroup: "", kind: "ServiceAccount", name: resourceIdToName(elem, deployID), namespace: <element namespace> }`
   *
   * @example
   * ```
   * function MyResource({ serviceAccountNames }: { serviceAccountNames: (string | Handle)[]}) {
   *   const { deployID } = useBuildHelpers();
   *   const [ resolvedServiceAccountNames, updateSANs] = useResources({
   *      initial: [],
   *      notReady: null,
   *      kinds: ["ServiceAccount"],
   *      thisResourceName: "MyResources",
   *      propName: "serviceAccountNames",
   *   });
   *
   *   updateSANs(serviceAccountNames, (e, props) => {
   *      return {
   *        apiGroup: (e.metadata.apiVersion?.split("/")[0]) || "",
   *        name: resourceElementToName(e, deployID),
   *        namespace: props.metadata.namespace,
   *      }
   *   });
   *
   *   return null;
   * }
   * ```
   *
   * @beta
   */
  export declare function useResources<ValT, NotReadyT>({ initial, notReady, kinds, thisResourceName, propName, }: {
      initial: ValT[];
      notReady: NotReadyT;
      kinds: string[];
      thisResourceName: string;
      propName: string;
  }): [
      (ValT | NotReadyT)[],
      (props: (ValT | Handle)[], f: (e: AdaptMountedElement, props: ResourceProps) => Promise<ValT> | ValT) => void
  ];/**
   * Hook to allow conversion of a prop that could be a value or a handle
   *
   * This function behaves similarly to {@link k8s.useResources}, but works for
   * a prop that is either a Handle or a single value instead of an array of
   * Handles and values.
   *
   * See {@link k8s.useResources} for more detailed documentation.
   *
   * @beta
   */
  export declare function useResource<ValT, NotReadyT>(opts: {
      initial: ValT | NotReadyT;
      notReady: NotReadyT;
      kinds: string[];
      thisResourceName: string;
      propName: string;
  }): [
      ValT | NotReadyT,
      (prop: ValT | Handle, f: (e: AdaptMountedElement, props: ResourceProps) => Promise<ValT> | ValT) => void
  ];/**
   * Options for {@link k8s.makeClusterInfo}
   *
   * @public
   */
  export declare interface MakeClusterInfoOptions {
      /**
       * A Javascript Object representing a valid kubeconfig, or a YAML string, or a path to a kubeconfig file.
       *
       * @remarks
       * If this is a Javascript object, it will be treated like a parsed kubeconfig.  If this is a string,
       * {@link k8s.makeClusterInfo} will first attempt to parse it as JSON.  If that fails, it will attempt
       * to parse it as YAML.  If that fails it will treat the string as a path of configs (like with the `KUBECONFIG`
       * environment variable).
       *
       * If kubeconfig is missing {@link k8s.makeClusterInfo} will use the `KUBECONFIG` environment variable to build
       * a suitable config using `kubectl config view --flatten` and return that as the kubeconfig in the resulting
       * {@link k8s.ClusterInfo}
       */
      kubeconfig?: Kubeconfig | string;
      /**
       * URL to the docker registry that this cluster uses to pull private images.
       *
       * @remarks
       * This is identical to the `registryPrefix` field in {@link k8s.ClusterInfo}.  It will
       * be returned verbatim in the resulting {@link k8s.ClusterInfo} object.
       */
      registryPrefix?: string | DockerSplitRegistryInfo;
  }/**
   * k8s ClusterRole resource
   *
   * @param propsIn - props for ServiceAccount as specifed in {@link k8s.ClusterRoleProps}
   *
   * @public
   */
  export declare function ClusterRole(propsIn: SFCDeclProps<ClusterRoleProps, typeof defaultProps>): Adapt.JSX.Element;/** @public */
  export declare function isClusterRoleProps(props: ResourceProps): props is ResourceProps & ResourceClusterRole;/** @internal */
  const clusterRoleResourceInfo: {
      kind: string;
      deployedWhen: () => true;
      statusQuery: (props: ResourcePropsWithConfig, observe: ObserveForStatus, buildData: BuildData) => Promise<any>;
      makeManifest: (manifest: Manifest, elem: AdaptElement<ResourceProps>, _deployID: string) => {
          aggregationRule: AggregationRule | undefined;
          rules: PolicyRule[] | undefined;
          apiVersion: string;
          kind: string;
          metadata: import("./manifest_support").MetadataInRequest;
          spec?: import("./DaemonSet").DaemonSetSpec | import("./common").CRSpec | import("./Pod").PodSpec | import("./Service").ServiceSpec | import("./Deployment").DeploymentSpec | undefined;
      };
  };/**
   * k8s ClusterRoleBinding resource
   *
   * @param propsIn - props for ServiceAccount as specifed in {@link k8s.ClusterRoleBindingProps}
   *
   * @public
   */
  export declare function ClusterRoleBinding(propsIn: SFCDeclProps<ClusterRoleBindingProps, typeof defaultProps>): Adapt.JSX.Element | null;/** @internal */
  const clusterRoleBindingResourceInfo: {
      kind: string;
      deployedWhen: () => true;
      statusQuery: (props: ResourcePropsWithConfig, observe: ObserveForStatus, buildData: BuildData) => Promise<any>;
      makeManifest: (manifest: Manifest, elem: AdaptElement<ResourceProps>, _deployID: string) => {
          roleRef: RoleRef;
          subjects: Subject[];
          apiVersion: string;
          kind: string;
          metadata: import("./manifest_support").MetadataInRequest;
          spec?: import("./DaemonSet").DaemonSetSpec | import("./common").CRSpec | import("./Pod").PodSpec | import("./Service").ServiceSpec | import("./Deployment").DeploymentSpec | undefined;
      };
  };/**
   * k8s ConfigMap resource
   *
   * @param propsIn - props for ConfigMap as specifed in {@link k8s.ConfigMapProps}
   *
   * @public
   */
  export declare function ConfigMap(propsIn: SFCDeclProps<ConfigMapProps, typeof defaultProps>): Adapt.JSX.Element;/** @internal */
  const configMapResourceInfo: {
      kind: string;
      deployedWhen: () => true;
      statusQuery: (props: ResourcePropsWithConfig, observe: ObserveForStatus, buildData: BuildData) => Promise<any>;
      makeManifest: (manifest: Manifest, elem: AdaptElement<ResourceProps>, _deployID: string) => {
          data: {
              [key: string]: string;
          } | undefined;
          binaryData: {
              [key: string]: string;
          } | undefined;
          immutable: boolean | undefined;
          apiVersion: string;
          kind: string;
          metadata: import("./manifest_support").MetadataInRequest;
          spec?: import("./DaemonSet").DaemonSetSpec | import("./common").CRSpec | import("./Pod").PodSpec | import("./Service").ServiceSpec | import("./Deployment").DeploymentSpec | undefined;
      };
  };/**
   * Low level utility function to translate from the abstract {@link Container}
   * component props ({@link ContainerProps}) to {@link k8s.K8sContainerProps}
   * to be used in a {@link k8s.K8sContainer}.
   * @remarks
   * Note: The `image` property in the passed in {@link ContainerProps} must
   * be a `string`, not a `Handle`.
   * In most cases, it is preferable to use the {@link k8s.Container} component
   * instead, which is designed specifically to deal with this issue.
   *
   * @param abstractProps - The abstract {@link ContainerProps} to translate from.
   * @param k8sProps - Props that are specific to the {@link k8s.K8sContainer}
   *     component that should be merged into the resulting returned
   *     {@link k8s.K8sContainerProps} object.
   * @public
   */
  export declare function k8sContainerProps(abstractProps: FromContainerProps, k8sProps?: Partial<K8sContainerProps>): K8sContainerProps;/**
   * Tests whether an element is a {@link k8s.K8sContainer} element
   * @param x - element to test
   * @returns `true` if element is a {@link k8s.K8sContainer}, `false` otherwise
   *
   * @remarks
   * Acts as a TypeScript type assertion that will assert that `x` is `AdaptElement<K8sContainerProps>`
   *
   * @public
   */
  export declare function isK8sContainerElement(x: AdaptElement): x is AdaptElement<K8sContainerProps>;/**
   * Component that implements the abstract {@link Container} interface and
   * translates to a Kubernetes-specific {@link k8s.K8sContainer}.
   * @public
   */
  export declare function Container(props: ContainerProps): Adapt.JSX.Element | null;/** @public */
  export declare interface VolumeMount {
      /**
       * Path within the container at which the volume should be mounted.
       *
       * Must not contain ':'.
       */
      mountPath: string;
      /**
       * mountPropagation determines how mounts are propagated from the host to container and the other way around.
       *
       * When not set, MountPropagationNone is used. This field is beta in 1.10.
       *
       * @defaultValue MountPropagationNone
       */
      mountPropagation?: string;
      /** This must match the Name of a Volume. */
      name: string;
      /**
       * Mounted read-only if true, read-write otherwise (false or unspecified).
       *
       * @defaultValue false
       */
      readOnly?: boolean;
      /**
       * Path within the volume from which the container's volume should be mounted.
       *
       * Defaults to "" (volume's root).
       *
       * @defaultValue ""
       */
      subPath?: string;
      /**
       * Expanded path within the volume from which the container's volume should be mounted.
       *
       * Behaves similarly to SubPath but environment variable references $(VAR_NAME)
       * are expanded using the container's environment.
       *
       * Defaults to "" (volume's root).
       *
       * SubPathExpr and SubPath are mutually exclusive.
       *
       * @defaultValue ""
       */
      subPathExpr?: string;
  }/** @public */
  export declare interface ConfigMapEnvSource {
      /**
       * Name of the referent.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names}
       */
      name?: string;
      /**
       * Specify whether the ConfigMap must be defined
       */
      optional?: boolean;
  }/** @public */
  export declare interface SecretEnvSource {
      /**
       * Name of the referent.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names}
       */
      name?: string;
      /**
       * Specify whether the Secret must be defined
       */
      optional?: boolean;
  }/** @public */
  export declare interface EnvFromSource {
      /** The ConfigMap to select from */
      configMapRef?: ConfigMapEnvSource;
      /** An optional identifier to prepend to each key in the ConfigMap. Must be a C_IDENTIFIER. */
      prefix?: string;
      /** SecretEnvSource	The Secret to select from */
      secretRef?: SecretEnvSource;
  }/** @public */
  export declare interface ExecAction {
      /**
       * Command is the command line to execute inside the container.
       *
       * The working directory for the command is root ('/') in the container's filesystem.
       * The command is simply exec'd, it is not run inside a shell,
       * so traditional shell instructions ('|', etc) won't work.
       * To use a shell, you need to explicitly call out to that shell.
       *
       * Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
       */
      command: string[];
  }/** @public */
  export declare interface HTTPGetAction {
      /**
       * Host name to connect to, defaults to the pod IP.
       *
       * You probably want to set "Host" in httpHeaders instead.
       */
      host?: string;
      /** Custom headers to set in the request. HTTP allows repeated headers. */
      httpHeaders?: {
          name: string;
          value: string;
      }[];
      /** Path to access on the HTTP server. */
      path: string;
      /**
       * Name or number of the port to access on the container.
       *
       * Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
       */
      port: number | string;
      /**
       * Scheme to use for connecting to the host.
       *
       * @defaultValue HTTP.
       */
      scheme?: string;
  }/** @public */
  export declare interface TCPSocketAction {
      /** Host name to connect to, defaults to the pod IP. */
      host?: string;
      /**
       * Number or name of the port to access on the container.
       *
       * Number must be in the range 1 to 65535.
       * Name must be an IANA_SVC_NAME.
       */
      port: string | number;
  }/** @public */
  export declare interface Probe {
      /**
       * Exec specifies the action to take.
       *
       * Only one of exec, httpGet, or tcpSocket should be specified
       */
      exec?: ExecAction;
      /**
       * Minimum consecutive failures for the probe to be considered failed after having succeeded.
       *
       * Defaults to 3. Minimum value is 1.
       *
       * @defaultValue 3
       */
      failureThreshold?: number;
      /** Specifies the http request to perform. */
      httpGet?: HTTPGetAction;
      /**
       *  Seconds after the container has started before liveness probes are initiated.
       *  More info: {@link https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes}
       */
      initialDelaySeconds?: number;
      /** How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. */
      periodSeconds?: number;
      /**
       * Minimum consecutive successes for the probe to be considered successful after having failed.
       *
       * Must be 1 for liveness and startup. Minimum value is 1.
       *
       * @defaultValue 1
       */
      successThreshold?: number;
      /**
       * Specifies an action involving a TCP port.
       *
       * TCP hooks not yet supported
       */
      tcpSocket?: TCPSocketAction;
      /**
       * Number of seconds after which the probe times out.
       *
       * Defaults to 1 second. Minimum value is 1.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes}
       *
       * @defaultValue 1
       */
      timeoutSeconds?: number;
  }/** @public */
  export declare interface ResourceRequirements {
      /**
       * Limits describes the maximum amount of compute resources allowed.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/}
       */
      limits?: {
          [key: string]: any;
      };
      /**
       * Describes the minimum amount of compute resources required.
       *
       * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
       * otherwise to an implementation-defined value.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/}
       */
      requests?: {
          [key: string]: any;
      };
  }/** @public */
  export declare type Handler = {
      exec: ExecAction;
  } | {
      httpGet: HTTPGetAction;
  } | {
      tcpSocket: TCPSocketAction;
  };/** @public */
  export declare interface Lifecycle {
      /**
       * PostStart is called immediately after a container is created.
       *
       * If the handler fails, the container is terminated and restarted according to its restart policy.
       * Other management of the container blocks until the hook completes.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks}
       */
      postStart: Handler;
      /**
       * Called immediately before a container is terminated due to an API request or management event such as liveness/startup probe failure, preemption, resource contention, etc.
       *
       * The handler is not called if the container crashes or exits.
       * The reason for termination is passed to the handler.
       * The Pod's termination grace period countdown begins before the PreStop hooked is executed.
       * Regardless of the outcome of the handler, the container will eventually terminate within the Pod's termination grace period.
       * Other management of the container blocks until the hook completes or until the termination grace period is reached.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks}
       */
      preStop: Handler;
  }/** @public */
  export declare interface VolumeDevice {
      /** The path inside of the container that the device will be mapped to. */
      devicePath: string;
      /** name must match the name of a persistentVolumeClaim in the pod */
      name: string;
  }/**
   * Resource spec for a Kubernetes container.
   * See the Kubernetes
   * {@link https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#container-v1-core | API docs }
   * for more details.
   * @public
   */
  export declare interface ContainerSpec {
      /**
       * Arguments to the entrypoint.
       *
       * The docker image's CMD is used if this is not provided.
       * Variable references $(VAR_NAME) are expanded using the container's environment.
       * If a variable cannot be resolved, the reference in the input string will be unchanged.
       * The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME).
       * Escaped references will never be expanded, regardless of whether the variable exists or not.
       * Cannot be updated.
       * More info: {@link https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell}
       */
      args?: string[];
      /**
       * Entrypoint array.
       *
       * Not executed within a shell.
       * The docker image's ENTRYPOINT is used if this is not provided.
       * Variable references $(VAR_NAME) are expanded using the container's environment.
       * If a variable cannot be resolved, the reference in the input string will be unchanged.
       * The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME).
       * Escaped references will never be expanded, regardless of whether the variable exists or not.
       * Cannot be updated.
       * More info: {@link https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell}
       */
      command?: string[];
      /**
       * List of environment variables to set in the container. Cannot be updated.
       */
      env?: EnvVar[];
      /**
       * List of sources to populate environment variables in the container.
       *
       * The keys defined within a source must be a C_IDENTIFIER.
       * All invalid keys will be reported as an event when the container is starting.
       * When a key exists in multiple sources, the value associated with the last source will take precedence.
       * Values defined by an Env with a duplicate key will take precedence. Cannot be updated.
       */
      envFrom?: EnvFromSource[];
      /**
       * Docker image name.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/containers/images}
       *
       * This field is optional to allow higher level config management to default or override container
       * images in workload controllers like Deployments and StatefulSets.
       */
      image?: string;
      /**
       * Image pull policy.
       *
       * One of Always, Never, IfNotPresent.
       * Defaults to Always if :latest tag is specified,
       * or IfNotPresent otherwise.
       * Cannot be updated.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/containers/images#updating-images}
       */
      imagePullPolicy?: "Always" | "Never" | "IfNotPresent";
      /**
       * List of sources to populate environment variables in the container.
       *
       * The keys defined within a source must be a C_IDENTIFIER.
       * All invalid keys will be reported as an event when the container is starting.
       * When a key exists in multiple sources, the value associated with the last source will take precedence.
       * Values defined by an Env with a duplicate key will take precedence. Cannot be updated.
       */
      lifecycle?: Lifecycle;
      /**
       * Periodic probe of container liveness.
       *
       * Container will be restarted if the probe fails.
       * Cannot be updated.
       * More info: {@link https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes}
       */
      livenessProbe?: Probe;
      /**
       * Name of the container specified as a DNS_LABEL.
       *
       * Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated.
       */
      name: string;
      /**
       * List of ports to expose from the container.
       *
       * Exposing a port here gives the system additional information about the network connections a container uses,
       * but is primarily informational.
       * Not specifying a port here DOES NOT prevent that port from being exposed.
       * Any port which is listening on the default "0.0.0.0" address inside a container will be accessible from
       * the network.
       * Cannot be updated.
       */
      ports?: ContainerPort[];
      /**
       * Periodic probe of container service readiness.
       *
       * Container will be removed from service endpoints if the probe fails.
       * Cannot be updated.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes}
       */
      readinessProbe?: Probe;
      /**
       * Compute Resources required by this container.
       *
       * Cannot be updated.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/}
       */
      resources?: ResourceRequirements;
      /**
       * Security options the pod should run with.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/policy/security-context/}
       * More info: {@link https://kubernetes.io/docs/tasks/configure-pod-container/security-context/}
       */
      securityContext?: PodSecurityContext;
      /**
       * Indicates that the Pod has successfully initialized.
       *
       * If specified, no other probes are executed until this completes successfully.
       * If this probe fails, the Pod will be restarted, just as if the livenessProbe failed.
       * This can be used to provide different probe parameters at the beginning of a Pod's lifecycle,
       * when it might take a long time to load data or warm a cache, than during steady-state operation.
       *
       * This cannot be updated.
       * This is a beta feature enabled by the StartupProbe feature flag.
       * More info: {@link https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes}
       */
      startupProbe?: Probe;
      /**
       * Whether this container should allocate a buffer for stdin in the container runtime.
       *
       * If this is not set, reads from stdin in the container will always result in EOF. Default is false.
       */
      stdin?: boolean;
      /**
       * Whether the container runtime should close the stdin channel after it has been opened by a single attach.
       *
       * When stdin is true the stdin stream will remain open across multiple attach sessions.
       * If stdinOnce is set to true, stdin is opened on container start,
       * is empty until the first client attaches to stdin,
       * and then remains open and accepts data until the client disconnects,
       * at which time stdin is closed and remains closed until the container is restarted.
       * If this flag is false, a container processes that reads from stdin will never receive an EOF. Default is false
       */
      stdinOnce?: boolean;
      /**
       * Path at which the file to which the container's termination message will be written is mounted into the container's filesystem.
       *
       * Message written is intended to be brief final status, such as an assertion failure message.
       * Will be truncated by the node if greater than 4096 bytes.
       * The total message length across all containers will be limited to 12kb.
       * Defaults to /dev/termination-log. Cannot be updated.
       */
      terminationMessagePath?: string;
      /**
       * Indicate how the termination message should be populated.
       *
       * File will use the contents of terminationMessagePath to populate the container status
       * message on both success and failure. FallbackToLogsOnError will use the last chunk of
       * container log output if the termination message file is empty and the container exited
       * with an error.
       * The log output is limited to 2048 bytes or 80 lines, whichever is smaller.
       * Defaults to File.
       * Cannot be updated.
       *
       * @defaultValue File
       */
      terminationMessagePolicy?: "File" | "FallbackToLogsOnError";
      /**
       * Whether this container should allocate a TTY for itself, also requires 'stdin' to be true.
       *
       * @defaultValue false
       */
      tty?: boolean;
      /**
       * volumeDevices is the list of block devices to be used by the container.
       */
      volumeDevices?: VolumeDevice[];
      /** volumeDevices is the list of block devices to be used by the container. */
      volumeMounts?: VolumeMount[];
      /**
       * Container's working directory.
       *
       * If not specified, the container runtime's default will be used,
       * which might be configured in the container image.
       * Cannot be updated.
       */
      workingDir?: string;
  }/**
   * Props for the Kubernetes-specific {@link k8s.K8sContainer} component.
   * @public
   */
  export declare interface K8sContainerProps extends ContainerSpec {
  }/** @public */
  export declare interface ContainerPort {
      /**
       * Number of port to expose on the pod's IP address.
       * @remarks
       * This must be a valid integer port number, `0 < x < 65536`.
       */
      containerPort: number;
      /** What host IP to bind the external port to. */
      hostIP?: string;
      /**
       * Number of port to expose on the host.
       * @remarks
       * If specified, this must be a valid integer port number,
       * `0 < x < 65536`. If HostNetwork is specified,
       * this must match ContainerPort. Most containers do not need this.
       */
      hostPort?: number;
      /**
       * A unique-within-pod name for the container
       * @remarks
       * If specified, this must be an IANA_SVC_NAME and unique within the pod.
       * Each named port in a pod must have a unique name. Name for the port
       * that can be referred to by services.
       */
      name?: string;
      /** Protocol for port. Must be UDP or TCP. Defaults to "TCP". */
      protocol?: string;
  }/** @public */
  export declare type EnvVar = EnvVarSimple | EnvVarFrom;/** @public */
  export declare interface EnvVarSimple {
      /** Name of the environment variable. Must be a C_IDENTIFIER. */
      name: string;
      /**
       * Variable references $(VAR_NAME) are expanded using the previous defined
       * environment variables in the container and any service environment
       * variables. If a variable cannot be resolved, the reference in the input
       * string will be unchanged. The $(VAR_NAME) syntax can be escaped with a
       * double $$, ie: $$(VAR_NAME). Escaped references will never be expanded,
       * regardless of whether the variable exists or not. Defaults to "".
       */
      value: string;
  }/** @public */
  export declare interface EnvVarFrom {
      /** Source for the environment variable's value. Cannot be used if value is not empty. */
      valueFrom?: any;
  }/**
   * See {@link k8s.k8sContainerProps}.
   * @public
   */
  export declare type FromContainerProps = ReplaceT<ContainerProps, {
      image: string;
  }> & BuiltinProps;/**
   * Kubernetes-specific container.
   * @public
   */
  export declare class K8sContainer extends PrimitiveComponent<K8sContainerProps> {
      static defaultProps: {
          imagePullPolicy: string;
      };
      validate(): undefined;
  }/**
   * Props for {@link k8s.Container}.
   * @public
   */
  export declare interface ContainerProps extends SFCDeclProps<ContainerProps> {
      /**
       * Additional {@link k8s.K8sContainerProps}-specific props that should be
       * added to the instantiated {@link k8s.K8sContainer}.
       */
      k8sContainerProps?: Partial<K8sContainerProps>;
  }/**
   * Spec for {@link k8s.DaemonSet} for use in {@link k8s.Resource}
   *
   * @public
   */
  export declare type DaemonSetSpec = Exclude<DaemonSetProps, ResourceBase> & {
      template: PodTemplateSpec;
  };/**
   * Component for Kubernetes DaemonSet
   *
   * @public
   */
  export declare class DaemonSet extends DeferredComponent<DaemonSetProps> {
      static defaultProps: {
          metadata: {};
          minReadySeconds: number;
          revisionHistoryLimit: number;
          updateStrategy: {
              type: string;
              rollingUpdate: {
                  maxUnavailable: number;
              };
          };
      };
      constructor(props: DaemonSetProps);
      build(helpers: BuildHelpers): Adapt.JSX.Element;
      status(_observe: ObserveForStatus, buildData: BuildData): Promise<Adapt.Status | undefined>;
  }/** @internal */
  const daemonSetResourceInfo: {
      kind: string;
      deployedWhen: typeof deployedWhen;
      statusQuery: (props: ResourcePropsWithConfig, observe: ObserveForStatus, buildData: BuildData) => Promise<any>;
  };/** @public */
  export declare interface DeploymentUpdateStrategyRecreate {
      type: "Recreate";
  }/** @public */
  export declare interface RollingUpdateDeployment {
      /**
       * The maximum number of pods that can be scheduled above the desired number of pods.
       *
       * Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
       * This can not be 0 if MaxUnavailable is 0.
       * Absolute number is calculated from percentage by rounding up.
       * Defaults to 25%.
       *
       * @example
       * When this is set to 30%, the new ReplicaSet can be scaled up immediately when the rolling update starts,
       * such that the total number of old and new pods do not exceed 130% of desired pods. Once old pods have been
       * killed, new ReplicaSet can be scaled up further, ensuring that total number of pods running at any time
       * during the update is at most 130% of desired pods.
       */
      maxSurge?: number | string;
      /**
       * The maximum number of pods that can be unavailable during the update.
       *
       * Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
       * Absolute number is calculated from percentage by rounding down.
       * This can not be 0 if MaxSurge is 0. Defaults to 25%.
       *
       * @example
       * When this is set to 30%, the old ReplicaSet can be scaled down to 70% of desired pods
       * immediately when the rolling update starts. Once new pods are ready, old ReplicaSet
       * can be scaled down further, followed by scaling up the new ReplicaSet, ensuring that
       * the total number of pods available at all times during the update is at least 70% of
       * desired pods.
       */
      maxUnavailable?: number | string;
  }/**
   * Spec for {@link k8s.Deployment} for use in {@link k8s.Resource}
   *
   * @public
   */
  export declare type DeploymentSpec = Exclude<DeploymentProps, ResourceBase> & {
      template: PodTemplateSpec;
  };/**
   * Props for {@link k8s.Deployment}
   *
   * @public
   */
  export declare interface DeploymentProps extends WithChildren {
      /** Information about the k8s cluster (ip address, auth info, etc.) */
      config: ClusterInfo;
      /** k8s metadata */
      metadata: Metadata;
      /**
       * The minimum number of seconds for which a newly created pod should
       * be ready without any of its container crashing, for it to be considered
       * available. Defaults to 0 (pod will be considered available as soon as it is ready).
       */
      minReadySeconds: number;
      /** Indicates that the deployment is paused */
      paused: boolean;
      /**
       * The maximum time in seconds for a deployment to make progress before it is considered to be failed.
       *
       * The deployment controller will continue to process failed deployments and a condition with a
       * ProgressDeadlineExceeded reason will be surfaced in the deployment status. Note that progress
       * will not be estimated during the time a deployment is paused. Defaults to 600s.
       */
      progressDeadlineSeconds: number;
      /**
       * Number of desired pods.
       *
       * Defaults to 1. 0 is not allowed.
       *
       * @defaultValue 1
       */
      replicas: number;
      /**
       * The number of old ReplicaSets to retain to allow rollback.
       *
       * This is a pointer to distinguish between explicit zero and not specified. Defaults to 10.
       *
       * @defaultValue 10
       */
      revisionHistoryLimit: number;
      /**
       * Label selector for pods.
       *
       * Existing ReplicaSets whose pods are selected by this will be the ones affected by this deployment.
       * It must match the pod template's labels.
       *
       * @remarks
       *
       * With Adapt, this is optional.  If not specified, adapt will pick a selector that will work with the pods
       * it creates as part of this {@link k8s.Deployment}
       */
      selector?: LabelSelector;
      /**
       * An deployment strategy to use to replace existing pods with new ones
       */
      strategy: DeploymentUpdateStrategy;
  }/**
   * Component for Kubernetes Deployment
   *
   * @public
   */
  export declare class Deployment extends DeferredComponent<DeploymentProps> {
      static defaultProps: {
          metadata: {};
          paused: boolean;
          replicas: number;
          progressDeadlineSeconds: number;
          minReadySeconds: number;
          revisionHistoryLimit: number;
          strategy: {
              type: string;
              rollingUpdate: {
                  maxSurge: string;
                  maxUnavailable: string;
              };
          };
      };
      constructor(props: DeploymentProps);
      build(helpers: BuildHelpers): Adapt.JSX.Element | null;
      deployedWhen: () => true | Adapt.Waiting;
      status(_observe: ObserveForStatus, buildData: BuildData): Promise<Adapt.Status | undefined>;
  }/** @internal */
  const deploymentResourceInfo: {
      kind: string;
      deployedWhen: typeof deployedWhen;
      statusQuery: (props: ResourcePropsWithConfig, observe: ObserveForStatus, buildData: BuildData) => Promise<any>;
  };/**
   * Type assertion to see if an element is both a {@link k8s.Resource | Resource}
   * and a {@link @adpt/core#FinalElement | FinalElement}
   *
   * @param e - element to test
   * @returns `true` if e is both a FinalElement and a {@link k8s.Resource | Resource}, `false` otherwise
   *
   * @public
   */
  export declare function isResourceFinalElement(e: AdaptElement): e is FinalDomElement<ResourceProps & Adapt.BuiltinProps>;/**
   * Tests whether a ResourceProps is for a template object
   *
   * @public
   */
  export declare function isResourcePropsWithConfig(x: ResourceProps & Partial<BuiltinProps>): x is ResourcePropsWithConfig & Partial<BuiltinProps>;/**
   * Tests to see if an object is a {@link k8s.Resource} element
   * @param x - object to test
   * @returns true if object is an AdaptElement of type {@link k8s.Resource}
   *
   * @public
   */
  export declare function isResource(x: any): x is AdaptElement<ResourceProps>;/**
   * Primitive Component recognized by the k8s plugin to represent resources
   * @public
   */
  export declare class Resource extends Action<ResourceProps> {
      defaultProps: {
          apiVersion: "v1";
          con: false;
      };
      manifest_: Manifest;
      constructor(props: ResourceProps);
      validate(): "Resource elements cannot have children" | undefined;
      shouldAct(op: ChangeType, ctx: ActionContext): Promise<ShouldAct>;
      action(op: ChangeType, ctx: ActionContext): Promise<void>;
      deployedWhen: (goalStatus: GoalStatus, helpers: DeployHelpers) => Promise<true | Adapt.Waiting | Adapt.Waiting[]>;
      status(observe: ObserveForStatus, buildData: BuildData): Promise<any>;
      private mountedElement;
      private manifest;
  }/** @internal */
  export declare function makePodManifest(props: PodProps & BuiltinProps, data: {
      volumes?: Volume[];
      serviceAccountName?: string;
  }): {
      kind: string;
      metadata: Metadata;
      spec: PodSpec;
  };/**
   * Tests whether x is a Pod element
   *
   * @param x - value to test
   * @returns `true` if x is a Pod element, false otherwise
   *
   * @public
   */
  export declare function isPod(x: any): x is AdaptElement<PodProps>;/** @public */
  export declare interface NodeSelectorRequirement {
      /** The label key that the selector applies to. */
      key: string;
      /**
       * Represents a key's relationship to a set of values.
       *
       * Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
       */
      operator: "In" | "NotIn" | "Exists" | "DoesNotExist" | "Gt" | "Lt";
      /**
       * Values for operator
       *
       * If the operator is In or NotIn, the values array must be non-empty.
       * If the operator is Exists or DoesNotExist, the values array must be empty.
       * If the operator is Gt or Lt, the values array must have a single element,
       * which will be interpreted as an integer.
       * This array is replaced during a strategic merge patch.
       */
      values: string[];
  }/** @public */
  export declare interface NodeSelectorTerm {
      /** A list of node selector requirements by node's labels. */
      matchExpressions?: NodeSelectorRequirement[];
      /** A list of node selector requirements by node's fields. */
      matchFields?: NodeSelectorRequirement[];
  }/** @public */
  export declare interface PreferredSchedulingTerm {
      /**
       * A node selector term, associated with the corresponding weight.
       */
      preference: NodeSelectorTerm;
      /** Weight associated with matching the corresponding nodeSelectorTerm, in the range 1-100. */
      weight: number;
  }/** @public */
  export declare interface NodeSelector {
      /** A list of node selector terms. The terms are ORed */
      nodeSelectorTerms: NodeSelectorTerm[];
  }/** @public */
  export declare interface NodeAffinity {
      /** The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding "weight" to the sum if the node matches the corresponding matchExpressions; the node(s) with the highest sum are the most preferred. */
      preferredDuringSchedulingIgnoredDuringExecution?: PreferredSchedulingTerm[];
      /** If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to an update), the system may or may not try to eventually evict the pod from its node. */
      requiredDuringSchedulingIgnoredDuringExecution?: NodeSelector;
  }/** @public */
  export declare interface PodAffinityTerm {
      /**
       * Label query over a set of resources, in this case pods.
       */
      labelSelector: LabelSelector;
      /** Specifies which namespaces the labelSelector applies to (matches against); null or empty list means "this pod's namespace" */
      namespaces?: string[];
      /** This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed. */
      topologyKey: string;
  }/** @public */
  export declare interface WeightedPodAffinityTerm {
      /** A pod affinity term, associated with the corresponding weight. */
      podAffinityTerm: PodAffinityTerm;
      /**
       * weight associated with matching the corresponding podAffinityTerm, in the range 1-100.
       */
      weight: number;
  }/** @public */
  export declare interface PodAffinity {
      /**
       * The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions.
       *
       * The node that is most preferred is the one with the greatest sum of weights,
       * i.e. for each node that meets all of the scheduling requirements (resource request,
       * requiredDuringScheduling affinity expressions, etc.), compute a sum by iterating
       * through the elements of this field and adding "weight" to the sum if the node has pods
       * which matches the corresponding podAffinityTerm; the node(s) with the highest sum are the most preferred.
       */
      preferredDuringSchedulingIgnoredDuringExecution: WeightedPodAffinityTerm[];
      /**
       * If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node.
       *
       * If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system may or may not try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each podAffinityTerm are intersected, i.e. all terms must be satisfied.
       */
      requiredDuringSchedulingIgnoredDuringExecution: PodAffinityTerm[];
  }/** @public */
  export declare interface PodAntiAffinity {
      /** The scheduler will prefer to schedule pods to nodes that satisfy the anti-affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling anti-affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the node(s) with the highest sum are the most preferred. */
      preferredDuringSchedulingIgnoredDuringExecution: WeightedPodAffinityTerm[];
      /** If the anti-affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the anti-affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system may or may not try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each podAffinityTerm are intersected, i.e. all terms must be satisfied. */
      requiredDuringSchedulingIgnoredDuringExecution: PodAffinity;
  }/** @public */
  export declare interface Affinity {
      /** Describes node affinity scheduling rules for the pod. */
      nodeAffinity: NodeAffinity;
      /** Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)). */
      podAffinity: PodAffinity;
      /** PodAntiAffinity	Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)). */
      podAntiAffinity: PodAntiAffinity;
  }/** @public */
  export declare interface PodDNSConfigOption {
      name: string;
      value?: string;
  }/** @public */
  export declare interface PodDNSConfig {
      /**
       * A list of DNS name server IP addresses.
       *
       * This will be appended to the base nameservers generated from DNSPolicy. Duplicated nameservers will be removed.
       */
      nameservers: string[];
      /**
       * A list of DNS resolver options.
       *
       * This will be merged with the base options generated from DNSPolicy.
       * Duplicated entries will be removed.
       * Resolution options given in Options will override those that appear in the base DNSPolicy.
       */
      options: PodDNSConfigOption[];
      /**
       * A list of DNS search domains for host-name lookup.
       *
       * This will be appended to the base search paths generated from DNSPolicy. Duplicated search paths will be removed.
       */
      searches: string[];
  }/** @public */
  export declare interface PodReadinessGate {
      /** Refers to a condition in the pod's condition list with matching type. */
      conditionType: string;
  }/** @public */
  export declare interface SELinuxOptions {
      /** SELinux level label that applies to the container. */
      level: string;
      /** SELinux role label that applies to the container. */
      role: string;
      /** SELinux type label that applies to the container. */
      type: string;
      /** SELinux user label that applies to the container */
      user: string;
  }/** @public */
  export declare interface SeccompProfile {
      /**
       * Indicates a profile defined in a file on the node should be used.
       *
       * The profile must be preconfigured on the node to work.
       * Must be a descending path, relative to the kubelet's configured seccomp profile location.
       * Must only be set if type is "Localhost".
       */
      localhostProfile?: string;
      /**
       * Indicates which kind of seccomp profile will be applied.
       *
       * Valid options are:
       * * Localhost - a profile defined in a file on the node should be used.
       * * RuntimeDefault - the container runtime default profile should be used.
       * * Unconfined - no profile should be applied.
       */
      type: "Localhost" | "RuntimeDefault" | "Unconfined";
  }/** @public */
  export declare interface Sysctl {
      name: string;
      value: string;
  }/** @public */
  export declare interface WindowsSecurityContextOptions {
      /**
       * The GMSA admission webhook ({@link https://github.com/kubernetes-sigs/windows-gmsa}) inlines the contents of the GMSA credential spec named by the GMSACredentialSpecName field.
       */
      gmsaCredentialSpec?: string;
      /**
       * GMSACredentialSpecName is the name of the GMSA credential spec to use.
       */
      gmsaCredentialSpecName?: string;
      /**
       * The UserName in Windows to run the entrypoint of the container process.
       *
       * Defaults to the user specified in image metadata if unspecified. May also be set in PodSecurityContext.
       * If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
       */
      runAsUserName?: string;
  }/** @public */
  export declare interface PodSecurityContext {
      /**
       * A special supplemental group that applies to all containers in a pod.
       *
       * Some volume types allow the Kubelet to change the ownership of that volume to be owned by the pod:
       *
       * 1. The owning GID will be the FSGroup
       * 2. The setgid bit is set (new files created in the volume will be owned by FSGroup)
       * 3. The permission bits are OR'd with rw-rw----
       *
       * If unset, the Kubelet will not modify the ownership and permissions of any volume.
       */
      fsGroup?: number;
      /**
       * Defines behavior of changing ownership and permission of the volume before being exposed inside Pod.
       *
       * This field will only apply to volume types which support fsGroup based ownership(and permissions).
       * It will have no effect on ephemeral volume types such as: secret, configmaps and emptydir.
       * Valid values are "OnRootMismatch" and "Always". If not specified defaults to "Always".
       *
       * @defaultValue Always
       */
      fsGroupChangePolicy?: "OnRootMismatch" | "Always";
      /**
       * The GID to run the entrypoint of the container process.
       *
       * Uses runtime default if unset. May also be set in SecurityContext.
       * If set in both SecurityContext and PodSecurityContext, the value specified in
       * SecurityContext takes precedence for that container.
       */
      runAsGroup?: number;
      /**
       * Indicates that the container must run as a non-root user.
       *
       * If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and
       * fail to start the container if it does. If unset or false, no such validation will be performed.
       * May also be set in SecurityContext.
       * If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
       */
      runAsNonRoot?: boolean;
      /**
       * The UID to run the entrypoint of the container process.
       *
       * Defaults to user specified in image metadata if unspecified.
       * May also be set in SecurityContext.
       * If set in both SecurityContext and PodSecurityContext, the value specified in
       * SecurityContext takes precedence for that container.
       */
      runAsUser?: number;
      /**
       * The SELinux context to be applied to all containers.
       *
       * If unspecified, the container runtime will allocate a random SELinux context for each container.
       * May also be set in SecurityContext.
       * If set in both SecurityContext and PodSecurityContext, the value specified in
       * SecurityContext takes precedence for that container.
       */
      seLinuxOptions?: SELinuxOptions;
      /**
       * The seccomp options to use by the containers in this pod.
       */
      seccompProfile?: SeccompProfile;
      /**
       * 	A list of groups applied to the first process run in each container, in addition to the container's primary GID.
       *
       *  If unspecified, no groups will be added to any container.
       */
      supplementalGroups?: number[];
      /**
       * Sysctls hold a list of namespaced sysctls used for the pod.
       *
       * Pods with unsupported sysctls (by the container runtime) might fail to launch.
       */
      sysctls?: Sysctl[];
      /**
       * The Windows specific settings applied to all containers.
       *
       * If unspecified, the options within a container's SecurityContext will be used.
       * If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
       */
      windowsOptions: WindowsSecurityContextOptions;
  }/** @public */
  export declare interface Toleration {
      /**
       * Indicates the taint effect to match.
       *
       * Empty means match all taint effects.
       * When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
       */
      effect?: "NoSchedule" | "PreferNoSchedule" | "NoExecute";
      /**
       * The taint key that the toleration applies to.
       *
       * Empty means match all taint keys.
       * If the key is empty, operator must be Exists;
       * this combination means to match all values and all keys.
       */
      key?: string;
      /**
       * Represents a key's relationship to the value.
       *
       * Valid operators are Exists and Equal.
       * Defaults to Equal.
       * Exists is equivalent to wildcard for value, so that a pod can tolerate all taints of a particular category.
       *
       * @defaultValue Equal
       */
      operator?: "Exists" | "Equal";
      /**
       * Represents the period of time the toleration (which must be of effect NoExecute, otherwise this field is ignored) tolerates the taint.
       *
       * By default, it is not set, which means tolerate the taint forever (do not evict).
       * Zero and negative values will be treated as 0 (evict immediately) by the system.
       */
      tolerationSeconds?: number;
      /**
       * Value is the taint value the toleration matches to.
       *
       * If the operator is Exists, the value should be empty, otherwise just a regular string.
       */
      value?: string;
  }/** @public */
  export declare interface TopologySpreadConstraint {
      /**
       * Used to find matching pods.
       *
       * Pods that match this label selector are counted to determine the
       * number of pods in their corresponding topology domain.
       */
      labelSelector: LabelSelector;
      /**
       * Describes the degree to which pods may be unevenly distributed.
       *
       * When `whenUnsatisfiable=DoNotSchedule`, it is the maximum permitted
       * difference between the number of matching pods in the target topology
       * and the global minimum.
       * For example, in a 3-zone cluster, MaxSkew is set to 1, and pods with
       * the same labelSelector spread as 1/1/0: | zone1 | zone2 | zone3 | | P | P | |
       * - if MaxSkew is 1, incoming pod can only be scheduled to zone3 to become 1/1/1;
       *   scheduling it onto zone1(zone2) would make the ActualSkew(2-0) on zone1(zone2) violate MaxSkew(1).
       * - if MaxSkew is 2, incoming pod can be scheduled onto any zone.
       * When `whenUnsatisfiable=ScheduleAnyway`, it is used to give higher precedence to topologies that satisfy it.
       * It's a required field. Default value is 1 and 0 is not allowed.
       *
       * @example
       *
       * @defaultValue 1
       */
      maxSkew: number;
      /**
       * The key of node labels.
       *
       * Nodes that have a label with this key and identical values are considered to be in the same topology.
       * We consider each \<key, value\> as a "bucket", and try to put balanced number of pods into each bucket.
       * It's a required field.
       */
      topologyKey: string;
      /**
       * Indicates how to deal with a pod if it doesn't satisfy the spread constraint.
       *
       * - DoNotSchedule (default) tells the scheduler not to schedule it.
       * - ScheduleAnyway tells the scheduler to schedule the pod in any location,
       *   but giving higher precedence to topologies that would help reduce the skew.
       *
       * A constraint is considered "Unsatisfiable" for an incoming pod if and only if every possible
       * node assigment for that pod would violate "MaxSkew" on some topology.
       * For example, in a 3-zone cluster, MaxSkew is set to 1, and pods with the same labelSelector
       * spread as 3/1/1: | zone1 | zone2 | zone3 | | P P P | P | P | If WhenUnsatisfiable is set to DoNotSchedule,
       * incoming pod can only be scheduled to zone2(zone3) to become 3/2/1(3/1/2)
       * as ActualSkew(2-1) on zone2(zone3) satisfies MaxSkew(1).
       * In other words, the cluster can still be imbalanced, but scheduler won't make it
       * *more* imbalanced.
       *
       * It's a required field.
       */
      whenUnsatisfiable: string;
  }/** @public */
  export declare interface KeyToPath {
      /** The key to project. */
      key: string;
      /**
       * mode bits to use on this file,
       * Must be a value between 0 and 0777.
       * If not specified, the volume defaultMode will be used.
       * This might be in conflict with other options that affect the file mode, like fsGroup,
       * and the result can be other mode bits set.
       */
      mode?: number;
      /**
       * The relative path of the file to map the key to.
       *
       * May not be an absolute path. May not contain the path element '..'. May not start with the string '..'.
       */
      path: string;
  }/** @public */
  export declare interface ConfigMapVolumeSource {
      /**
       * mode bits to use on created files by default.
       *
       * Must be a value between 0 and 0777. Defaults to 0644.
       * Directories within the path are not affected by this setting.
       * This might be in conflict with other options that affect the file mode,
       * like fsGroup, and the result can be other mode bits set.
       */
      defaultMode?: number;
      /**
       * If unspecified, each key-value pair in the Data field of the referenced ConfigMap will be projected into the volume as a file whose name is the key and content is the value.
       *
       * If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present.
       * If a key is specified which is not present in the ConfigMap, the volume setup will error unless it is marked optional.
       * Paths must be relative and may not contain the '..' path or start with '..'.
       */
      items?: KeyToPath[];
      /**
       * Name of the referent.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names}
       */
      name: string | Handle;
      /** Specify whether the ConfigMap or its keys must be defined */
      optional?: boolean;
  }/** @public */
  export declare interface SecretVolumeSource {
      /**
       * mode bits to use on created files by default.
       *
       * Must be a value between 0 and 0777. Defaults to 0644.
       * Directories within the path are not affected by this setting.
       * This might be in conflict with other options that affect the file mode,
       * like fsGroup, and the result can be other mode bits set.
       */
      defaultMode?: number;
      /**
       * If unspecified, each key-value pair in the Data field of the referenced Secret will be projected into the volume as a file whose name is the key and content is the value.
       *
       * If specified, the listed keys will be projected into the specified paths,
       * and unlisted keys will not be present. If a key is specified which is not
       * present in the Secret, the volume setup will error unless it is marked optional.
       *
       * Paths must be relative and may not contain the '..' path or start with '..'.
       */
      items?: KeyToPath[];
      /** Specify whether the Secret or its keys must be defined */
      optional?: boolean;
      /**
       * Name of the secret in the pod's namespace to use.
       *
       *  More info: {@link https://kubernetes.io/docs/concepts/storage/volumes#secret}
       */
      secretName: string | Handle;
  }/** @public */
  export declare interface EmptyDirVolumeSource {
      /**
       * What type of storage medium should back this directory.
       *
       * The default is "" which means to use the node's default medium.
       * Must be an empty string (default) or Memory.
       * More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
       */
      medium: string;
      /**
       * Total amount of local storage required for this EmptyDir volume.
       *
       * The size limit is also applicable for memory medium.
       * The maximum usage on memory medium EmptyDir would be the minimum
       * value between the SizeLimit specified here and the sum of memory limits of all containers in a pod.
       * The default is nil which means that the limit is undefined.
       * More info: {@link http://kubernetes.io/docs/user-guide/volumes#emptydir}
       */
      sizeLimit: string;
  }/**
   * Volumes for {@link k8s.PodProps}
   *
   * @public
   */
  export declare interface Volume {
      /**
       * Volume's name.
       *
       * Must be a DNS_LABEL and unique within the pod.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names}
       */
      name: string;
      /**
       * Represents a configMap that should populate this volume
       */
      configMap?: ConfigMapVolumeSource;
      /**
       * EmptyDir represents a temporary directory that shares a pod's lifetime.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/storage/volumes#emptydir}
       *
       */
      emptyDir?: EmptyDirVolumeSource;
      /**
       * Represents a secret that should populate this volume.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/storage/volumes#secret}
       */
      secret?: SecretVolumeSource;
      /** Other k8s volume kinds not typed yet for \@adpt/cloud */
      [key: string]: any;
  }/**
   * Props for the {@link k8s.Pod} component
   *
   * @public
   */
  export declare interface PodProps extends WithChildren {
      /**
       *  True is this is a template for use in a controller, false otherwise
       *  @defaultValue false
       */
      isTemplate: boolean;
      /** Information about the k8s cluster (ip address, auth info, etc.) */
      config?: ClusterInfo;
      /** k8s metadata */
      metadata: Metadata;
      /**
       * Optional duration in seconds the pod may be active on the node relative to StartTime before the system will actively try to mark it failed and kill associated containers.
       *
       * Value must be a positive integer.
       */
      activeDeadlineSeconds?: number;
      /** If specified, the pod's scheduling constraints */
      affinity?: Affinity;
      /** AutomountServiceAccountToken indicates whether a service account token should be automatically mounted. */
      automountServiceAccountToken?: boolean;
      /**
       *  Specifies the DNS parameters of a pod.
       *
       *  Parameters specified here will be merged to the generated DNS configuration based on DNSPolicy.
       */
      dnsConfig?: PodDNSConfig;
      /**
       * Set DNS policy for the pod.
       *
       * Valid values are 'ClusterFirstWithHostNet', 'ClusterFirst', 'Default' or 'None'.
       * DNS parameters given in DNSConfig will be merged with the policy selected with DNSPolicy.
       * To have DNS options set along with hostNetwork, you have to specify DNS policy explicitly
       * to 'ClusterFirstWithHostNet'.
       *
       * @defaultValue ClusterFirst
       */
      dnsPolicy: "ClusterFirstWithHostNet" | "ClusterFirst" | "Default" | "None";
      /**
       * Indicates whether information about services should be injected into pod's environment variables matching the syntax of Docker links.
       *
       * @defaultValue true
       */
      enableServiceLinks: boolean;
      /**
       * An optional list of hosts and IPs that will be injected into the pod's hosts file if specified.
       *
       * This is only valid for non-hostNetwork pods.
       */
      hostAliases?: HostAlias[];
      /**
       * Use the host's ipc namespace.
       * @defaultValue false
       */
      hostIPC: boolean;
      /**
       * Host networking requested for this pod.
       *
       * Use the host's network namespace.
       * If this option is set, the ports that will be used must be specified. Default to false.
       */
      hostNetwork?: boolean;
      /**
       * Use the host's pid namespace.
       * @defaultValue false
       */
      hostPID: boolean;
      /**
       * Specifies the hostname of the Pod.
       *
       * If not specified, the pod's hostname will be set to a system-defined value.
       */
      hostname?: string;
      /**
       * List of references to secrets in the same namespace to use for pulling any of the images used by this PodSpec.
       *
       * If specified, these secrets will be passed to individual puller implementations for them to use.
       * For example, in the case of docker, only DockerConfig type secrets are honored.
       * More info: {@link https://kubernetes.io/docs/concepts/containers/images#specifying-imagepullsecrets-on-a-pod}
       */
      imagePullSecrets?: LocalObjectReference[];
      /**
       * A request to schedule this pod onto a specific node.
       *
       * If it is non-empty, the scheduler simply schedules this pod onto that node,
       * assuming that it fits resource requirements.
       */
      nodeName?: string;
      /**
       * A selector which must be true for the pod to fit on a node.
       *
       * Selector which must match a node's labels for the pod to be scheduled on that node.
       * More info: {@link https://kubernetes.io/docs/concepts/configuration/assign-pod-node/}
       */
      nodeSelector?: {
          [label: string]: boolean | string;
      };
      /**
       * Overhead represents the resource overhead associated with running a pod for a given RuntimeClass.
       *
       * This field will be autopopulated at admission time by the RuntimeClass admission controller.
       * If the RuntimeClass admission controller is enabled, overhead must not be set in Pod create requests.
       * The RuntimeClass admission controller will reject Pod create requests which have the overhead already set.
       * If RuntimeClass is configured and selected in the PodSpec, Overhead will be set to the value defined in
       * the corresponding RuntimeClass, otherwise it will remain unset and treated as zero.
       *
       * More info: {@link https://git.k8s.io/enhancements/keps/sig-node/20190226-pod-overhead.md}
       *
       * This field is alpha-level as of Kubernetes v1.16, and is only honored by servers that enable
       * the PodOverhead feature.
       * @alpha
       */
      overhead?: unknown;
      /**
       * PreemptionPolicy is the Policy for preempting pods with lower priority.
       *
       * This field is beta-level, gated by the NonPreemptingPriority feature-gate.
       *
       * @defaultValue PreemptLowerPriority
       * @beta
       */
      preemptionPolicy?: "Never" | "PreemptLowerPriority";
      /**
       * The priority various system components use this field to find the priority of the pod.
       *
       * When Priority Admission Controller is enabled, it prevents users from setting this field.
       * The admission controller populates this field from PriorityClassName.
       * The higher the value, the higher the priority.
       */
      priority?: number;
      /**
       * If specified, indicates the pod's priority.
       *
       * "system-node-critical" and "system-cluster-critical" are two special keywords which indicate the highest
       * priorities with the former being the highest priority. Any other name must be defined by creating a PriorityClass
       * object with that name. If not specified, the pod priority will be default or zero if there is no default.
       */
      priorityClassName?: string;
      /**
       *  If specified, all readiness gates will be evaluated for pod readiness.
       *
       *  A pod is ready when all its containers are ready AND all conditions specified
       *  in the readiness gates have status equal to "True"
       *
       *  More info: {@link https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#pod-readiness-gate}
       */
      readinessGates?: PodReadinessGate[];
      /**
       * Restart policy for all containers within the pod.
       *
       * One of Always, OnFailure, Never. Default to Always.
       * More info: {@link https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy}
       *
       * @defaultValue Always
       */
      restartPolicy: "Always" | "OnFailure" | "Never";
      /**
       * Refers to a RuntimeClass object in the node.k8s.io group, which should be used to run this pod.
       *
       * If no RuntimeClass resource matches the named class, the pod will not be run.
       * If unset or empty, the "legacy" RuntimeClass will be used, which is an implicit
       * class with an empty definition that uses the default runtime handler.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/containers/runtime-class/}
       *
       * This is a beta feature as of Kubernetes v1.14.
       */
      runtimeClassName?: string;
      /**
       *  If specified, the pod will be dispatched by specified scheduler.
       *  If not specified, the pod will be dispatched by default scheduler.
       */
      schedulerName?: string;
      /**
       * SecurityContext holds pod-level security attributes and common container settings.
       * See type description for default values of each field.
       *
       * @defaultValue \{\}
       */
      securityContext: PodSecurityContext;
      /**
       * ServiceAccountName is the name of the ServiceAccount to use to run this pod.
       * More info: {@link https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/}
       */
      serviceAccountName?: string | Handle;
      /**
       * If true the pod's hostname will be configured as the pod's FQDN, rather than the leaf name (the default).
       * In Linux containers, this means setting the FQDN in the hostname field of the kernel
       * (the nodename field of struct utsname).
       * In Windows containers, this means setting the registry value of hostname for the registry key
       * HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters to FQDN.
       * If a pod does not have FQDN, this has no effect.
       *
       * @defaultValue false
       */
      setHostnameAsFQDN?: boolean;
      /**
       * Share a single process namespace between all of the containers in a pod.
       * When this is set containers will be able to view and signal processes from other containers in the same pod,
       * and the first process in each container will not be assigned PID 1.
       * HostPID and ShareProcessNamespace cannot both be set.
       *
       * @defaultValue false
       */
      shareProcessNamespace: boolean;
      /**
       *  If specified, the fully qualified Pod hostname will be "\<hostname\>.\<subdomain\>.\<pod namespace\>.svc.\<cluster domain\>".
       *  If not specified, the pod will not have a domainname at all.
       */
      subdomain?: string;
      /**
       * Optional duration in seconds the pod needs to terminate gracefully.
       *
       * May be decreased in delete request. Value must be non-negative integer.
       * The value zero indicates delete immediately. If this value is nil, the default
       * grace period will be used instead. The grace period is the duration in seconds
       * after the processes running in the pod are sent a termination signal and the time
       * when the processes are forcibly halted with a kill signal. Set this value longer
       * than the expected cleanup time for your process. Defaults to 30 seconds.
       */
      terminationGracePeriodSeconds?: number;
      /** If specified, the pod's tolerations. */
      tolerations?: Toleration[];
      /**
       *  TopologySpreadConstraints describes how a group of pods ought to spread across topology domains.
       *
       *  Scheduler will schedule pods in a way which abides by the constraints. All topologySpreadConstraints are ANDed.
       */
      topologySpreadConstraints?: TopologySpreadConstraint[];
      /**
       * List of volumes that can be mounted by containers belonging to the pod.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/storage/volumes}
       */
      volumes?: Volume[];
  }/**
   * Component for Kubernetes Pods
   *
   * @public
   */
  export declare class Pod extends DeferredComponent<PodProps, ResolvedVolumes & ResolvedServiceAccountName> {
      static defaultProps: {
          isTemplate: boolean;
          metadata: {};
          dnsPolicy: string;
          enableServiceLinks: boolean;
          hostIPC: boolean;
          hostPID: boolean;
          restartPolicy: string;
          securityContext: {};
          shareProcessNamespace: boolean;
          terminationGracePeriodSeconds: number;
      };
      initialState(): {};
      build(helpers: BuildHelpers): Adapt.JSX.Element | null;
      status(_observe: ObserveForStatus, buildData: BuildData): Promise<Adapt.Status | undefined>;
  }/**
   * Spec for for Kubernetes Pods
   *
   * @public
   */
  export declare interface PodSpec extends Omit<PodProps, "config" | "metadata" | "isTemplate"> {
      containers: ContainerSpec[];
      terminationGracePeriodSeconds?: number;
  }/** @internal */
  const podResourceInfo: {
      kind: string;
      deployedWhen: typeof deployedWhen;
      statusQuery: (props: ResourcePropsWithConfig, observe: ObserveForStatus, buildData: BuildData) => Promise<any>;
  };/**
   * k8s Secret resource
   *
   * @param propsIn - props for Secret as specifed in {@link k8s.SecretProps}
   *
   * @public
   */
  export declare function Secret(propsIn: SFCDeclProps<SecretProps, typeof defaultProps>): Adapt.JSX.Element;/** @internal */
  const secretResourceInfo: {
      kind: string;
      deployedWhen: () => true;
      statusQuery: (props: ResourcePropsWithConfig, observe: ObserveForStatus, buildData: BuildData) => Promise<any>;
      makeManifest: (manifest: Manifest, elem: AdaptElement<ResourceProps>, _deployID: string) => {
          data: {
              [key: string]: string;
          } | undefined;
          stringData: {
              [key: string]: string;
          } | undefined;
          type: string | undefined;
          apiVersion: string; /**
           * stringData allows specifying non-binary secret data in string form.
           *
           * It is provided as a write-only convenience method. All keys and values are merged into the data field on write,
           * overwriting any existing values. It is never output when reading from the API.
           */
          kind: string;
          metadata: import("./manifest_support").MetadataInRequest;
          spec?: import("./DaemonSet").DaemonSetSpec | import("./common").CRSpec | import("./Pod").PodSpec | import("./Service").ServiceSpec | import("./Deployment").DeploymentSpec | undefined;
      };
  };/**
   * Convert {@link NetworkService} props to {@link k8s.Service} props
   * @param abstractProps - props to convert
   * @returns Kubernetes spec corresponding to `abstractProps`
   *
   * @internal
   */
  export declare function k8sServiceProps(abstractProps: NetworkServiceProps & BuiltinProps): Omit<ServiceProps, keyof ResourceBase>;/**
   * Native Kubernetes Service resource
   *
   * @remarks
   *
   * Implements the {@link NetworkServiceInstance} interface.
   *
   * @public
   */
  export declare function Service(propsIn: SFCDeclProps<ServiceProps, typeof defaultProps>): Adapt.JSX.Element;/** @public */
  export declare interface ServiceProps extends ServiceSpec {
      /** Legal configuration loaded from kubeconfig */
      config: ClusterInfo;
      metadata?: Metadata;
      selector?: Handle | EndpointSelector;
  }/** @public */
  export declare interface ServiceSpec {
      /**
       * Cluster IP for a {@link k8s.Service}
       *
       * @remarks
       * `clusterIP` is the IP address of the service and is usually assigned
       * randomly by the master. If an address is specified manually and is not
       * in use by others, it will be allocated to the service; otherwise,
       * creation of the service will fail. This field can not be changed through
       * updates. Valid values are "None", empty string (""), or a valid IP
       * address. "None" can be specified for headless services when proxying is
       * not required. Only applies to types ClusterIP, NodePort, and
       * LoadBalancer. Ignored if type is ExternalName.
       *
       * For more information, see the
       * {@link https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies |
       * Kubernetes documentation}.
       */
      clusterIP?: string;
      /**
       * A list of IP addresses for which nodes in the cluster
       * will also accept traffic for this service.
       *
       * @remarks
       * These IPs are not managed by
       * Kubernetes. The user is responsible for ensuring that traffic arrives at
       * a node with this IP. A common example is external load balancers that are
       * not part of the Kubernetes system.
       */
      externalIPs?: string[];
      /**
       * The external reference that kubedns or equivalent
       * will return as a CNAME record for this service.
       *
       * @remarks
       * No proxying will be involved. Must be a
       * {@link https://tools.ietf.org/html/rfc1123 | valid RFC-1123 hostname}
       * and requires Type to be ExternalName.
       */
      externalName?: string;
      /**
       * Denotes if this Service desires to route
       * external traffic to node-local or cluster-wide endpoints.
       *
       * @remarks
       * "Local" preserves the client source IP and avoids a second hop for
       * LoadBalancer and Nodeport type services, but risks potentially
       * imbalanced traffic spreading. "Cluster" obscures the client source IP
       * and may cause a second hop to another node, but should have good overall
       * load-spreading.
       */
      externalTrafficPolicy?: string;
      /**
       * Specifies the healthcheck nodePort for the service.
       *
       * @remarks
       * If not specified, HealthCheckNodePort is created by the service
       * api backend with the allocated nodePort. Will use user-specified nodePort
       * value if specified by the client. Only affects when Type is set to
       * LoadBalancer and ExternalTrafficPolicy is set to Local.
       */
      healthCheckNodePort?: number;
      /**
       * Only applies to Service Type: LoadBalancer. LoadBalancer will
       * get created with the IP specified in this field.
       *
       * @remarks
       * This feature depends on
       * whether the underlying cloud provider supports specifying the loadBalancerIP
       * when a load balancer is created. This field will be ignored if the
       * cloud provider does not support the feature.
       */
      loadBalancerIP?: string;
      /**
       * If specified and supported by the platform, this will
       * restrict traffic through the cloud provider load balancer
       * to the specified client IPs.
       *
       * @remarks
       * This field will be ignored if the cloud provider
       * does not support the feature.
       *
       * For more information, see the
       * {@link https://v1-17.docs.kubernetes.io/docs/tasks/access-application-cluster/configure-cloud-provider-firewall/ |
       * Kubernetes documentation}.
       */
      loadBalancerSourceRanges?: string[];
      /**
       * The list of ports that are exposed by this service.
       *
       * @remarks
       * For more information, see the
       * {@link https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies |
       * Kubernetes documentation}.
       */
      ports?: ServicePort[];
      /**
       * When set to true, indicates that
       * DNS implementations must publish the notReadyAddresses of subsets for the
       * Endpoints associated with the Service.
       *
       * @remarks
       * The default value is false. The
       * primary use case for setting this field is to use a StatefulSet's Headless
       * Service to propagate SRV records for its Pods without respect to their
       * readiness for purpose of peer discovery.
       */
      publishNotReadyAddresses?: boolean;
      /**
       * Route service traffic to pods with label keys and values
       * matching this selector.
       *
       * @remarks
       * If empty or not present, the service is assumed to
       * have an external process managing its endpoints, which Kubernetes will not
       * modify. Only applies to types ClusterIP, NodePort, and LoadBalancer.
       * Ignored if type is ExternalName.
       *
       * For more information, see the
       * {@link https://kubernetes.io/docs/concepts/services-networking/service/ |
       * Kubernetes documentation}.
       */
      selector?: EndpointSelector | object;
      /**
       * Used to maintain session affinity.
       *
       * @remarks
       * Possible values are:
       *
       * - `"ClientIP"`: Enables client IP based session affinity.
       *
       * - `"None"`: Disables session affinity.
       *
       * For more information, see the
       * {@link https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies |
       * Kubernetes documentation}.
       * @defaultValue `"None"`
       */
      sessionAffinity?: string;
      /**
       * Determines how the Service is exposed.
       *
       * @remarks
       * Valid options are:
       *
       * - `"ExternalName"`: maps to the specified externalName.
       *
       * - `"ClusterIP"`: allocates a cluster-internal IP address for load
       * balancing to endpoints. Endpoints are determined by the selector or if
       * that is not specified, by manual construction of an Endpoints object. If
       * clusterIP is "None", no virtual IP is allocated and the endpoints are
       * published as a set of endpoints rather than a stable IP.
       *
       * - `"NodePort"`: Builds on ClusterIP and allocates a port on every node
       * which routes to the clusterIP.
       *
       * - `"LoadBalancer"`: Builds on NodePort and creates an external load
       * balancer (if supported in the current cloud) which routes to the
       * clusterIP.
       *
       * For more information, see the
       * {@link https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services---service-types |
       * Kubernetes documentation}.
       * @defaultValue `"ClusterIP"`
       */
      type?: string;
  }/** @public */
  export declare interface ServicePort {
      /**
       * The name of this port within the service.
       *
       * @remarks
       * This must be a DNS_LABEL.
       * All ports within a ServiceSpec must have unique names.This maps to the
       * Name' field in EndpointPort objects. Optional if only one ServicePort is
       * defined on this service.
       */
      name?: string;
      /**
       * The port on each node on which this service is exposed when
       * type=NodePort or LoadBalancer.
       *
       * @remarks
       * Usually assigned by the system. If
       * specified, it will be allocated to the service if unused or else creation
       * of the service will fail.
       *
       * For more information, see the
       * {@link https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport |
       * Kubernetes documentation}.
       * @defaultValue Automatically allocates a port if the ServiceType of this
       * Service requires one.
       */
      nodePort?: number;
      /** The port that will be exposed by this service. */
      port?: number;
      /** The IP protocol for this port.Supports "TCP" and "UDP".Default is TCP. */
      protocol?: string;
      /**
       * Number or name of the port to access on the pods targeted by the
       * service.
       *
       * @remarks
       * Number must be in the range 1 to 65535. Name must be an
       * IANA_SVC_NAME. If this is a string, it will be looked up as a named port
       * in the target Pod's container ports. If this is not specified, the value
       * of the 'port' field is used (an identity map). This field is ignored for
       * services with clusterIP = None, and should be omitted or set equal to the
       * 'port' field.
       *
       * For more information, see the
       * {@link https://kubernetes.io/docs/concepts/services-networking/service/#defining-a-service |
       * Kubernetes documentation}.
       */
      targetPort?: number | string;
  }/** @internal */
  const serviceResourceInfo: {
      kind: string;
      deployedWhen: typeof deployedWhen;
      statusQuery: (props: ResourcePropsWithConfig, observe: ObserveForStatus, buildData: BuildData) => Promise<any>;
  };/**
   * k8s ServiceAccount resource
   *
   * @param propsIn - props for ServiceAccount as specifed in {@link k8s.ServiceAccountProps}
   *
   * @public
   */
  export declare function ServiceAccount(propsIn: SFCDeclProps<ServiceAccountProps, typeof defaultProps>): Adapt.JSX.Element;/** @public */
  export declare function isServiceAccountProps(p: ResourceProps): p is ResourceProps & ResourceServiceAccount;/** @internal */
  const serviceAccountResourceInfo: {
      kind: string;
      deployedWhen: () => true;
      statusQuery: (props: ResourcePropsWithConfig, observe: ObserveForStatus, buildData: BuildData) => Promise<any>;
      makeManifest: (manifest: Manifest, elem: AdaptElement<ResourceProps>, _deployID: string) => {
          automountServiceAccountToken: boolean | undefined;
          imagePullSecrets: {
              name: string;
          }[] | undefined;
          secrets: ObjectReference[] | undefined;
          apiVersion: string;
          kind: string;
          metadata: import("./manifest_support").MetadataInRequest;
          spec?: import("./DaemonSet").DaemonSetSpec | import("./common").CRSpec | import("./Pod").PodSpec | import("./Service").ServiceSpec | import("./Deployment").DeploymentSpec | undefined;
      };
  };/**
   * Props for {@link k8s.ServiceDeployment}
   *
   * @public
   */
  export declare interface ServiceDeploymentProps<T extends AllowableComponentProps = DeploymentProps> extends ServiceProps {
      config: ClusterInfo;
      serviceProps?: Partial<ServiceProps>;
      component: ComponentType<T>;
      componentProps: T;
      podProps?: Partial<PodProps>;
      containerProps?: Partial<OmitT<K8sContainerProps, "image">>;
  }/**
   * A component for mapping a group of abstract {@link Container}s and
   * {@link NetworkService}s to Kubernetes {@link k8s.Pod}s and
   * {@link k8s.K8sContainer}s.
   *
   * @remarks
   * This component is intended to be used to replace {@link Container} and
   * {@link NetworkService} components that are grouped together, as the
   * only children of a common parent in a pattern that looks like this:
   *
   * ```tsx
   * <Service>
   *   <Container ... />
   *   <Container ... />
   *   <NetworkService ... />
   * </Service>
   * ```
   *
   * `ServiceDeployment` would map those abstract components into corresponding
   * k8s components like this:
   * ```tsx
   * <Group>
   *   <docker.RegistryDockerImage ... /> //If props.config specifies a registry
   *   <k8s.Deployment ... >
   *     <Pod isTemplate>
   *       <k8s.K8sContainer ... />
   *     </Pod>
   *   </k8s.Deployment>
   *   <docker.RegistryDockerImage ... /> //If props.config specifies a registry
   *   <k8s.Deployment ... >
   *     <Pod isTemplate>
   *       <k8s.K8sContainer ... />
   *     </Pod>
   *   </k8s.Pod>
   *   <k8s.Service ... />
   * </Group>
   * ```
   * An example style rule to do this is:
   * ```tsx
   * {Adapt.rule((matchedProps) => {
   *     const { handle, ...remainingProps } = matchedProps;
   *     return <ServiceDeployment config={kubeconfig} {...remainingProps} />;
   * })}
   * ```
   * `ServiceDeployment` also requires the `config` prop which specifies
   * connection and authentication information for the Kubernetes cluster on
   * which these objects should be created.
   *
   * @public
   */
  export declare class ServiceDeployment<T extends AllowableComponentProps> extends DeferredComponent<ServiceDeploymentProps<T>> {
      static defaultProps: {
          component: typeof Deployment;
          componentProps: {
              replicas: number;
          };
      };
      build(helpers: BuildHelpers): Adapt.JSX.Element;
  }/** @public */
  export declare function computeNamespaceFromMetadata(metadata?: Metadata): string;/** @public */
  export declare function isLabelSelector(x: any): x is LabelSelector;/**
   * Kubernetes Kind
   *
   * @public
   */
  export declare type Kind = string;/** @public */
  export declare interface CRSpec {
      [key: string]: any;
  }/** @public */
  export declare type Spec = DaemonSetSpec | DeploymentSpec | PodSpec | ServiceSpec | CRSpec;/** @public */
  export declare interface Metadata {
      namespace?: string;
      labels?: {
          [key: string]: string;
      };
      annotations?: {
          [key: string]: string;
      };
  }/** @public */
  export declare type ResourceProps = {
      key: string;
  } & (ResourceClusterRole | ResourceClusterRoleBinding | ResourceDaemonSet | ResourcePod | ResourceService | ResourceServiceAccount | ResourceConfigMap | ResourceSecret | ResourceCR);/** @public */
  export declare type ResourcePropsWithConfig = ResourceProps & {
      config: ClusterInfo;
  };/** @public */
  export declare interface ResourceInfo {
      kind: Kind;
      statusQuery?: (props: ResourceProps, observe: ObserveForStatus, buildData: BuildData) => unknown | Promise<unknown>;
      specsEqual(actual: Spec, element: Spec): boolean;
  }/**
   * Holds the information needed to connect, authenticate, and run code in a kuberenetes cluster
   *
   * @public
   */
  export declare interface ClusterInfo {
      /** Javascript object formed by parsing a valid kubeconfig file */
      kubeconfig: Kubeconfig;
      /**
       * Registry to which Docker images used by the cluster in `kubeconfig` should be pushed and pulled
       *
       * @remarks
       * If `registryPrefix` is a string, it is assumed that the cluster can pull from the same string
       * that outsiders can push to.
       *
       * If `registryPrefix` is of the form `{ external: string, internal: string }` then the `external`
       * string will be used to push images, and the `internal` string will be used to pull images.
       *
       * Note(manishv)
       * This is a bit of a hack to allow one hostname or IP address to push images from outside
       * a particular environment (say k8s) and a different URL for that environment to pull
       * images.
       *
       * A good example of this is a k3s-dind (k3s docker-in-docker) instance of kubernetes where
       * a private registry is running on a docker network attached to the k3s-dind instance, but where we
       * want to push {@link docker.LocalDockerImage} built images to that registry.  Since
       * {@link docker.LocalDockerImage | LocalDockerImage} is outside the k3s-dind environment, it must
       * use a host accessible network to push to the registry.  However, since the k3s-dind instance sees
       * the registry from within Docker, it must use a different address to pull the images for use.
       *
       * Once network scopes are fully supported, this interface will change to whatever is appropriate.  It
       * is best if you can arrange to have the same URL or registry string work for all access regardless
       * of which network the registry, Adapt host, and ultimate container running environment uses.
       *
       */
      registryPrefix?: string | DockerSplitRegistryInfo;
  }/** @public */
  export declare interface ResourceBase {
      /**
       * config to connect to the k8s cluster
       *
       * required if isTemplate is false
       */
      config?: ClusterInfo;
      /**
       * Specifies whether this resource is just a template for use in a controller
       */
      isTemplate?: boolean;
      apiVersion?: string;
      kind: Kind;
      metadata?: Metadata;
  }/**
   * @public
   */
  export declare interface PolicyRule {
      /**
       * APIGroups is the name of the APIGroup that contains the resources.
       *
       * If multiple API groups are specified, any action requested against one
       * of the enumerated resources in any API group will be allowed.
       */
      apiGroups?: string[];
      /**
       * NonResourceURLs is a set of partial urls that a user should have access to.
       *
       * *s are allowed, but only as the full, final step in the path.
       * Since non-resource URLs are not namespaced, this field is only applicable
       * for ClusterRoles referenced from a ClusterRoleBinding.
       * Rules can either apply to API resources (such as "pods" or "secrets") or
       * non-resource URL paths (such as "/api"), but not both.
       */
      nonResourceURLs?: string[];
      /**
       * ResourceNames is an optional white list of names that the rule applies to.
       *
       * An empty set means that everything is allowed.
       */
      resourceNames?: string[];
      /**
       * Resources is a list of resources this rule applies to.
       *
       * ResourceAll represents all resources.
       */
      resources: string[];
      /**
       * Verbs is a list of Verbs that apply to ALL the ResourceKinds and
       * AttributeRestrictions contained in this rule.
       *
       * VerbAll represents all kinds.
       */
      verbs: string[];
  }/**
   * AggregationRule for {@link k8s.ClusterRole}
   *
   * @public
   */
  export declare interface AggregationRule {
      /**
       * ClusterRoleSelectors holds a list of selectors which will be used to
       * find ClusterRoles and create the rules.
       *
       * If any of the selectors match, then the ClusterRole's permissions will be added
       */
      clusterRoleSelector: LabelSelector;
  }/** @public */
  export declare interface ResourceClusterRole extends ResourceBase {
      apiVersion: "rbac.authorization.k8s.io/v1";
      kind: "ClusterRole";
      aggregationRule?: AggregationRule;
      rules?: PolicyRule[];
  }/**
   * RoleRef for {@link k8s.ResourceClusterRoleBinding}
   *
   * @public
   */
  export declare interface RoleRef {
      /** apiGroup is the group for the resource being referenced */
      apiGroup: string;
      /** kind is the type of resource being referenced */
      kind: string;
      /** Name is the name of resource being referenced */
      name: string;
  }/**
   * Subject for {@link k8s.ResourceClusterRoleBinding}
   *
   * @public
   */
  export declare interface Subject {
      /** apiGroup is the group for the object being referenced */
      apiGroup: string;
      /** kind is the type of object being referenced */
      kind: string;
      /**
       * Name of the object being referenced.
       */
      name: string;
      /**
       * Namespace of the referenced object.
       *
       * If the object kind is non-namespace, such as "User" or "Group", and this value
       * is not empty the Authorizer should report an error.
       */
      namespace?: string;
  }/** @public */
  export declare interface ResourceClusterRoleBinding extends ResourceBase {
      apiVersion: "rbac.authorization.k8s.io/v1";
      kind: "ClusterRoleBinding";
      roleRef: RoleRef;
      subjects: Subject[];
  }/** @public */
  export declare interface ResourceDaemonSet extends ResourceBase {
      apiVersion: "apps/v1";
      kind: "DaemonSet";
      spec: DaemonSetSpec;
  }/** @public */
  export declare interface ResourcePod extends ResourceBase {
      kind: "Pod";
      spec: PodSpec;
  }/** @public */
  export declare interface ResourceService extends ResourceBase {
      kind: "Service";
      spec: ServiceSpec;
  }/** @public */
  export declare interface ResourceServiceAccount extends ResourceBase {
      kind: "ServiceAccount";
      automountServiceAccountToken?: boolean;
      imagePullSecrets?: {
          name: string;
      }[];
      secrets?: ObjectReference[];
  }/** @public */
  export declare interface ResourceConfigMap extends ResourceBase {
      kind: "ConfigMap";
      binaryData?: {
          [key: string]: string;
      };
      data?: {
          [key: string]: string;
      };
      /** @beta */
      immutable?: boolean;
  }/** @public */
  export declare interface ResourceSecret extends ResourceBase {
      kind: "Secret";
      data?: {
          [key: string]: string;
      };
      stringData?: {
          [key: string]: string;
      };
      type?: string;
  }/** @public */
  export declare interface ResourceCR extends ResourceBase {
      kind: string;
      spec: CRSpec;
  }/** @public */
  export declare interface Kubeconfig {
      apiVersion?: "v1";
      kind: "Config";
      "current-context": string;
      contexts: {
          name: string;
          context: {
              cluster: string;
              user: string;
          };
      }[];
      clusters: {
          name: string;
          cluster: {
              "certificate-authority-data": string;
              server: string;
          };
      }[];
      preferences?: unknown;
      users: {
          name: string;
          user: {
              "client-certificate-data"?: string;
              "client-key-data"?: string;
              "username"?: string;
              "password"?: string;
          };
      }[];
  }/** @public */
  export declare interface LabelSelector {
      /**
       * matchExpressions is a list of label selector requirements. The requirements are ANDed.
       */
      matchExpressions?: LabelSelectorRequirement[];
      /**
       * matchLabels is a map of `{key,value}`pairs. A single `{key,value}` in the matchLabels map
       * is equivalent to an element of matchExpressions, whose key field is "key", the operator
       * is "In", and the values array contains only "value". The requirements are ANDed.
       */
      matchLabels?: {
          [key: string]: string;
      };
  }/** @public */
  export declare interface LocalObjectReference {
      /**
       * Name of the referent.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names}
       */
      name: string;
  }/**
   * PodTemplateSpec from k8s API
   *
   * @public
   */
  export declare interface PodTemplateSpec {
      /**
       * Standard object's metadata.
       * More Info: {@link https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata}
       */
      metadata: Metadata;
      /**
       * Specification of the desired behavior of the pod.
       * More Info: {@link https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status}
       */
      spec: PodSpec;
  }/**
   * ObjectReference from k8s API
   *
   * @public
   */
  export declare interface ObjectReference {
      /**
       * If referring to a piece of an object instead of an entire object,
       * this string should contain a valid JSON/Go field access statement,
       * such as desiredState.manifest.containers[2].
       *
       * For example, if the object reference is to a container within a pod,
       * this would take on a value like: "spec.containers\{name\}" (where "name"
       * refers to the name of the container that triggered the event) or if no
       * container name is specified "spec.containers[2]"
       * (container with index 2 in this pod).
       * This syntax is chosen only to have some well-defined way of referencing a
       * part of an object.
       */
      fieldPath: string;
      /**
       * Name of the referent.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names}
       *
       */
      name: string;
      /**
       * Namespace of the referent.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/}
       */
      namespace: string;
      /**
       * Specific resourceVersion to which this reference is made, if any.
       *
       * More info: {@link https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency}
       */
      resourceVersion: string;
      /**
       * UID of the referent.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids}
       */
      uid: string;
  }/**
   * Make a {@link k8s.ClusterInfo} object suitable for use with k8s resources
   *
   * @remarks
   *
   * This function will take a set of options and generate a {@link k8s.ClusterInfo}
   * object that contains the kubeconfig, registryPrefix for private images, and any other
   * relevant information for the cluster
   *
   * See {@link k8s.MakeClusterInfoOptions} for information on how the information
   * is computed.
   *
   * @returns A {@link k8s.ClusterInfo} object.
   *
   * @public
   */
  export declare function makeClusterInfo(options: MakeClusterInfoOptions): Promise<ClusterInfo>;/** @internal */
  export declare function isResourcePodTemplate(x: any): x is AdaptElement<ResourcePod>;/**
   * Hook that allows a prop to be either an array of handle to k8s resources and values
   *
   * @param initial - initial value of the prop, before the handles are be resolved
   * @param notReady - is a marker value to indicate that a handle's value isn't available yet
   * @param kinds - an array of legal k8s Kinds that a prop handle can point to
   * @param thisResourceName - the name of the resource using the hook, for error messages
   * @param propName - the name of the prop being resolved, again for error messages
   *
   * @returns A two element array, the first element is the current value, the second the update function
   *
   * This hook will start by returning the initial value and an update function that updates
   * the value the hook returns.  The update function takes 2 arguments - the prop value which
   * is an array with a mix of values and handles to be resolved, and a function that receives
   * the elements that any handles point to along with that elements props.  This function
   * can be passed by the caller of update to resolve handles as appropriate for the component.
   *
   * For example, {@link k8s.ClusterRoleBinding} uses this hook to resolve the subjects prop,
   * which is an array of other objects (typically {@link ServiceAccount}) that a particular
   * {@link k8s.ClusterRole} should point to.  When ClusterRoleBinding calls the update method,
   * it passes a function that will convert a {@link k8s.Resource} element of Kind `ServiceAccount`
   * to the underlying `Subject` object that kubernetes expects, namely
   * `{ apiGroup: "", kind: "ServiceAccount", name: resourceIdToName(elem, deployID), namespace: <element namespace> }`
   *
   * @example
   * ```
   * function MyResource({ serviceAccountNames }: { serviceAccountNames: (string | Handle)[]}) {
   *   const { deployID } = useBuildHelpers();
   *   const [ resolvedServiceAccountNames, updateSANs] = useResources({
   *      initial: [],
   *      notReady: null,
   *      kinds: ["ServiceAccount"],
   *      thisResourceName: "MyResources",
   *      propName: "serviceAccountNames",
   *   });
   *
   *   updateSANs(serviceAccountNames, (e, props) => {
   *      return {
   *        apiGroup: (e.metadata.apiVersion?.split("/")[0]) || "",
   *        name: resourceElementToName(e, deployID),
   *        namespace: props.metadata.namespace,
   *      }
   *   });
   *
   *   return null;
   * }
   * ```
   *
   * @beta
   */
  export declare function useResources<ValT, NotReadyT>({ initial, notReady, kinds, thisResourceName, propName, }: {
      initial: ValT[];
      notReady: NotReadyT;
      kinds: string[];
      thisResourceName: string;
      propName: string;
  }): [
      (ValT | NotReadyT)[],
      (props: (ValT | Handle)[], f: (e: AdaptMountedElement, props: ResourceProps) => Promise<ValT> | ValT) => void
  ];/**
   * Hook to allow conversion of a prop that could be a value or a handle
   *
   * This function behaves similarly to {@link k8s.useResources}, but works for
   * a prop that is either a Handle or a single value instead of an array of
   * Handles and values.
   *
   * See {@link k8s.useResources} for more detailed documentation.
   *
   * @beta
   */
  export declare function useResource<ValT, NotReadyT>(opts: {
      initial: ValT | NotReadyT;
      notReady: NotReadyT;
      kinds: string[];
      thisResourceName: string;
      propName: string;
  }): [
      ValT | NotReadyT,
      (prop: ValT | Handle, f: (e: AdaptMountedElement, props: ResourceProps) => Promise<ValT> | ValT) => void
  ];/**
   * Options for {@link k8s.makeClusterInfo}
   *
   * @public
   */
  export declare interface MakeClusterInfoOptions {
      /**
       * A Javascript Object representing a valid kubeconfig, or a YAML string, or a path to a kubeconfig file.
       *
       * @remarks
       * If this is a Javascript object, it will be treated like a parsed kubeconfig.  If this is a string,
       * {@link k8s.makeClusterInfo} will first attempt to parse it as JSON.  If that fails, it will attempt
       * to parse it as YAML.  If that fails it will treat the string as a path of configs (like with the `KUBECONFIG`
       * environment variable).
       *
       * If kubeconfig is missing {@link k8s.makeClusterInfo} will use the `KUBECONFIG` environment variable to build
       * a suitable config using `kubectl config view --flatten` and return that as the kubeconfig in the resulting
       * {@link k8s.ClusterInfo}
       */
      kubeconfig?: Kubeconfig | string;
      /**
       * URL to the docker registry that this cluster uses to pull private images.
       *
       * @remarks
       * This is identical to the `registryPrefix` field in {@link k8s.ClusterInfo}.  It will
       * be returned verbatim in the resulting {@link k8s.ClusterInfo} object.
       */
      registryPrefix?: string | DockerSplitRegistryInfo;
  }/**
   * k8s ClusterRole resource
   *
   * @param propsIn - props for ServiceAccount as specifed in {@link k8s.ClusterRoleProps}
   *
   * @public
   */
  export declare function ClusterRole(propsIn: SFCDeclProps<ClusterRoleProps, typeof defaultProps>): Adapt.JSX.Element;/** @public */
  export declare function isClusterRoleProps(props: ResourceProps): props is ResourceProps & ResourceClusterRole;/** @internal */
  const clusterRoleResourceInfo: {
      kind: string;
      deployedWhen: () => true;
      statusQuery: (props: ResourcePropsWithConfig, observe: ObserveForStatus, buildData: BuildData) => Promise<any>;
      makeManifest: (manifest: Manifest, elem: AdaptElement<ResourceProps>, _deployID: string) => {
          aggregationRule: AggregationRule | undefined;
          rules: PolicyRule[] | undefined;
          apiVersion: string;
          kind: string;
          metadata: import("./manifest_support").MetadataInRequest;
          spec?: import("./DaemonSet").DaemonSetSpec | import("./common").CRSpec | import("./Pod").PodSpec | import("./Service").ServiceSpec | import("./Deployment").DeploymentSpec | undefined;
      };
  };/**
   * k8s ClusterRoleBinding resource
   *
   * @param propsIn - props for ServiceAccount as specifed in {@link k8s.ClusterRoleBindingProps}
   *
   * @public
   */
  export declare function ClusterRoleBinding(propsIn: SFCDeclProps<ClusterRoleBindingProps, typeof defaultProps>): Adapt.JSX.Element | null;/** @internal */
  const clusterRoleBindingResourceInfo: {
      kind: string;
      deployedWhen: () => true;
      statusQuery: (props: ResourcePropsWithConfig, observe: ObserveForStatus, buildData: BuildData) => Promise<any>;
      makeManifest: (manifest: Manifest, elem: AdaptElement<ResourceProps>, _deployID: string) => {
          roleRef: RoleRef;
          subjects: Subject[];
          apiVersion: string;
          kind: string;
          metadata: import("./manifest_support").MetadataInRequest;
          spec?: import("./DaemonSet").DaemonSetSpec | import("./common").CRSpec | import("./Pod").PodSpec | import("./Service").ServiceSpec | import("./Deployment").DeploymentSpec | undefined;
      };
  };/**
   * k8s ConfigMap resource
   *
   * @param propsIn - props for ConfigMap as specifed in {@link k8s.ConfigMapProps}
   *
   * @public
   */
  export declare function ConfigMap(propsIn: SFCDeclProps<ConfigMapProps, typeof defaultProps>): Adapt.JSX.Element;/** @internal */
  const configMapResourceInfo: {
      kind: string;
      deployedWhen: () => true;
      statusQuery: (props: ResourcePropsWithConfig, observe: ObserveForStatus, buildData: BuildData) => Promise<any>;
      makeManifest: (manifest: Manifest, elem: AdaptElement<ResourceProps>, _deployID: string) => {
          data: {
              [key: string]: string;
          } | undefined;
          binaryData: {
              [key: string]: string;
          } | undefined;
          immutable: boolean | undefined;
          apiVersion: string;
          kind: string;
          metadata: import("./manifest_support").MetadataInRequest;
          spec?: import("./DaemonSet").DaemonSetSpec | import("./common").CRSpec | import("./Pod").PodSpec | import("./Service").ServiceSpec | import("./Deployment").DeploymentSpec | undefined;
      };
  };/**
   * Low level utility function to translate from the abstract {@link Container}
   * component props ({@link ContainerProps}) to {@link k8s.K8sContainerProps}
   * to be used in a {@link k8s.K8sContainer}.
   * @remarks
   * Note: The `image` property in the passed in {@link ContainerProps} must
   * be a `string`, not a `Handle`.
   * In most cases, it is preferable to use the {@link k8s.Container} component
   * instead, which is designed specifically to deal with this issue.
   *
   * @param abstractProps - The abstract {@link ContainerProps} to translate from.
   * @param k8sProps - Props that are specific to the {@link k8s.K8sContainer}
   *     component that should be merged into the resulting returned
   *     {@link k8s.K8sContainerProps} object.
   * @public
   */
  export declare function k8sContainerProps(abstractProps: FromContainerProps, k8sProps?: Partial<K8sContainerProps>): K8sContainerProps;/**
   * Tests whether an element is a {@link k8s.K8sContainer} element
   * @param x - element to test
   * @returns `true` if element is a {@link k8s.K8sContainer}, `false` otherwise
   *
   * @remarks
   * Acts as a TypeScript type assertion that will assert that `x` is `AdaptElement<K8sContainerProps>`
   *
   * @public
   */
  export declare function isK8sContainerElement(x: AdaptElement): x is AdaptElement<K8sContainerProps>;/**
   * Component that implements the abstract {@link Container} interface and
   * translates to a Kubernetes-specific {@link k8s.K8sContainer}.
   * @public
   */
  export declare function Container(props: ContainerProps): Adapt.JSX.Element | null;/** @public */
  export declare interface VolumeMount {
      /**
       * Path within the container at which the volume should be mounted.
       *
       * Must not contain ':'.
       */
      mountPath: string;
      /**
       * mountPropagation determines how mounts are propagated from the host to container and the other way around.
       *
       * When not set, MountPropagationNone is used. This field is beta in 1.10.
       *
       * @defaultValue MountPropagationNone
       */
      mountPropagation?: string;
      /** This must match the Name of a Volume. */
      name: string;
      /**
       * Mounted read-only if true, read-write otherwise (false or unspecified).
       *
       * @defaultValue false
       */
      readOnly?: boolean;
      /**
       * Path within the volume from which the container's volume should be mounted.
       *
       * Defaults to "" (volume's root).
       *
       * @defaultValue ""
       */
      subPath?: string;
      /**
       * Expanded path within the volume from which the container's volume should be mounted.
       *
       * Behaves similarly to SubPath but environment variable references $(VAR_NAME)
       * are expanded using the container's environment.
       *
       * Defaults to "" (volume's root).
       *
       * SubPathExpr and SubPath are mutually exclusive.
       *
       * @defaultValue ""
       */
      subPathExpr?: string;
  }/** @public */
  export declare interface ConfigMapEnvSource {
      /**
       * Name of the referent.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names}
       */
      name?: string;
      /**
       * Specify whether the ConfigMap must be defined
       */
      optional?: boolean;
  }/** @public */
  export declare interface SecretEnvSource {
      /**
       * Name of the referent.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names}
       */
      name?: string;
      /**
       * Specify whether the Secret must be defined
       */
      optional?: boolean;
  }/** @public */
  export declare interface EnvFromSource {
      /** The ConfigMap to select from */
      configMapRef?: ConfigMapEnvSource;
      /** An optional identifier to prepend to each key in the ConfigMap. Must be a C_IDENTIFIER. */
      prefix?: string;
      /** SecretEnvSource	The Secret to select from */
      secretRef?: SecretEnvSource;
  }/** @public */
  export declare interface ExecAction {
      /**
       * Command is the command line to execute inside the container.
       *
       * The working directory for the command is root ('/') in the container's filesystem.
       * The command is simply exec'd, it is not run inside a shell,
       * so traditional shell instructions ('|', etc) won't work.
       * To use a shell, you need to explicitly call out to that shell.
       *
       * Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
       */
      command: string[];
  }/** @public */
  export declare interface HTTPGetAction {
      /**
       * Host name to connect to, defaults to the pod IP.
       *
       * You probably want to set "Host" in httpHeaders instead.
       */
      host?: string;
      /** Custom headers to set in the request. HTTP allows repeated headers. */
      httpHeaders?: {
          name: string;
          value: string;
      }[];
      /** Path to access on the HTTP server. */
      path: string;
      /**
       * Name or number of the port to access on the container.
       *
       * Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
       */
      port: number | string;
      /**
       * Scheme to use for connecting to the host.
       *
       * @defaultValue HTTP.
       */
      scheme?: string;
  }/** @public */
  export declare interface TCPSocketAction {
      /** Host name to connect to, defaults to the pod IP. */
      host?: string;
      /**
       * Number or name of the port to access on the container.
       *
       * Number must be in the range 1 to 65535.
       * Name must be an IANA_SVC_NAME.
       */
      port: string | number;
  }/** @public */
  export declare interface Probe {
      /**
       * Exec specifies the action to take.
       *
       * Only one of exec, httpGet, or tcpSocket should be specified
       */
      exec?: ExecAction;
      /**
       * Minimum consecutive failures for the probe to be considered failed after having succeeded.
       *
       * Defaults to 3. Minimum value is 1.
       *
       * @defaultValue 3
       */
      failureThreshold?: number;
      /** Specifies the http request to perform. */
      httpGet?: HTTPGetAction;
      /**
       *  Seconds after the container has started before liveness probes are initiated.
       *  More info: {@link https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes}
       */
      initialDelaySeconds?: number;
      /** How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. */
      periodSeconds?: number;
      /**
       * Minimum consecutive successes for the probe to be considered successful after having failed.
       *
       * Must be 1 for liveness and startup. Minimum value is 1.
       *
       * @defaultValue 1
       */
      successThreshold?: number;
      /**
       * Specifies an action involving a TCP port.
       *
       * TCP hooks not yet supported
       */
      tcpSocket?: TCPSocketAction;
      /**
       * Number of seconds after which the probe times out.
       *
       * Defaults to 1 second. Minimum value is 1.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes}
       *
       * @defaultValue 1
       */
      timeoutSeconds?: number;
  }/** @public */
  export declare interface ResourceRequirements {
      /**
       * Limits describes the maximum amount of compute resources allowed.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/}
       */
      limits?: {
          [key: string]: any;
      };
      /**
       * Describes the minimum amount of compute resources required.
       *
       * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
       * otherwise to an implementation-defined value.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/}
       */
      requests?: {
          [key: string]: any;
      };
  }/** @public */
  export declare type Handler = {
      exec: ExecAction;
  } | {
      httpGet: HTTPGetAction;
  } | {
      tcpSocket: TCPSocketAction;
  };/** @public */
  export declare interface Lifecycle {
      /**
       * PostStart is called immediately after a container is created.
       *
       * If the handler fails, the container is terminated and restarted according to its restart policy.
       * Other management of the container blocks until the hook completes.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks}
       */
      postStart: Handler;
      /**
       * Called immediately before a container is terminated due to an API request or management event such as liveness/startup probe failure, preemption, resource contention, etc.
       *
       * The handler is not called if the container crashes or exits.
       * The reason for termination is passed to the handler.
       * The Pod's termination grace period countdown begins before the PreStop hooked is executed.
       * Regardless of the outcome of the handler, the container will eventually terminate within the Pod's termination grace period.
       * Other management of the container blocks until the hook completes or until the termination grace period is reached.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks}
       */
      preStop: Handler;
  }/** @public */
  export declare interface VolumeDevice {
      /** The path inside of the container that the device will be mapped to. */
      devicePath: string;
      /** name must match the name of a persistentVolumeClaim in the pod */
      name: string;
  }/**
   * Resource spec for a Kubernetes container.
   * See the Kubernetes
   * {@link https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#container-v1-core | API docs }
   * for more details.
   * @public
   */
  export declare interface ContainerSpec {
      /**
       * Arguments to the entrypoint.
       *
       * The docker image's CMD is used if this is not provided.
       * Variable references $(VAR_NAME) are expanded using the container's environment.
       * If a variable cannot be resolved, the reference in the input string will be unchanged.
       * The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME).
       * Escaped references will never be expanded, regardless of whether the variable exists or not.
       * Cannot be updated.
       * More info: {@link https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell}
       */
      args?: string[];
      /**
       * Entrypoint array.
       *
       * Not executed within a shell.
       * The docker image's ENTRYPOINT is used if this is not provided.
       * Variable references $(VAR_NAME) are expanded using the container's environment.
       * If a variable cannot be resolved, the reference in the input string will be unchanged.
       * The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME).
       * Escaped references will never be expanded, regardless of whether the variable exists or not.
       * Cannot be updated.
       * More info: {@link https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell}
       */
      command?: string[];
      /**
       * List of environment variables to set in the container. Cannot be updated.
       */
      env?: EnvVar[];
      /**
       * List of sources to populate environment variables in the container.
       *
       * The keys defined within a source must be a C_IDENTIFIER.
       * All invalid keys will be reported as an event when the container is starting.
       * When a key exists in multiple sources, the value associated with the last source will take precedence.
       * Values defined by an Env with a duplicate key will take precedence. Cannot be updated.
       */
      envFrom?: EnvFromSource[];
      /**
       * Docker image name.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/containers/images}
       *
       * This field is optional to allow higher level config management to default or override container
       * images in workload controllers like Deployments and StatefulSets.
       */
      image?: string;
      /**
       * Image pull policy.
       *
       * One of Always, Never, IfNotPresent.
       * Defaults to Always if :latest tag is specified,
       * or IfNotPresent otherwise.
       * Cannot be updated.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/containers/images#updating-images}
       */
      imagePullPolicy?: "Always" | "Never" | "IfNotPresent";
      /**
       * List of sources to populate environment variables in the container.
       *
       * The keys defined within a source must be a C_IDENTIFIER.
       * All invalid keys will be reported as an event when the container is starting.
       * When a key exists in multiple sources, the value associated with the last source will take precedence.
       * Values defined by an Env with a duplicate key will take precedence. Cannot be updated.
       */
      lifecycle?: Lifecycle;
      /**
       * Periodic probe of container liveness.
       *
       * Container will be restarted if the probe fails.
       * Cannot be updated.
       * More info: {@link https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes}
       */
      livenessProbe?: Probe;
      /**
       * Name of the container specified as a DNS_LABEL.
       *
       * Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated.
       */
      name: string;
      /**
       * List of ports to expose from the container.
       *
       * Exposing a port here gives the system additional information about the network connections a container uses,
       * but is primarily informational.
       * Not specifying a port here DOES NOT prevent that port from being exposed.
       * Any port which is listening on the default "0.0.0.0" address inside a container will be accessible from
       * the network.
       * Cannot be updated.
       */
      ports?: ContainerPort[];
      /**
       * Periodic probe of container service readiness.
       *
       * Container will be removed from service endpoints if the probe fails.
       * Cannot be updated.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes}
       */
      readinessProbe?: Probe;
      /**
       * Compute Resources required by this container.
       *
       * Cannot be updated.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/}
       */
      resources?: ResourceRequirements;
      /**
       * Security options the pod should run with.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/policy/security-context/}
       * More info: {@link https://kubernetes.io/docs/tasks/configure-pod-container/security-context/}
       */
      securityContext?: PodSecurityContext;
      /**
       * Indicates that the Pod has successfully initialized.
       *
       * If specified, no other probes are executed until this completes successfully.
       * If this probe fails, the Pod will be restarted, just as if the livenessProbe failed.
       * This can be used to provide different probe parameters at the beginning of a Pod's lifecycle,
       * when it might take a long time to load data or warm a cache, than during steady-state operation.
       *
       * This cannot be updated.
       * This is a beta feature enabled by the StartupProbe feature flag.
       * More info: {@link https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes}
       */
      startupProbe?: Probe;
      /**
       * Whether this container should allocate a buffer for stdin in the container runtime.
       *
       * If this is not set, reads from stdin in the container will always result in EOF. Default is false.
       */
      stdin?: boolean;
      /**
       * Whether the container runtime should close the stdin channel after it has been opened by a single attach.
       *
       * When stdin is true the stdin stream will remain open across multiple attach sessions.
       * If stdinOnce is set to true, stdin is opened on container start,
       * is empty until the first client attaches to stdin,
       * and then remains open and accepts data until the client disconnects,
       * at which time stdin is closed and remains closed until the container is restarted.
       * If this flag is false, a container processes that reads from stdin will never receive an EOF. Default is false
       */
      stdinOnce?: boolean;
      /**
       * Path at which the file to which the container's termination message will be written is mounted into the container's filesystem.
       *
       * Message written is intended to be brief final status, such as an assertion failure message.
       * Will be truncated by the node if greater than 4096 bytes.
       * The total message length across all containers will be limited to 12kb.
       * Defaults to /dev/termination-log. Cannot be updated.
       */
      terminationMessagePath?: string;
      /**
       * Indicate how the termination message should be populated.
       *
       * File will use the contents of terminationMessagePath to populate the container status
       * message on both success and failure. FallbackToLogsOnError will use the last chunk of
       * container log output if the termination message file is empty and the container exited
       * with an error.
       * The log output is limited to 2048 bytes or 80 lines, whichever is smaller.
       * Defaults to File.
       * Cannot be updated.
       *
       * @defaultValue File
       */
      terminationMessagePolicy?: "File" | "FallbackToLogsOnError";
      /**
       * Whether this container should allocate a TTY for itself, also requires 'stdin' to be true.
       *
       * @defaultValue false
       */
      tty?: boolean;
      /**
       * volumeDevices is the list of block devices to be used by the container.
       */
      volumeDevices?: VolumeDevice[];
      /** volumeDevices is the list of block devices to be used by the container. */
      volumeMounts?: VolumeMount[];
      /**
       * Container's working directory.
       *
       * If not specified, the container runtime's default will be used,
       * which might be configured in the container image.
       * Cannot be updated.
       */
      workingDir?: string;
  }/**
   * Props for the Kubernetes-specific {@link k8s.K8sContainer} component.
   * @public
   */
  export declare interface K8sContainerProps extends ContainerSpec {
  }/** @public */
  export declare interface ContainerPort {
      /**
       * Number of port to expose on the pod's IP address.
       * @remarks
       * This must be a valid integer port number, `0 < x < 65536`.
       */
      containerPort: number;
      /** What host IP to bind the external port to. */
      hostIP?: string;
      /**
       * Number of port to expose on the host.
       * @remarks
       * If specified, this must be a valid integer port number,
       * `0 < x < 65536`. If HostNetwork is specified,
       * this must match ContainerPort. Most containers do not need this.
       */
      hostPort?: number;
      /**
       * A unique-within-pod name for the container
       * @remarks
       * If specified, this must be an IANA_SVC_NAME and unique within the pod.
       * Each named port in a pod must have a unique name. Name for the port
       * that can be referred to by services.
       */
      name?: string;
      /** Protocol for port. Must be UDP or TCP. Defaults to "TCP". */
      protocol?: string;
  }/** @public */
  export declare type EnvVar = EnvVarSimple | EnvVarFrom;/** @public */
  export declare interface EnvVarSimple {
      /** Name of the environment variable. Must be a C_IDENTIFIER. */
      name: string;
      /**
       * Variable references $(VAR_NAME) are expanded using the previous defined
       * environment variables in the container and any service environment
       * variables. If a variable cannot be resolved, the reference in the input
       * string will be unchanged. The $(VAR_NAME) syntax can be escaped with a
       * double $$, ie: $$(VAR_NAME). Escaped references will never be expanded,
       * regardless of whether the variable exists or not. Defaults to "".
       */
      value: string;
  }/** @public */
  export declare interface EnvVarFrom {
      /** Source for the environment variable's value. Cannot be used if value is not empty. */
      valueFrom?: any;
  }/**
   * See {@link k8s.k8sContainerProps}.
   * @public
   */
  export declare type FromContainerProps = ReplaceT<ContainerProps, {
      image: string;
  }> & BuiltinProps;/**
   * Kubernetes-specific container.
   * @public
   */
  export declare class K8sContainer extends PrimitiveComponent<K8sContainerProps> {
      static defaultProps: {
          imagePullPolicy: string;
      };
      validate(): undefined;
  }/**
   * Props for {@link k8s.Container}.
   * @public
   */
  export declare interface ContainerProps extends SFCDeclProps<ContainerProps> {
      /**
       * Additional {@link k8s.K8sContainerProps}-specific props that should be
       * added to the instantiated {@link k8s.K8sContainer}.
       */
      k8sContainerProps?: Partial<K8sContainerProps>;
  }/**
   * Spec for {@link k8s.DaemonSet} for use in {@link k8s.Resource}
   *
   * @public
   */
  export declare type DaemonSetSpec = Exclude<DaemonSetProps, ResourceBase> & {
      template: PodTemplateSpec;
  };/**
   * Component for Kubernetes DaemonSet
   *
   * @public
   */
  export declare class DaemonSet extends DeferredComponent<DaemonSetProps> {
      static defaultProps: {
          metadata: {};
          minReadySeconds: number;
          revisionHistoryLimit: number;
          updateStrategy: {
              type: string;
              rollingUpdate: {
                  maxUnavailable: number;
              };
          };
      };
      constructor(props: DaemonSetProps);
      build(helpers: BuildHelpers): Adapt.JSX.Element;
      status(_observe: ObserveForStatus, buildData: BuildData): Promise<Adapt.Status | undefined>;
  }/** @internal */
  const daemonSetResourceInfo: {
      kind: string;
      deployedWhen: typeof deployedWhen;
      statusQuery: (props: ResourcePropsWithConfig, observe: ObserveForStatus, buildData: BuildData) => Promise<any>;
  };/** @public */
  export declare interface DeploymentUpdateStrategyRecreate {
      type: "Recreate";
  }/** @public */
  export declare interface RollingUpdateDeployment {
      /**
       * The maximum number of pods that can be scheduled above the desired number of pods.
       *
       * Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
       * This can not be 0 if MaxUnavailable is 0.
       * Absolute number is calculated from percentage by rounding up.
       * Defaults to 25%.
       *
       * @example
       * When this is set to 30%, the new ReplicaSet can be scaled up immediately when the rolling update starts,
       * such that the total number of old and new pods do not exceed 130% of desired pods. Once old pods have been
       * killed, new ReplicaSet can be scaled up further, ensuring that total number of pods running at any time
       * during the update is at most 130% of desired pods.
       */
      maxSurge?: number | string;
      /**
       * The maximum number of pods that can be unavailable during the update.
       *
       * Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
       * Absolute number is calculated from percentage by rounding down.
       * This can not be 0 if MaxSurge is 0. Defaults to 25%.
       *
       * @example
       * When this is set to 30%, the old ReplicaSet can be scaled down to 70% of desired pods
       * immediately when the rolling update starts. Once new pods are ready, old ReplicaSet
       * can be scaled down further, followed by scaling up the new ReplicaSet, ensuring that
       * the total number of pods available at all times during the update is at least 70% of
       * desired pods.
       */
      maxUnavailable?: number | string;
  }/**
   * Spec for {@link k8s.Deployment} for use in {@link k8s.Resource}
   *
   * @public
   */
  export declare type DeploymentSpec = Exclude<DeploymentProps, ResourceBase> & {
      template: PodTemplateSpec;
  };/**
   * Props for {@link k8s.Deployment}
   *
   * @public
   */
  export declare interface DeploymentProps extends WithChildren {
      /** Information about the k8s cluster (ip address, auth info, etc.) */
      config: ClusterInfo;
      /** k8s metadata */
      metadata: Metadata;
      /**
       * The minimum number of seconds for which a newly created pod should
       * be ready without any of its container crashing, for it to be considered
       * available. Defaults to 0 (pod will be considered available as soon as it is ready).
       */
      minReadySeconds: number;
      /** Indicates that the deployment is paused */
      paused: boolean;
      /**
       * The maximum time in seconds for a deployment to make progress before it is considered to be failed.
       *
       * The deployment controller will continue to process failed deployments and a condition with a
       * ProgressDeadlineExceeded reason will be surfaced in the deployment status. Note that progress
       * will not be estimated during the time a deployment is paused. Defaults to 600s.
       */
      progressDeadlineSeconds: number;
      /**
       * Number of desired pods.
       *
       * Defaults to 1. 0 is not allowed.
       *
       * @defaultValue 1
       */
      replicas: number;
      /**
       * The number of old ReplicaSets to retain to allow rollback.
       *
       * This is a pointer to distinguish between explicit zero and not specified. Defaults to 10.
       *
       * @defaultValue 10
       */
      revisionHistoryLimit: number;
      /**
       * Label selector for pods.
       *
       * Existing ReplicaSets whose pods are selected by this will be the ones affected by this deployment.
       * It must match the pod template's labels.
       *
       * @remarks
       *
       * With Adapt, this is optional.  If not specified, adapt will pick a selector that will work with the pods
       * it creates as part of this {@link k8s.Deployment}
       */
      selector?: LabelSelector;
      /**
       * An deployment strategy to use to replace existing pods with new ones
       */
      strategy: DeploymentUpdateStrategy;
  }/**
   * Component for Kubernetes Deployment
   *
   * @public
   */
  export declare class Deployment extends DeferredComponent<DeploymentProps> {
      static defaultProps: {
          metadata: {};
          paused: boolean;
          replicas: number;
          progressDeadlineSeconds: number;
          minReadySeconds: number;
          revisionHistoryLimit: number;
          strategy: {
              type: string;
              rollingUpdate: {
                  maxSurge: string;
                  maxUnavailable: string;
              };
          };
      };
      constructor(props: DeploymentProps);
      build(helpers: BuildHelpers): Adapt.JSX.Element | null;
      deployedWhen: () => true | Adapt.Waiting;
      status(_observe: ObserveForStatus, buildData: BuildData): Promise<Adapt.Status | undefined>;
  }/** @internal */
  const deploymentResourceInfo: {
      kind: string;
      deployedWhen: typeof deployedWhen;
      statusQuery: (props: ResourcePropsWithConfig, observe: ObserveForStatus, buildData: BuildData) => Promise<any>;
  };/**
   * Type assertion to see if an element is both a {@link k8s.Resource | Resource}
   * and a {@link @adpt/core#FinalElement | FinalElement}
   *
   * @param e - element to test
   * @returns `true` if e is both a FinalElement and a {@link k8s.Resource | Resource}, `false` otherwise
   *
   * @public
   */
  export declare function isResourceFinalElement(e: AdaptElement): e is FinalDomElement<ResourceProps & Adapt.BuiltinProps>;/**
   * Tests whether a ResourceProps is for a template object
   *
   * @public
   */
  export declare function isResourcePropsWithConfig(x: ResourceProps & Partial<BuiltinProps>): x is ResourcePropsWithConfig & Partial<BuiltinProps>;/**
   * Tests to see if an object is a {@link k8s.Resource} element
   * @param x - object to test
   * @returns true if object is an AdaptElement of type {@link k8s.Resource}
   *
   * @public
   */
  export declare function isResource(x: any): x is AdaptElement<ResourceProps>;/**
   * Primitive Component recognized by the k8s plugin to represent resources
   * @public
   */
  export declare class Resource extends Action<ResourceProps> {
      defaultProps: {
          apiVersion: "v1";
          con: false;
      };
      manifest_: Manifest;
      constructor(props: ResourceProps);
      validate(): "Resource elements cannot have children" | undefined;
      shouldAct(op: ChangeType, ctx: ActionContext): Promise<ShouldAct>;
      action(op: ChangeType, ctx: ActionContext): Promise<void>;
      deployedWhen: (goalStatus: GoalStatus, helpers: DeployHelpers) => Promise<true | Adapt.Waiting | Adapt.Waiting[]>;
      status(observe: ObserveForStatus, buildData: BuildData): Promise<any>;
      private mountedElement;
      private manifest;
  }/** @internal */
  export declare function makePodManifest(props: PodProps & BuiltinProps, data: {
      volumes?: Volume[];
      serviceAccountName?: string;
  }): {
      kind: string;
      metadata: Metadata;
      spec: PodSpec;
  };/**
   * Tests whether x is a Pod element
   *
   * @param x - value to test
   * @returns `true` if x is a Pod element, false otherwise
   *
   * @public
   */
  export declare function isPod(x: any): x is AdaptElement<PodProps>;/** @public */
  export declare interface NodeSelectorRequirement {
      /** The label key that the selector applies to. */
      key: string;
      /**
       * Represents a key's relationship to a set of values.
       *
       * Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
       */
      operator: "In" | "NotIn" | "Exists" | "DoesNotExist" | "Gt" | "Lt";
      /**
       * Values for operator
       *
       * If the operator is In or NotIn, the values array must be non-empty.
       * If the operator is Exists or DoesNotExist, the values array must be empty.
       * If the operator is Gt or Lt, the values array must have a single element,
       * which will be interpreted as an integer.
       * This array is replaced during a strategic merge patch.
       */
      values: string[];
  }/** @public */
  export declare interface NodeSelectorTerm {
      /** A list of node selector requirements by node's labels. */
      matchExpressions?: NodeSelectorRequirement[];
      /** A list of node selector requirements by node's fields. */
      matchFields?: NodeSelectorRequirement[];
  }/** @public */
  export declare interface PreferredSchedulingTerm {
      /**
       * A node selector term, associated with the corresponding weight.
       */
      preference: NodeSelectorTerm;
      /** Weight associated with matching the corresponding nodeSelectorTerm, in the range 1-100. */
      weight: number;
  }/** @public */
  export declare interface NodeSelector {
      /** A list of node selector terms. The terms are ORed */
      nodeSelectorTerms: NodeSelectorTerm[];
  }/** @public */
  export declare interface NodeAffinity {
      /** The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding "weight" to the sum if the node matches the corresponding matchExpressions; the node(s) with the highest sum are the most preferred. */
      preferredDuringSchedulingIgnoredDuringExecution?: PreferredSchedulingTerm[];
      /** If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to an update), the system may or may not try to eventually evict the pod from its node. */
      requiredDuringSchedulingIgnoredDuringExecution?: NodeSelector;
  }/** @public */
  export declare interface PodAffinityTerm {
      /**
       * Label query over a set of resources, in this case pods.
       */
      labelSelector: LabelSelector;
      /** Specifies which namespaces the labelSelector applies to (matches against); null or empty list means "this pod's namespace" */
      namespaces?: string[];
      /** This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed. */
      topologyKey: string;
  }/** @public */
  export declare interface WeightedPodAffinityTerm {
      /** A pod affinity term, associated with the corresponding weight. */
      podAffinityTerm: PodAffinityTerm;
      /**
       * weight associated with matching the corresponding podAffinityTerm, in the range 1-100.
       */
      weight: number;
  }/** @public */
  export declare interface PodAffinity {
      /**
       * The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions.
       *
       * The node that is most preferred is the one with the greatest sum of weights,
       * i.e. for each node that meets all of the scheduling requirements (resource request,
       * requiredDuringScheduling affinity expressions, etc.), compute a sum by iterating
       * through the elements of this field and adding "weight" to the sum if the node has pods
       * which matches the corresponding podAffinityTerm; the node(s) with the highest sum are the most preferred.
       */
      preferredDuringSchedulingIgnoredDuringExecution: WeightedPodAffinityTerm[];
      /**
       * If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node.
       *
       * If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system may or may not try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each podAffinityTerm are intersected, i.e. all terms must be satisfied.
       */
      requiredDuringSchedulingIgnoredDuringExecution: PodAffinityTerm[];
  }/** @public */
  export declare interface PodAntiAffinity {
      /** The scheduler will prefer to schedule pods to nodes that satisfy the anti-affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling anti-affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the node(s) with the highest sum are the most preferred. */
      preferredDuringSchedulingIgnoredDuringExecution: WeightedPodAffinityTerm[];
      /** If the anti-affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the anti-affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system may or may not try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each podAffinityTerm are intersected, i.e. all terms must be satisfied. */
      requiredDuringSchedulingIgnoredDuringExecution: PodAffinity;
  }/** @public */
  export declare interface Affinity {
      /** Describes node affinity scheduling rules for the pod. */
      nodeAffinity: NodeAffinity;
      /** Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)). */
      podAffinity: PodAffinity;
      /** PodAntiAffinity	Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)). */
      podAntiAffinity: PodAntiAffinity;
  }/** @public */
  export declare interface PodDNSConfigOption {
      name: string;
      value?: string;
  }/** @public */
  export declare interface PodDNSConfig {
      /**
       * A list of DNS name server IP addresses.
       *
       * This will be appended to the base nameservers generated from DNSPolicy. Duplicated nameservers will be removed.
       */
      nameservers: string[];
      /**
       * A list of DNS resolver options.
       *
       * This will be merged with the base options generated from DNSPolicy.
       * Duplicated entries will be removed.
       * Resolution options given in Options will override those that appear in the base DNSPolicy.
       */
      options: PodDNSConfigOption[];
      /**
       * A list of DNS search domains for host-name lookup.
       *
       * This will be appended to the base search paths generated from DNSPolicy. Duplicated search paths will be removed.
       */
      searches: string[];
  }/** @public */
  export declare interface PodReadinessGate {
      /** Refers to a condition in the pod's condition list with matching type. */
      conditionType: string;
  }/** @public */
  export declare interface SELinuxOptions {
      /** SELinux level label that applies to the container. */
      level: string;
      /** SELinux role label that applies to the container. */
      role: string;
      /** SELinux type label that applies to the container. */
      type: string;
      /** SELinux user label that applies to the container */
      user: string;
  }/** @public */
  export declare interface SeccompProfile {
      /**
       * Indicates a profile defined in a file on the node should be used.
       *
       * The profile must be preconfigured on the node to work.
       * Must be a descending path, relative to the kubelet's configured seccomp profile location.
       * Must only be set if type is "Localhost".
       */
      localhostProfile?: string;
      /**
       * Indicates which kind of seccomp profile will be applied.
       *
       * Valid options are:
       * * Localhost - a profile defined in a file on the node should be used.
       * * RuntimeDefault - the container runtime default profile should be used.
       * * Unconfined - no profile should be applied.
       */
      type: "Localhost" | "RuntimeDefault" | "Unconfined";
  }/** @public */
  export declare interface Sysctl {
      name: string;
      value: string;
  }/** @public */
  export declare interface WindowsSecurityContextOptions {
      /**
       * The GMSA admission webhook ({@link https://github.com/kubernetes-sigs/windows-gmsa}) inlines the contents of the GMSA credential spec named by the GMSACredentialSpecName field.
       */
      gmsaCredentialSpec?: string;
      /**
       * GMSACredentialSpecName is the name of the GMSA credential spec to use.
       */
      gmsaCredentialSpecName?: string;
      /**
       * The UserName in Windows to run the entrypoint of the container process.
       *
       * Defaults to the user specified in image metadata if unspecified. May also be set in PodSecurityContext.
       * If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
       */
      runAsUserName?: string;
  }/** @public */
  export declare interface PodSecurityContext {
      /**
       * A special supplemental group that applies to all containers in a pod.
       *
       * Some volume types allow the Kubelet to change the ownership of that volume to be owned by the pod:
       *
       * 1. The owning GID will be the FSGroup
       * 2. The setgid bit is set (new files created in the volume will be owned by FSGroup)
       * 3. The permission bits are OR'd with rw-rw----
       *
       * If unset, the Kubelet will not modify the ownership and permissions of any volume.
       */
      fsGroup?: number;
      /**
       * Defines behavior of changing ownership and permission of the volume before being exposed inside Pod.
       *
       * This field will only apply to volume types which support fsGroup based ownership(and permissions).
       * It will have no effect on ephemeral volume types such as: secret, configmaps and emptydir.
       * Valid values are "OnRootMismatch" and "Always". If not specified defaults to "Always".
       *
       * @defaultValue Always
       */
      fsGroupChangePolicy?: "OnRootMismatch" | "Always";
      /**
       * The GID to run the entrypoint of the container process.
       *
       * Uses runtime default if unset. May also be set in SecurityContext.
       * If set in both SecurityContext and PodSecurityContext, the value specified in
       * SecurityContext takes precedence for that container.
       */
      runAsGroup?: number;
      /**
       * Indicates that the container must run as a non-root user.
       *
       * If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and
       * fail to start the container if it does. If unset or false, no such validation will be performed.
       * May also be set in SecurityContext.
       * If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
       */
      runAsNonRoot?: boolean;
      /**
       * The UID to run the entrypoint of the container process.
       *
       * Defaults to user specified in image metadata if unspecified.
       * May also be set in SecurityContext.
       * If set in both SecurityContext and PodSecurityContext, the value specified in
       * SecurityContext takes precedence for that container.
       */
      runAsUser?: number;
      /**
       * The SELinux context to be applied to all containers.
       *
       * If unspecified, the container runtime will allocate a random SELinux context for each container.
       * May also be set in SecurityContext.
       * If set in both SecurityContext and PodSecurityContext, the value specified in
       * SecurityContext takes precedence for that container.
       */
      seLinuxOptions?: SELinuxOptions;
      /**
       * The seccomp options to use by the containers in this pod.
       */
      seccompProfile?: SeccompProfile;
      /**
       * 	A list of groups applied to the first process run in each container, in addition to the container's primary GID.
       *
       *  If unspecified, no groups will be added to any container.
       */
      supplementalGroups?: number[];
      /**
       * Sysctls hold a list of namespaced sysctls used for the pod.
       *
       * Pods with unsupported sysctls (by the container runtime) might fail to launch.
       */
      sysctls?: Sysctl[];
      /**
       * The Windows specific settings applied to all containers.
       *
       * If unspecified, the options within a container's SecurityContext will be used.
       * If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
       */
      windowsOptions: WindowsSecurityContextOptions;
  }/** @public */
  export declare interface Toleration {
      /**
       * Indicates the taint effect to match.
       *
       * Empty means match all taint effects.
       * When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
       */
      effect?: "NoSchedule" | "PreferNoSchedule" | "NoExecute";
      /**
       * The taint key that the toleration applies to.
       *
       * Empty means match all taint keys.
       * If the key is empty, operator must be Exists;
       * this combination means to match all values and all keys.
       */
      key?: string;
      /**
       * Represents a key's relationship to the value.
       *
       * Valid operators are Exists and Equal.
       * Defaults to Equal.
       * Exists is equivalent to wildcard for value, so that a pod can tolerate all taints of a particular category.
       *
       * @defaultValue Equal
       */
      operator?: "Exists" | "Equal";
      /**
       * Represents the period of time the toleration (which must be of effect NoExecute, otherwise this field is ignored) tolerates the taint.
       *
       * By default, it is not set, which means tolerate the taint forever (do not evict).
       * Zero and negative values will be treated as 0 (evict immediately) by the system.
       */
      tolerationSeconds?: number;
      /**
       * Value is the taint value the toleration matches to.
       *
       * If the operator is Exists, the value should be empty, otherwise just a regular string.
       */
      value?: string;
  }/** @public */
  export declare interface TopologySpreadConstraint {
      /**
       * Used to find matching pods.
       *
       * Pods that match this label selector are counted to determine the
       * number of pods in their corresponding topology domain.
       */
      labelSelector: LabelSelector;
      /**
       * Describes the degree to which pods may be unevenly distributed.
       *
       * When `whenUnsatisfiable=DoNotSchedule`, it is the maximum permitted
       * difference between the number of matching pods in the target topology
       * and the global minimum.
       * For example, in a 3-zone cluster, MaxSkew is set to 1, and pods with
       * the same labelSelector spread as 1/1/0: | zone1 | zone2 | zone3 | | P | P | |
       * - if MaxSkew is 1, incoming pod can only be scheduled to zone3 to become 1/1/1;
       *   scheduling it onto zone1(zone2) would make the ActualSkew(2-0) on zone1(zone2) violate MaxSkew(1).
       * - if MaxSkew is 2, incoming pod can be scheduled onto any zone.
       * When `whenUnsatisfiable=ScheduleAnyway`, it is used to give higher precedence to topologies that satisfy it.
       * It's a required field. Default value is 1 and 0 is not allowed.
       *
       * @example
       *
       * @defaultValue 1
       */
      maxSkew: number;
      /**
       * The key of node labels.
       *
       * Nodes that have a label with this key and identical values are considered to be in the same topology.
       * We consider each \<key, value\> as a "bucket", and try to put balanced number of pods into each bucket.
       * It's a required field.
       */
      topologyKey: string;
      /**
       * Indicates how to deal with a pod if it doesn't satisfy the spread constraint.
       *
       * - DoNotSchedule (default) tells the scheduler not to schedule it.
       * - ScheduleAnyway tells the scheduler to schedule the pod in any location,
       *   but giving higher precedence to topologies that would help reduce the skew.
       *
       * A constraint is considered "Unsatisfiable" for an incoming pod if and only if every possible
       * node assigment for that pod would violate "MaxSkew" on some topology.
       * For example, in a 3-zone cluster, MaxSkew is set to 1, and pods with the same labelSelector
       * spread as 3/1/1: | zone1 | zone2 | zone3 | | P P P | P | P | If WhenUnsatisfiable is set to DoNotSchedule,
       * incoming pod can only be scheduled to zone2(zone3) to become 3/2/1(3/1/2)
       * as ActualSkew(2-1) on zone2(zone3) satisfies MaxSkew(1).
       * In other words, the cluster can still be imbalanced, but scheduler won't make it
       * *more* imbalanced.
       *
       * It's a required field.
       */
      whenUnsatisfiable: string;
  }/** @public */
  export declare interface KeyToPath {
      /** The key to project. */
      key: string;
      /**
       * mode bits to use on this file,
       * Must be a value between 0 and 0777.
       * If not specified, the volume defaultMode will be used.
       * This might be in conflict with other options that affect the file mode, like fsGroup,
       * and the result can be other mode bits set.
       */
      mode?: number;
      /**
       * The relative path of the file to map the key to.
       *
       * May not be an absolute path. May not contain the path element '..'. May not start with the string '..'.
       */
      path: string;
  }/** @public */
  export declare interface ConfigMapVolumeSource {
      /**
       * mode bits to use on created files by default.
       *
       * Must be a value between 0 and 0777. Defaults to 0644.
       * Directories within the path are not affected by this setting.
       * This might be in conflict with other options that affect the file mode,
       * like fsGroup, and the result can be other mode bits set.
       */
      defaultMode?: number;
      /**
       * If unspecified, each key-value pair in the Data field of the referenced ConfigMap will be projected into the volume as a file whose name is the key and content is the value.
       *
       * If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present.
       * If a key is specified which is not present in the ConfigMap, the volume setup will error unless it is marked optional.
       * Paths must be relative and may not contain the '..' path or start with '..'.
       */
      items?: KeyToPath[];
      /**
       * Name of the referent.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names}
       */
      name: string | Handle;
      /** Specify whether the ConfigMap or its keys must be defined */
      optional?: boolean;
  }/** @public */
  export declare interface SecretVolumeSource {
      /**
       * mode bits to use on created files by default.
       *
       * Must be a value between 0 and 0777. Defaults to 0644.
       * Directories within the path are not affected by this setting.
       * This might be in conflict with other options that affect the file mode,
       * like fsGroup, and the result can be other mode bits set.
       */
      defaultMode?: number;
      /**
       * If unspecified, each key-value pair in the Data field of the referenced Secret will be projected into the volume as a file whose name is the key and content is the value.
       *
       * If specified, the listed keys will be projected into the specified paths,
       * and unlisted keys will not be present. If a key is specified which is not
       * present in the Secret, the volume setup will error unless it is marked optional.
       *
       * Paths must be relative and may not contain the '..' path or start with '..'.
       */
      items?: KeyToPath[];
      /** Specify whether the Secret or its keys must be defined */
      optional?: boolean;
      /**
       * Name of the secret in the pod's namespace to use.
       *
       *  More info: {@link https://kubernetes.io/docs/concepts/storage/volumes#secret}
       */
      secretName: string | Handle;
  }/** @public */
  export declare interface EmptyDirVolumeSource {
      /**
       * What type of storage medium should back this directory.
       *
       * The default is "" which means to use the node's default medium.
       * Must be an empty string (default) or Memory.
       * More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
       */
      medium: string;
      /**
       * Total amount of local storage required for this EmptyDir volume.
       *
       * The size limit is also applicable for memory medium.
       * The maximum usage on memory medium EmptyDir would be the minimum
       * value between the SizeLimit specified here and the sum of memory limits of all containers in a pod.
       * The default is nil which means that the limit is undefined.
       * More info: {@link http://kubernetes.io/docs/user-guide/volumes#emptydir}
       */
      sizeLimit: string;
  }/**
   * Volumes for {@link k8s.PodProps}
   *
   * @public
   */
  export declare interface Volume {
      /**
       * Volume's name.
       *
       * Must be a DNS_LABEL and unique within the pod.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names}
       */
      name: string;
      /**
       * Represents a configMap that should populate this volume
       */
      configMap?: ConfigMapVolumeSource;
      /**
       * EmptyDir represents a temporary directory that shares a pod's lifetime.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/storage/volumes#emptydir}
       *
       */
      emptyDir?: EmptyDirVolumeSource;
      /**
       * Represents a secret that should populate this volume.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/storage/volumes#secret}
       */
      secret?: SecretVolumeSource;
      /** Other k8s volume kinds not typed yet for \@adpt/cloud */
      [key: string]: any;
  }/**
   * Props for the {@link k8s.Pod} component
   *
   * @public
   */
  export declare interface PodProps extends WithChildren {
      /**
       *  True is this is a template for use in a controller, false otherwise
       *  @defaultValue false
       */
      isTemplate: boolean;
      /** Information about the k8s cluster (ip address, auth info, etc.) */
      config?: ClusterInfo;
      /** k8s metadata */
      metadata: Metadata;
      /**
       * Optional duration in seconds the pod may be active on the node relative to StartTime before the system will actively try to mark it failed and kill associated containers.
       *
       * Value must be a positive integer.
       */
      activeDeadlineSeconds?: number;
      /** If specified, the pod's scheduling constraints */
      affinity?: Affinity;
      /** AutomountServiceAccountToken indicates whether a service account token should be automatically mounted. */
      automountServiceAccountToken?: boolean;
      /**
       *  Specifies the DNS parameters of a pod.
       *
       *  Parameters specified here will be merged to the generated DNS configuration based on DNSPolicy.
       */
      dnsConfig?: PodDNSConfig;
      /**
       * Set DNS policy for the pod.
       *
       * Valid values are 'ClusterFirstWithHostNet', 'ClusterFirst', 'Default' or 'None'.
       * DNS parameters given in DNSConfig will be merged with the policy selected with DNSPolicy.
       * To have DNS options set along with hostNetwork, you have to specify DNS policy explicitly
       * to 'ClusterFirstWithHostNet'.
       *
       * @defaultValue ClusterFirst
       */
      dnsPolicy: "ClusterFirstWithHostNet" | "ClusterFirst" | "Default" | "None";
      /**
       * Indicates whether information about services should be injected into pod's environment variables matching the syntax of Docker links.
       *
       * @defaultValue true
       */
      enableServiceLinks: boolean;
      /**
       * An optional list of hosts and IPs that will be injected into the pod's hosts file if specified.
       *
       * This is only valid for non-hostNetwork pods.
       */
      hostAliases?: HostAlias[];
      /**
       * Use the host's ipc namespace.
       * @defaultValue false
       */
      hostIPC: boolean;
      /**
       * Host networking requested for this pod.
       *
       * Use the host's network namespace.
       * If this option is set, the ports that will be used must be specified. Default to false.
       */
      hostNetwork?: boolean;
      /**
       * Use the host's pid namespace.
       * @defaultValue false
       */
      hostPID: boolean;
      /**
       * Specifies the hostname of the Pod.
       *
       * If not specified, the pod's hostname will be set to a system-defined value.
       */
      hostname?: string;
      /**
       * List of references to secrets in the same namespace to use for pulling any of the images used by this PodSpec.
       *
       * If specified, these secrets will be passed to individual puller implementations for them to use.
       * For example, in the case of docker, only DockerConfig type secrets are honored.
       * More info: {@link https://kubernetes.io/docs/concepts/containers/images#specifying-imagepullsecrets-on-a-pod}
       */
      imagePullSecrets?: LocalObjectReference[];
      /**
       * A request to schedule this pod onto a specific node.
       *
       * If it is non-empty, the scheduler simply schedules this pod onto that node,
       * assuming that it fits resource requirements.
       */
      nodeName?: string;
      /**
       * A selector which must be true for the pod to fit on a node.
       *
       * Selector which must match a node's labels for the pod to be scheduled on that node.
       * More info: {@link https://kubernetes.io/docs/concepts/configuration/assign-pod-node/}
       */
      nodeSelector?: {
          [label: string]: boolean | string;
      };
      /**
       * Overhead represents the resource overhead associated with running a pod for a given RuntimeClass.
       *
       * This field will be autopopulated at admission time by the RuntimeClass admission controller.
       * If the RuntimeClass admission controller is enabled, overhead must not be set in Pod create requests.
       * The RuntimeClass admission controller will reject Pod create requests which have the overhead already set.
       * If RuntimeClass is configured and selected in the PodSpec, Overhead will be set to the value defined in
       * the corresponding RuntimeClass, otherwise it will remain unset and treated as zero.
       *
       * More info: {@link https://git.k8s.io/enhancements/keps/sig-node/20190226-pod-overhead.md}
       *
       * This field is alpha-level as of Kubernetes v1.16, and is only honored by servers that enable
       * the PodOverhead feature.
       * @alpha
       */
      overhead?: unknown;
      /**
       * PreemptionPolicy is the Policy for preempting pods with lower priority.
       *
       * This field is beta-level, gated by the NonPreemptingPriority feature-gate.
       *
       * @defaultValue PreemptLowerPriority
       * @beta
       */
      preemptionPolicy?: "Never" | "PreemptLowerPriority";
      /**
       * The priority various system components use this field to find the priority of the pod.
       *
       * When Priority Admission Controller is enabled, it prevents users from setting this field.
       * The admission controller populates this field from PriorityClassName.
       * The higher the value, the higher the priority.
       */
      priority?: number;
      /**
       * If specified, indicates the pod's priority.
       *
       * "system-node-critical" and "system-cluster-critical" are two special keywords which indicate the highest
       * priorities with the former being the highest priority. Any other name must be defined by creating a PriorityClass
       * object with that name. If not specified, the pod priority will be default or zero if there is no default.
       */
      priorityClassName?: string;
      /**
       *  If specified, all readiness gates will be evaluated for pod readiness.
       *
       *  A pod is ready when all its containers are ready AND all conditions specified
       *  in the readiness gates have status equal to "True"
       *
       *  More info: {@link https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#pod-readiness-gate}
       */
      readinessGates?: PodReadinessGate[];
      /**
       * Restart policy for all containers within the pod.
       *
       * One of Always, OnFailure, Never. Default to Always.
       * More info: {@link https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy}
       *
       * @defaultValue Always
       */
      restartPolicy: "Always" | "OnFailure" | "Never";
      /**
       * Refers to a RuntimeClass object in the node.k8s.io group, which should be used to run this pod.
       *
       * If no RuntimeClass resource matches the named class, the pod will not be run.
       * If unset or empty, the "legacy" RuntimeClass will be used, which is an implicit
       * class with an empty definition that uses the default runtime handler.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/containers/runtime-class/}
       *
       * This is a beta feature as of Kubernetes v1.14.
       */
      runtimeClassName?: string;
      /**
       *  If specified, the pod will be dispatched by specified scheduler.
       *  If not specified, the pod will be dispatched by default scheduler.
       */
      schedulerName?: string;
      /**
       * SecurityContext holds pod-level security attributes and common container settings.
       * See type description for default values of each field.
       *
       * @defaultValue \{\}
       */
      securityContext: PodSecurityContext;
      /**
       * ServiceAccountName is the name of the ServiceAccount to use to run this pod.
       * More info: {@link https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/}
       */
      serviceAccountName?: string | Handle;
      /**
       * If true the pod's hostname will be configured as the pod's FQDN, rather than the leaf name (the default).
       * In Linux containers, this means setting the FQDN in the hostname field of the kernel
       * (the nodename field of struct utsname).
       * In Windows containers, this means setting the registry value of hostname for the registry key
       * HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters to FQDN.
       * If a pod does not have FQDN, this has no effect.
       *
       * @defaultValue false
       */
      setHostnameAsFQDN?: boolean;
      /**
       * Share a single process namespace between all of the containers in a pod.
       * When this is set containers will be able to view and signal processes from other containers in the same pod,
       * and the first process in each container will not be assigned PID 1.
       * HostPID and ShareProcessNamespace cannot both be set.
       *
       * @defaultValue false
       */
      shareProcessNamespace: boolean;
      /**
       *  If specified, the fully qualified Pod hostname will be "\<hostname\>.\<subdomain\>.\<pod namespace\>.svc.\<cluster domain\>".
       *  If not specified, the pod will not have a domainname at all.
       */
      subdomain?: string;
      /**
       * Optional duration in seconds the pod needs to terminate gracefully.
       *
       * May be decreased in delete request. Value must be non-negative integer.
       * The value zero indicates delete immediately. If this value is nil, the default
       * grace period will be used instead. The grace period is the duration in seconds
       * after the processes running in the pod are sent a termination signal and the time
       * when the processes are forcibly halted with a kill signal. Set this value longer
       * than the expected cleanup time for your process. Defaults to 30 seconds.
       */
      terminationGracePeriodSeconds?: number;
      /** If specified, the pod's tolerations. */
      tolerations?: Toleration[];
      /**
       *  TopologySpreadConstraints describes how a group of pods ought to spread across topology domains.
       *
       *  Scheduler will schedule pods in a way which abides by the constraints. All topologySpreadConstraints are ANDed.
       */
      topologySpreadConstraints?: TopologySpreadConstraint[];
      /**
       * List of volumes that can be mounted by containers belonging to the pod.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/storage/volumes}
       */
      volumes?: Volume[];
  }/**
   * Component for Kubernetes Pods
   *
   * @public
   */
  export declare class Pod extends DeferredComponent<PodProps, ResolvedVolumes & ResolvedServiceAccountName> {
      static defaultProps: {
          isTemplate: boolean;
          metadata: {};
          dnsPolicy: string;
          enableServiceLinks: boolean;
          hostIPC: boolean;
          hostPID: boolean;
          restartPolicy: string;
          securityContext: {};
          shareProcessNamespace: boolean;
          terminationGracePeriodSeconds: number;
      };
      initialState(): {};
      build(helpers: BuildHelpers): Adapt.JSX.Element | null;
      status(_observe: ObserveForStatus, buildData: BuildData): Promise<Adapt.Status | undefined>;
  }/**
   * Spec for for Kubernetes Pods
   *
   * @public
   */
  export declare interface PodSpec extends Omit<PodProps, "config" | "metadata" | "isTemplate"> {
      containers: ContainerSpec[];
      terminationGracePeriodSeconds?: number;
  }/** @internal */
  const podResourceInfo: {
      kind: string;
      deployedWhen: typeof deployedWhen;
      statusQuery: (props: ResourcePropsWithConfig, observe: ObserveForStatus, buildData: BuildData) => Promise<any>;
  };/**
   * k8s Secret resource
   *
   * @param propsIn - props for Secret as specifed in {@link k8s.SecretProps}
   *
   * @public
   */
  export declare function Secret(propsIn: SFCDeclProps<SecretProps, typeof defaultProps>): Adapt.JSX.Element;/** @internal */
  const secretResourceInfo: {
      kind: string;
      deployedWhen: () => true;
      statusQuery: (props: ResourcePropsWithConfig, observe: ObserveForStatus, buildData: BuildData) => Promise<any>;
      makeManifest: (manifest: Manifest, elem: AdaptElement<ResourceProps>, _deployID: string) => {
          data: {
              [key: string]: string;
          } | undefined;
          stringData: {
              [key: string]: string;
          } | undefined;
          type: string | undefined;
          apiVersion: string; /**
           * stringData allows specifying non-binary secret data in string form.
           *
           * It is provided as a write-only convenience method. All keys and values are merged into the data field on write,
           * overwriting any existing values. It is never output when reading from the API.
           */
          kind: string;
          metadata: import("./manifest_support").MetadataInRequest;
          spec?: import("./DaemonSet").DaemonSetSpec | import("./common").CRSpec | import("./Pod").PodSpec | import("./Service").ServiceSpec | import("./Deployment").DeploymentSpec | undefined;
      };
  };/**
   * Convert {@link NetworkService} props to {@link k8s.Service} props
   * @param abstractProps - props to convert
   * @returns Kubernetes spec corresponding to `abstractProps`
   *
   * @internal
   */
  export declare function k8sServiceProps(abstractProps: NetworkServiceProps & BuiltinProps): Omit<ServiceProps, keyof ResourceBase>;/**
   * Native Kubernetes Service resource
   *
   * @remarks
   *
   * Implements the {@link NetworkServiceInstance} interface.
   *
   * @public
   */
  export declare function Service(propsIn: SFCDeclProps<ServiceProps, typeof defaultProps>): Adapt.JSX.Element;/** @public */
  export declare interface ServiceProps extends ServiceSpec {
      /** Legal configuration loaded from kubeconfig */
      config: ClusterInfo;
      metadata?: Metadata;
      selector?: Handle | EndpointSelector;
  }/** @public */
  export declare interface ServiceSpec {
      /**
       * Cluster IP for a {@link k8s.Service}
       *
       * @remarks
       * `clusterIP` is the IP address of the service and is usually assigned
       * randomly by the master. If an address is specified manually and is not
       * in use by others, it will be allocated to the service; otherwise,
       * creation of the service will fail. This field can not be changed through
       * updates. Valid values are "None", empty string (""), or a valid IP
       * address. "None" can be specified for headless services when proxying is
       * not required. Only applies to types ClusterIP, NodePort, and
       * LoadBalancer. Ignored if type is ExternalName.
       *
       * For more information, see the
       * {@link https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies |
       * Kubernetes documentation}.
       */
      clusterIP?: string;
      /**
       * A list of IP addresses for which nodes in the cluster
       * will also accept traffic for this service.
       *
       * @remarks
       * These IPs are not managed by
       * Kubernetes. The user is responsible for ensuring that traffic arrives at
       * a node with this IP. A common example is external load balancers that are
       * not part of the Kubernetes system.
       */
      externalIPs?: string[];
      /**
       * The external reference that kubedns or equivalent
       * will return as a CNAME record for this service.
       *
       * @remarks
       * No proxying will be involved. Must be a
       * {@link https://tools.ietf.org/html/rfc1123 | valid RFC-1123 hostname}
       * and requires Type to be ExternalName.
       */
      externalName?: string;
      /**
       * Denotes if this Service desires to route
       * external traffic to node-local or cluster-wide endpoints.
       *
       * @remarks
       * "Local" preserves the client source IP and avoids a second hop for
       * LoadBalancer and Nodeport type services, but risks potentially
       * imbalanced traffic spreading. "Cluster" obscures the client source IP
       * and may cause a second hop to another node, but should have good overall
       * load-spreading.
       */
      externalTrafficPolicy?: string;
      /**
       * Specifies the healthcheck nodePort for the service.
       *
       * @remarks
       * If not specified, HealthCheckNodePort is created by the service
       * api backend with the allocated nodePort. Will use user-specified nodePort
       * value if specified by the client. Only affects when Type is set to
       * LoadBalancer and ExternalTrafficPolicy is set to Local.
       */
      healthCheckNodePort?: number;
      /**
       * Only applies to Service Type: LoadBalancer. LoadBalancer will
       * get created with the IP specified in this field.
       *
       * @remarks
       * This feature depends on
       * whether the underlying cloud provider supports specifying the loadBalancerIP
       * when a load balancer is created. This field will be ignored if the
       * cloud provider does not support the feature.
       */
      loadBalancerIP?: string;
      /**
       * If specified and supported by the platform, this will
       * restrict traffic through the cloud provider load balancer
       * to the specified client IPs.
       *
       * @remarks
       * This field will be ignored if the cloud provider
       * does not support the feature.
       *
       * For more information, see the
       * {@link https://v1-17.docs.kubernetes.io/docs/tasks/access-application-cluster/configure-cloud-provider-firewall/ |
       * Kubernetes documentation}.
       */
      loadBalancerSourceRanges?: string[];
      /**
       * The list of ports that are exposed by this service.
       *
       * @remarks
       * For more information, see the
       * {@link https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies |
       * Kubernetes documentation}.
       */
      ports?: ServicePort[];
      /**
       * When set to true, indicates that
       * DNS implementations must publish the notReadyAddresses of subsets for the
       * Endpoints associated with the Service.
       *
       * @remarks
       * The default value is false. The
       * primary use case for setting this field is to use a StatefulSet's Headless
       * Service to propagate SRV records for its Pods without respect to their
       * readiness for purpose of peer discovery.
       */
      publishNotReadyAddresses?: boolean;
      /**
       * Route service traffic to pods with label keys and values
       * matching this selector.
       *
       * @remarks
       * If empty or not present, the service is assumed to
       * have an external process managing its endpoints, which Kubernetes will not
       * modify. Only applies to types ClusterIP, NodePort, and LoadBalancer.
       * Ignored if type is ExternalName.
       *
       * For more information, see the
       * {@link https://kubernetes.io/docs/concepts/services-networking/service/ |
       * Kubernetes documentation}.
       */
      selector?: EndpointSelector | object;
      /**
       * Used to maintain session affinity.
       *
       * @remarks
       * Possible values are:
       *
       * - `"ClientIP"`: Enables client IP based session affinity.
       *
       * - `"None"`: Disables session affinity.
       *
       * For more information, see the
       * {@link https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies |
       * Kubernetes documentation}.
       * @defaultValue `"None"`
       */
      sessionAffinity?: string;
      /**
       * Determines how the Service is exposed.
       *
       * @remarks
       * Valid options are:
       *
       * - `"ExternalName"`: maps to the specified externalName.
       *
       * - `"ClusterIP"`: allocates a cluster-internal IP address for load
       * balancing to endpoints. Endpoints are determined by the selector or if
       * that is not specified, by manual construction of an Endpoints object. If
       * clusterIP is "None", no virtual IP is allocated and the endpoints are
       * published as a set of endpoints rather than a stable IP.
       *
       * - `"NodePort"`: Builds on ClusterIP and allocates a port on every node
       * which routes to the clusterIP.
       *
       * - `"LoadBalancer"`: Builds on NodePort and creates an external load
       * balancer (if supported in the current cloud) which routes to the
       * clusterIP.
       *
       * For more information, see the
       * {@link https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services---service-types |
       * Kubernetes documentation}.
       * @defaultValue `"ClusterIP"`
       */
      type?: string;
  }/** @public */
  export declare interface ServicePort {
      /**
       * The name of this port within the service.
       *
       * @remarks
       * This must be a DNS_LABEL.
       * All ports within a ServiceSpec must have unique names.This maps to the
       * Name' field in EndpointPort objects. Optional if only one ServicePort is
       * defined on this service.
       */
      name?: string;
      /**
       * The port on each node on which this service is exposed when
       * type=NodePort or LoadBalancer.
       *
       * @remarks
       * Usually assigned by the system. If
       * specified, it will be allocated to the service if unused or else creation
       * of the service will fail.
       *
       * For more information, see the
       * {@link https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport |
       * Kubernetes documentation}.
       * @defaultValue Automatically allocates a port if the ServiceType of this
       * Service requires one.
       */
      nodePort?: number;
      /** The port that will be exposed by this service. */
      port?: number;
      /** The IP protocol for this port.Supports "TCP" and "UDP".Default is TCP. */
      protocol?: string;
      /**
       * Number or name of the port to access on the pods targeted by the
       * service.
       *
       * @remarks
       * Number must be in the range 1 to 65535. Name must be an
       * IANA_SVC_NAME. If this is a string, it will be looked up as a named port
       * in the target Pod's container ports. If this is not specified, the value
       * of the 'port' field is used (an identity map). This field is ignored for
       * services with clusterIP = None, and should be omitted or set equal to the
       * 'port' field.
       *
       * For more information, see the
       * {@link https://kubernetes.io/docs/concepts/services-networking/service/#defining-a-service |
       * Kubernetes documentation}.
       */
      targetPort?: number | string;
  }/** @internal */
  const serviceResourceInfo: {
      kind: string;
      deployedWhen: typeof deployedWhen;
      statusQuery: (props: ResourcePropsWithConfig, observe: ObserveForStatus, buildData: BuildData) => Promise<any>;
  };/**
   * k8s ServiceAccount resource
   *
   * @param propsIn - props for ServiceAccount as specifed in {@link k8s.ServiceAccountProps}
   *
   * @public
   */
  export declare function ServiceAccount(propsIn: SFCDeclProps<ServiceAccountProps, typeof defaultProps>): Adapt.JSX.Element;/** @public */
  export declare function isServiceAccountProps(p: ResourceProps): p is ResourceProps & ResourceServiceAccount;/** @internal */
  const serviceAccountResourceInfo: {
      kind: string;
      deployedWhen: () => true;
      statusQuery: (props: ResourcePropsWithConfig, observe: ObserveForStatus, buildData: BuildData) => Promise<any>;
      makeManifest: (manifest: Manifest, elem: AdaptElement<ResourceProps>, _deployID: string) => {
          automountServiceAccountToken: boolean | undefined;
          imagePullSecrets: {
              name: string;
          }[] | undefined;
          secrets: ObjectReference[] | undefined;
          apiVersion: string;
          kind: string;
          metadata: import("./manifest_support").MetadataInRequest;
          spec?: import("./DaemonSet").DaemonSetSpec | import("./common").CRSpec | import("./Pod").PodSpec | import("./Service").ServiceSpec | import("./Deployment").DeploymentSpec | undefined;
      };
  };/**
   * Props for {@link k8s.ServiceDeployment}
   *
   * @public
   */
  export declare interface ServiceDeploymentProps<T extends AllowableComponentProps = DeploymentProps> extends ServiceProps {
      config: ClusterInfo;
      serviceProps?: Partial<ServiceProps>;
      component: ComponentType<T>;
      componentProps: T;
      podProps?: Partial<PodProps>;
      containerProps?: Partial<OmitT<K8sContainerProps, "image">>;
  }/**
   * A component for mapping a group of abstract {@link Container}s and
   * {@link NetworkService}s to Kubernetes {@link k8s.Pod}s and
   * {@link k8s.K8sContainer}s.
   *
   * @remarks
   * This component is intended to be used to replace {@link Container} and
   * {@link NetworkService} components that are grouped together, as the
   * only children of a common parent in a pattern that looks like this:
   *
   * ```tsx
   * <Service>
   *   <Container ... />
   *   <Container ... />
   *   <NetworkService ... />
   * </Service>
   * ```
   *
   * `ServiceDeployment` would map those abstract components into corresponding
   * k8s components like this:
   * ```tsx
   * <Group>
   *   <docker.RegistryDockerImage ... /> //If props.config specifies a registry
   *   <k8s.Deployment ... >
   *     <Pod isTemplate>
   *       <k8s.K8sContainer ... />
   *     </Pod>
   *   </k8s.Deployment>
   *   <docker.RegistryDockerImage ... /> //If props.config specifies a registry
   *   <k8s.Deployment ... >
   *     <Pod isTemplate>
   *       <k8s.K8sContainer ... />
   *     </Pod>
   *   </k8s.Pod>
   *   <k8s.Service ... />
   * </Group>
   * ```
   * An example style rule to do this is:
   * ```tsx
   * {Adapt.rule((matchedProps) => {
   *     const { handle, ...remainingProps } = matchedProps;
   *     return <ServiceDeployment config={kubeconfig} {...remainingProps} />;
   * })}
   * ```
   * `ServiceDeployment` also requires the `config` prop which specifies
   * connection and authentication information for the Kubernetes cluster on
   * which these objects should be created.
   *
   * @public
   */
  export declare class ServiceDeployment<T extends AllowableComponentProps> extends DeferredComponent<ServiceDeploymentProps<T>> {
      static defaultProps: {
          component: typeof Deployment;
          componentProps: {
              replicas: number;
          };
      };
      build(helpers: BuildHelpers): Adapt.JSX.Element;
  }/** @public */
  export declare function computeNamespaceFromMetadata(metadata?: Metadata): string;/** @public */
  export declare function isLabelSelector(x: any): x is LabelSelector;/**
   * Kubernetes Kind
   *
   * @public
   */
  export declare type Kind = string;/** @public */
  export declare interface CRSpec {
      [key: string]: any;
  }/** @public */
  export declare type Spec = DaemonSetSpec | DeploymentSpec | PodSpec | ServiceSpec | CRSpec;/** @public */
  export declare interface Metadata {
      namespace?: string;
      labels?: {
          [key: string]: string;
      };
      annotations?: {
          [key: string]: string;
      };
  }/** @public */
  export declare type ResourceProps = {
      key: string;
  } & (ResourceClusterRole | ResourceClusterRoleBinding | ResourceDaemonSet | ResourcePod | ResourceService | ResourceServiceAccount | ResourceConfigMap | ResourceSecret | ResourceCR);/** @public */
  export declare type ResourcePropsWithConfig = ResourceProps & {
      config: ClusterInfo;
  };/** @public */
  export declare interface ResourceInfo {
      kind: Kind;
      statusQuery?: (props: ResourceProps, observe: ObserveForStatus, buildData: BuildData) => unknown | Promise<unknown>;
      specsEqual(actual: Spec, element: Spec): boolean;
  }/**
   * Holds the information needed to connect, authenticate, and run code in a kuberenetes cluster
   *
   * @public
   */
  export declare interface ClusterInfo {
      /** Javascript object formed by parsing a valid kubeconfig file */
      kubeconfig: Kubeconfig;
      /**
       * Registry to which Docker images used by the cluster in `kubeconfig` should be pushed and pulled
       *
       * @remarks
       * If `registryPrefix` is a string, it is assumed that the cluster can pull from the same string
       * that outsiders can push to.
       *
       * If `registryPrefix` is of the form `{ external: string, internal: string }` then the `external`
       * string will be used to push images, and the `internal` string will be used to pull images.
       *
       * Note(manishv)
       * This is a bit of a hack to allow one hostname or IP address to push images from outside
       * a particular environment (say k8s) and a different URL for that environment to pull
       * images.
       *
       * A good example of this is a k3s-dind (k3s docker-in-docker) instance of kubernetes where
       * a private registry is running on a docker network attached to the k3s-dind instance, but where we
       * want to push {@link docker.LocalDockerImage} built images to that registry.  Since
       * {@link docker.LocalDockerImage | LocalDockerImage} is outside the k3s-dind environment, it must
       * use a host accessible network to push to the registry.  However, since the k3s-dind instance sees
       * the registry from within Docker, it must use a different address to pull the images for use.
       *
       * Once network scopes are fully supported, this interface will change to whatever is appropriate.  It
       * is best if you can arrange to have the same URL or registry string work for all access regardless
       * of which network the registry, Adapt host, and ultimate container running environment uses.
       *
       */
      registryPrefix?: string | DockerSplitRegistryInfo;
  }/** @public */
  export declare interface ResourceBase {
      /**
       * config to connect to the k8s cluster
       *
       * required if isTemplate is false
       */
      config?: ClusterInfo;
      /**
       * Specifies whether this resource is just a template for use in a controller
       */
      isTemplate?: boolean;
      apiVersion?: string;
      kind: Kind;
      metadata?: Metadata;
  }/**
   * @public
   */
  export declare interface PolicyRule {
      /**
       * APIGroups is the name of the APIGroup that contains the resources.
       *
       * If multiple API groups are specified, any action requested against one
       * of the enumerated resources in any API group will be allowed.
       */
      apiGroups?: string[];
      /**
       * NonResourceURLs is a set of partial urls that a user should have access to.
       *
       * *s are allowed, but only as the full, final step in the path.
       * Since non-resource URLs are not namespaced, this field is only applicable
       * for ClusterRoles referenced from a ClusterRoleBinding.
       * Rules can either apply to API resources (such as "pods" or "secrets") or
       * non-resource URL paths (such as "/api"), but not both.
       */
      nonResourceURLs?: string[];
      /**
       * ResourceNames is an optional white list of names that the rule applies to.
       *
       * An empty set means that everything is allowed.
       */
      resourceNames?: string[];
      /**
       * Resources is a list of resources this rule applies to.
       *
       * ResourceAll represents all resources.
       */
      resources: string[];
      /**
       * Verbs is a list of Verbs that apply to ALL the ResourceKinds and
       * AttributeRestrictions contained in this rule.
       *
       * VerbAll represents all kinds.
       */
      verbs: string[];
  }/**
   * AggregationRule for {@link k8s.ClusterRole}
   *
   * @public
   */
  export declare interface AggregationRule {
      /**
       * ClusterRoleSelectors holds a list of selectors which will be used to
       * find ClusterRoles and create the rules.
       *
       * If any of the selectors match, then the ClusterRole's permissions will be added
       */
      clusterRoleSelector: LabelSelector;
  }/** @public */
  export declare interface ResourceClusterRole extends ResourceBase {
      apiVersion: "rbac.authorization.k8s.io/v1";
      kind: "ClusterRole";
      aggregationRule?: AggregationRule;
      rules?: PolicyRule[];
  }/**
   * RoleRef for {@link k8s.ResourceClusterRoleBinding}
   *
   * @public
   */
  export declare interface RoleRef {
      /** apiGroup is the group for the resource being referenced */
      apiGroup: string;
      /** kind is the type of resource being referenced */
      kind: string;
      /** Name is the name of resource being referenced */
      name: string;
  }/**
   * Subject for {@link k8s.ResourceClusterRoleBinding}
   *
   * @public
   */
  export declare interface Subject {
      /** apiGroup is the group for the object being referenced */
      apiGroup: string;
      /** kind is the type of object being referenced */
      kind: string;
      /**
       * Name of the object being referenced.
       */
      name: string;
      /**
       * Namespace of the referenced object.
       *
       * If the object kind is non-namespace, such as "User" or "Group", and this value
       * is not empty the Authorizer should report an error.
       */
      namespace?: string;
  }/** @public */
  export declare interface ResourceClusterRoleBinding extends ResourceBase {
      apiVersion: "rbac.authorization.k8s.io/v1";
      kind: "ClusterRoleBinding";
      roleRef: RoleRef;
      subjects: Subject[];
  }/** @public */
  export declare interface ResourceDaemonSet extends ResourceBase {
      apiVersion: "apps/v1";
      kind: "DaemonSet";
      spec: DaemonSetSpec;
  }/** @public */
  export declare interface ResourcePod extends ResourceBase {
      kind: "Pod";
      spec: PodSpec;
  }/** @public */
  export declare interface ResourceService extends ResourceBase {
      kind: "Service";
      spec: ServiceSpec;
  }/** @public */
  export declare interface ResourceServiceAccount extends ResourceBase {
      kind: "ServiceAccount";
      automountServiceAccountToken?: boolean;
      imagePullSecrets?: {
          name: string;
      }[];
      secrets?: ObjectReference[];
  }/** @public */
  export declare interface ResourceConfigMap extends ResourceBase {
      kind: "ConfigMap";
      binaryData?: {
          [key: string]: string;
      };
      data?: {
          [key: string]: string;
      };
      /** @beta */
      immutable?: boolean;
  }/** @public */
  export declare interface ResourceSecret extends ResourceBase {
      kind: "Secret";
      data?: {
          [key: string]: string;
      };
      stringData?: {
          [key: string]: string;
      };
      type?: string;
  }/** @public */
  export declare interface ResourceCR extends ResourceBase {
      kind: string;
      spec: CRSpec;
  }/** @public */
  export declare interface Kubeconfig {
      apiVersion?: "v1";
      kind: "Config";
      "current-context": string;
      contexts: {
          name: string;
          context: {
              cluster: string;
              user: string;
          };
      }[];
      clusters: {
          name: string;
          cluster: {
              "certificate-authority-data": string;
              server: string;
          };
      }[];
      preferences?: unknown;
      users: {
          name: string;
          user: {
              "client-certificate-data"?: string;
              "client-key-data"?: string;
              "username"?: string;
              "password"?: string;
          };
      }[];
  }/** @public */
  export declare interface LabelSelector {
      /**
       * matchExpressions is a list of label selector requirements. The requirements are ANDed.
       */
      matchExpressions?: LabelSelectorRequirement[];
      /**
       * matchLabels is a map of `{key,value}`pairs. A single `{key,value}` in the matchLabels map
       * is equivalent to an element of matchExpressions, whose key field is "key", the operator
       * is "In", and the values array contains only "value". The requirements are ANDed.
       */
      matchLabels?: {
          [key: string]: string;
      };
  }/** @public */
  export declare interface LocalObjectReference {
      /**
       * Name of the referent.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names}
       */
      name: string;
  }/**
   * PodTemplateSpec from k8s API
   *
   * @public
   */
  export declare interface PodTemplateSpec {
      /**
       * Standard object's metadata.
       * More Info: {@link https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata}
       */
      metadata: Metadata;
      /**
       * Specification of the desired behavior of the pod.
       * More Info: {@link https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status}
       */
      spec: PodSpec;
  }/**
   * ObjectReference from k8s API
   *
   * @public
   */
  export declare interface ObjectReference {
      /**
       * If referring to a piece of an object instead of an entire object,
       * this string should contain a valid JSON/Go field access statement,
       * such as desiredState.manifest.containers[2].
       *
       * For example, if the object reference is to a container within a pod,
       * this would take on a value like: "spec.containers\{name\}" (where "name"
       * refers to the name of the container that triggered the event) or if no
       * container name is specified "spec.containers[2]"
       * (container with index 2 in this pod).
       * This syntax is chosen only to have some well-defined way of referencing a
       * part of an object.
       */
      fieldPath: string;
      /**
       * Name of the referent.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names}
       *
       */
      name: string;
      /**
       * Namespace of the referent.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/}
       */
      namespace: string;
      /**
       * Specific resourceVersion to which this reference is made, if any.
       *
       * More info: {@link https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency}
       */
      resourceVersion: string;
      /**
       * UID of the referent.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids}
       */
      uid: string;
  }/**
   * Make a {@link k8s.ClusterInfo} object suitable for use with k8s resources
   *
   * @remarks
   *
   * This function will take a set of options and generate a {@link k8s.ClusterInfo}
   * object that contains the kubeconfig, registryPrefix for private images, and any other
   * relevant information for the cluster
   *
   * See {@link k8s.MakeClusterInfoOptions} for information on how the information
   * is computed.
   *
   * @returns A {@link k8s.ClusterInfo} object.
   *
   * @public
   */
  export declare function makeClusterInfo(options: MakeClusterInfoOptions): Promise<ClusterInfo>;/** @internal */
  export declare function isResourcePodTemplate(x: any): x is AdaptElement<ResourcePod>;/**
   * Hook that allows a prop to be either an array of handle to k8s resources and values
   *
   * @param initial - initial value of the prop, before the handles are be resolved
   * @param notReady - is a marker value to indicate that a handle's value isn't available yet
   * @param kinds - an array of legal k8s Kinds that a prop handle can point to
   * @param thisResourceName - the name of the resource using the hook, for error messages
   * @param propName - the name of the prop being resolved, again for error messages
   *
   * @returns A two element array, the first element is the current value, the second the update function
   *
   * This hook will start by returning the initial value and an update function that updates
   * the value the hook returns.  The update function takes 2 arguments - the prop value which
   * is an array with a mix of values and handles to be resolved, and a function that receives
   * the elements that any handles point to along with that elements props.  This function
   * can be passed by the caller of update to resolve handles as appropriate for the component.
   *
   * For example, {@link k8s.ClusterRoleBinding} uses this hook to resolve the subjects prop,
   * which is an array of other objects (typically {@link ServiceAccount}) that a particular
   * {@link k8s.ClusterRole} should point to.  When ClusterRoleBinding calls the update method,
   * it passes a function that will convert a {@link k8s.Resource} element of Kind `ServiceAccount`
   * to the underlying `Subject` object that kubernetes expects, namely
   * `{ apiGroup: "", kind: "ServiceAccount", name: resourceIdToName(elem, deployID), namespace: <element namespace> }`
   *
   * @example
   * ```
   * function MyResource({ serviceAccountNames }: { serviceAccountNames: (string | Handle)[]}) {
   *   const { deployID } = useBuildHelpers();
   *   const [ resolvedServiceAccountNames, updateSANs] = useResources({
   *      initial: [],
   *      notReady: null,
   *      kinds: ["ServiceAccount"],
   *      thisResourceName: "MyResources",
   *      propName: "serviceAccountNames",
   *   });
   *
   *   updateSANs(serviceAccountNames, (e, props) => {
   *      return {
   *        apiGroup: (e.metadata.apiVersion?.split("/")[0]) || "",
   *        name: resourceElementToName(e, deployID),
   *        namespace: props.metadata.namespace,
   *      }
   *   });
   *
   *   return null;
   * }
   * ```
   *
   * @beta
   */
  export declare function useResources<ValT, NotReadyT>({ initial, notReady, kinds, thisResourceName, propName, }: {
      initial: ValT[];
      notReady: NotReadyT;
      kinds: string[];
      thisResourceName: string;
      propName: string;
  }): [
      (ValT | NotReadyT)[],
      (props: (ValT | Handle)[], f: (e: AdaptMountedElement, props: ResourceProps) => Promise<ValT> | ValT) => void
  ];/**
   * Hook to allow conversion of a prop that could be a value or a handle
   *
   * This function behaves similarly to {@link k8s.useResources}, but works for
   * a prop that is either a Handle or a single value instead of an array of
   * Handles and values.
   *
   * See {@link k8s.useResources} for more detailed documentation.
   *
   * @beta
   */
  export declare function useResource<ValT, NotReadyT>(opts: {
      initial: ValT | NotReadyT;
      notReady: NotReadyT;
      kinds: string[];
      thisResourceName: string;
      propName: string;
  }): [
      ValT | NotReadyT,
      (prop: ValT | Handle, f: (e: AdaptMountedElement, props: ResourceProps) => Promise<ValT> | ValT) => void
  ];/**
   * Options for {@link k8s.makeClusterInfo}
   *
   * @public
   */
  export declare interface MakeClusterInfoOptions {
      /**
       * A Javascript Object representing a valid kubeconfig, or a YAML string, or a path to a kubeconfig file.
       *
       * @remarks
       * If this is a Javascript object, it will be treated like a parsed kubeconfig.  If this is a string,
       * {@link k8s.makeClusterInfo} will first attempt to parse it as JSON.  If that fails, it will attempt
       * to parse it as YAML.  If that fails it will treat the string as a path of configs (like with the `KUBECONFIG`
       * environment variable).
       *
       * If kubeconfig is missing {@link k8s.makeClusterInfo} will use the `KUBECONFIG` environment variable to build
       * a suitable config using `kubectl config view --flatten` and return that as the kubeconfig in the resulting
       * {@link k8s.ClusterInfo}
       */
      kubeconfig?: Kubeconfig | string;
      /**
       * URL to the docker registry that this cluster uses to pull private images.
       *
       * @remarks
       * This is identical to the `registryPrefix` field in {@link k8s.ClusterInfo}.  It will
       * be returned verbatim in the resulting {@link k8s.ClusterInfo} object.
       */
      registryPrefix?: string | DockerSplitRegistryInfo;
  }/**
   * k8s ClusterRole resource
   *
   * @param propsIn - props for ServiceAccount as specifed in {@link k8s.ClusterRoleProps}
   *
   * @public
   */
  export declare function ClusterRole(propsIn: SFCDeclProps<ClusterRoleProps, typeof defaultProps>): Adapt.JSX.Element;/** @public */
  export declare function isClusterRoleProps(props: ResourceProps): props is ResourceProps & ResourceClusterRole;/** @internal */
  const clusterRoleResourceInfo: {
      kind: string;
      deployedWhen: () => true;
      statusQuery: (props: ResourcePropsWithConfig, observe: ObserveForStatus, buildData: BuildData) => Promise<any>;
      makeManifest: (manifest: Manifest, elem: AdaptElement<ResourceProps>, _deployID: string) => {
          aggregationRule: AggregationRule | undefined;
          rules: PolicyRule[] | undefined;
          apiVersion: string;
          kind: string;
          metadata: import("./manifest_support").MetadataInRequest;
          spec?: import("./DaemonSet").DaemonSetSpec | import("./common").CRSpec | import("./Pod").PodSpec | import("./Service").ServiceSpec | import("./Deployment").DeploymentSpec | undefined;
      };
  };/**
   * k8s ClusterRoleBinding resource
   *
   * @param propsIn - props for ServiceAccount as specifed in {@link k8s.ClusterRoleBindingProps}
   *
   * @public
   */
  export declare function ClusterRoleBinding(propsIn: SFCDeclProps<ClusterRoleBindingProps, typeof defaultProps>): Adapt.JSX.Element | null;/** @internal */
  const clusterRoleBindingResourceInfo: {
      kind: string;
      deployedWhen: () => true;
      statusQuery: (props: ResourcePropsWithConfig, observe: ObserveForStatus, buildData: BuildData) => Promise<any>;
      makeManifest: (manifest: Manifest, elem: AdaptElement<ResourceProps>, _deployID: string) => {
          roleRef: RoleRef;
          subjects: Subject[];
          apiVersion: string;
          kind: string;
          metadata: import("./manifest_support").MetadataInRequest;
          spec?: import("./DaemonSet").DaemonSetSpec | import("./common").CRSpec | import("./Pod").PodSpec | import("./Service").ServiceSpec | import("./Deployment").DeploymentSpec | undefined;
      };
  };/**
   * k8s ConfigMap resource
   *
   * @param propsIn - props for ConfigMap as specifed in {@link k8s.ConfigMapProps}
   *
   * @public
   */
  export declare function ConfigMap(propsIn: SFCDeclProps<ConfigMapProps, typeof defaultProps>): Adapt.JSX.Element;/** @internal */
  const configMapResourceInfo: {
      kind: string;
      deployedWhen: () => true;
      statusQuery: (props: ResourcePropsWithConfig, observe: ObserveForStatus, buildData: BuildData) => Promise<any>;
      makeManifest: (manifest: Manifest, elem: AdaptElement<ResourceProps>, _deployID: string) => {
          data: {
              [key: string]: string;
          } | undefined;
          binaryData: {
              [key: string]: string;
          } | undefined;
          immutable: boolean | undefined;
          apiVersion: string;
          kind: string;
          metadata: import("./manifest_support").MetadataInRequest;
          spec?: import("./DaemonSet").DaemonSetSpec | import("./common").CRSpec | import("./Pod").PodSpec | import("./Service").ServiceSpec | import("./Deployment").DeploymentSpec | undefined;
      };
  };/**
   * Low level utility function to translate from the abstract {@link Container}
   * component props ({@link ContainerProps}) to {@link k8s.K8sContainerProps}
   * to be used in a {@link k8s.K8sContainer}.
   * @remarks
   * Note: The `image` property in the passed in {@link ContainerProps} must
   * be a `string`, not a `Handle`.
   * In most cases, it is preferable to use the {@link k8s.Container} component
   * instead, which is designed specifically to deal with this issue.
   *
   * @param abstractProps - The abstract {@link ContainerProps} to translate from.
   * @param k8sProps - Props that are specific to the {@link k8s.K8sContainer}
   *     component that should be merged into the resulting returned
   *     {@link k8s.K8sContainerProps} object.
   * @public
   */
  export declare function k8sContainerProps(abstractProps: FromContainerProps, k8sProps?: Partial<K8sContainerProps>): K8sContainerProps;/**
   * Tests whether an element is a {@link k8s.K8sContainer} element
   * @param x - element to test
   * @returns `true` if element is a {@link k8s.K8sContainer}, `false` otherwise
   *
   * @remarks
   * Acts as a TypeScript type assertion that will assert that `x` is `AdaptElement<K8sContainerProps>`
   *
   * @public
   */
  export declare function isK8sContainerElement(x: AdaptElement): x is AdaptElement<K8sContainerProps>;/**
   * Component that implements the abstract {@link Container} interface and
   * translates to a Kubernetes-specific {@link k8s.K8sContainer}.
   * @public
   */
  export declare function Container(props: ContainerProps): Adapt.JSX.Element | null;/** @public */
  export declare interface VolumeMount {
      /**
       * Path within the container at which the volume should be mounted.
       *
       * Must not contain ':'.
       */
      mountPath: string;
      /**
       * mountPropagation determines how mounts are propagated from the host to container and the other way around.
       *
       * When not set, MountPropagationNone is used. This field is beta in 1.10.
       *
       * @defaultValue MountPropagationNone
       */
      mountPropagation?: string;
      /** This must match the Name of a Volume. */
      name: string;
      /**
       * Mounted read-only if true, read-write otherwise (false or unspecified).
       *
       * @defaultValue false
       */
      readOnly?: boolean;
      /**
       * Path within the volume from which the container's volume should be mounted.
       *
       * Defaults to "" (volume's root).
       *
       * @defaultValue ""
       */
      subPath?: string;
      /**
       * Expanded path within the volume from which the container's volume should be mounted.
       *
       * Behaves similarly to SubPath but environment variable references $(VAR_NAME)
       * are expanded using the container's environment.
       *
       * Defaults to "" (volume's root).
       *
       * SubPathExpr and SubPath are mutually exclusive.
       *
       * @defaultValue ""
       */
      subPathExpr?: string;
  }/** @public */
  export declare interface ConfigMapEnvSource {
      /**
       * Name of the referent.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names}
       */
      name?: string;
      /**
       * Specify whether the ConfigMap must be defined
       */
      optional?: boolean;
  }/** @public */
  export declare interface SecretEnvSource {
      /**
       * Name of the referent.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names}
       */
      name?: string;
      /**
       * Specify whether the Secret must be defined
       */
      optional?: boolean;
  }/** @public */
  export declare interface EnvFromSource {
      /** The ConfigMap to select from */
      configMapRef?: ConfigMapEnvSource;
      /** An optional identifier to prepend to each key in the ConfigMap. Must be a C_IDENTIFIER. */
      prefix?: string;
      /** SecretEnvSource	The Secret to select from */
      secretRef?: SecretEnvSource;
  }/** @public */
  export declare interface ExecAction {
      /**
       * Command is the command line to execute inside the container.
       *
       * The working directory for the command is root ('/') in the container's filesystem.
       * The command is simply exec'd, it is not run inside a shell,
       * so traditional shell instructions ('|', etc) won't work.
       * To use a shell, you need to explicitly call out to that shell.
       *
       * Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
       */
      command: string[];
  }/** @public */
  export declare interface HTTPGetAction {
      /**
       * Host name to connect to, defaults to the pod IP.
       *
       * You probably want to set "Host" in httpHeaders instead.
       */
      host?: string;
      /** Custom headers to set in the request. HTTP allows repeated headers. */
      httpHeaders?: {
          name: string;
          value: string;
      }[];
      /** Path to access on the HTTP server. */
      path: string;
      /**
       * Name or number of the port to access on the container.
       *
       * Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
       */
      port: number | string;
      /**
       * Scheme to use for connecting to the host.
       *
       * @defaultValue HTTP.
       */
      scheme?: string;
  }/** @public */
  export declare interface TCPSocketAction {
      /** Host name to connect to, defaults to the pod IP. */
      host?: string;
      /**
       * Number or name of the port to access on the container.
       *
       * Number must be in the range 1 to 65535.
       * Name must be an IANA_SVC_NAME.
       */
      port: string | number;
  }/** @public */
  export declare interface Probe {
      /**
       * Exec specifies the action to take.
       *
       * Only one of exec, httpGet, or tcpSocket should be specified
       */
      exec?: ExecAction;
      /**
       * Minimum consecutive failures for the probe to be considered failed after having succeeded.
       *
       * Defaults to 3. Minimum value is 1.
       *
       * @defaultValue 3
       */
      failureThreshold?: number;
      /** Specifies the http request to perform. */
      httpGet?: HTTPGetAction;
      /**
       *  Seconds after the container has started before liveness probes are initiated.
       *  More info: {@link https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes}
       */
      initialDelaySeconds?: number;
      /** How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. */
      periodSeconds?: number;
      /**
       * Minimum consecutive successes for the probe to be considered successful after having failed.
       *
       * Must be 1 for liveness and startup. Minimum value is 1.
       *
       * @defaultValue 1
       */
      successThreshold?: number;
      /**
       * Specifies an action involving a TCP port.
       *
       * TCP hooks not yet supported
       */
      tcpSocket?: TCPSocketAction;
      /**
       * Number of seconds after which the probe times out.
       *
       * Defaults to 1 second. Minimum value is 1.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes}
       *
       * @defaultValue 1
       */
      timeoutSeconds?: number;
  }/** @public */
  export declare interface ResourceRequirements {
      /**
       * Limits describes the maximum amount of compute resources allowed.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/}
       */
      limits?: {
          [key: string]: any;
      };
      /**
       * Describes the minimum amount of compute resources required.
       *
       * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
       * otherwise to an implementation-defined value.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/}
       */
      requests?: {
          [key: string]: any;
      };
  }/** @public */
  export declare type Handler = {
      exec: ExecAction;
  } | {
      httpGet: HTTPGetAction;
  } | {
      tcpSocket: TCPSocketAction;
  };/** @public */
  export declare interface Lifecycle {
      /**
       * PostStart is called immediately after a container is created.
       *
       * If the handler fails, the container is terminated and restarted according to its restart policy.
       * Other management of the container blocks until the hook completes.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks}
       */
      postStart: Handler;
      /**
       * Called immediately before a container is terminated due to an API request or management event such as liveness/startup probe failure, preemption, resource contention, etc.
       *
       * The handler is not called if the container crashes or exits.
       * The reason for termination is passed to the handler.
       * The Pod's termination grace period countdown begins before the PreStop hooked is executed.
       * Regardless of the outcome of the handler, the container will eventually terminate within the Pod's termination grace period.
       * Other management of the container blocks until the hook completes or until the termination grace period is reached.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks}
       */
      preStop: Handler;
  }/** @public */
  export declare interface VolumeDevice {
      /** The path inside of the container that the device will be mapped to. */
      devicePath: string;
      /** name must match the name of a persistentVolumeClaim in the pod */
      name: string;
  }/**
   * Resource spec for a Kubernetes container.
   * See the Kubernetes
   * {@link https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#container-v1-core | API docs }
   * for more details.
   * @public
   */
  export declare interface ContainerSpec {
      /**
       * Arguments to the entrypoint.
       *
       * The docker image's CMD is used if this is not provided.
       * Variable references $(VAR_NAME) are expanded using the container's environment.
       * If a variable cannot be resolved, the reference in the input string will be unchanged.
       * The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME).
       * Escaped references will never be expanded, regardless of whether the variable exists or not.
       * Cannot be updated.
       * More info: {@link https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell}
       */
      args?: string[];
      /**
       * Entrypoint array.
       *
       * Not executed within a shell.
       * The docker image's ENTRYPOINT is used if this is not provided.
       * Variable references $(VAR_NAME) are expanded using the container's environment.
       * If a variable cannot be resolved, the reference in the input string will be unchanged.
       * The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME).
       * Escaped references will never be expanded, regardless of whether the variable exists or not.
       * Cannot be updated.
       * More info: {@link https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell}
       */
      command?: string[];
      /**
       * List of environment variables to set in the container. Cannot be updated.
       */
      env?: EnvVar[];
      /**
       * List of sources to populate environment variables in the container.
       *
       * The keys defined within a source must be a C_IDENTIFIER.
       * All invalid keys will be reported as an event when the container is starting.
       * When a key exists in multiple sources, the value associated with the last source will take precedence.
       * Values defined by an Env with a duplicate key will take precedence. Cannot be updated.
       */
      envFrom?: EnvFromSource[];
      /**
       * Docker image name.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/containers/images}
       *
       * This field is optional to allow higher level config management to default or override container
       * images in workload controllers like Deployments and StatefulSets.
       */
      image?: string;
      /**
       * Image pull policy.
       *
       * One of Always, Never, IfNotPresent.
       * Defaults to Always if :latest tag is specified,
       * or IfNotPresent otherwise.
       * Cannot be updated.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/containers/images#updating-images}
       */
      imagePullPolicy?: "Always" | "Never" | "IfNotPresent";
      /**
       * List of sources to populate environment variables in the container.
       *
       * The keys defined within a source must be a C_IDENTIFIER.
       * All invalid keys will be reported as an event when the container is starting.
       * When a key exists in multiple sources, the value associated with the last source will take precedence.
       * Values defined by an Env with a duplicate key will take precedence. Cannot be updated.
       */
      lifecycle?: Lifecycle;
      /**
       * Periodic probe of container liveness.
       *
       * Container will be restarted if the probe fails.
       * Cannot be updated.
       * More info: {@link https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes}
       */
      livenessProbe?: Probe;
      /**
       * Name of the container specified as a DNS_LABEL.
       *
       * Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated.
       */
      name: string;
      /**
       * List of ports to expose from the container.
       *
       * Exposing a port here gives the system additional information about the network connections a container uses,
       * but is primarily informational.
       * Not specifying a port here DOES NOT prevent that port from being exposed.
       * Any port which is listening on the default "0.0.0.0" address inside a container will be accessible from
       * the network.
       * Cannot be updated.
       */
      ports?: ContainerPort[];
      /**
       * Periodic probe of container service readiness.
       *
       * Container will be removed from service endpoints if the probe fails.
       * Cannot be updated.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes}
       */
      readinessProbe?: Probe;
      /**
       * Compute Resources required by this container.
       *
       * Cannot be updated.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/}
       */
      resources?: ResourceRequirements;
      /**
       * Security options the pod should run with.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/policy/security-context/}
       * More info: {@link https://kubernetes.io/docs/tasks/configure-pod-container/security-context/}
       */
      securityContext?: PodSecurityContext;
      /**
       * Indicates that the Pod has successfully initialized.
       *
       * If specified, no other probes are executed until this completes successfully.
       * If this probe fails, the Pod will be restarted, just as if the livenessProbe failed.
       * This can be used to provide different probe parameters at the beginning of a Pod's lifecycle,
       * when it might take a long time to load data or warm a cache, than during steady-state operation.
       *
       * This cannot be updated.
       * This is a beta feature enabled by the StartupProbe feature flag.
       * More info: {@link https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes}
       */
      startupProbe?: Probe;
      /**
       * Whether this container should allocate a buffer for stdin in the container runtime.
       *
       * If this is not set, reads from stdin in the container will always result in EOF. Default is false.
       */
      stdin?: boolean;
      /**
       * Whether the container runtime should close the stdin channel after it has been opened by a single attach.
       *
       * When stdin is true the stdin stream will remain open across multiple attach sessions.
       * If stdinOnce is set to true, stdin is opened on container start,
       * is empty until the first client attaches to stdin,
       * and then remains open and accepts data until the client disconnects,
       * at which time stdin is closed and remains closed until the container is restarted.
       * If this flag is false, a container processes that reads from stdin will never receive an EOF. Default is false
       */
      stdinOnce?: boolean;
      /**
       * Path at which the file to which the container's termination message will be written is mounted into the container's filesystem.
       *
       * Message written is intended to be brief final status, such as an assertion failure message.
       * Will be truncated by the node if greater than 4096 bytes.
       * The total message length across all containers will be limited to 12kb.
       * Defaults to /dev/termination-log. Cannot be updated.
       */
      terminationMessagePath?: string;
      /**
       * Indicate how the termination message should be populated.
       *
       * File will use the contents of terminationMessagePath to populate the container status
       * message on both success and failure. FallbackToLogsOnError will use the last chunk of
       * container log output if the termination message file is empty and the container exited
       * with an error.
       * The log output is limited to 2048 bytes or 80 lines, whichever is smaller.
       * Defaults to File.
       * Cannot be updated.
       *
       * @defaultValue File
       */
      terminationMessagePolicy?: "File" | "FallbackToLogsOnError";
      /**
       * Whether this container should allocate a TTY for itself, also requires 'stdin' to be true.
       *
       * @defaultValue false
       */
      tty?: boolean;
      /**
       * volumeDevices is the list of block devices to be used by the container.
       */
      volumeDevices?: VolumeDevice[];
      /** volumeDevices is the list of block devices to be used by the container. */
      volumeMounts?: VolumeMount[];
      /**
       * Container's working directory.
       *
       * If not specified, the container runtime's default will be used,
       * which might be configured in the container image.
       * Cannot be updated.
       */
      workingDir?: string;
  }/**
   * Props for the Kubernetes-specific {@link k8s.K8sContainer} component.
   * @public
   */
  export declare interface K8sContainerProps extends ContainerSpec {
  }/** @public */
  export declare interface ContainerPort {
      /**
       * Number of port to expose on the pod's IP address.
       * @remarks
       * This must be a valid integer port number, `0 < x < 65536`.
       */
      containerPort: number;
      /** What host IP to bind the external port to. */
      hostIP?: string;
      /**
       * Number of port to expose on the host.
       * @remarks
       * If specified, this must be a valid integer port number,
       * `0 < x < 65536`. If HostNetwork is specified,
       * this must match ContainerPort. Most containers do not need this.
       */
      hostPort?: number;
      /**
       * A unique-within-pod name for the container
       * @remarks
       * If specified, this must be an IANA_SVC_NAME and unique within the pod.
       * Each named port in a pod must have a unique name. Name for the port
       * that can be referred to by services.
       */
      name?: string;
      /** Protocol for port. Must be UDP or TCP. Defaults to "TCP". */
      protocol?: string;
  }/** @public */
  export declare type EnvVar = EnvVarSimple | EnvVarFrom;/** @public */
  export declare interface EnvVarSimple {
      /** Name of the environment variable. Must be a C_IDENTIFIER. */
      name: string;
      /**
       * Variable references $(VAR_NAME) are expanded using the previous defined
       * environment variables in the container and any service environment
       * variables. If a variable cannot be resolved, the reference in the input
       * string will be unchanged. The $(VAR_NAME) syntax can be escaped with a
       * double $$, ie: $$(VAR_NAME). Escaped references will never be expanded,
       * regardless of whether the variable exists or not. Defaults to "".
       */
      value: string;
  }/** @public */
  export declare interface EnvVarFrom {
      /** Source for the environment variable's value. Cannot be used if value is not empty. */
      valueFrom?: any;
  }/**
   * See {@link k8s.k8sContainerProps}.
   * @public
   */
  export declare type FromContainerProps = ReplaceT<ContainerProps, {
      image: string;
  }> & BuiltinProps;/**
   * Kubernetes-specific container.
   * @public
   */
  export declare class K8sContainer extends PrimitiveComponent<K8sContainerProps> {
      static defaultProps: {
          imagePullPolicy: string;
      };
      validate(): undefined;
  }/**
   * Props for {@link k8s.Container}.
   * @public
   */
  export declare interface ContainerProps extends SFCDeclProps<ContainerProps> {
      /**
       * Additional {@link k8s.K8sContainerProps}-specific props that should be
       * added to the instantiated {@link k8s.K8sContainer}.
       */
      k8sContainerProps?: Partial<K8sContainerProps>;
  }/**
   * Spec for {@link k8s.DaemonSet} for use in {@link k8s.Resource}
   *
   * @public
   */
  export declare type DaemonSetSpec = Exclude<DaemonSetProps, ResourceBase> & {
      template: PodTemplateSpec;
  };/**
   * Component for Kubernetes DaemonSet
   *
   * @public
   */
  export declare class DaemonSet extends DeferredComponent<DaemonSetProps> {
      static defaultProps: {
          metadata: {};
          minReadySeconds: number;
          revisionHistoryLimit: number;
          updateStrategy: {
              type: string;
              rollingUpdate: {
                  maxUnavailable: number;
              };
          };
      };
      constructor(props: DaemonSetProps);
      build(helpers: BuildHelpers): Adapt.JSX.Element;
      status(_observe: ObserveForStatus, buildData: BuildData): Promise<Adapt.Status | undefined>;
  }/** @internal */
  const daemonSetResourceInfo: {
      kind: string;
      deployedWhen: typeof deployedWhen;
      statusQuery: (props: ResourcePropsWithConfig, observe: ObserveForStatus, buildData: BuildData) => Promise<any>;
  };/** @public */
  export declare interface DeploymentUpdateStrategyRecreate {
      type: "Recreate";
  }/** @public */
  export declare interface RollingUpdateDeployment {
      /**
       * The maximum number of pods that can be scheduled above the desired number of pods.
       *
       * Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
       * This can not be 0 if MaxUnavailable is 0.
       * Absolute number is calculated from percentage by rounding up.
       * Defaults to 25%.
       *
       * @example
       * When this is set to 30%, the new ReplicaSet can be scaled up immediately when the rolling update starts,
       * such that the total number of old and new pods do not exceed 130% of desired pods. Once old pods have been
       * killed, new ReplicaSet can be scaled up further, ensuring that total number of pods running at any time
       * during the update is at most 130% of desired pods.
       */
      maxSurge?: number | string;
      /**
       * The maximum number of pods that can be unavailable during the update.
       *
       * Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
       * Absolute number is calculated from percentage by rounding down.
       * This can not be 0 if MaxSurge is 0. Defaults to 25%.
       *
       * @example
       * When this is set to 30%, the old ReplicaSet can be scaled down to 70% of desired pods
       * immediately when the rolling update starts. Once new pods are ready, old ReplicaSet
       * can be scaled down further, followed by scaling up the new ReplicaSet, ensuring that
       * the total number of pods available at all times during the update is at least 70% of
       * desired pods.
       */
      maxUnavailable?: number | string;
  }/**
   * Spec for {@link k8s.Deployment} for use in {@link k8s.Resource}
   *
   * @public
   */
  export declare type DeploymentSpec = Exclude<DeploymentProps, ResourceBase> & {
      template: PodTemplateSpec;
  };/**
   * Props for {@link k8s.Deployment}
   *
   * @public
   */
  export declare interface DeploymentProps extends WithChildren {
      /** Information about the k8s cluster (ip address, auth info, etc.) */
      config: ClusterInfo;
      /** k8s metadata */
      metadata: Metadata;
      /**
       * The minimum number of seconds for which a newly created pod should
       * be ready without any of its container crashing, for it to be considered
       * available. Defaults to 0 (pod will be considered available as soon as it is ready).
       */
      minReadySeconds: number;
      /** Indicates that the deployment is paused */
      paused: boolean;
      /**
       * The maximum time in seconds for a deployment to make progress before it is considered to be failed.
       *
       * The deployment controller will continue to process failed deployments and a condition with a
       * ProgressDeadlineExceeded reason will be surfaced in the deployment status. Note that progress
       * will not be estimated during the time a deployment is paused. Defaults to 600s.
       */
      progressDeadlineSeconds: number;
      /**
       * Number of desired pods.
       *
       * Defaults to 1. 0 is not allowed.
       *
       * @defaultValue 1
       */
      replicas: number;
      /**
       * The number of old ReplicaSets to retain to allow rollback.
       *
       * This is a pointer to distinguish between explicit zero and not specified. Defaults to 10.
       *
       * @defaultValue 10
       */
      revisionHistoryLimit: number;
      /**
       * Label selector for pods.
       *
       * Existing ReplicaSets whose pods are selected by this will be the ones affected by this deployment.
       * It must match the pod template's labels.
       *
       * @remarks
       *
       * With Adapt, this is optional.  If not specified, adapt will pick a selector that will work with the pods
       * it creates as part of this {@link k8s.Deployment}
       */
      selector?: LabelSelector;
      /**
       * An deployment strategy to use to replace existing pods with new ones
       */
      strategy: DeploymentUpdateStrategy;
  }/**
   * Component for Kubernetes Deployment
   *
   * @public
   */
  export declare class Deployment extends DeferredComponent<DeploymentProps> {
      static defaultProps: {
          metadata: {};
          paused: boolean;
          replicas: number;
          progressDeadlineSeconds: number;
          minReadySeconds: number;
          revisionHistoryLimit: number;
          strategy: {
              type: string;
              rollingUpdate: {
                  maxSurge: string;
                  maxUnavailable: string;
              };
          };
      };
      constructor(props: DeploymentProps);
      build(helpers: BuildHelpers): Adapt.JSX.Element | null;
      deployedWhen: () => true | Adapt.Waiting;
      status(_observe: ObserveForStatus, buildData: BuildData): Promise<Adapt.Status | undefined>;
  }/** @internal */
  const deploymentResourceInfo: {
      kind: string;
      deployedWhen: typeof deployedWhen;
      statusQuery: (props: ResourcePropsWithConfig, observe: ObserveForStatus, buildData: BuildData) => Promise<any>;
  };/**
   * Type assertion to see if an element is both a {@link k8s.Resource | Resource}
   * and a {@link @adpt/core#FinalElement | FinalElement}
   *
   * @param e - element to test
   * @returns `true` if e is both a FinalElement and a {@link k8s.Resource | Resource}, `false` otherwise
   *
   * @public
   */
  export declare function isResourceFinalElement(e: AdaptElement): e is FinalDomElement<ResourceProps & Adapt.BuiltinProps>;/**
   * Tests whether a ResourceProps is for a template object
   *
   * @public
   */
  export declare function isResourcePropsWithConfig(x: ResourceProps & Partial<BuiltinProps>): x is ResourcePropsWithConfig & Partial<BuiltinProps>;/**
   * Tests to see if an object is a {@link k8s.Resource} element
   * @param x - object to test
   * @returns true if object is an AdaptElement of type {@link k8s.Resource}
   *
   * @public
   */
  export declare function isResource(x: any): x is AdaptElement<ResourceProps>;/**
   * Primitive Component recognized by the k8s plugin to represent resources
   * @public
   */
  export declare class Resource extends Action<ResourceProps> {
      defaultProps: {
          apiVersion: "v1";
          con: false;
      };
      manifest_: Manifest;
      constructor(props: ResourceProps);
      validate(): "Resource elements cannot have children" | undefined;
      shouldAct(op: ChangeType, ctx: ActionContext): Promise<ShouldAct>;
      action(op: ChangeType, ctx: ActionContext): Promise<void>;
      deployedWhen: (goalStatus: GoalStatus, helpers: DeployHelpers) => Promise<true | Adapt.Waiting | Adapt.Waiting[]>;
      status(observe: ObserveForStatus, buildData: BuildData): Promise<any>;
      private mountedElement;
      private manifest;
  }/** @internal */
  export declare function makePodManifest(props: PodProps & BuiltinProps, data: {
      volumes?: Volume[];
      serviceAccountName?: string;
  }): {
      kind: string;
      metadata: Metadata;
      spec: PodSpec;
  };/**
   * Tests whether x is a Pod element
   *
   * @param x - value to test
   * @returns `true` if x is a Pod element, false otherwise
   *
   * @public
   */
  export declare function isPod(x: any): x is AdaptElement<PodProps>;/** @public */
  export declare interface NodeSelectorRequirement {
      /** The label key that the selector applies to. */
      key: string;
      /**
       * Represents a key's relationship to a set of values.
       *
       * Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
       */
      operator: "In" | "NotIn" | "Exists" | "DoesNotExist" | "Gt" | "Lt";
      /**
       * Values for operator
       *
       * If the operator is In or NotIn, the values array must be non-empty.
       * If the operator is Exists or DoesNotExist, the values array must be empty.
       * If the operator is Gt or Lt, the values array must have a single element,
       * which will be interpreted as an integer.
       * This array is replaced during a strategic merge patch.
       */
      values: string[];
  }/** @public */
  export declare interface NodeSelectorTerm {
      /** A list of node selector requirements by node's labels. */
      matchExpressions?: NodeSelectorRequirement[];
      /** A list of node selector requirements by node's fields. */
      matchFields?: NodeSelectorRequirement[];
  }/** @public */
  export declare interface PreferredSchedulingTerm {
      /**
       * A node selector term, associated with the corresponding weight.
       */
      preference: NodeSelectorTerm;
      /** Weight associated with matching the corresponding nodeSelectorTerm, in the range 1-100. */
      weight: number;
  }/** @public */
  export declare interface NodeSelector {
      /** A list of node selector terms. The terms are ORed */
      nodeSelectorTerms: NodeSelectorTerm[];
  }/** @public */
  export declare interface NodeAffinity {
      /** The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding "weight" to the sum if the node matches the corresponding matchExpressions; the node(s) with the highest sum are the most preferred. */
      preferredDuringSchedulingIgnoredDuringExecution?: PreferredSchedulingTerm[];
      /** If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to an update), the system may or may not try to eventually evict the pod from its node. */
      requiredDuringSchedulingIgnoredDuringExecution?: NodeSelector;
  }/** @public */
  export declare interface PodAffinityTerm {
      /**
       * Label query over a set of resources, in this case pods.
       */
      labelSelector: LabelSelector;
      /** Specifies which namespaces the labelSelector applies to (matches against); null or empty list means "this pod's namespace" */
      namespaces?: string[];
      /** This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed. */
      topologyKey: string;
  }/** @public */
  export declare interface WeightedPodAffinityTerm {
      /** A pod affinity term, associated with the corresponding weight. */
      podAffinityTerm: PodAffinityTerm;
      /**
       * weight associated with matching the corresponding podAffinityTerm, in the range 1-100.
       */
      weight: number;
  }/** @public */
  export declare interface PodAffinity {
      /**
       * The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions.
       *
       * The node that is most preferred is the one with the greatest sum of weights,
       * i.e. for each node that meets all of the scheduling requirements (resource request,
       * requiredDuringScheduling affinity expressions, etc.), compute a sum by iterating
       * through the elements of this field and adding "weight" to the sum if the node has pods
       * which matches the corresponding podAffinityTerm; the node(s) with the highest sum are the most preferred.
       */
      preferredDuringSchedulingIgnoredDuringExecution: WeightedPodAffinityTerm[];
      /**
       * If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node.
       *
       * If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system may or may not try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each podAffinityTerm are intersected, i.e. all terms must be satisfied.
       */
      requiredDuringSchedulingIgnoredDuringExecution: PodAffinityTerm[];
  }/** @public */
  export declare interface PodAntiAffinity {
      /** The scheduler will prefer to schedule pods to nodes that satisfy the anti-affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling anti-affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the node(s) with the highest sum are the most preferred. */
      preferredDuringSchedulingIgnoredDuringExecution: WeightedPodAffinityTerm[];
      /** If the anti-affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the anti-affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system may or may not try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each podAffinityTerm are intersected, i.e. all terms must be satisfied. */
      requiredDuringSchedulingIgnoredDuringExecution: PodAffinity;
  }/** @public */
  export declare interface Affinity {
      /** Describes node affinity scheduling rules for the pod. */
      nodeAffinity: NodeAffinity;
      /** Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)). */
      podAffinity: PodAffinity;
      /** PodAntiAffinity	Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)). */
      podAntiAffinity: PodAntiAffinity;
  }/** @public */
  export declare interface PodDNSConfigOption {
      name: string;
      value?: string;
  }/** @public */
  export declare interface PodDNSConfig {
      /**
       * A list of DNS name server IP addresses.
       *
       * This will be appended to the base nameservers generated from DNSPolicy. Duplicated nameservers will be removed.
       */
      nameservers: string[];
      /**
       * A list of DNS resolver options.
       *
       * This will be merged with the base options generated from DNSPolicy.
       * Duplicated entries will be removed.
       * Resolution options given in Options will override those that appear in the base DNSPolicy.
       */
      options: PodDNSConfigOption[];
      /**
       * A list of DNS search domains for host-name lookup.
       *
       * This will be appended to the base search paths generated from DNSPolicy. Duplicated search paths will be removed.
       */
      searches: string[];
  }/** @public */
  export declare interface PodReadinessGate {
      /** Refers to a condition in the pod's condition list with matching type. */
      conditionType: string;
  }/** @public */
  export declare interface SELinuxOptions {
      /** SELinux level label that applies to the container. */
      level: string;
      /** SELinux role label that applies to the container. */
      role: string;
      /** SELinux type label that applies to the container. */
      type: string;
      /** SELinux user label that applies to the container */
      user: string;
  }/** @public */
  export declare interface SeccompProfile {
      /**
       * Indicates a profile defined in a file on the node should be used.
       *
       * The profile must be preconfigured on the node to work.
       * Must be a descending path, relative to the kubelet's configured seccomp profile location.
       * Must only be set if type is "Localhost".
       */
      localhostProfile?: string;
      /**
       * Indicates which kind of seccomp profile will be applied.
       *
       * Valid options are:
       * * Localhost - a profile defined in a file on the node should be used.
       * * RuntimeDefault - the container runtime default profile should be used.
       * * Unconfined - no profile should be applied.
       */
      type: "Localhost" | "RuntimeDefault" | "Unconfined";
  }/** @public */
  export declare interface Sysctl {
      name: string;
      value: string;
  }/** @public */
  export declare interface WindowsSecurityContextOptions {
      /**
       * The GMSA admission webhook ({@link https://github.com/kubernetes-sigs/windows-gmsa}) inlines the contents of the GMSA credential spec named by the GMSACredentialSpecName field.
       */
      gmsaCredentialSpec?: string;
      /**
       * GMSACredentialSpecName is the name of the GMSA credential spec to use.
       */
      gmsaCredentialSpecName?: string;
      /**
       * The UserName in Windows to run the entrypoint of the container process.
       *
       * Defaults to the user specified in image metadata if unspecified. May also be set in PodSecurityContext.
       * If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
       */
      runAsUserName?: string;
  }/** @public */
  export declare interface PodSecurityContext {
      /**
       * A special supplemental group that applies to all containers in a pod.
       *
       * Some volume types allow the Kubelet to change the ownership of that volume to be owned by the pod:
       *
       * 1. The owning GID will be the FSGroup
       * 2. The setgid bit is set (new files created in the volume will be owned by FSGroup)
       * 3. The permission bits are OR'd with rw-rw----
       *
       * If unset, the Kubelet will not modify the ownership and permissions of any volume.
       */
      fsGroup?: number;
      /**
       * Defines behavior of changing ownership and permission of the volume before being exposed inside Pod.
       *
       * This field will only apply to volume types which support fsGroup based ownership(and permissions).
       * It will have no effect on ephemeral volume types such as: secret, configmaps and emptydir.
       * Valid values are "OnRootMismatch" and "Always". If not specified defaults to "Always".
       *
       * @defaultValue Always
       */
      fsGroupChangePolicy?: "OnRootMismatch" | "Always";
      /**
       * The GID to run the entrypoint of the container process.
       *
       * Uses runtime default if unset. May also be set in SecurityContext.
       * If set in both SecurityContext and PodSecurityContext, the value specified in
       * SecurityContext takes precedence for that container.
       */
      runAsGroup?: number;
      /**
       * Indicates that the container must run as a non-root user.
       *
       * If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and
       * fail to start the container if it does. If unset or false, no such validation will be performed.
       * May also be set in SecurityContext.
       * If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
       */
      runAsNonRoot?: boolean;
      /**
       * The UID to run the entrypoint of the container process.
       *
       * Defaults to user specified in image metadata if unspecified.
       * May also be set in SecurityContext.
       * If set in both SecurityContext and PodSecurityContext, the value specified in
       * SecurityContext takes precedence for that container.
       */
      runAsUser?: number;
      /**
       * The SELinux context to be applied to all containers.
       *
       * If unspecified, the container runtime will allocate a random SELinux context for each container.
       * May also be set in SecurityContext.
       * If set in both SecurityContext and PodSecurityContext, the value specified in
       * SecurityContext takes precedence for that container.
       */
      seLinuxOptions?: SELinuxOptions;
      /**
       * The seccomp options to use by the containers in this pod.
       */
      seccompProfile?: SeccompProfile;
      /**
       * 	A list of groups applied to the first process run in each container, in addition to the container's primary GID.
       *
       *  If unspecified, no groups will be added to any container.
       */
      supplementalGroups?: number[];
      /**
       * Sysctls hold a list of namespaced sysctls used for the pod.
       *
       * Pods with unsupported sysctls (by the container runtime) might fail to launch.
       */
      sysctls?: Sysctl[];
      /**
       * The Windows specific settings applied to all containers.
       *
       * If unspecified, the options within a container's SecurityContext will be used.
       * If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
       */
      windowsOptions: WindowsSecurityContextOptions;
  }/** @public */
  export declare interface Toleration {
      /**
       * Indicates the taint effect to match.
       *
       * Empty means match all taint effects.
       * When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
       */
      effect?: "NoSchedule" | "PreferNoSchedule" | "NoExecute";
      /**
       * The taint key that the toleration applies to.
       *
       * Empty means match all taint keys.
       * If the key is empty, operator must be Exists;
       * this combination means to match all values and all keys.
       */
      key?: string;
      /**
       * Represents a key's relationship to the value.
       *
       * Valid operators are Exists and Equal.
       * Defaults to Equal.
       * Exists is equivalent to wildcard for value, so that a pod can tolerate all taints of a particular category.
       *
       * @defaultValue Equal
       */
      operator?: "Exists" | "Equal";
      /**
       * Represents the period of time the toleration (which must be of effect NoExecute, otherwise this field is ignored) tolerates the taint.
       *
       * By default, it is not set, which means tolerate the taint forever (do not evict).
       * Zero and negative values will be treated as 0 (evict immediately) by the system.
       */
      tolerationSeconds?: number;
      /**
       * Value is the taint value the toleration matches to.
       *
       * If the operator is Exists, the value should be empty, otherwise just a regular string.
       */
      value?: string;
  }/** @public */
  export declare interface TopologySpreadConstraint {
      /**
       * Used to find matching pods.
       *
       * Pods that match this label selector are counted to determine the
       * number of pods in their corresponding topology domain.
       */
      labelSelector: LabelSelector;
      /**
       * Describes the degree to which pods may be unevenly distributed.
       *
       * When `whenUnsatisfiable=DoNotSchedule`, it is the maximum permitted
       * difference between the number of matching pods in the target topology
       * and the global minimum.
       * For example, in a 3-zone cluster, MaxSkew is set to 1, and pods with
       * the same labelSelector spread as 1/1/0: | zone1 | zone2 | zone3 | | P | P | |
       * - if MaxSkew is 1, incoming pod can only be scheduled to zone3 to become 1/1/1;
       *   scheduling it onto zone1(zone2) would make the ActualSkew(2-0) on zone1(zone2) violate MaxSkew(1).
       * - if MaxSkew is 2, incoming pod can be scheduled onto any zone.
       * When `whenUnsatisfiable=ScheduleAnyway`, it is used to give higher precedence to topologies that satisfy it.
       * It's a required field. Default value is 1 and 0 is not allowed.
       *
       * @example
       *
       * @defaultValue 1
       */
      maxSkew: number;
      /**
       * The key of node labels.
       *
       * Nodes that have a label with this key and identical values are considered to be in the same topology.
       * We consider each \<key, value\> as a "bucket", and try to put balanced number of pods into each bucket.
       * It's a required field.
       */
      topologyKey: string;
      /**
       * Indicates how to deal with a pod if it doesn't satisfy the spread constraint.
       *
       * - DoNotSchedule (default) tells the scheduler not to schedule it.
       * - ScheduleAnyway tells the scheduler to schedule the pod in any location,
       *   but giving higher precedence to topologies that would help reduce the skew.
       *
       * A constraint is considered "Unsatisfiable" for an incoming pod if and only if every possible
       * node assigment for that pod would violate "MaxSkew" on some topology.
       * For example, in a 3-zone cluster, MaxSkew is set to 1, and pods with the same labelSelector
       * spread as 3/1/1: | zone1 | zone2 | zone3 | | P P P | P | P | If WhenUnsatisfiable is set to DoNotSchedule,
       * incoming pod can only be scheduled to zone2(zone3) to become 3/2/1(3/1/2)
       * as ActualSkew(2-1) on zone2(zone3) satisfies MaxSkew(1).
       * In other words, the cluster can still be imbalanced, but scheduler won't make it
       * *more* imbalanced.
       *
       * It's a required field.
       */
      whenUnsatisfiable: string;
  }/** @public */
  export declare interface KeyToPath {
      /** The key to project. */
      key: string;
      /**
       * mode bits to use on this file,
       * Must be a value between 0 and 0777.
       * If not specified, the volume defaultMode will be used.
       * This might be in conflict with other options that affect the file mode, like fsGroup,
       * and the result can be other mode bits set.
       */
      mode?: number;
      /**
       * The relative path of the file to map the key to.
       *
       * May not be an absolute path. May not contain the path element '..'. May not start with the string '..'.
       */
      path: string;
  }/** @public */
  export declare interface ConfigMapVolumeSource {
      /**
       * mode bits to use on created files by default.
       *
       * Must be a value between 0 and 0777. Defaults to 0644.
       * Directories within the path are not affected by this setting.
       * This might be in conflict with other options that affect the file mode,
       * like fsGroup, and the result can be other mode bits set.
       */
      defaultMode?: number;
      /**
       * If unspecified, each key-value pair in the Data field of the referenced ConfigMap will be projected into the volume as a file whose name is the key and content is the value.
       *
       * If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present.
       * If a key is specified which is not present in the ConfigMap, the volume setup will error unless it is marked optional.
       * Paths must be relative and may not contain the '..' path or start with '..'.
       */
      items?: KeyToPath[];
      /**
       * Name of the referent.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names}
       */
      name: string | Handle;
      /** Specify whether the ConfigMap or its keys must be defined */
      optional?: boolean;
  }/** @public */
  export declare interface SecretVolumeSource {
      /**
       * mode bits to use on created files by default.
       *
       * Must be a value between 0 and 0777. Defaults to 0644.
       * Directories within the path are not affected by this setting.
       * This might be in conflict with other options that affect the file mode,
       * like fsGroup, and the result can be other mode bits set.
       */
      defaultMode?: number;
      /**
       * If unspecified, each key-value pair in the Data field of the referenced Secret will be projected into the volume as a file whose name is the key and content is the value.
       *
       * If specified, the listed keys will be projected into the specified paths,
       * and unlisted keys will not be present. If a key is specified which is not
       * present in the Secret, the volume setup will error unless it is marked optional.
       *
       * Paths must be relative and may not contain the '..' path or start with '..'.
       */
      items?: KeyToPath[];
      /** Specify whether the Secret or its keys must be defined */
      optional?: boolean;
      /**
       * Name of the secret in the pod's namespace to use.
       *
       *  More info: {@link https://kubernetes.io/docs/concepts/storage/volumes#secret}
       */
      secretName: string | Handle;
  }/** @public */
  export declare interface EmptyDirVolumeSource {
      /**
       * What type of storage medium should back this directory.
       *
       * The default is "" which means to use the node's default medium.
       * Must be an empty string (default) or Memory.
       * More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
       */
      medium: string;
      /**
       * Total amount of local storage required for this EmptyDir volume.
       *
       * The size limit is also applicable for memory medium.
       * The maximum usage on memory medium EmptyDir would be the minimum
       * value between the SizeLimit specified here and the sum of memory limits of all containers in a pod.
       * The default is nil which means that the limit is undefined.
       * More info: {@link http://kubernetes.io/docs/user-guide/volumes#emptydir}
       */
      sizeLimit: string;
  }/**
   * Volumes for {@link k8s.PodProps}
   *
   * @public
   */
  export declare interface Volume {
      /**
       * Volume's name.
       *
       * Must be a DNS_LABEL and unique within the pod.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names}
       */
      name: string;
      /**
       * Represents a configMap that should populate this volume
       */
      configMap?: ConfigMapVolumeSource;
      /**
       * EmptyDir represents a temporary directory that shares a pod's lifetime.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/storage/volumes#emptydir}
       *
       */
      emptyDir?: EmptyDirVolumeSource;
      /**
       * Represents a secret that should populate this volume.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/storage/volumes#secret}
       */
      secret?: SecretVolumeSource;
      /** Other k8s volume kinds not typed yet for \@adpt/cloud */
      [key: string]: any;
  }/**
   * Props for the {@link k8s.Pod} component
   *
   * @public
   */
  export declare interface PodProps extends WithChildren {
      /**
       *  True is this is a template for use in a controller, false otherwise
       *  @defaultValue false
       */
      isTemplate: boolean;
      /** Information about the k8s cluster (ip address, auth info, etc.) */
      config?: ClusterInfo;
      /** k8s metadata */
      metadata: Metadata;
      /**
       * Optional duration in seconds the pod may be active on the node relative to StartTime before the system will actively try to mark it failed and kill associated containers.
       *
       * Value must be a positive integer.
       */
      activeDeadlineSeconds?: number;
      /** If specified, the pod's scheduling constraints */
      affinity?: Affinity;
      /** AutomountServiceAccountToken indicates whether a service account token should be automatically mounted. */
      automountServiceAccountToken?: boolean;
      /**
       *  Specifies the DNS parameters of a pod.
       *
       *  Parameters specified here will be merged to the generated DNS configuration based on DNSPolicy.
       */
      dnsConfig?: PodDNSConfig;
      /**
       * Set DNS policy for the pod.
       *
       * Valid values are 'ClusterFirstWithHostNet', 'ClusterFirst', 'Default' or 'None'.
       * DNS parameters given in DNSConfig will be merged with the policy selected with DNSPolicy.
       * To have DNS options set along with hostNetwork, you have to specify DNS policy explicitly
       * to 'ClusterFirstWithHostNet'.
       *
       * @defaultValue ClusterFirst
       */
      dnsPolicy: "ClusterFirstWithHostNet" | "ClusterFirst" | "Default" | "None";
      /**
       * Indicates whether information about services should be injected into pod's environment variables matching the syntax of Docker links.
       *
       * @defaultValue true
       */
      enableServiceLinks: boolean;
      /**
       * An optional list of hosts and IPs that will be injected into the pod's hosts file if specified.
       *
       * This is only valid for non-hostNetwork pods.
       */
      hostAliases?: HostAlias[];
      /**
       * Use the host's ipc namespace.
       * @defaultValue false
       */
      hostIPC: boolean;
      /**
       * Host networking requested for this pod.
       *
       * Use the host's network namespace.
       * If this option is set, the ports that will be used must be specified. Default to false.
       */
      hostNetwork?: boolean;
      /**
       * Use the host's pid namespace.
       * @defaultValue false
       */
      hostPID: boolean;
      /**
       * Specifies the hostname of the Pod.
       *
       * If not specified, the pod's hostname will be set to a system-defined value.
       */
      hostname?: string;
      /**
       * List of references to secrets in the same namespace to use for pulling any of the images used by this PodSpec.
       *
       * If specified, these secrets will be passed to individual puller implementations for them to use.
       * For example, in the case of docker, only DockerConfig type secrets are honored.
       * More info: {@link https://kubernetes.io/docs/concepts/containers/images#specifying-imagepullsecrets-on-a-pod}
       */
      imagePullSecrets?: LocalObjectReference[];
      /**
       * A request to schedule this pod onto a specific node.
       *
       * If it is non-empty, the scheduler simply schedules this pod onto that node,
       * assuming that it fits resource requirements.
       */
      nodeName?: string;
      /**
       * A selector which must be true for the pod to fit on a node.
       *
       * Selector which must match a node's labels for the pod to be scheduled on that node.
       * More info: {@link https://kubernetes.io/docs/concepts/configuration/assign-pod-node/}
       */
      nodeSelector?: {
          [label: string]: boolean | string;
      };
      /**
       * Overhead represents the resource overhead associated with running a pod for a given RuntimeClass.
       *
       * This field will be autopopulated at admission time by the RuntimeClass admission controller.
       * If the RuntimeClass admission controller is enabled, overhead must not be set in Pod create requests.
       * The RuntimeClass admission controller will reject Pod create requests which have the overhead already set.
       * If RuntimeClass is configured and selected in the PodSpec, Overhead will be set to the value defined in
       * the corresponding RuntimeClass, otherwise it will remain unset and treated as zero.
       *
       * More info: {@link https://git.k8s.io/enhancements/keps/sig-node/20190226-pod-overhead.md}
       *
       * This field is alpha-level as of Kubernetes v1.16, and is only honored by servers that enable
       * the PodOverhead feature.
       * @alpha
       */
      overhead?: unknown;
      /**
       * PreemptionPolicy is the Policy for preempting pods with lower priority.
       *
       * This field is beta-level, gated by the NonPreemptingPriority feature-gate.
       *
       * @defaultValue PreemptLowerPriority
       * @beta
       */
      preemptionPolicy?: "Never" | "PreemptLowerPriority";
      /**
       * The priority various system components use this field to find the priority of the pod.
       *
       * When Priority Admission Controller is enabled, it prevents users from setting this field.
       * The admission controller populates this field from PriorityClassName.
       * The higher the value, the higher the priority.
       */
      priority?: number;
      /**
       * If specified, indicates the pod's priority.
       *
       * "system-node-critical" and "system-cluster-critical" are two special keywords which indicate the highest
       * priorities with the former being the highest priority. Any other name must be defined by creating a PriorityClass
       * object with that name. If not specified, the pod priority will be default or zero if there is no default.
       */
      priorityClassName?: string;
      /**
       *  If specified, all readiness gates will be evaluated for pod readiness.
       *
       *  A pod is ready when all its containers are ready AND all conditions specified
       *  in the readiness gates have status equal to "True"
       *
       *  More info: {@link https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#pod-readiness-gate}
       */
      readinessGates?: PodReadinessGate[];
      /**
       * Restart policy for all containers within the pod.
       *
       * One of Always, OnFailure, Never. Default to Always.
       * More info: {@link https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy}
       *
       * @defaultValue Always
       */
      restartPolicy: "Always" | "OnFailure" | "Never";
      /**
       * Refers to a RuntimeClass object in the node.k8s.io group, which should be used to run this pod.
       *
       * If no RuntimeClass resource matches the named class, the pod will not be run.
       * If unset or empty, the "legacy" RuntimeClass will be used, which is an implicit
       * class with an empty definition that uses the default runtime handler.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/containers/runtime-class/}
       *
       * This is a beta feature as of Kubernetes v1.14.
       */
      runtimeClassName?: string;
      /**
       *  If specified, the pod will be dispatched by specified scheduler.
       *  If not specified, the pod will be dispatched by default scheduler.
       */
      schedulerName?: string;
      /**
       * SecurityContext holds pod-level security attributes and common container settings.
       * See type description for default values of each field.
       *
       * @defaultValue \{\}
       */
      securityContext: PodSecurityContext;
      /**
       * ServiceAccountName is the name of the ServiceAccount to use to run this pod.
       * More info: {@link https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/}
       */
      serviceAccountName?: string | Handle;
      /**
       * If true the pod's hostname will be configured as the pod's FQDN, rather than the leaf name (the default).
       * In Linux containers, this means setting the FQDN in the hostname field of the kernel
       * (the nodename field of struct utsname).
       * In Windows containers, this means setting the registry value of hostname for the registry key
       * HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters to FQDN.
       * If a pod does not have FQDN, this has no effect.
       *
       * @defaultValue false
       */
      setHostnameAsFQDN?: boolean;
      /**
       * Share a single process namespace between all of the containers in a pod.
       * When this is set containers will be able to view and signal processes from other containers in the same pod,
       * and the first process in each container will not be assigned PID 1.
       * HostPID and ShareProcessNamespace cannot both be set.
       *
       * @defaultValue false
       */
      shareProcessNamespace: boolean;
      /**
       *  If specified, the fully qualified Pod hostname will be "\<hostname\>.\<subdomain\>.\<pod namespace\>.svc.\<cluster domain\>".
       *  If not specified, the pod will not have a domainname at all.
       */
      subdomain?: string;
      /**
       * Optional duration in seconds the pod needs to terminate gracefully.
       *
       * May be decreased in delete request. Value must be non-negative integer.
       * The value zero indicates delete immediately. If this value is nil, the default
       * grace period will be used instead. The grace period is the duration in seconds
       * after the processes running in the pod are sent a termination signal and the time
       * when the processes are forcibly halted with a kill signal. Set this value longer
       * than the expected cleanup time for your process. Defaults to 30 seconds.
       */
      terminationGracePeriodSeconds?: number;
      /** If specified, the pod's tolerations. */
      tolerations?: Toleration[];
      /**
       *  TopologySpreadConstraints describes how a group of pods ought to spread across topology domains.
       *
       *  Scheduler will schedule pods in a way which abides by the constraints. All topologySpreadConstraints are ANDed.
       */
      topologySpreadConstraints?: TopologySpreadConstraint[];
      /**
       * List of volumes that can be mounted by containers belonging to the pod.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/storage/volumes}
       */
      volumes?: Volume[];
  }/**
   * Component for Kubernetes Pods
   *
   * @public
   */
  export declare class Pod extends DeferredComponent<PodProps, ResolvedVolumes & ResolvedServiceAccountName> {
      static defaultProps: {
          isTemplate: boolean;
          metadata: {};
          dnsPolicy: string;
          enableServiceLinks: boolean;
          hostIPC: boolean;
          hostPID: boolean;
          restartPolicy: string;
          securityContext: {};
          shareProcessNamespace: boolean;
          terminationGracePeriodSeconds: number;
      };
      initialState(): {};
      build(helpers: BuildHelpers): Adapt.JSX.Element | null;
      status(_observe: ObserveForStatus, buildData: BuildData): Promise<Adapt.Status | undefined>;
  }/**
   * Spec for for Kubernetes Pods
   *
   * @public
   */
  export declare interface PodSpec extends Omit<PodProps, "config" | "metadata" | "isTemplate"> {
      containers: ContainerSpec[];
      terminationGracePeriodSeconds?: number;
  }/** @internal */
  const podResourceInfo: {
      kind: string;
      deployedWhen: typeof deployedWhen;
      statusQuery: (props: ResourcePropsWithConfig, observe: ObserveForStatus, buildData: BuildData) => Promise<any>;
  };/**
   * k8s Secret resource
   *
   * @param propsIn - props for Secret as specifed in {@link k8s.SecretProps}
   *
   * @public
   */
  export declare function Secret(propsIn: SFCDeclProps<SecretProps, typeof defaultProps>): Adapt.JSX.Element;/** @internal */
  const secretResourceInfo: {
      kind: string;
      deployedWhen: () => true;
      statusQuery: (props: ResourcePropsWithConfig, observe: ObserveForStatus, buildData: BuildData) => Promise<any>;
      makeManifest: (manifest: Manifest, elem: AdaptElement<ResourceProps>, _deployID: string) => {
          data: {
              [key: string]: string;
          } | undefined;
          stringData: {
              [key: string]: string;
          } | undefined;
          type: string | undefined;
          apiVersion: string; /**
           * stringData allows specifying non-binary secret data in string form.
           *
           * It is provided as a write-only convenience method. All keys and values are merged into the data field on write,
           * overwriting any existing values. It is never output when reading from the API.
           */
          kind: string;
          metadata: import("./manifest_support").MetadataInRequest;
          spec?: import("./DaemonSet").DaemonSetSpec | import("./common").CRSpec | import("./Pod").PodSpec | import("./Service").ServiceSpec | import("./Deployment").DeploymentSpec | undefined;
      };
  };/**
   * Convert {@link NetworkService} props to {@link k8s.Service} props
   * @param abstractProps - props to convert
   * @returns Kubernetes spec corresponding to `abstractProps`
   *
   * @internal
   */
  export declare function k8sServiceProps(abstractProps: NetworkServiceProps & BuiltinProps): Omit<ServiceProps, keyof ResourceBase>;/**
   * Native Kubernetes Service resource
   *
   * @remarks
   *
   * Implements the {@link NetworkServiceInstance} interface.
   *
   * @public
   */
  export declare function Service(propsIn: SFCDeclProps<ServiceProps, typeof defaultProps>): Adapt.JSX.Element;/** @public */
  export declare interface ServiceProps extends ServiceSpec {
      /** Legal configuration loaded from kubeconfig */
      config: ClusterInfo;
      metadata?: Metadata;
      selector?: Handle | EndpointSelector;
  }/** @public */
  export declare interface ServiceSpec {
      /**
       * Cluster IP for a {@link k8s.Service}
       *
       * @remarks
       * `clusterIP` is the IP address of the service and is usually assigned
       * randomly by the master. If an address is specified manually and is not
       * in use by others, it will be allocated to the service; otherwise,
       * creation of the service will fail. This field can not be changed through
       * updates. Valid values are "None", empty string (""), or a valid IP
       * address. "None" can be specified for headless services when proxying is
       * not required. Only applies to types ClusterIP, NodePort, and
       * LoadBalancer. Ignored if type is ExternalName.
       *
       * For more information, see the
       * {@link https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies |
       * Kubernetes documentation}.
       */
      clusterIP?: string;
      /**
       * A list of IP addresses for which nodes in the cluster
       * will also accept traffic for this service.
       *
       * @remarks
       * These IPs are not managed by
       * Kubernetes. The user is responsible for ensuring that traffic arrives at
       * a node with this IP. A common example is external load balancers that are
       * not part of the Kubernetes system.
       */
      externalIPs?: string[];
      /**
       * The external reference that kubedns or equivalent
       * will return as a CNAME record for this service.
       *
       * @remarks
       * No proxying will be involved. Must be a
       * {@link https://tools.ietf.org/html/rfc1123 | valid RFC-1123 hostname}
       * and requires Type to be ExternalName.
       */
      externalName?: string;
      /**
       * Denotes if this Service desires to route
       * external traffic to node-local or cluster-wide endpoints.
       *
       * @remarks
       * "Local" preserves the client source IP and avoids a second hop for
       * LoadBalancer and Nodeport type services, but risks potentially
       * imbalanced traffic spreading. "Cluster" obscures the client source IP
       * and may cause a second hop to another node, but should have good overall
       * load-spreading.
       */
      externalTrafficPolicy?: string;
      /**
       * Specifies the healthcheck nodePort for the service.
       *
       * @remarks
       * If not specified, HealthCheckNodePort is created by the service
       * api backend with the allocated nodePort. Will use user-specified nodePort
       * value if specified by the client. Only affects when Type is set to
       * LoadBalancer and ExternalTrafficPolicy is set to Local.
       */
      healthCheckNodePort?: number;
      /**
       * Only applies to Service Type: LoadBalancer. LoadBalancer will
       * get created with the IP specified in this field.
       *
       * @remarks
       * This feature depends on
       * whether the underlying cloud provider supports specifying the loadBalancerIP
       * when a load balancer is created. This field will be ignored if the
       * cloud provider does not support the feature.
       */
      loadBalancerIP?: string;
      /**
       * If specified and supported by the platform, this will
       * restrict traffic through the cloud provider load balancer
       * to the specified client IPs.
       *
       * @remarks
       * This field will be ignored if the cloud provider
       * does not support the feature.
       *
       * For more information, see the
       * {@link https://v1-17.docs.kubernetes.io/docs/tasks/access-application-cluster/configure-cloud-provider-firewall/ |
       * Kubernetes documentation}.
       */
      loadBalancerSourceRanges?: string[];
      /**
       * The list of ports that are exposed by this service.
       *
       * @remarks
       * For more information, see the
       * {@link https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies |
       * Kubernetes documentation}.
       */
      ports?: ServicePort[];
      /**
       * When set to true, indicates that
       * DNS implementations must publish the notReadyAddresses of subsets for the
       * Endpoints associated with the Service.
       *
       * @remarks
       * The default value is false. The
       * primary use case for setting this field is to use a StatefulSet's Headless
       * Service to propagate SRV records for its Pods without respect to their
       * readiness for purpose of peer discovery.
       */
      publishNotReadyAddresses?: boolean;
      /**
       * Route service traffic to pods with label keys and values
       * matching this selector.
       *
       * @remarks
       * If empty or not present, the service is assumed to
       * have an external process managing its endpoints, which Kubernetes will not
       * modify. Only applies to types ClusterIP, NodePort, and LoadBalancer.
       * Ignored if type is ExternalName.
       *
       * For more information, see the
       * {@link https://kubernetes.io/docs/concepts/services-networking/service/ |
       * Kubernetes documentation}.
       */
      selector?: EndpointSelector | object;
      /**
       * Used to maintain session affinity.
       *
       * @remarks
       * Possible values are:
       *
       * - `"ClientIP"`: Enables client IP based session affinity.
       *
       * - `"None"`: Disables session affinity.
       *
       * For more information, see the
       * {@link https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies |
       * Kubernetes documentation}.
       * @defaultValue `"None"`
       */
      sessionAffinity?: string;
      /**
       * Determines how the Service is exposed.
       *
       * @remarks
       * Valid options are:
       *
       * - `"ExternalName"`: maps to the specified externalName.
       *
       * - `"ClusterIP"`: allocates a cluster-internal IP address for load
       * balancing to endpoints. Endpoints are determined by the selector or if
       * that is not specified, by manual construction of an Endpoints object. If
       * clusterIP is "None", no virtual IP is allocated and the endpoints are
       * published as a set of endpoints rather than a stable IP.
       *
       * - `"NodePort"`: Builds on ClusterIP and allocates a port on every node
       * which routes to the clusterIP.
       *
       * - `"LoadBalancer"`: Builds on NodePort and creates an external load
       * balancer (if supported in the current cloud) which routes to the
       * clusterIP.
       *
       * For more information, see the
       * {@link https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services---service-types |
       * Kubernetes documentation}.
       * @defaultValue `"ClusterIP"`
       */
      type?: string;
  }/** @public */
  export declare interface ServicePort {
      /**
       * The name of this port within the service.
       *
       * @remarks
       * This must be a DNS_LABEL.
       * All ports within a ServiceSpec must have unique names.This maps to the
       * Name' field in EndpointPort objects. Optional if only one ServicePort is
       * defined on this service.
       */
      name?: string;
      /**
       * The port on each node on which this service is exposed when
       * type=NodePort or LoadBalancer.
       *
       * @remarks
       * Usually assigned by the system. If
       * specified, it will be allocated to the service if unused or else creation
       * of the service will fail.
       *
       * For more information, see the
       * {@link https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport |
       * Kubernetes documentation}.
       * @defaultValue Automatically allocates a port if the ServiceType of this
       * Service requires one.
       */
      nodePort?: number;
      /** The port that will be exposed by this service. */
      port?: number;
      /** The IP protocol for this port.Supports "TCP" and "UDP".Default is TCP. */
      protocol?: string;
      /**
       * Number or name of the port to access on the pods targeted by the
       * service.
       *
       * @remarks
       * Number must be in the range 1 to 65535. Name must be an
       * IANA_SVC_NAME. If this is a string, it will be looked up as a named port
       * in the target Pod's container ports. If this is not specified, the value
       * of the 'port' field is used (an identity map). This field is ignored for
       * services with clusterIP = None, and should be omitted or set equal to the
       * 'port' field.
       *
       * For more information, see the
       * {@link https://kubernetes.io/docs/concepts/services-networking/service/#defining-a-service |
       * Kubernetes documentation}.
       */
      targetPort?: number | string;
  }/** @internal */
  const serviceResourceInfo: {
      kind: string;
      deployedWhen: typeof deployedWhen;
      statusQuery: (props: ResourcePropsWithConfig, observe: ObserveForStatus, buildData: BuildData) => Promise<any>;
  };/**
   * k8s ServiceAccount resource
   *
   * @param propsIn - props for ServiceAccount as specifed in {@link k8s.ServiceAccountProps}
   *
   * @public
   */
  export declare function ServiceAccount(propsIn: SFCDeclProps<ServiceAccountProps, typeof defaultProps>): Adapt.JSX.Element;/** @public */
  export declare function isServiceAccountProps(p: ResourceProps): p is ResourceProps & ResourceServiceAccount;/** @internal */
  const serviceAccountResourceInfo: {
      kind: string;
      deployedWhen: () => true;
      statusQuery: (props: ResourcePropsWithConfig, observe: ObserveForStatus, buildData: BuildData) => Promise<any>;
      makeManifest: (manifest: Manifest, elem: AdaptElement<ResourceProps>, _deployID: string) => {
          automountServiceAccountToken: boolean | undefined;
          imagePullSecrets: {
              name: string;
          }[] | undefined;
          secrets: ObjectReference[] | undefined;
          apiVersion: string;
          kind: string;
          metadata: import("./manifest_support").MetadataInRequest;
          spec?: import("./DaemonSet").DaemonSetSpec | import("./common").CRSpec | import("./Pod").PodSpec | import("./Service").ServiceSpec | import("./Deployment").DeploymentSpec | undefined;
      };
  };/**
   * Props for {@link k8s.ServiceDeployment}
   *
   * @public
   */
  export declare interface ServiceDeploymentProps<T extends AllowableComponentProps = DeploymentProps> extends ServiceProps {
      config: ClusterInfo;
      serviceProps?: Partial<ServiceProps>;
      component: ComponentType<T>;
      componentProps: T;
      podProps?: Partial<PodProps>;
      containerProps?: Partial<OmitT<K8sContainerProps, "image">>;
  }/**
   * A component for mapping a group of abstract {@link Container}s and
   * {@link NetworkService}s to Kubernetes {@link k8s.Pod}s and
   * {@link k8s.K8sContainer}s.
   *
   * @remarks
   * This component is intended to be used to replace {@link Container} and
   * {@link NetworkService} components that are grouped together, as the
   * only children of a common parent in a pattern that looks like this:
   *
   * ```tsx
   * <Service>
   *   <Container ... />
   *   <Container ... />
   *   <NetworkService ... />
   * </Service>
   * ```
   *
   * `ServiceDeployment` would map those abstract components into corresponding
   * k8s components like this:
   * ```tsx
   * <Group>
   *   <docker.RegistryDockerImage ... /> //If props.config specifies a registry
   *   <k8s.Deployment ... >
   *     <Pod isTemplate>
   *       <k8s.K8sContainer ... />
   *     </Pod>
   *   </k8s.Deployment>
   *   <docker.RegistryDockerImage ... /> //If props.config specifies a registry
   *   <k8s.Deployment ... >
   *     <Pod isTemplate>
   *       <k8s.K8sContainer ... />
   *     </Pod>
   *   </k8s.Pod>
   *   <k8s.Service ... />
   * </Group>
   * ```
   * An example style rule to do this is:
   * ```tsx
   * {Adapt.rule((matchedProps) => {
   *     const { handle, ...remainingProps } = matchedProps;
   *     return <ServiceDeployment config={kubeconfig} {...remainingProps} />;
   * })}
   * ```
   * `ServiceDeployment` also requires the `config` prop which specifies
   * connection and authentication information for the Kubernetes cluster on
   * which these objects should be created.
   *
   * @public
   */
  export declare class ServiceDeployment<T extends AllowableComponentProps> extends DeferredComponent<ServiceDeploymentProps<T>> {
      static defaultProps: {
          component: typeof Deployment;
          componentProps: {
              replicas: number;
          };
      };
      build(helpers: BuildHelpers): Adapt.JSX.Element;
  }/** @public */
  export declare function computeNamespaceFromMetadata(metadata?: Metadata): string;/** @public */
  export declare function isLabelSelector(x: any): x is LabelSelector;/**
   * Kubernetes Kind
   *
   * @public
   */
  export declare type Kind = string;/** @public */
  export declare interface CRSpec {
      [key: string]: any;
  }/** @public */
  export declare type Spec = DaemonSetSpec | DeploymentSpec | PodSpec | ServiceSpec | CRSpec;/** @public */
  export declare interface Metadata {
      namespace?: string;
      labels?: {
          [key: string]: string;
      };
      annotations?: {
          [key: string]: string;
      };
  }/** @public */
  export declare type ResourceProps = {
      key: string;
  } & (ResourceClusterRole | ResourceClusterRoleBinding | ResourceDaemonSet | ResourcePod | ResourceService | ResourceServiceAccount | ResourceConfigMap | ResourceSecret | ResourceCR);/** @public */
  export declare type ResourcePropsWithConfig = ResourceProps & {
      config: ClusterInfo;
  };/** @public */
  export declare interface ResourceInfo {
      kind: Kind;
      statusQuery?: (props: ResourceProps, observe: ObserveForStatus, buildData: BuildData) => unknown | Promise<unknown>;
      specsEqual(actual: Spec, element: Spec): boolean;
  }/**
   * Holds the information needed to connect, authenticate, and run code in a kuberenetes cluster
   *
   * @public
   */
  export declare interface ClusterInfo {
      /** Javascript object formed by parsing a valid kubeconfig file */
      kubeconfig: Kubeconfig;
      /**
       * Registry to which Docker images used by the cluster in `kubeconfig` should be pushed and pulled
       *
       * @remarks
       * If `registryPrefix` is a string, it is assumed that the cluster can pull from the same string
       * that outsiders can push to.
       *
       * If `registryPrefix` is of the form `{ external: string, internal: string }` then the `external`
       * string will be used to push images, and the `internal` string will be used to pull images.
       *
       * Note(manishv)
       * This is a bit of a hack to allow one hostname or IP address to push images from outside
       * a particular environment (say k8s) and a different URL for that environment to pull
       * images.
       *
       * A good example of this is a k3s-dind (k3s docker-in-docker) instance of kubernetes where
       * a private registry is running on a docker network attached to the k3s-dind instance, but where we
       * want to push {@link docker.LocalDockerImage} built images to that registry.  Since
       * {@link docker.LocalDockerImage | LocalDockerImage} is outside the k3s-dind environment, it must
       * use a host accessible network to push to the registry.  However, since the k3s-dind instance sees
       * the registry from within Docker, it must use a different address to pull the images for use.
       *
       * Once network scopes are fully supported, this interface will change to whatever is appropriate.  It
       * is best if you can arrange to have the same URL or registry string work for all access regardless
       * of which network the registry, Adapt host, and ultimate container running environment uses.
       *
       */
      registryPrefix?: string | DockerSplitRegistryInfo;
  }/** @public */
  export declare interface ResourceBase {
      /**
       * config to connect to the k8s cluster
       *
       * required if isTemplate is false
       */
      config?: ClusterInfo;
      /**
       * Specifies whether this resource is just a template for use in a controller
       */
      isTemplate?: boolean;
      apiVersion?: string;
      kind: Kind;
      metadata?: Metadata;
  }/**
   * @public
   */
  export declare interface PolicyRule {
      /**
       * APIGroups is the name of the APIGroup that contains the resources.
       *
       * If multiple API groups are specified, any action requested against one
       * of the enumerated resources in any API group will be allowed.
       */
      apiGroups?: string[];
      /**
       * NonResourceURLs is a set of partial urls that a user should have access to.
       *
       * *s are allowed, but only as the full, final step in the path.
       * Since non-resource URLs are not namespaced, this field is only applicable
       * for ClusterRoles referenced from a ClusterRoleBinding.
       * Rules can either apply to API resources (such as "pods" or "secrets") or
       * non-resource URL paths (such as "/api"), but not both.
       */
      nonResourceURLs?: string[];
      /**
       * ResourceNames is an optional white list of names that the rule applies to.
       *
       * An empty set means that everything is allowed.
       */
      resourceNames?: string[];
      /**
       * Resources is a list of resources this rule applies to.
       *
       * ResourceAll represents all resources.
       */
      resources: string[];
      /**
       * Verbs is a list of Verbs that apply to ALL the ResourceKinds and
       * AttributeRestrictions contained in this rule.
       *
       * VerbAll represents all kinds.
       */
      verbs: string[];
  }/**
   * AggregationRule for {@link k8s.ClusterRole}
   *
   * @public
   */
  export declare interface AggregationRule {
      /**
       * ClusterRoleSelectors holds a list of selectors which will be used to
       * find ClusterRoles and create the rules.
       *
       * If any of the selectors match, then the ClusterRole's permissions will be added
       */
      clusterRoleSelector: LabelSelector;
  }/** @public */
  export declare interface ResourceClusterRole extends ResourceBase {
      apiVersion: "rbac.authorization.k8s.io/v1";
      kind: "ClusterRole";
      aggregationRule?: AggregationRule;
      rules?: PolicyRule[];
  }/**
   * RoleRef for {@link k8s.ResourceClusterRoleBinding}
   *
   * @public
   */
  export declare interface RoleRef {
      /** apiGroup is the group for the resource being referenced */
      apiGroup: string;
      /** kind is the type of resource being referenced */
      kind: string;
      /** Name is the name of resource being referenced */
      name: string;
  }/**
   * Subject for {@link k8s.ResourceClusterRoleBinding}
   *
   * @public
   */
  export declare interface Subject {
      /** apiGroup is the group for the object being referenced */
      apiGroup: string;
      /** kind is the type of object being referenced */
      kind: string;
      /**
       * Name of the object being referenced.
       */
      name: string;
      /**
       * Namespace of the referenced object.
       *
       * If the object kind is non-namespace, such as "User" or "Group", and this value
       * is not empty the Authorizer should report an error.
       */
      namespace?: string;
  }/** @public */
  export declare interface ResourceClusterRoleBinding extends ResourceBase {
      apiVersion: "rbac.authorization.k8s.io/v1";
      kind: "ClusterRoleBinding";
      roleRef: RoleRef;
      subjects: Subject[];
  }/** @public */
  export declare interface ResourceDaemonSet extends ResourceBase {
      apiVersion: "apps/v1";
      kind: "DaemonSet";
      spec: DaemonSetSpec;
  }/** @public */
  export declare interface ResourcePod extends ResourceBase {
      kind: "Pod";
      spec: PodSpec;
  }/** @public */
  export declare interface ResourceService extends ResourceBase {
      kind: "Service";
      spec: ServiceSpec;
  }/** @public */
  export declare interface ResourceServiceAccount extends ResourceBase {
      kind: "ServiceAccount";
      automountServiceAccountToken?: boolean;
      imagePullSecrets?: {
          name: string;
      }[];
      secrets?: ObjectReference[];
  }/** @public */
  export declare interface ResourceConfigMap extends ResourceBase {
      kind: "ConfigMap";
      binaryData?: {
          [key: string]: string;
      };
      data?: {
          [key: string]: string;
      };
      /** @beta */
      immutable?: boolean;
  }/** @public */
  export declare interface ResourceSecret extends ResourceBase {
      kind: "Secret";
      data?: {
          [key: string]: string;
      };
      stringData?: {
          [key: string]: string;
      };
      type?: string;
  }/** @public */
  export declare interface ResourceCR extends ResourceBase {
      kind: string;
      spec: CRSpec;
  }/** @public */
  export declare interface Kubeconfig {
      apiVersion?: "v1";
      kind: "Config";
      "current-context": string;
      contexts: {
          name: string;
          context: {
              cluster: string;
              user: string;
          };
      }[];
      clusters: {
          name: string;
          cluster: {
              "certificate-authority-data": string;
              server: string;
          };
      }[];
      preferences?: unknown;
      users: {
          name: string;
          user: {
              "client-certificate-data"?: string;
              "client-key-data"?: string;
              "username"?: string;
              "password"?: string;
          };
      }[];
  }/** @public */
  export declare interface LabelSelector {
      /**
       * matchExpressions is a list of label selector requirements. The requirements are ANDed.
       */
      matchExpressions?: LabelSelectorRequirement[];
      /**
       * matchLabels is a map of `{key,value}`pairs. A single `{key,value}` in the matchLabels map
       * is equivalent to an element of matchExpressions, whose key field is "key", the operator
       * is "In", and the values array contains only "value". The requirements are ANDed.
       */
      matchLabels?: {
          [key: string]: string;
      };
  }/** @public */
  export declare interface LocalObjectReference {
      /**
       * Name of the referent.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names}
       */
      name: string;
  }/**
   * PodTemplateSpec from k8s API
   *
   * @public
   */
  export declare interface PodTemplateSpec {
      /**
       * Standard object's metadata.
       * More Info: {@link https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata}
       */
      metadata: Metadata;
      /**
       * Specification of the desired behavior of the pod.
       * More Info: {@link https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status}
       */
      spec: PodSpec;
  }/**
   * ObjectReference from k8s API
   *
   * @public
   */
  export declare interface ObjectReference {
      /**
       * If referring to a piece of an object instead of an entire object,
       * this string should contain a valid JSON/Go field access statement,
       * such as desiredState.manifest.containers[2].
       *
       * For example, if the object reference is to a container within a pod,
       * this would take on a value like: "spec.containers\{name\}" (where "name"
       * refers to the name of the container that triggered the event) or if no
       * container name is specified "spec.containers[2]"
       * (container with index 2 in this pod).
       * This syntax is chosen only to have some well-defined way of referencing a
       * part of an object.
       */
      fieldPath: string;
      /**
       * Name of the referent.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names}
       *
       */
      name: string;
      /**
       * Namespace of the referent.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/}
       */
      namespace: string;
      /**
       * Specific resourceVersion to which this reference is made, if any.
       *
       * More info: {@link https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency}
       */
      resourceVersion: string;
      /**
       * UID of the referent.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids}
       */
      uid: string;
  }/**
   * Make a {@link k8s.ClusterInfo} object suitable for use with k8s resources
   *
   * @remarks
   *
   * This function will take a set of options and generate a {@link k8s.ClusterInfo}
   * object that contains the kubeconfig, registryPrefix for private images, and any other
   * relevant information for the cluster
   *
   * See {@link k8s.MakeClusterInfoOptions} for information on how the information
   * is computed.
   *
   * @returns A {@link k8s.ClusterInfo} object.
   *
   * @public
   */
  export declare function makeClusterInfo(options: MakeClusterInfoOptions): Promise<ClusterInfo>;/** @internal */
  export declare function isResourcePodTemplate(x: any): x is AdaptElement<ResourcePod>;/**
   * Hook that allows a prop to be either an array of handle to k8s resources and values
   *
   * @param initial - initial value of the prop, before the handles are be resolved
   * @param notReady - is a marker value to indicate that a handle's value isn't available yet
   * @param kinds - an array of legal k8s Kinds that a prop handle can point to
   * @param thisResourceName - the name of the resource using the hook, for error messages
   * @param propName - the name of the prop being resolved, again for error messages
   *
   * @returns A two element array, the first element is the current value, the second the update function
   *
   * This hook will start by returning the initial value and an update function that updates
   * the value the hook returns.  The update function takes 2 arguments - the prop value which
   * is an array with a mix of values and handles to be resolved, and a function that receives
   * the elements that any handles point to along with that elements props.  This function
   * can be passed by the caller of update to resolve handles as appropriate for the component.
   *
   * For example, {@link k8s.ClusterRoleBinding} uses this hook to resolve the subjects prop,
   * which is an array of other objects (typically {@link ServiceAccount}) that a particular
   * {@link k8s.ClusterRole} should point to.  When ClusterRoleBinding calls the update method,
   * it passes a function that will convert a {@link k8s.Resource} element of Kind `ServiceAccount`
   * to the underlying `Subject` object that kubernetes expects, namely
   * `{ apiGroup: "", kind: "ServiceAccount", name: resourceIdToName(elem, deployID), namespace: <element namespace> }`
   *
   * @example
   * ```
   * function MyResource({ serviceAccountNames }: { serviceAccountNames: (string | Handle)[]}) {
   *   const { deployID } = useBuildHelpers();
   *   const [ resolvedServiceAccountNames, updateSANs] = useResources({
   *      initial: [],
   *      notReady: null,
   *      kinds: ["ServiceAccount"],
   *      thisResourceName: "MyResources",
   *      propName: "serviceAccountNames",
   *   });
   *
   *   updateSANs(serviceAccountNames, (e, props) => {
   *      return {
   *        apiGroup: (e.metadata.apiVersion?.split("/")[0]) || "",
   *        name: resourceElementToName(e, deployID),
   *        namespace: props.metadata.namespace,
   *      }
   *   });
   *
   *   return null;
   * }
   * ```
   *
   * @beta
   */
  export declare function useResources<ValT, NotReadyT>({ initial, notReady, kinds, thisResourceName, propName, }: {
      initial: ValT[];
      notReady: NotReadyT;
      kinds: string[];
      thisResourceName: string;
      propName: string;
  }): [
      (ValT | NotReadyT)[],
      (props: (ValT | Handle)[], f: (e: AdaptMountedElement, props: ResourceProps) => Promise<ValT> | ValT) => void
  ];/**
   * Hook to allow conversion of a prop that could be a value or a handle
   *
   * This function behaves similarly to {@link k8s.useResources}, but works for
   * a prop that is either a Handle or a single value instead of an array of
   * Handles and values.
   *
   * See {@link k8s.useResources} for more detailed documentation.
   *
   * @beta
   */
  export declare function useResource<ValT, NotReadyT>(opts: {
      initial: ValT | NotReadyT;
      notReady: NotReadyT;
      kinds: string[];
      thisResourceName: string;
      propName: string;
  }): [
      ValT | NotReadyT,
      (prop: ValT | Handle, f: (e: AdaptMountedElement, props: ResourceProps) => Promise<ValT> | ValT) => void
  ];/**
   * Options for {@link k8s.makeClusterInfo}
   *
   * @public
   */
  export declare interface MakeClusterInfoOptions {
      /**
       * A Javascript Object representing a valid kubeconfig, or a YAML string, or a path to a kubeconfig file.
       *
       * @remarks
       * If this is a Javascript object, it will be treated like a parsed kubeconfig.  If this is a string,
       * {@link k8s.makeClusterInfo} will first attempt to parse it as JSON.  If that fails, it will attempt
       * to parse it as YAML.  If that fails it will treat the string as a path of configs (like with the `KUBECONFIG`
       * environment variable).
       *
       * If kubeconfig is missing {@link k8s.makeClusterInfo} will use the `KUBECONFIG` environment variable to build
       * a suitable config using `kubectl config view --flatten` and return that as the kubeconfig in the resulting
       * {@link k8s.ClusterInfo}
       */
      kubeconfig?: Kubeconfig | string;
      /**
       * URL to the docker registry that this cluster uses to pull private images.
       *
       * @remarks
       * This is identical to the `registryPrefix` field in {@link k8s.ClusterInfo}.  It will
       * be returned verbatim in the resulting {@link k8s.ClusterInfo} object.
       */
      registryPrefix?: string | DockerSplitRegistryInfo;
  }/**
   * k8s ClusterRole resource
   *
   * @param propsIn - props for ServiceAccount as specifed in {@link k8s.ClusterRoleProps}
   *
   * @public
   */
  export declare function ClusterRole(propsIn: SFCDeclProps<ClusterRoleProps, typeof defaultProps>): Adapt.JSX.Element;/** @public */
  export declare function isClusterRoleProps(props: ResourceProps): props is ResourceProps & ResourceClusterRole;/** @internal */
  const clusterRoleResourceInfo: {
      kind: string;
      deployedWhen: () => true;
      statusQuery: (props: ResourcePropsWithConfig, observe: ObserveForStatus, buildData: BuildData) => Promise<any>;
      makeManifest: (manifest: Manifest, elem: AdaptElement<ResourceProps>, _deployID: string) => {
          aggregationRule: AggregationRule | undefined;
          rules: PolicyRule[] | undefined;
          apiVersion: string;
          kind: string;
          metadata: import("./manifest_support").MetadataInRequest;
          spec?: import("./DaemonSet").DaemonSetSpec | import("./common").CRSpec | import("./Pod").PodSpec | import("./Service").ServiceSpec | import("./Deployment").DeploymentSpec | undefined;
      };
  };/**
   * k8s ClusterRoleBinding resource
   *
   * @param propsIn - props for ServiceAccount as specifed in {@link k8s.ClusterRoleBindingProps}
   *
   * @public
   */
  export declare function ClusterRoleBinding(propsIn: SFCDeclProps<ClusterRoleBindingProps, typeof defaultProps>): Adapt.JSX.Element | null;/** @internal */
  const clusterRoleBindingResourceInfo: {
      kind: string;
      deployedWhen: () => true;
      statusQuery: (props: ResourcePropsWithConfig, observe: ObserveForStatus, buildData: BuildData) => Promise<any>;
      makeManifest: (manifest: Manifest, elem: AdaptElement<ResourceProps>, _deployID: string) => {
          roleRef: RoleRef;
          subjects: Subject[];
          apiVersion: string;
          kind: string;
          metadata: import("./manifest_support").MetadataInRequest;
          spec?: import("./DaemonSet").DaemonSetSpec | import("./common").CRSpec | import("./Pod").PodSpec | import("./Service").ServiceSpec | import("./Deployment").DeploymentSpec | undefined;
      };
  };/**
   * k8s ConfigMap resource
   *
   * @param propsIn - props for ConfigMap as specifed in {@link k8s.ConfigMapProps}
   *
   * @public
   */
  export declare function ConfigMap(propsIn: SFCDeclProps<ConfigMapProps, typeof defaultProps>): Adapt.JSX.Element;/** @internal */
  const configMapResourceInfo: {
      kind: string;
      deployedWhen: () => true;
      statusQuery: (props: ResourcePropsWithConfig, observe: ObserveForStatus, buildData: BuildData) => Promise<any>;
      makeManifest: (manifest: Manifest, elem: AdaptElement<ResourceProps>, _deployID: string) => {
          data: {
              [key: string]: string;
          } | undefined;
          binaryData: {
              [key: string]: string;
          } | undefined;
          immutable: boolean | undefined;
          apiVersion: string;
          kind: string;
          metadata: import("./manifest_support").MetadataInRequest;
          spec?: import("./DaemonSet").DaemonSetSpec | import("./common").CRSpec | import("./Pod").PodSpec | import("./Service").ServiceSpec | import("./Deployment").DeploymentSpec | undefined;
      };
  };/**
   * Low level utility function to translate from the abstract {@link Container}
   * component props ({@link ContainerProps}) to {@link k8s.K8sContainerProps}
   * to be used in a {@link k8s.K8sContainer}.
   * @remarks
   * Note: The `image` property in the passed in {@link ContainerProps} must
   * be a `string`, not a `Handle`.
   * In most cases, it is preferable to use the {@link k8s.Container} component
   * instead, which is designed specifically to deal with this issue.
   *
   * @param abstractProps - The abstract {@link ContainerProps} to translate from.
   * @param k8sProps - Props that are specific to the {@link k8s.K8sContainer}
   *     component that should be merged into the resulting returned
   *     {@link k8s.K8sContainerProps} object.
   * @public
   */
  export declare function k8sContainerProps(abstractProps: FromContainerProps, k8sProps?: Partial<K8sContainerProps>): K8sContainerProps;/**
   * Tests whether an element is a {@link k8s.K8sContainer} element
   * @param x - element to test
   * @returns `true` if element is a {@link k8s.K8sContainer}, `false` otherwise
   *
   * @remarks
   * Acts as a TypeScript type assertion that will assert that `x` is `AdaptElement<K8sContainerProps>`
   *
   * @public
   */
  export declare function isK8sContainerElement(x: AdaptElement): x is AdaptElement<K8sContainerProps>;/**
   * Component that implements the abstract {@link Container} interface and
   * translates to a Kubernetes-specific {@link k8s.K8sContainer}.
   * @public
   */
  export declare function Container(props: ContainerProps): Adapt.JSX.Element | null;/** @public */
  export declare interface VolumeMount {
      /**
       * Path within the container at which the volume should be mounted.
       *
       * Must not contain ':'.
       */
      mountPath: string;
      /**
       * mountPropagation determines how mounts are propagated from the host to container and the other way around.
       *
       * When not set, MountPropagationNone is used. This field is beta in 1.10.
       *
       * @defaultValue MountPropagationNone
       */
      mountPropagation?: string;
      /** This must match the Name of a Volume. */
      name: string;
      /**
       * Mounted read-only if true, read-write otherwise (false or unspecified).
       *
       * @defaultValue false
       */
      readOnly?: boolean;
      /**
       * Path within the volume from which the container's volume should be mounted.
       *
       * Defaults to "" (volume's root).
       *
       * @defaultValue ""
       */
      subPath?: string;
      /**
       * Expanded path within the volume from which the container's volume should be mounted.
       *
       * Behaves similarly to SubPath but environment variable references $(VAR_NAME)
       * are expanded using the container's environment.
       *
       * Defaults to "" (volume's root).
       *
       * SubPathExpr and SubPath are mutually exclusive.
       *
       * @defaultValue ""
       */
      subPathExpr?: string;
  }/** @public */
  export declare interface ConfigMapEnvSource {
      /**
       * Name of the referent.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names}
       */
      name?: string;
      /**
       * Specify whether the ConfigMap must be defined
       */
      optional?: boolean;
  }/** @public */
  export declare interface SecretEnvSource {
      /**
       * Name of the referent.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names}
       */
      name?: string;
      /**
       * Specify whether the Secret must be defined
       */
      optional?: boolean;
  }/** @public */
  export declare interface EnvFromSource {
      /** The ConfigMap to select from */
      configMapRef?: ConfigMapEnvSource;
      /** An optional identifier to prepend to each key in the ConfigMap. Must be a C_IDENTIFIER. */
      prefix?: string;
      /** SecretEnvSource	The Secret to select from */
      secretRef?: SecretEnvSource;
  }/** @public */
  export declare interface ExecAction {
      /**
       * Command is the command line to execute inside the container.
       *
       * The working directory for the command is root ('/') in the container's filesystem.
       * The command is simply exec'd, it is not run inside a shell,
       * so traditional shell instructions ('|', etc) won't work.
       * To use a shell, you need to explicitly call out to that shell.
       *
       * Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
       */
      command: string[];
  }/** @public */
  export declare interface HTTPGetAction {
      /**
       * Host name to connect to, defaults to the pod IP.
       *
       * You probably want to set "Host" in httpHeaders instead.
       */
      host?: string;
      /** Custom headers to set in the request. HTTP allows repeated headers. */
      httpHeaders?: {
          name: string;
          value: string;
      }[];
      /** Path to access on the HTTP server. */
      path: string;
      /**
       * Name or number of the port to access on the container.
       *
       * Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
       */
      port: number | string;
      /**
       * Scheme to use for connecting to the host.
       *
       * @defaultValue HTTP.
       */
      scheme?: string;
  }/** @public */
  export declare interface TCPSocketAction {
      /** Host name to connect to, defaults to the pod IP. */
      host?: string;
      /**
       * Number or name of the port to access on the container.
       *
       * Number must be in the range 1 to 65535.
       * Name must be an IANA_SVC_NAME.
       */
      port: string | number;
  }/** @public */
  export declare interface Probe {
      /**
       * Exec specifies the action to take.
       *
       * Only one of exec, httpGet, or tcpSocket should be specified
       */
      exec?: ExecAction;
      /**
       * Minimum consecutive failures for the probe to be considered failed after having succeeded.
       *
       * Defaults to 3. Minimum value is 1.
       *
       * @defaultValue 3
       */
      failureThreshold?: number;
      /** Specifies the http request to perform. */
      httpGet?: HTTPGetAction;
      /**
       *  Seconds after the container has started before liveness probes are initiated.
       *  More info: {@link https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes}
       */
      initialDelaySeconds?: number;
      /** How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. */
      periodSeconds?: number;
      /**
       * Minimum consecutive successes for the probe to be considered successful after having failed.
       *
       * Must be 1 for liveness and startup. Minimum value is 1.
       *
       * @defaultValue 1
       */
      successThreshold?: number;
      /**
       * Specifies an action involving a TCP port.
       *
       * TCP hooks not yet supported
       */
      tcpSocket?: TCPSocketAction;
      /**
       * Number of seconds after which the probe times out.
       *
       * Defaults to 1 second. Minimum value is 1.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes}
       *
       * @defaultValue 1
       */
      timeoutSeconds?: number;
  }/** @public */
  export declare interface ResourceRequirements {
      /**
       * Limits describes the maximum amount of compute resources allowed.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/}
       */
      limits?: {
          [key: string]: any;
      };
      /**
       * Describes the minimum amount of compute resources required.
       *
       * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
       * otherwise to an implementation-defined value.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/}
       */
      requests?: {
          [key: string]: any;
      };
  }/** @public */
  export declare type Handler = {
      exec: ExecAction;
  } | {
      httpGet: HTTPGetAction;
  } | {
      tcpSocket: TCPSocketAction;
  };/** @public */
  export declare interface Lifecycle {
      /**
       * PostStart is called immediately after a container is created.
       *
       * If the handler fails, the container is terminated and restarted according to its restart policy.
       * Other management of the container blocks until the hook completes.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks}
       */
      postStart: Handler;
      /**
       * Called immediately before a container is terminated due to an API request or management event such as liveness/startup probe failure, preemption, resource contention, etc.
       *
       * The handler is not called if the container crashes or exits.
       * The reason for termination is passed to the handler.
       * The Pod's termination grace period countdown begins before the PreStop hooked is executed.
       * Regardless of the outcome of the handler, the container will eventually terminate within the Pod's termination grace period.
       * Other management of the container blocks until the hook completes or until the termination grace period is reached.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks}
       */
      preStop: Handler;
  }/** @public */
  export declare interface VolumeDevice {
      /** The path inside of the container that the device will be mapped to. */
      devicePath: string;
      /** name must match the name of a persistentVolumeClaim in the pod */
      name: string;
  }/**
   * Resource spec for a Kubernetes container.
   * See the Kubernetes
   * {@link https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#container-v1-core | API docs }
   * for more details.
   * @public
   */
  export declare interface ContainerSpec {
      /**
       * Arguments to the entrypoint.
       *
       * The docker image's CMD is used if this is not provided.
       * Variable references $(VAR_NAME) are expanded using the container's environment.
       * If a variable cannot be resolved, the reference in the input string will be unchanged.
       * The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME).
       * Escaped references will never be expanded, regardless of whether the variable exists or not.
       * Cannot be updated.
       * More info: {@link https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell}
       */
      args?: string[];
      /**
       * Entrypoint array.
       *
       * Not executed within a shell.
       * The docker image's ENTRYPOINT is used if this is not provided.
       * Variable references $(VAR_NAME) are expanded using the container's environment.
       * If a variable cannot be resolved, the reference in the input string will be unchanged.
       * The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME).
       * Escaped references will never be expanded, regardless of whether the variable exists or not.
       * Cannot be updated.
       * More info: {@link https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell}
       */
      command?: string[];
      /**
       * List of environment variables to set in the container. Cannot be updated.
       */
      env?: EnvVar[];
      /**
       * List of sources to populate environment variables in the container.
       *
       * The keys defined within a source must be a C_IDENTIFIER.
       * All invalid keys will be reported as an event when the container is starting.
       * When a key exists in multiple sources, the value associated with the last source will take precedence.
       * Values defined by an Env with a duplicate key will take precedence. Cannot be updated.
       */
      envFrom?: EnvFromSource[];
      /**
       * Docker image name.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/containers/images}
       *
       * This field is optional to allow higher level config management to default or override container
       * images in workload controllers like Deployments and StatefulSets.
       */
      image?: string;
      /**
       * Image pull policy.
       *
       * One of Always, Never, IfNotPresent.
       * Defaults to Always if :latest tag is specified,
       * or IfNotPresent otherwise.
       * Cannot be updated.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/containers/images#updating-images}
       */
      imagePullPolicy?: "Always" | "Never" | "IfNotPresent";
      /**
       * List of sources to populate environment variables in the container.
       *
       * The keys defined within a source must be a C_IDENTIFIER.
       * All invalid keys will be reported as an event when the container is starting.
       * When a key exists in multiple sources, the value associated with the last source will take precedence.
       * Values defined by an Env with a duplicate key will take precedence. Cannot be updated.
       */
      lifecycle?: Lifecycle;
      /**
       * Periodic probe of container liveness.
       *
       * Container will be restarted if the probe fails.
       * Cannot be updated.
       * More info: {@link https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes}
       */
      livenessProbe?: Probe;
      /**
       * Name of the container specified as a DNS_LABEL.
       *
       * Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated.
       */
      name: string;
      /**
       * List of ports to expose from the container.
       *
       * Exposing a port here gives the system additional information about the network connections a container uses,
       * but is primarily informational.
       * Not specifying a port here DOES NOT prevent that port from being exposed.
       * Any port which is listening on the default "0.0.0.0" address inside a container will be accessible from
       * the network.
       * Cannot be updated.
       */
      ports?: ContainerPort[];
      /**
       * Periodic probe of container service readiness.
       *
       * Container will be removed from service endpoints if the probe fails.
       * Cannot be updated.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes}
       */
      readinessProbe?: Probe;
      /**
       * Compute Resources required by this container.
       *
       * Cannot be updated.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/}
       */
      resources?: ResourceRequirements;
      /**
       * Security options the pod should run with.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/policy/security-context/}
       * More info: {@link https://kubernetes.io/docs/tasks/configure-pod-container/security-context/}
       */
      securityContext?: PodSecurityContext;
      /**
       * Indicates that the Pod has successfully initialized.
       *
       * If specified, no other probes are executed until this completes successfully.
       * If this probe fails, the Pod will be restarted, just as if the livenessProbe failed.
       * This can be used to provide different probe parameters at the beginning of a Pod's lifecycle,
       * when it might take a long time to load data or warm a cache, than during steady-state operation.
       *
       * This cannot be updated.
       * This is a beta feature enabled by the StartupProbe feature flag.
       * More info: {@link https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes}
       */
      startupProbe?: Probe;
      /**
       * Whether this container should allocate a buffer for stdin in the container runtime.
       *
       * If this is not set, reads from stdin in the container will always result in EOF. Default is false.
       */
      stdin?: boolean;
      /**
       * Whether the container runtime should close the stdin channel after it has been opened by a single attach.
       *
       * When stdin is true the stdin stream will remain open across multiple attach sessions.
       * If stdinOnce is set to true, stdin is opened on container start,
       * is empty until the first client attaches to stdin,
       * and then remains open and accepts data until the client disconnects,
       * at which time stdin is closed and remains closed until the container is restarted.
       * If this flag is false, a container processes that reads from stdin will never receive an EOF. Default is false
       */
      stdinOnce?: boolean;
      /**
       * Path at which the file to which the container's termination message will be written is mounted into the container's filesystem.
       *
       * Message written is intended to be brief final status, such as an assertion failure message.
       * Will be truncated by the node if greater than 4096 bytes.
       * The total message length across all containers will be limited to 12kb.
       * Defaults to /dev/termination-log. Cannot be updated.
       */
      terminationMessagePath?: string;
      /**
       * Indicate how the termination message should be populated.
       *
       * File will use the contents of terminationMessagePath to populate the container status
       * message on both success and failure. FallbackToLogsOnError will use the last chunk of
       * container log output if the termination message file is empty and the container exited
       * with an error.
       * The log output is limited to 2048 bytes or 80 lines, whichever is smaller.
       * Defaults to File.
       * Cannot be updated.
       *
       * @defaultValue File
       */
      terminationMessagePolicy?: "File" | "FallbackToLogsOnError";
      /**
       * Whether this container should allocate a TTY for itself, also requires 'stdin' to be true.
       *
       * @defaultValue false
       */
      tty?: boolean;
      /**
       * volumeDevices is the list of block devices to be used by the container.
       */
      volumeDevices?: VolumeDevice[];
      /** volumeDevices is the list of block devices to be used by the container. */
      volumeMounts?: VolumeMount[];
      /**
       * Container's working directory.
       *
       * If not specified, the container runtime's default will be used,
       * which might be configured in the container image.
       * Cannot be updated.
       */
      workingDir?: string;
  }/**
   * Props for the Kubernetes-specific {@link k8s.K8sContainer} component.
   * @public
   */
  export declare interface K8sContainerProps extends ContainerSpec {
  }/** @public */
  export declare interface ContainerPort {
      /**
       * Number of port to expose on the pod's IP address.
       * @remarks
       * This must be a valid integer port number, `0 < x < 65536`.
       */
      containerPort: number;
      /** What host IP to bind the external port to. */
      hostIP?: string;
      /**
       * Number of port to expose on the host.
       * @remarks
       * If specified, this must be a valid integer port number,
       * `0 < x < 65536`. If HostNetwork is specified,
       * this must match ContainerPort. Most containers do not need this.
       */
      hostPort?: number;
      /**
       * A unique-within-pod name for the container
       * @remarks
       * If specified, this must be an IANA_SVC_NAME and unique within the pod.
       * Each named port in a pod must have a unique name. Name for the port
       * that can be referred to by services.
       */
      name?: string;
      /** Protocol for port. Must be UDP or TCP. Defaults to "TCP". */
      protocol?: string;
  }/** @public */
  export declare type EnvVar = EnvVarSimple | EnvVarFrom;/** @public */
  export declare interface EnvVarSimple {
      /** Name of the environment variable. Must be a C_IDENTIFIER. */
      name: string;
      /**
       * Variable references $(VAR_NAME) are expanded using the previous defined
       * environment variables in the container and any service environment
       * variables. If a variable cannot be resolved, the reference in the input
       * string will be unchanged. The $(VAR_NAME) syntax can be escaped with a
       * double $$, ie: $$(VAR_NAME). Escaped references will never be expanded,
       * regardless of whether the variable exists or not. Defaults to "".
       */
      value: string;
  }/** @public */
  export declare interface EnvVarFrom {
      /** Source for the environment variable's value. Cannot be used if value is not empty. */
      valueFrom?: any;
  }/**
   * See {@link k8s.k8sContainerProps}.
   * @public
   */
  export declare type FromContainerProps = ReplaceT<ContainerProps, {
      image: string;
  }> & BuiltinProps;/**
   * Kubernetes-specific container.
   * @public
   */
  export declare class K8sContainer extends PrimitiveComponent<K8sContainerProps> {
      static defaultProps: {
          imagePullPolicy: string;
      };
      validate(): undefined;
  }/**
   * Props for {@link k8s.Container}.
   * @public
   */
  export declare interface ContainerProps extends SFCDeclProps<ContainerProps> {
      /**
       * Additional {@link k8s.K8sContainerProps}-specific props that should be
       * added to the instantiated {@link k8s.K8sContainer}.
       */
      k8sContainerProps?: Partial<K8sContainerProps>;
  }/**
   * Spec for {@link k8s.DaemonSet} for use in {@link k8s.Resource}
   *
   * @public
   */
  export declare type DaemonSetSpec = Exclude<DaemonSetProps, ResourceBase> & {
      template: PodTemplateSpec;
  };/**
   * Component for Kubernetes DaemonSet
   *
   * @public
   */
  export declare class DaemonSet extends DeferredComponent<DaemonSetProps> {
      static defaultProps: {
          metadata: {};
          minReadySeconds: number;
          revisionHistoryLimit: number;
          updateStrategy: {
              type: string;
              rollingUpdate: {
                  maxUnavailable: number;
              };
          };
      };
      constructor(props: DaemonSetProps);
      build(helpers: BuildHelpers): Adapt.JSX.Element;
      status(_observe: ObserveForStatus, buildData: BuildData): Promise<Adapt.Status | undefined>;
  }/** @internal */
  const daemonSetResourceInfo: {
      kind: string;
      deployedWhen: typeof deployedWhen;
      statusQuery: (props: ResourcePropsWithConfig, observe: ObserveForStatus, buildData: BuildData) => Promise<any>;
  };/** @public */
  export declare interface DeploymentUpdateStrategyRecreate {
      type: "Recreate";
  }/** @public */
  export declare interface RollingUpdateDeployment {
      /**
       * The maximum number of pods that can be scheduled above the desired number of pods.
       *
       * Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
       * This can not be 0 if MaxUnavailable is 0.
       * Absolute number is calculated from percentage by rounding up.
       * Defaults to 25%.
       *
       * @example
       * When this is set to 30%, the new ReplicaSet can be scaled up immediately when the rolling update starts,
       * such that the total number of old and new pods do not exceed 130% of desired pods. Once old pods have been
       * killed, new ReplicaSet can be scaled up further, ensuring that total number of pods running at any time
       * during the update is at most 130% of desired pods.
       */
      maxSurge?: number | string;
      /**
       * The maximum number of pods that can be unavailable during the update.
       *
       * Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
       * Absolute number is calculated from percentage by rounding down.
       * This can not be 0 if MaxSurge is 0. Defaults to 25%.
       *
       * @example
       * When this is set to 30%, the old ReplicaSet can be scaled down to 70% of desired pods
       * immediately when the rolling update starts. Once new pods are ready, old ReplicaSet
       * can be scaled down further, followed by scaling up the new ReplicaSet, ensuring that
       * the total number of pods available at all times during the update is at least 70% of
       * desired pods.
       */
      maxUnavailable?: number | string;
  }/**
   * Spec for {@link k8s.Deployment} for use in {@link k8s.Resource}
   *
   * @public
   */
  export declare type DeploymentSpec = Exclude<DeploymentProps, ResourceBase> & {
      template: PodTemplateSpec;
  };/**
   * Props for {@link k8s.Deployment}
   *
   * @public
   */
  export declare interface DeploymentProps extends WithChildren {
      /** Information about the k8s cluster (ip address, auth info, etc.) */
      config: ClusterInfo;
      /** k8s metadata */
      metadata: Metadata;
      /**
       * The minimum number of seconds for which a newly created pod should
       * be ready without any of its container crashing, for it to be considered
       * available. Defaults to 0 (pod will be considered available as soon as it is ready).
       */
      minReadySeconds: number;
      /** Indicates that the deployment is paused */
      paused: boolean;
      /**
       * The maximum time in seconds for a deployment to make progress before it is considered to be failed.
       *
       * The deployment controller will continue to process failed deployments and a condition with a
       * ProgressDeadlineExceeded reason will be surfaced in the deployment status. Note that progress
       * will not be estimated during the time a deployment is paused. Defaults to 600s.
       */
      progressDeadlineSeconds: number;
      /**
       * Number of desired pods.
       *
       * Defaults to 1. 0 is not allowed.
       *
       * @defaultValue 1
       */
      replicas: number;
      /**
       * The number of old ReplicaSets to retain to allow rollback.
       *
       * This is a pointer to distinguish between explicit zero and not specified. Defaults to 10.
       *
       * @defaultValue 10
       */
      revisionHistoryLimit: number;
      /**
       * Label selector for pods.
       *
       * Existing ReplicaSets whose pods are selected by this will be the ones affected by this deployment.
       * It must match the pod template's labels.
       *
       * @remarks
       *
       * With Adapt, this is optional.  If not specified, adapt will pick a selector that will work with the pods
       * it creates as part of this {@link k8s.Deployment}
       */
      selector?: LabelSelector;
      /**
       * An deployment strategy to use to replace existing pods with new ones
       */
      strategy: DeploymentUpdateStrategy;
  }/**
   * Component for Kubernetes Deployment
   *
   * @public
   */
  export declare class Deployment extends DeferredComponent<DeploymentProps> {
      static defaultProps: {
          metadata: {};
          paused: boolean;
          replicas: number;
          progressDeadlineSeconds: number;
          minReadySeconds: number;
          revisionHistoryLimit: number;
          strategy: {
              type: string;
              rollingUpdate: {
                  maxSurge: string;
                  maxUnavailable: string;
              };
          };
      };
      constructor(props: DeploymentProps);
      build(helpers: BuildHelpers): Adapt.JSX.Element | null;
      deployedWhen: () => true | Adapt.Waiting;
      status(_observe: ObserveForStatus, buildData: BuildData): Promise<Adapt.Status | undefined>;
  }/** @internal */
  const deploymentResourceInfo: {
      kind: string;
      deployedWhen: typeof deployedWhen;
      statusQuery: (props: ResourcePropsWithConfig, observe: ObserveForStatus, buildData: BuildData) => Promise<any>;
  };/**
   * Type assertion to see if an element is both a {@link k8s.Resource | Resource}
   * and a {@link @adpt/core#FinalElement | FinalElement}
   *
   * @param e - element to test
   * @returns `true` if e is both a FinalElement and a {@link k8s.Resource | Resource}, `false` otherwise
   *
   * @public
   */
  export declare function isResourceFinalElement(e: AdaptElement): e is FinalDomElement<ResourceProps & Adapt.BuiltinProps>;/**
   * Tests whether a ResourceProps is for a template object
   *
   * @public
   */
  export declare function isResourcePropsWithConfig(x: ResourceProps & Partial<BuiltinProps>): x is ResourcePropsWithConfig & Partial<BuiltinProps>;/**
   * Tests to see if an object is a {@link k8s.Resource} element
   * @param x - object to test
   * @returns true if object is an AdaptElement of type {@link k8s.Resource}
   *
   * @public
   */
  export declare function isResource(x: any): x is AdaptElement<ResourceProps>;/**
   * Primitive Component recognized by the k8s plugin to represent resources
   * @public
   */
  export declare class Resource extends Action<ResourceProps> {
      defaultProps: {
          apiVersion: "v1";
          con: false;
      };
      manifest_: Manifest;
      constructor(props: ResourceProps);
      validate(): "Resource elements cannot have children" | undefined;
      shouldAct(op: ChangeType, ctx: ActionContext): Promise<ShouldAct>;
      action(op: ChangeType, ctx: ActionContext): Promise<void>;
      deployedWhen: (goalStatus: GoalStatus, helpers: DeployHelpers) => Promise<true | Adapt.Waiting | Adapt.Waiting[]>;
      status(observe: ObserveForStatus, buildData: BuildData): Promise<any>;
      private mountedElement;
      private manifest;
  }/** @internal */
  export declare function makePodManifest(props: PodProps & BuiltinProps, data: {
      volumes?: Volume[];
      serviceAccountName?: string;
  }): {
      kind: string;
      metadata: Metadata;
      spec: PodSpec;
  };/**
   * Tests whether x is a Pod element
   *
   * @param x - value to test
   * @returns `true` if x is a Pod element, false otherwise
   *
   * @public
   */
  export declare function isPod(x: any): x is AdaptElement<PodProps>;/** @public */
  export declare interface NodeSelectorRequirement {
      /** The label key that the selector applies to. */
      key: string;
      /**
       * Represents a key's relationship to a set of values.
       *
       * Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
       */
      operator: "In" | "NotIn" | "Exists" | "DoesNotExist" | "Gt" | "Lt";
      /**
       * Values for operator
       *
       * If the operator is In or NotIn, the values array must be non-empty.
       * If the operator is Exists or DoesNotExist, the values array must be empty.
       * If the operator is Gt or Lt, the values array must have a single element,
       * which will be interpreted as an integer.
       * This array is replaced during a strategic merge patch.
       */
      values: string[];
  }/** @public */
  export declare interface NodeSelectorTerm {
      /** A list of node selector requirements by node's labels. */
      matchExpressions?: NodeSelectorRequirement[];
      /** A list of node selector requirements by node's fields. */
      matchFields?: NodeSelectorRequirement[];
  }/** @public */
  export declare interface PreferredSchedulingTerm {
      /**
       * A node selector term, associated with the corresponding weight.
       */
      preference: NodeSelectorTerm;
      /** Weight associated with matching the corresponding nodeSelectorTerm, in the range 1-100. */
      weight: number;
  }/** @public */
  export declare interface NodeSelector {
      /** A list of node selector terms. The terms are ORed */
      nodeSelectorTerms: NodeSelectorTerm[];
  }/** @public */
  export declare interface NodeAffinity {
      /** The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding "weight" to the sum if the node matches the corresponding matchExpressions; the node(s) with the highest sum are the most preferred. */
      preferredDuringSchedulingIgnoredDuringExecution?: PreferredSchedulingTerm[];
      /** If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to an update), the system may or may not try to eventually evict the pod from its node. */
      requiredDuringSchedulingIgnoredDuringExecution?: NodeSelector;
  }/** @public */
  export declare interface PodAffinityTerm {
      /**
       * Label query over a set of resources, in this case pods.
       */
      labelSelector: LabelSelector;
      /** Specifies which namespaces the labelSelector applies to (matches against); null or empty list means "this pod's namespace" */
      namespaces?: string[];
      /** This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed. */
      topologyKey: string;
  }/** @public */
  export declare interface WeightedPodAffinityTerm {
      /** A pod affinity term, associated with the corresponding weight. */
      podAffinityTerm: PodAffinityTerm;
      /**
       * weight associated with matching the corresponding podAffinityTerm, in the range 1-100.
       */
      weight: number;
  }/** @public */
  export declare interface PodAffinity {
      /**
       * The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions.
       *
       * The node that is most preferred is the one with the greatest sum of weights,
       * i.e. for each node that meets all of the scheduling requirements (resource request,
       * requiredDuringScheduling affinity expressions, etc.), compute a sum by iterating
       * through the elements of this field and adding "weight" to the sum if the node has pods
       * which matches the corresponding podAffinityTerm; the node(s) with the highest sum are the most preferred.
       */
      preferredDuringSchedulingIgnoredDuringExecution: WeightedPodAffinityTerm[];
      /**
       * If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node.
       *
       * If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system may or may not try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each podAffinityTerm are intersected, i.e. all terms must be satisfied.
       */
      requiredDuringSchedulingIgnoredDuringExecution: PodAffinityTerm[];
  }/** @public */
  export declare interface PodAntiAffinity {
      /** The scheduler will prefer to schedule pods to nodes that satisfy the anti-affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling anti-affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the node(s) with the highest sum are the most preferred. */
      preferredDuringSchedulingIgnoredDuringExecution: WeightedPodAffinityTerm[];
      /** If the anti-affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the anti-affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system may or may not try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each podAffinityTerm are intersected, i.e. all terms must be satisfied. */
      requiredDuringSchedulingIgnoredDuringExecution: PodAffinity;
  }/** @public */
  export declare interface Affinity {
      /** Describes node affinity scheduling rules for the pod. */
      nodeAffinity: NodeAffinity;
      /** Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)). */
      podAffinity: PodAffinity;
      /** PodAntiAffinity	Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)). */
      podAntiAffinity: PodAntiAffinity;
  }/** @public */
  export declare interface PodDNSConfigOption {
      name: string;
      value?: string;
  }/** @public */
  export declare interface PodDNSConfig {
      /**
       * A list of DNS name server IP addresses.
       *
       * This will be appended to the base nameservers generated from DNSPolicy. Duplicated nameservers will be removed.
       */
      nameservers: string[];
      /**
       * A list of DNS resolver options.
       *
       * This will be merged with the base options generated from DNSPolicy.
       * Duplicated entries will be removed.
       * Resolution options given in Options will override those that appear in the base DNSPolicy.
       */
      options: PodDNSConfigOption[];
      /**
       * A list of DNS search domains for host-name lookup.
       *
       * This will be appended to the base search paths generated from DNSPolicy. Duplicated search paths will be removed.
       */
      searches: string[];
  }/** @public */
  export declare interface PodReadinessGate {
      /** Refers to a condition in the pod's condition list with matching type. */
      conditionType: string;
  }/** @public */
  export declare interface SELinuxOptions {
      /** SELinux level label that applies to the container. */
      level: string;
      /** SELinux role label that applies to the container. */
      role: string;
      /** SELinux type label that applies to the container. */
      type: string;
      /** SELinux user label that applies to the container */
      user: string;
  }/** @public */
  export declare interface SeccompProfile {
      /**
       * Indicates a profile defined in a file on the node should be used.
       *
       * The profile must be preconfigured on the node to work.
       * Must be a descending path, relative to the kubelet's configured seccomp profile location.
       * Must only be set if type is "Localhost".
       */
      localhostProfile?: string;
      /**
       * Indicates which kind of seccomp profile will be applied.
       *
       * Valid options are:
       * * Localhost - a profile defined in a file on the node should be used.
       * * RuntimeDefault - the container runtime default profile should be used.
       * * Unconfined - no profile should be applied.
       */
      type: "Localhost" | "RuntimeDefault" | "Unconfined";
  }/** @public */
  export declare interface Sysctl {
      name: string;
      value: string;
  }/** @public */
  export declare interface WindowsSecurityContextOptions {
      /**
       * The GMSA admission webhook ({@link https://github.com/kubernetes-sigs/windows-gmsa}) inlines the contents of the GMSA credential spec named by the GMSACredentialSpecName field.
       */
      gmsaCredentialSpec?: string;
      /**
       * GMSACredentialSpecName is the name of the GMSA credential spec to use.
       */
      gmsaCredentialSpecName?: string;
      /**
       * The UserName in Windows to run the entrypoint of the container process.
       *
       * Defaults to the user specified in image metadata if unspecified. May also be set in PodSecurityContext.
       * If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
       */
      runAsUserName?: string;
  }/** @public */
  export declare interface PodSecurityContext {
      /**
       * A special supplemental group that applies to all containers in a pod.
       *
       * Some volume types allow the Kubelet to change the ownership of that volume to be owned by the pod:
       *
       * 1. The owning GID will be the FSGroup
       * 2. The setgid bit is set (new files created in the volume will be owned by FSGroup)
       * 3. The permission bits are OR'd with rw-rw----
       *
       * If unset, the Kubelet will not modify the ownership and permissions of any volume.
       */
      fsGroup?: number;
      /**
       * Defines behavior of changing ownership and permission of the volume before being exposed inside Pod.
       *
       * This field will only apply to volume types which support fsGroup based ownership(and permissions).
       * It will have no effect on ephemeral volume types such as: secret, configmaps and emptydir.
       * Valid values are "OnRootMismatch" and "Always". If not specified defaults to "Always".
       *
       * @defaultValue Always
       */
      fsGroupChangePolicy?: "OnRootMismatch" | "Always";
      /**
       * The GID to run the entrypoint of the container process.
       *
       * Uses runtime default if unset. May also be set in SecurityContext.
       * If set in both SecurityContext and PodSecurityContext, the value specified in
       * SecurityContext takes precedence for that container.
       */
      runAsGroup?: number;
      /**
       * Indicates that the container must run as a non-root user.
       *
       * If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and
       * fail to start the container if it does. If unset or false, no such validation will be performed.
       * May also be set in SecurityContext.
       * If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
       */
      runAsNonRoot?: boolean;
      /**
       * The UID to run the entrypoint of the container process.
       *
       * Defaults to user specified in image metadata if unspecified.
       * May also be set in SecurityContext.
       * If set in both SecurityContext and PodSecurityContext, the value specified in
       * SecurityContext takes precedence for that container.
       */
      runAsUser?: number;
      /**
       * The SELinux context to be applied to all containers.
       *
       * If unspecified, the container runtime will allocate a random SELinux context for each container.
       * May also be set in SecurityContext.
       * If set in both SecurityContext and PodSecurityContext, the value specified in
       * SecurityContext takes precedence for that container.
       */
      seLinuxOptions?: SELinuxOptions;
      /**
       * The seccomp options to use by the containers in this pod.
       */
      seccompProfile?: SeccompProfile;
      /**
       * 	A list of groups applied to the first process run in each container, in addition to the container's primary GID.
       *
       *  If unspecified, no groups will be added to any container.
       */
      supplementalGroups?: number[];
      /**
       * Sysctls hold a list of namespaced sysctls used for the pod.
       *
       * Pods with unsupported sysctls (by the container runtime) might fail to launch.
       */
      sysctls?: Sysctl[];
      /**
       * The Windows specific settings applied to all containers.
       *
       * If unspecified, the options within a container's SecurityContext will be used.
       * If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
       */
      windowsOptions: WindowsSecurityContextOptions;
  }/** @public */
  export declare interface Toleration {
      /**
       * Indicates the taint effect to match.
       *
       * Empty means match all taint effects.
       * When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
       */
      effect?: "NoSchedule" | "PreferNoSchedule" | "NoExecute";
      /**
       * The taint key that the toleration applies to.
       *
       * Empty means match all taint keys.
       * If the key is empty, operator must be Exists;
       * this combination means to match all values and all keys.
       */
      key?: string;
      /**
       * Represents a key's relationship to the value.
       *
       * Valid operators are Exists and Equal.
       * Defaults to Equal.
       * Exists is equivalent to wildcard for value, so that a pod can tolerate all taints of a particular category.
       *
       * @defaultValue Equal
       */
      operator?: "Exists" | "Equal";
      /**
       * Represents the period of time the toleration (which must be of effect NoExecute, otherwise this field is ignored) tolerates the taint.
       *
       * By default, it is not set, which means tolerate the taint forever (do not evict).
       * Zero and negative values will be treated as 0 (evict immediately) by the system.
       */
      tolerationSeconds?: number;
      /**
       * Value is the taint value the toleration matches to.
       *
       * If the operator is Exists, the value should be empty, otherwise just a regular string.
       */
      value?: string;
  }/** @public */
  export declare interface TopologySpreadConstraint {
      /**
       * Used to find matching pods.
       *
       * Pods that match this label selector are counted to determine the
       * number of pods in their corresponding topology domain.
       */
      labelSelector: LabelSelector;
      /**
       * Describes the degree to which pods may be unevenly distributed.
       *
       * When `whenUnsatisfiable=DoNotSchedule`, it is the maximum permitted
       * difference between the number of matching pods in the target topology
       * and the global minimum.
       * For example, in a 3-zone cluster, MaxSkew is set to 1, and pods with
       * the same labelSelector spread as 1/1/0: | zone1 | zone2 | zone3 | | P | P | |
       * - if MaxSkew is 1, incoming pod can only be scheduled to zone3 to become 1/1/1;
       *   scheduling it onto zone1(zone2) would make the ActualSkew(2-0) on zone1(zone2) violate MaxSkew(1).
       * - if MaxSkew is 2, incoming pod can be scheduled onto any zone.
       * When `whenUnsatisfiable=ScheduleAnyway`, it is used to give higher precedence to topologies that satisfy it.
       * It's a required field. Default value is 1 and 0 is not allowed.
       *
       * @example
       *
       * @defaultValue 1
       */
      maxSkew: number;
      /**
       * The key of node labels.
       *
       * Nodes that have a label with this key and identical values are considered to be in the same topology.
       * We consider each \<key, value\> as a "bucket", and try to put balanced number of pods into each bucket.
       * It's a required field.
       */
      topologyKey: string;
      /**
       * Indicates how to deal with a pod if it doesn't satisfy the spread constraint.
       *
       * - DoNotSchedule (default) tells the scheduler not to schedule it.
       * - ScheduleAnyway tells the scheduler to schedule the pod in any location,
       *   but giving higher precedence to topologies that would help reduce the skew.
       *
       * A constraint is considered "Unsatisfiable" for an incoming pod if and only if every possible
       * node assigment for that pod would violate "MaxSkew" on some topology.
       * For example, in a 3-zone cluster, MaxSkew is set to 1, and pods with the same labelSelector
       * spread as 3/1/1: | zone1 | zone2 | zone3 | | P P P | P | P | If WhenUnsatisfiable is set to DoNotSchedule,
       * incoming pod can only be scheduled to zone2(zone3) to become 3/2/1(3/1/2)
       * as ActualSkew(2-1) on zone2(zone3) satisfies MaxSkew(1).
       * In other words, the cluster can still be imbalanced, but scheduler won't make it
       * *more* imbalanced.
       *
       * It's a required field.
       */
      whenUnsatisfiable: string;
  }/** @public */
  export declare interface KeyToPath {
      /** The key to project. */
      key: string;
      /**
       * mode bits to use on this file,
       * Must be a value between 0 and 0777.
       * If not specified, the volume defaultMode will be used.
       * This might be in conflict with other options that affect the file mode, like fsGroup,
       * and the result can be other mode bits set.
       */
      mode?: number;
      /**
       * The relative path of the file to map the key to.
       *
       * May not be an absolute path. May not contain the path element '..'. May not start with the string '..'.
       */
      path: string;
  }/** @public */
  export declare interface ConfigMapVolumeSource {
      /**
       * mode bits to use on created files by default.
       *
       * Must be a value between 0 and 0777. Defaults to 0644.
       * Directories within the path are not affected by this setting.
       * This might be in conflict with other options that affect the file mode,
       * like fsGroup, and the result can be other mode bits set.
       */
      defaultMode?: number;
      /**
       * If unspecified, each key-value pair in the Data field of the referenced ConfigMap will be projected into the volume as a file whose name is the key and content is the value.
       *
       * If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present.
       * If a key is specified which is not present in the ConfigMap, the volume setup will error unless it is marked optional.
       * Paths must be relative and may not contain the '..' path or start with '..'.
       */
      items?: KeyToPath[];
      /**
       * Name of the referent.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names}
       */
      name: string | Handle;
      /** Specify whether the ConfigMap or its keys must be defined */
      optional?: boolean;
  }/** @public */
  export declare interface SecretVolumeSource {
      /**
       * mode bits to use on created files by default.
       *
       * Must be a value between 0 and 0777. Defaults to 0644.
       * Directories within the path are not affected by this setting.
       * This might be in conflict with other options that affect the file mode,
       * like fsGroup, and the result can be other mode bits set.
       */
      defaultMode?: number;
      /**
       * If unspecified, each key-value pair in the Data field of the referenced Secret will be projected into the volume as a file whose name is the key and content is the value.
       *
       * If specified, the listed keys will be projected into the specified paths,
       * and unlisted keys will not be present. If a key is specified which is not
       * present in the Secret, the volume setup will error unless it is marked optional.
       *
       * Paths must be relative and may not contain the '..' path or start with '..'.
       */
      items?: KeyToPath[];
      /** Specify whether the Secret or its keys must be defined */
      optional?: boolean;
      /**
       * Name of the secret in the pod's namespace to use.
       *
       *  More info: {@link https://kubernetes.io/docs/concepts/storage/volumes#secret}
       */
      secretName: string | Handle;
  }/** @public */
  export declare interface EmptyDirVolumeSource {
      /**
       * What type of storage medium should back this directory.
       *
       * The default is "" which means to use the node's default medium.
       * Must be an empty string (default) or Memory.
       * More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
       */
      medium: string;
      /**
       * Total amount of local storage required for this EmptyDir volume.
       *
       * The size limit is also applicable for memory medium.
       * The maximum usage on memory medium EmptyDir would be the minimum
       * value between the SizeLimit specified here and the sum of memory limits of all containers in a pod.
       * The default is nil which means that the limit is undefined.
       * More info: {@link http://kubernetes.io/docs/user-guide/volumes#emptydir}
       */
      sizeLimit: string;
  }/**
   * Volumes for {@link k8s.PodProps}
   *
   * @public
   */
  export declare interface Volume {
      /**
       * Volume's name.
       *
       * Must be a DNS_LABEL and unique within the pod.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names}
       */
      name: string;
      /**
       * Represents a configMap that should populate this volume
       */
      configMap?: ConfigMapVolumeSource;
      /**
       * EmptyDir represents a temporary directory that shares a pod's lifetime.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/storage/volumes#emptydir}
       *
       */
      emptyDir?: EmptyDirVolumeSource;
      /**
       * Represents a secret that should populate this volume.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/storage/volumes#secret}
       */
      secret?: SecretVolumeSource;
      /** Other k8s volume kinds not typed yet for \@adpt/cloud */
      [key: string]: any;
  }/**
   * Props for the {@link k8s.Pod} component
   *
   * @public
   */
  export declare interface PodProps extends WithChildren {
      /**
       *  True is this is a template for use in a controller, false otherwise
       *  @defaultValue false
       */
      isTemplate: boolean;
      /** Information about the k8s cluster (ip address, auth info, etc.) */
      config?: ClusterInfo;
      /** k8s metadata */
      metadata: Metadata;
      /**
       * Optional duration in seconds the pod may be active on the node relative to StartTime before the system will actively try to mark it failed and kill associated containers.
       *
       * Value must be a positive integer.
       */
      activeDeadlineSeconds?: number;
      /** If specified, the pod's scheduling constraints */
      affinity?: Affinity;
      /** AutomountServiceAccountToken indicates whether a service account token should be automatically mounted. */
      automountServiceAccountToken?: boolean;
      /**
       *  Specifies the DNS parameters of a pod.
       *
       *  Parameters specified here will be merged to the generated DNS configuration based on DNSPolicy.
       */
      dnsConfig?: PodDNSConfig;
      /**
       * Set DNS policy for the pod.
       *
       * Valid values are 'ClusterFirstWithHostNet', 'ClusterFirst', 'Default' or 'None'.
       * DNS parameters given in DNSConfig will be merged with the policy selected with DNSPolicy.
       * To have DNS options set along with hostNetwork, you have to specify DNS policy explicitly
       * to 'ClusterFirstWithHostNet'.
       *
       * @defaultValue ClusterFirst
       */
      dnsPolicy: "ClusterFirstWithHostNet" | "ClusterFirst" | "Default" | "None";
      /**
       * Indicates whether information about services should be injected into pod's environment variables matching the syntax of Docker links.
       *
       * @defaultValue true
       */
      enableServiceLinks: boolean;
      /**
       * An optional list of hosts and IPs that will be injected into the pod's hosts file if specified.
       *
       * This is only valid for non-hostNetwork pods.
       */
      hostAliases?: HostAlias[];
      /**
       * Use the host's ipc namespace.
       * @defaultValue false
       */
      hostIPC: boolean;
      /**
       * Host networking requested for this pod.
       *
       * Use the host's network namespace.
       * If this option is set, the ports that will be used must be specified. Default to false.
       */
      hostNetwork?: boolean;
      /**
       * Use the host's pid namespace.
       * @defaultValue false
       */
      hostPID: boolean;
      /**
       * Specifies the hostname of the Pod.
       *
       * If not specified, the pod's hostname will be set to a system-defined value.
       */
      hostname?: string;
      /**
       * List of references to secrets in the same namespace to use for pulling any of the images used by this PodSpec.
       *
       * If specified, these secrets will be passed to individual puller implementations for them to use.
       * For example, in the case of docker, only DockerConfig type secrets are honored.
       * More info: {@link https://kubernetes.io/docs/concepts/containers/images#specifying-imagepullsecrets-on-a-pod}
       */
      imagePullSecrets?: LocalObjectReference[];
      /**
       * A request to schedule this pod onto a specific node.
       *
       * If it is non-empty, the scheduler simply schedules this pod onto that node,
       * assuming that it fits resource requirements.
       */
      nodeName?: string;
      /**
       * A selector which must be true for the pod to fit on a node.
       *
       * Selector which must match a node's labels for the pod to be scheduled on that node.
       * More info: {@link https://kubernetes.io/docs/concepts/configuration/assign-pod-node/}
       */
      nodeSelector?: {
          [label: string]: boolean | string;
      };
      /**
       * Overhead represents the resource overhead associated with running a pod for a given RuntimeClass.
       *
       * This field will be autopopulated at admission time by the RuntimeClass admission controller.
       * If the RuntimeClass admission controller is enabled, overhead must not be set in Pod create requests.
       * The RuntimeClass admission controller will reject Pod create requests which have the overhead already set.
       * If RuntimeClass is configured and selected in the PodSpec, Overhead will be set to the value defined in
       * the corresponding RuntimeClass, otherwise it will remain unset and treated as zero.
       *
       * More info: {@link https://git.k8s.io/enhancements/keps/sig-node/20190226-pod-overhead.md}
       *
       * This field is alpha-level as of Kubernetes v1.16, and is only honored by servers that enable
       * the PodOverhead feature.
       * @alpha
       */
      overhead?: unknown;
      /**
       * PreemptionPolicy is the Policy for preempting pods with lower priority.
       *
       * This field is beta-level, gated by the NonPreemptingPriority feature-gate.
       *
       * @defaultValue PreemptLowerPriority
       * @beta
       */
      preemptionPolicy?: "Never" | "PreemptLowerPriority";
      /**
       * The priority various system components use this field to find the priority of the pod.
       *
       * When Priority Admission Controller is enabled, it prevents users from setting this field.
       * The admission controller populates this field from PriorityClassName.
       * The higher the value, the higher the priority.
       */
      priority?: number;
      /**
       * If specified, indicates the pod's priority.
       *
       * "system-node-critical" and "system-cluster-critical" are two special keywords which indicate the highest
       * priorities with the former being the highest priority. Any other name must be defined by creating a PriorityClass
       * object with that name. If not specified, the pod priority will be default or zero if there is no default.
       */
      priorityClassName?: string;
      /**
       *  If specified, all readiness gates will be evaluated for pod readiness.
       *
       *  A pod is ready when all its containers are ready AND all conditions specified
       *  in the readiness gates have status equal to "True"
       *
       *  More info: {@link https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#pod-readiness-gate}
       */
      readinessGates?: PodReadinessGate[];
      /**
       * Restart policy for all containers within the pod.
       *
       * One of Always, OnFailure, Never. Default to Always.
       * More info: {@link https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy}
       *
       * @defaultValue Always
       */
      restartPolicy: "Always" | "OnFailure" | "Never";
      /**
       * Refers to a RuntimeClass object in the node.k8s.io group, which should be used to run this pod.
       *
       * If no RuntimeClass resource matches the named class, the pod will not be run.
       * If unset or empty, the "legacy" RuntimeClass will be used, which is an implicit
       * class with an empty definition that uses the default runtime handler.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/containers/runtime-class/}
       *
       * This is a beta feature as of Kubernetes v1.14.
       */
      runtimeClassName?: string;
      /**
       *  If specified, the pod will be dispatched by specified scheduler.
       *  If not specified, the pod will be dispatched by default scheduler.
       */
      schedulerName?: string;
      /**
       * SecurityContext holds pod-level security attributes and common container settings.
       * See type description for default values of each field.
       *
       * @defaultValue \{\}
       */
      securityContext: PodSecurityContext;
      /**
       * ServiceAccountName is the name of the ServiceAccount to use to run this pod.
       * More info: {@link https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/}
       */
      serviceAccountName?: string | Handle;
      /**
       * If true the pod's hostname will be configured as the pod's FQDN, rather than the leaf name (the default).
       * In Linux containers, this means setting the FQDN in the hostname field of the kernel
       * (the nodename field of struct utsname).
       * In Windows containers, this means setting the registry value of hostname for the registry key
       * HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters to FQDN.
       * If a pod does not have FQDN, this has no effect.
       *
       * @defaultValue false
       */
      setHostnameAsFQDN?: boolean;
      /**
       * Share a single process namespace between all of the containers in a pod.
       * When this is set containers will be able to view and signal processes from other containers in the same pod,
       * and the first process in each container will not be assigned PID 1.
       * HostPID and ShareProcessNamespace cannot both be set.
       *
       * @defaultValue false
       */
      shareProcessNamespace: boolean;
      /**
       *  If specified, the fully qualified Pod hostname will be "\<hostname\>.\<subdomain\>.\<pod namespace\>.svc.\<cluster domain\>".
       *  If not specified, the pod will not have a domainname at all.
       */
      subdomain?: string;
      /**
       * Optional duration in seconds the pod needs to terminate gracefully.
       *
       * May be decreased in delete request. Value must be non-negative integer.
       * The value zero indicates delete immediately. If this value is nil, the default
       * grace period will be used instead. The grace period is the duration in seconds
       * after the processes running in the pod are sent a termination signal and the time
       * when the processes are forcibly halted with a kill signal. Set this value longer
       * than the expected cleanup time for your process. Defaults to 30 seconds.
       */
      terminationGracePeriodSeconds?: number;
      /** If specified, the pod's tolerations. */
      tolerations?: Toleration[];
      /**
       *  TopologySpreadConstraints describes how a group of pods ought to spread across topology domains.
       *
       *  Scheduler will schedule pods in a way which abides by the constraints. All topologySpreadConstraints are ANDed.
       */
      topologySpreadConstraints?: TopologySpreadConstraint[];
      /**
       * List of volumes that can be mounted by containers belonging to the pod.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/storage/volumes}
       */
      volumes?: Volume[];
  }/**
   * Component for Kubernetes Pods
   *
   * @public
   */
  export declare class Pod extends DeferredComponent<PodProps, ResolvedVolumes & ResolvedServiceAccountName> {
      static defaultProps: {
          isTemplate: boolean;
          metadata: {};
          dnsPolicy: string;
          enableServiceLinks: boolean;
          hostIPC: boolean;
          hostPID: boolean;
          restartPolicy: string;
          securityContext: {};
          shareProcessNamespace: boolean;
          terminationGracePeriodSeconds: number;
      };
      initialState(): {};
      build(helpers: BuildHelpers): Adapt.JSX.Element | null;
      status(_observe: ObserveForStatus, buildData: BuildData): Promise<Adapt.Status | undefined>;
  }/**
   * Spec for for Kubernetes Pods
   *
   * @public
   */
  export declare interface PodSpec extends Omit<PodProps, "config" | "metadata" | "isTemplate"> {
      containers: ContainerSpec[];
      terminationGracePeriodSeconds?: number;
  }/** @internal */
  const podResourceInfo: {
      kind: string;
      deployedWhen: typeof deployedWhen;
      statusQuery: (props: ResourcePropsWithConfig, observe: ObserveForStatus, buildData: BuildData) => Promise<any>;
  };/**
   * k8s Secret resource
   *
   * @param propsIn - props for Secret as specifed in {@link k8s.SecretProps}
   *
   * @public
   */
  export declare function Secret(propsIn: SFCDeclProps<SecretProps, typeof defaultProps>): Adapt.JSX.Element;/** @internal */
  const secretResourceInfo: {
      kind: string;
      deployedWhen: () => true;
      statusQuery: (props: ResourcePropsWithConfig, observe: ObserveForStatus, buildData: BuildData) => Promise<any>;
      makeManifest: (manifest: Manifest, elem: AdaptElement<ResourceProps>, _deployID: string) => {
          data: {
              [key: string]: string;
          } | undefined;
          stringData: {
              [key: string]: string;
          } | undefined;
          type: string | undefined;
          apiVersion: string; /**
           * stringData allows specifying non-binary secret data in string form.
           *
           * It is provided as a write-only convenience method. All keys and values are merged into the data field on write,
           * overwriting any existing values. It is never output when reading from the API.
           */
          kind: string;
          metadata: import("./manifest_support").MetadataInRequest;
          spec?: import("./DaemonSet").DaemonSetSpec | import("./common").CRSpec | import("./Pod").PodSpec | import("./Service").ServiceSpec | import("./Deployment").DeploymentSpec | undefined;
      };
  };/**
   * Convert {@link NetworkService} props to {@link k8s.Service} props
   * @param abstractProps - props to convert
   * @returns Kubernetes spec corresponding to `abstractProps`
   *
   * @internal
   */
  export declare function k8sServiceProps(abstractProps: NetworkServiceProps & BuiltinProps): Omit<ServiceProps, keyof ResourceBase>;/**
   * Native Kubernetes Service resource
   *
   * @remarks
   *
   * Implements the {@link NetworkServiceInstance} interface.
   *
   * @public
   */
  export declare function Service(propsIn: SFCDeclProps<ServiceProps, typeof defaultProps>): Adapt.JSX.Element;/** @public */
  export declare interface ServiceProps extends ServiceSpec {
      /** Legal configuration loaded from kubeconfig */
      config: ClusterInfo;
      metadata?: Metadata;
      selector?: Handle | EndpointSelector;
  }/** @public */
  export declare interface ServiceSpec {
      /**
       * Cluster IP for a {@link k8s.Service}
       *
       * @remarks
       * `clusterIP` is the IP address of the service and is usually assigned
       * randomly by the master. If an address is specified manually and is not
       * in use by others, it will be allocated to the service; otherwise,
       * creation of the service will fail. This field can not be changed through
       * updates. Valid values are "None", empty string (""), or a valid IP
       * address. "None" can be specified for headless services when proxying is
       * not required. Only applies to types ClusterIP, NodePort, and
       * LoadBalancer. Ignored if type is ExternalName.
       *
       * For more information, see the
       * {@link https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies |
       * Kubernetes documentation}.
       */
      clusterIP?: string;
      /**
       * A list of IP addresses for which nodes in the cluster
       * will also accept traffic for this service.
       *
       * @remarks
       * These IPs are not managed by
       * Kubernetes. The user is responsible for ensuring that traffic arrives at
       * a node with this IP. A common example is external load balancers that are
       * not part of the Kubernetes system.
       */
      externalIPs?: string[];
      /**
       * The external reference that kubedns or equivalent
       * will return as a CNAME record for this service.
       *
       * @remarks
       * No proxying will be involved. Must be a
       * {@link https://tools.ietf.org/html/rfc1123 | valid RFC-1123 hostname}
       * and requires Type to be ExternalName.
       */
      externalName?: string;
      /**
       * Denotes if this Service desires to route
       * external traffic to node-local or cluster-wide endpoints.
       *
       * @remarks
       * "Local" preserves the client source IP and avoids a second hop for
       * LoadBalancer and Nodeport type services, but risks potentially
       * imbalanced traffic spreading. "Cluster" obscures the client source IP
       * and may cause a second hop to another node, but should have good overall
       * load-spreading.
       */
      externalTrafficPolicy?: string;
      /**
       * Specifies the healthcheck nodePort for the service.
       *
       * @remarks
       * If not specified, HealthCheckNodePort is created by the service
       * api backend with the allocated nodePort. Will use user-specified nodePort
       * value if specified by the client. Only affects when Type is set to
       * LoadBalancer and ExternalTrafficPolicy is set to Local.
       */
      healthCheckNodePort?: number;
      /**
       * Only applies to Service Type: LoadBalancer. LoadBalancer will
       * get created with the IP specified in this field.
       *
       * @remarks
       * This feature depends on
       * whether the underlying cloud provider supports specifying the loadBalancerIP
       * when a load balancer is created. This field will be ignored if the
       * cloud provider does not support the feature.
       */
      loadBalancerIP?: string;
      /**
       * If specified and supported by the platform, this will
       * restrict traffic through the cloud provider load balancer
       * to the specified client IPs.
       *
       * @remarks
       * This field will be ignored if the cloud provider
       * does not support the feature.
       *
       * For more information, see the
       * {@link https://v1-17.docs.kubernetes.io/docs/tasks/access-application-cluster/configure-cloud-provider-firewall/ |
       * Kubernetes documentation}.
       */
      loadBalancerSourceRanges?: string[];
      /**
       * The list of ports that are exposed by this service.
       *
       * @remarks
       * For more information, see the
       * {@link https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies |
       * Kubernetes documentation}.
       */
      ports?: ServicePort[];
      /**
       * When set to true, indicates that
       * DNS implementations must publish the notReadyAddresses of subsets for the
       * Endpoints associated with the Service.
       *
       * @remarks
       * The default value is false. The
       * primary use case for setting this field is to use a StatefulSet's Headless
       * Service to propagate SRV records for its Pods without respect to their
       * readiness for purpose of peer discovery.
       */
      publishNotReadyAddresses?: boolean;
      /**
       * Route service traffic to pods with label keys and values
       * matching this selector.
       *
       * @remarks
       * If empty or not present, the service is assumed to
       * have an external process managing its endpoints, which Kubernetes will not
       * modify. Only applies to types ClusterIP, NodePort, and LoadBalancer.
       * Ignored if type is ExternalName.
       *
       * For more information, see the
       * {@link https://kubernetes.io/docs/concepts/services-networking/service/ |
       * Kubernetes documentation}.
       */
      selector?: EndpointSelector | object;
      /**
       * Used to maintain session affinity.
       *
       * @remarks
       * Possible values are:
       *
       * - `"ClientIP"`: Enables client IP based session affinity.
       *
       * - `"None"`: Disables session affinity.
       *
       * For more information, see the
       * {@link https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies |
       * Kubernetes documentation}.
       * @defaultValue `"None"`
       */
      sessionAffinity?: string;
      /**
       * Determines how the Service is exposed.
       *
       * @remarks
       * Valid options are:
       *
       * - `"ExternalName"`: maps to the specified externalName.
       *
       * - `"ClusterIP"`: allocates a cluster-internal IP address for load
       * balancing to endpoints. Endpoints are determined by the selector or if
       * that is not specified, by manual construction of an Endpoints object. If
       * clusterIP is "None", no virtual IP is allocated and the endpoints are
       * published as a set of endpoints rather than a stable IP.
       *
       * - `"NodePort"`: Builds on ClusterIP and allocates a port on every node
       * which routes to the clusterIP.
       *
       * - `"LoadBalancer"`: Builds on NodePort and creates an external load
       * balancer (if supported in the current cloud) which routes to the
       * clusterIP.
       *
       * For more information, see the
       * {@link https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services---service-types |
       * Kubernetes documentation}.
       * @defaultValue `"ClusterIP"`
       */
      type?: string;
  }/** @public */
  export declare interface ServicePort {
      /**
       * The name of this port within the service.
       *
       * @remarks
       * This must be a DNS_LABEL.
       * All ports within a ServiceSpec must have unique names.This maps to the
       * Name' field in EndpointPort objects. Optional if only one ServicePort is
       * defined on this service.
       */
      name?: string;
      /**
       * The port on each node on which this service is exposed when
       * type=NodePort or LoadBalancer.
       *
       * @remarks
       * Usually assigned by the system. If
       * specified, it will be allocated to the service if unused or else creation
       * of the service will fail.
       *
       * For more information, see the
       * {@link https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport |
       * Kubernetes documentation}.
       * @defaultValue Automatically allocates a port if the ServiceType of this
       * Service requires one.
       */
      nodePort?: number;
      /** The port that will be exposed by this service. */
      port?: number;
      /** The IP protocol for this port.Supports "TCP" and "UDP".Default is TCP. */
      protocol?: string;
      /**
       * Number or name of the port to access on the pods targeted by the
       * service.
       *
       * @remarks
       * Number must be in the range 1 to 65535. Name must be an
       * IANA_SVC_NAME. If this is a string, it will be looked up as a named port
       * in the target Pod's container ports. If this is not specified, the value
       * of the 'port' field is used (an identity map). This field is ignored for
       * services with clusterIP = None, and should be omitted or set equal to the
       * 'port' field.
       *
       * For more information, see the
       * {@link https://kubernetes.io/docs/concepts/services-networking/service/#defining-a-service |
       * Kubernetes documentation}.
       */
      targetPort?: number | string;
  }/** @internal */
  const serviceResourceInfo: {
      kind: string;
      deployedWhen: typeof deployedWhen;
      statusQuery: (props: ResourcePropsWithConfig, observe: ObserveForStatus, buildData: BuildData) => Promise<any>;
  };/**
   * k8s ServiceAccount resource
   *
   * @param propsIn - props for ServiceAccount as specifed in {@link k8s.ServiceAccountProps}
   *
   * @public
   */
  export declare function ServiceAccount(propsIn: SFCDeclProps<ServiceAccountProps, typeof defaultProps>): Adapt.JSX.Element;/** @public */
  export declare function isServiceAccountProps(p: ResourceProps): p is ResourceProps & ResourceServiceAccount;/** @internal */
  const serviceAccountResourceInfo: {
      kind: string;
      deployedWhen: () => true;
      statusQuery: (props: ResourcePropsWithConfig, observe: ObserveForStatus, buildData: BuildData) => Promise<any>;
      makeManifest: (manifest: Manifest, elem: AdaptElement<ResourceProps>, _deployID: string) => {
          automountServiceAccountToken: boolean | undefined;
          imagePullSecrets: {
              name: string;
          }[] | undefined;
          secrets: ObjectReference[] | undefined;
          apiVersion: string;
          kind: string;
          metadata: import("./manifest_support").MetadataInRequest;
          spec?: import("./DaemonSet").DaemonSetSpec | import("./common").CRSpec | import("./Pod").PodSpec | import("./Service").ServiceSpec | import("./Deployment").DeploymentSpec | undefined;
      };
  };/**
   * Props for {@link k8s.ServiceDeployment}
   *
   * @public
   */
  export declare interface ServiceDeploymentProps<T extends AllowableComponentProps = DeploymentProps> extends ServiceProps {
      config: ClusterInfo;
      serviceProps?: Partial<ServiceProps>;
      component: ComponentType<T>;
      componentProps: T;
      podProps?: Partial<PodProps>;
      containerProps?: Partial<OmitT<K8sContainerProps, "image">>;
  }/**
   * A component for mapping a group of abstract {@link Container}s and
   * {@link NetworkService}s to Kubernetes {@link k8s.Pod}s and
   * {@link k8s.K8sContainer}s.
   *
   * @remarks
   * This component is intended to be used to replace {@link Container} and
   * {@link NetworkService} components that are grouped together, as the
   * only children of a common parent in a pattern that looks like this:
   *
   * ```tsx
   * <Service>
   *   <Container ... />
   *   <Container ... />
   *   <NetworkService ... />
   * </Service>
   * ```
   *
   * `ServiceDeployment` would map those abstract components into corresponding
   * k8s components like this:
   * ```tsx
   * <Group>
   *   <docker.RegistryDockerImage ... /> //If props.config specifies a registry
   *   <k8s.Deployment ... >
   *     <Pod isTemplate>
   *       <k8s.K8sContainer ... />
   *     </Pod>
   *   </k8s.Deployment>
   *   <docker.RegistryDockerImage ... /> //If props.config specifies a registry
   *   <k8s.Deployment ... >
   *     <Pod isTemplate>
   *       <k8s.K8sContainer ... />
   *     </Pod>
   *   </k8s.Pod>
   *   <k8s.Service ... />
   * </Group>
   * ```
   * An example style rule to do this is:
   * ```tsx
   * {Adapt.rule((matchedProps) => {
   *     const { handle, ...remainingProps } = matchedProps;
   *     return <ServiceDeployment config={kubeconfig} {...remainingProps} />;
   * })}
   * ```
   * `ServiceDeployment` also requires the `config` prop which specifies
   * connection and authentication information for the Kubernetes cluster on
   * which these objects should be created.
   *
   * @public
   */
  export declare class ServiceDeployment<T extends AllowableComponentProps> extends DeferredComponent<ServiceDeploymentProps<T>> {
      static defaultProps: {
          component: typeof Deployment;
          componentProps: {
              replicas: number;
          };
      };
      build(helpers: BuildHelpers): Adapt.JSX.Element;
  }/** @public */
  export declare function computeNamespaceFromMetadata(metadata?: Metadata): string;/** @public */
  export declare function isLabelSelector(x: any): x is LabelSelector;/**
   * Kubernetes Kind
   *
   * @public
   */
  export declare type Kind = string;/** @public */
  export declare interface CRSpec {
      [key: string]: any;
  }/** @public */
  export declare type Spec = DaemonSetSpec | DeploymentSpec | PodSpec | ServiceSpec | CRSpec;/** @public */
  export declare interface Metadata {
      namespace?: string;
      labels?: {
          [key: string]: string;
      };
      annotations?: {
          [key: string]: string;
      };
  }/** @public */
  export declare type ResourceProps = {
      key: string;
  } & (ResourceClusterRole | ResourceClusterRoleBinding | ResourceDaemonSet | ResourcePod | ResourceService | ResourceServiceAccount | ResourceConfigMap | ResourceSecret | ResourceCR);/** @public */
  export declare type ResourcePropsWithConfig = ResourceProps & {
      config: ClusterInfo;
  };/** @public */
  export declare interface ResourceInfo {
      kind: Kind;
      statusQuery?: (props: ResourceProps, observe: ObserveForStatus, buildData: BuildData) => unknown | Promise<unknown>;
      specsEqual(actual: Spec, element: Spec): boolean;
  }/**
   * Holds the information needed to connect, authenticate, and run code in a kuberenetes cluster
   *
   * @public
   */
  export declare interface ClusterInfo {
      /** Javascript object formed by parsing a valid kubeconfig file */
      kubeconfig: Kubeconfig;
      /**
       * Registry to which Docker images used by the cluster in `kubeconfig` should be pushed and pulled
       *
       * @remarks
       * If `registryPrefix` is a string, it is assumed that the cluster can pull from the same string
       * that outsiders can push to.
       *
       * If `registryPrefix` is of the form `{ external: string, internal: string }` then the `external`
       * string will be used to push images, and the `internal` string will be used to pull images.
       *
       * Note(manishv)
       * This is a bit of a hack to allow one hostname or IP address to push images from outside
       * a particular environment (say k8s) and a different URL for that environment to pull
       * images.
       *
       * A good example of this is a k3s-dind (k3s docker-in-docker) instance of kubernetes where
       * a private registry is running on a docker network attached to the k3s-dind instance, but where we
       * want to push {@link docker.LocalDockerImage} built images to that registry.  Since
       * {@link docker.LocalDockerImage | LocalDockerImage} is outside the k3s-dind environment, it must
       * use a host accessible network to push to the registry.  However, since the k3s-dind instance sees
       * the registry from within Docker, it must use a different address to pull the images for use.
       *
       * Once network scopes are fully supported, this interface will change to whatever is appropriate.  It
       * is best if you can arrange to have the same URL or registry string work for all access regardless
       * of which network the registry, Adapt host, and ultimate container running environment uses.
       *
       */
      registryPrefix?: string | DockerSplitRegistryInfo;
  }/** @public */
  export declare interface ResourceBase {
      /**
       * config to connect to the k8s cluster
       *
       * required if isTemplate is false
       */
      config?: ClusterInfo;
      /**
       * Specifies whether this resource is just a template for use in a controller
       */
      isTemplate?: boolean;
      apiVersion?: string;
      kind: Kind;
      metadata?: Metadata;
  }/**
   * @public
   */
  export declare interface PolicyRule {
      /**
       * APIGroups is the name of the APIGroup that contains the resources.
       *
       * If multiple API groups are specified, any action requested against one
       * of the enumerated resources in any API group will be allowed.
       */
      apiGroups?: string[];
      /**
       * NonResourceURLs is a set of partial urls that a user should have access to.
       *
       * *s are allowed, but only as the full, final step in the path.
       * Since non-resource URLs are not namespaced, this field is only applicable
       * for ClusterRoles referenced from a ClusterRoleBinding.
       * Rules can either apply to API resources (such as "pods" or "secrets") or
       * non-resource URL paths (such as "/api"), but not both.
       */
      nonResourceURLs?: string[];
      /**
       * ResourceNames is an optional white list of names that the rule applies to.
       *
       * An empty set means that everything is allowed.
       */
      resourceNames?: string[];
      /**
       * Resources is a list of resources this rule applies to.
       *
       * ResourceAll represents all resources.
       */
      resources: string[];
      /**
       * Verbs is a list of Verbs that apply to ALL the ResourceKinds and
       * AttributeRestrictions contained in this rule.
       *
       * VerbAll represents all kinds.
       */
      verbs: string[];
  }/**
   * AggregationRule for {@link k8s.ClusterRole}
   *
   * @public
   */
  export declare interface AggregationRule {
      /**
       * ClusterRoleSelectors holds a list of selectors which will be used to
       * find ClusterRoles and create the rules.
       *
       * If any of the selectors match, then the ClusterRole's permissions will be added
       */
      clusterRoleSelector: LabelSelector;
  }/** @public */
  export declare interface ResourceClusterRole extends ResourceBase {
      apiVersion: "rbac.authorization.k8s.io/v1";
      kind: "ClusterRole";
      aggregationRule?: AggregationRule;
      rules?: PolicyRule[];
  }/**
   * RoleRef for {@link k8s.ResourceClusterRoleBinding}
   *
   * @public
   */
  export declare interface RoleRef {
      /** apiGroup is the group for the resource being referenced */
      apiGroup: string;
      /** kind is the type of resource being referenced */
      kind: string;
      /** Name is the name of resource being referenced */
      name: string;
  }/**
   * Subject for {@link k8s.ResourceClusterRoleBinding}
   *
   * @public
   */
  export declare interface Subject {
      /** apiGroup is the group for the object being referenced */
      apiGroup: string;
      /** kind is the type of object being referenced */
      kind: string;
      /**
       * Name of the object being referenced.
       */
      name: string;
      /**
       * Namespace of the referenced object.
       *
       * If the object kind is non-namespace, such as "User" or "Group", and this value
       * is not empty the Authorizer should report an error.
       */
      namespace?: string;
  }/** @public */
  export declare interface ResourceClusterRoleBinding extends ResourceBase {
      apiVersion: "rbac.authorization.k8s.io/v1";
      kind: "ClusterRoleBinding";
      roleRef: RoleRef;
      subjects: Subject[];
  }/** @public */
  export declare interface ResourceDaemonSet extends ResourceBase {
      apiVersion: "apps/v1";
      kind: "DaemonSet";
      spec: DaemonSetSpec;
  }/** @public */
  export declare interface ResourcePod extends ResourceBase {
      kind: "Pod";
      spec: PodSpec;
  }/** @public */
  export declare interface ResourceService extends ResourceBase {
      kind: "Service";
      spec: ServiceSpec;
  }/** @public */
  export declare interface ResourceServiceAccount extends ResourceBase {
      kind: "ServiceAccount";
      automountServiceAccountToken?: boolean;
      imagePullSecrets?: {
          name: string;
      }[];
      secrets?: ObjectReference[];
  }/** @public */
  export declare interface ResourceConfigMap extends ResourceBase {
      kind: "ConfigMap";
      binaryData?: {
          [key: string]: string;
      };
      data?: {
          [key: string]: string;
      };
      /** @beta */
      immutable?: boolean;
  }/** @public */
  export declare interface ResourceSecret extends ResourceBase {
      kind: "Secret";
      data?: {
          [key: string]: string;
      };
      stringData?: {
          [key: string]: string;
      };
      type?: string;
  }/** @public */
  export declare interface ResourceCR extends ResourceBase {
      kind: string;
      spec: CRSpec;
  }/** @public */
  export declare interface Kubeconfig {
      apiVersion?: "v1";
      kind: "Config";
      "current-context": string;
      contexts: {
          name: string;
          context: {
              cluster: string;
              user: string;
          };
      }[];
      clusters: {
          name: string;
          cluster: {
              "certificate-authority-data": string;
              server: string;
          };
      }[];
      preferences?: unknown;
      users: {
          name: string;
          user: {
              "client-certificate-data"?: string;
              "client-key-data"?: string;
              "username"?: string;
              "password"?: string;
          };
      }[];
  }/** @public */
  export declare interface LabelSelector {
      /**
       * matchExpressions is a list of label selector requirements. The requirements are ANDed.
       */
      matchExpressions?: LabelSelectorRequirement[];
      /**
       * matchLabels is a map of `{key,value}`pairs. A single `{key,value}` in the matchLabels map
       * is equivalent to an element of matchExpressions, whose key field is "key", the operator
       * is "In", and the values array contains only "value". The requirements are ANDed.
       */
      matchLabels?: {
          [key: string]: string;
      };
  }/** @public */
  export declare interface LocalObjectReference {
      /**
       * Name of the referent.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names}
       */
      name: string;
  }/**
   * PodTemplateSpec from k8s API
   *
   * @public
   */
  export declare interface PodTemplateSpec {
      /**
       * Standard object's metadata.
       * More Info: {@link https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata}
       */
      metadata: Metadata;
      /**
       * Specification of the desired behavior of the pod.
       * More Info: {@link https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status}
       */
      spec: PodSpec;
  }/**
   * ObjectReference from k8s API
   *
   * @public
   */
  export declare interface ObjectReference {
      /**
       * If referring to a piece of an object instead of an entire object,
       * this string should contain a valid JSON/Go field access statement,
       * such as desiredState.manifest.containers[2].
       *
       * For example, if the object reference is to a container within a pod,
       * this would take on a value like: "spec.containers\{name\}" (where "name"
       * refers to the name of the container that triggered the event) or if no
       * container name is specified "spec.containers[2]"
       * (container with index 2 in this pod).
       * This syntax is chosen only to have some well-defined way of referencing a
       * part of an object.
       */
      fieldPath: string;
      /**
       * Name of the referent.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names}
       *
       */
      name: string;
      /**
       * Namespace of the referent.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/}
       */
      namespace: string;
      /**
       * Specific resourceVersion to which this reference is made, if any.
       *
       * More info: {@link https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency}
       */
      resourceVersion: string;
      /**
       * UID of the referent.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids}
       */
      uid: string;
  }/**
   * Make a {@link k8s.ClusterInfo} object suitable for use with k8s resources
   *
   * @remarks
   *
   * This function will take a set of options and generate a {@link k8s.ClusterInfo}
   * object that contains the kubeconfig, registryPrefix for private images, and any other
   * relevant information for the cluster
   *
   * See {@link k8s.MakeClusterInfoOptions} for information on how the information
   * is computed.
   *
   * @returns A {@link k8s.ClusterInfo} object.
   *
   * @public
   */
  export declare function makeClusterInfo(options: MakeClusterInfoOptions): Promise<ClusterInfo>;/** @internal */
  export declare function isResourcePodTemplate(x: any): x is AdaptElement<ResourcePod>;/**
   * Hook that allows a prop to be either an array of handle to k8s resources and values
   *
   * @param initial - initial value of the prop, before the handles are be resolved
   * @param notReady - is a marker value to indicate that a handle's value isn't available yet
   * @param kinds - an array of legal k8s Kinds that a prop handle can point to
   * @param thisResourceName - the name of the resource using the hook, for error messages
   * @param propName - the name of the prop being resolved, again for error messages
   *
   * @returns A two element array, the first element is the current value, the second the update function
   *
   * This hook will start by returning the initial value and an update function that updates
   * the value the hook returns.  The update function takes 2 arguments - the prop value which
   * is an array with a mix of values and handles to be resolved, and a function that receives
   * the elements that any handles point to along with that elements props.  This function
   * can be passed by the caller of update to resolve handles as appropriate for the component.
   *
   * For example, {@link k8s.ClusterRoleBinding} uses this hook to resolve the subjects prop,
   * which is an array of other objects (typically {@link ServiceAccount}) that a particular
   * {@link k8s.ClusterRole} should point to.  When ClusterRoleBinding calls the update method,
   * it passes a function that will convert a {@link k8s.Resource} element of Kind `ServiceAccount`
   * to the underlying `Subject` object that kubernetes expects, namely
   * `{ apiGroup: "", kind: "ServiceAccount", name: resourceIdToName(elem, deployID), namespace: <element namespace> }`
   *
   * @example
   * ```
   * function MyResource({ serviceAccountNames }: { serviceAccountNames: (string | Handle)[]}) {
   *   const { deployID } = useBuildHelpers();
   *   const [ resolvedServiceAccountNames, updateSANs] = useResources({
   *      initial: [],
   *      notReady: null,
   *      kinds: ["ServiceAccount"],
   *      thisResourceName: "MyResources",
   *      propName: "serviceAccountNames",
   *   });
   *
   *   updateSANs(serviceAccountNames, (e, props) => {
   *      return {
   *        apiGroup: (e.metadata.apiVersion?.split("/")[0]) || "",
   *        name: resourceElementToName(e, deployID),
   *        namespace: props.metadata.namespace,
   *      }
   *   });
   *
   *   return null;
   * }
   * ```
   *
   * @beta
   */
  export declare function useResources<ValT, NotReadyT>({ initial, notReady, kinds, thisResourceName, propName, }: {
      initial: ValT[];
      notReady: NotReadyT;
      kinds: string[];
      thisResourceName: string;
      propName: string;
  }): [
      (ValT | NotReadyT)[],
      (props: (ValT | Handle)[], f: (e: AdaptMountedElement, props: ResourceProps) => Promise<ValT> | ValT) => void
  ];/**
   * Hook to allow conversion of a prop that could be a value or a handle
   *
   * This function behaves similarly to {@link k8s.useResources}, but works for
   * a prop that is either a Handle or a single value instead of an array of
   * Handles and values.
   *
   * See {@link k8s.useResources} for more detailed documentation.
   *
   * @beta
   */
  export declare function useResource<ValT, NotReadyT>(opts: {
      initial: ValT | NotReadyT;
      notReady: NotReadyT;
      kinds: string[];
      thisResourceName: string;
      propName: string;
  }): [
      ValT | NotReadyT,
      (prop: ValT | Handle, f: (e: AdaptMountedElement, props: ResourceProps) => Promise<ValT> | ValT) => void
  ];/**
   * Options for {@link k8s.makeClusterInfo}
   *
   * @public
   */
  export declare interface MakeClusterInfoOptions {
      /**
       * A Javascript Object representing a valid kubeconfig, or a YAML string, or a path to a kubeconfig file.
       *
       * @remarks
       * If this is a Javascript object, it will be treated like a parsed kubeconfig.  If this is a string,
       * {@link k8s.makeClusterInfo} will first attempt to parse it as JSON.  If that fails, it will attempt
       * to parse it as YAML.  If that fails it will treat the string as a path of configs (like with the `KUBECONFIG`
       * environment variable).
       *
       * If kubeconfig is missing {@link k8s.makeClusterInfo} will use the `KUBECONFIG` environment variable to build
       * a suitable config using `kubectl config view --flatten` and return that as the kubeconfig in the resulting
       * {@link k8s.ClusterInfo}
       */
      kubeconfig?: Kubeconfig | string;
      /**
       * URL to the docker registry that this cluster uses to pull private images.
       *
       * @remarks
       * This is identical to the `registryPrefix` field in {@link k8s.ClusterInfo}.  It will
       * be returned verbatim in the resulting {@link k8s.ClusterInfo} object.
       */
      registryPrefix?: string | DockerSplitRegistryInfo;
  }/**
   * k8s ClusterRole resource
   *
   * @param propsIn - props for ServiceAccount as specifed in {@link k8s.ClusterRoleProps}
   *
   * @public
   */
  export declare function ClusterRole(propsIn: SFCDeclProps<ClusterRoleProps, typeof defaultProps>): Adapt.JSX.Element;/** @public */
  export declare function isClusterRoleProps(props: ResourceProps): props is ResourceProps & ResourceClusterRole;/** @internal */
  const clusterRoleResourceInfo: {
      kind: string;
      deployedWhen: () => true;
      statusQuery: (props: ResourcePropsWithConfig, observe: ObserveForStatus, buildData: BuildData) => Promise<any>;
      makeManifest: (manifest: Manifest, elem: AdaptElement<ResourceProps>, _deployID: string) => {
          aggregationRule: AggregationRule | undefined;
          rules: PolicyRule[] | undefined;
          apiVersion: string;
          kind: string;
          metadata: import("./manifest_support").MetadataInRequest;
          spec?: import("./DaemonSet").DaemonSetSpec | import("./common").CRSpec | import("./Pod").PodSpec | import("./Service").ServiceSpec | import("./Deployment").DeploymentSpec | undefined;
      };
  };/**
   * k8s ClusterRoleBinding resource
   *
   * @param propsIn - props for ServiceAccount as specifed in {@link k8s.ClusterRoleBindingProps}
   *
   * @public
   */
  export declare function ClusterRoleBinding(propsIn: SFCDeclProps<ClusterRoleBindingProps, typeof defaultProps>): Adapt.JSX.Element | null;/** @internal */
  const clusterRoleBindingResourceInfo: {
      kind: string;
      deployedWhen: () => true;
      statusQuery: (props: ResourcePropsWithConfig, observe: ObserveForStatus, buildData: BuildData) => Promise<any>;
      makeManifest: (manifest: Manifest, elem: AdaptElement<ResourceProps>, _deployID: string) => {
          roleRef: RoleRef;
          subjects: Subject[];
          apiVersion: string;
          kind: string;
          metadata: import("./manifest_support").MetadataInRequest;
          spec?: import("./DaemonSet").DaemonSetSpec | import("./common").CRSpec | import("./Pod").PodSpec | import("./Service").ServiceSpec | import("./Deployment").DeploymentSpec | undefined;
      };
  };/**
   * k8s ConfigMap resource
   *
   * @param propsIn - props for ConfigMap as specifed in {@link k8s.ConfigMapProps}
   *
   * @public
   */
  export declare function ConfigMap(propsIn: SFCDeclProps<ConfigMapProps, typeof defaultProps>): Adapt.JSX.Element;/** @internal */
  const configMapResourceInfo: {
      kind: string;
      deployedWhen: () => true;
      statusQuery: (props: ResourcePropsWithConfig, observe: ObserveForStatus, buildData: BuildData) => Promise<any>;
      makeManifest: (manifest: Manifest, elem: AdaptElement<ResourceProps>, _deployID: string) => {
          data: {
              [key: string]: string;
          } | undefined;
          binaryData: {
              [key: string]: string;
          } | undefined;
          immutable: boolean | undefined;
          apiVersion: string;
          kind: string;
          metadata: import("./manifest_support").MetadataInRequest;
          spec?: import("./DaemonSet").DaemonSetSpec | import("./common").CRSpec | import("./Pod").PodSpec | import("./Service").ServiceSpec | import("./Deployment").DeploymentSpec | undefined;
      };
  };/**
   * Low level utility function to translate from the abstract {@link Container}
   * component props ({@link ContainerProps}) to {@link k8s.K8sContainerProps}
   * to be used in a {@link k8s.K8sContainer}.
   * @remarks
   * Note: The `image` property in the passed in {@link ContainerProps} must
   * be a `string`, not a `Handle`.
   * In most cases, it is preferable to use the {@link k8s.Container} component
   * instead, which is designed specifically to deal with this issue.
   *
   * @param abstractProps - The abstract {@link ContainerProps} to translate from.
   * @param k8sProps - Props that are specific to the {@link k8s.K8sContainer}
   *     component that should be merged into the resulting returned
   *     {@link k8s.K8sContainerProps} object.
   * @public
   */
  export declare function k8sContainerProps(abstractProps: FromContainerProps, k8sProps?: Partial<K8sContainerProps>): K8sContainerProps;/**
   * Tests whether an element is a {@link k8s.K8sContainer} element
   * @param x - element to test
   * @returns `true` if element is a {@link k8s.K8sContainer}, `false` otherwise
   *
   * @remarks
   * Acts as a TypeScript type assertion that will assert that `x` is `AdaptElement<K8sContainerProps>`
   *
   * @public
   */
  export declare function isK8sContainerElement(x: AdaptElement): x is AdaptElement<K8sContainerProps>;/**
   * Component that implements the abstract {@link Container} interface and
   * translates to a Kubernetes-specific {@link k8s.K8sContainer}.
   * @public
   */
  export declare function Container(props: ContainerProps): Adapt.JSX.Element | null;/** @public */
  export declare interface VolumeMount {
      /**
       * Path within the container at which the volume should be mounted.
       *
       * Must not contain ':'.
       */
      mountPath: string;
      /**
       * mountPropagation determines how mounts are propagated from the host to container and the other way around.
       *
       * When not set, MountPropagationNone is used. This field is beta in 1.10.
       *
       * @defaultValue MountPropagationNone
       */
      mountPropagation?: string;
      /** This must match the Name of a Volume. */
      name: string;
      /**
       * Mounted read-only if true, read-write otherwise (false or unspecified).
       *
       * @defaultValue false
       */
      readOnly?: boolean;
      /**
       * Path within the volume from which the container's volume should be mounted.
       *
       * Defaults to "" (volume's root).
       *
       * @defaultValue ""
       */
      subPath?: string;
      /**
       * Expanded path within the volume from which the container's volume should be mounted.
       *
       * Behaves similarly to SubPath but environment variable references $(VAR_NAME)
       * are expanded using the container's environment.
       *
       * Defaults to "" (volume's root).
       *
       * SubPathExpr and SubPath are mutually exclusive.
       *
       * @defaultValue ""
       */
      subPathExpr?: string;
  }/** @public */
  export declare interface ConfigMapEnvSource {
      /**
       * Name of the referent.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names}
       */
      name?: string;
      /**
       * Specify whether the ConfigMap must be defined
       */
      optional?: boolean;
  }/** @public */
  export declare interface SecretEnvSource {
      /**
       * Name of the referent.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names}
       */
      name?: string;
      /**
       * Specify whether the Secret must be defined
       */
      optional?: boolean;
  }/** @public */
  export declare interface EnvFromSource {
      /** The ConfigMap to select from */
      configMapRef?: ConfigMapEnvSource;
      /** An optional identifier to prepend to each key in the ConfigMap. Must be a C_IDENTIFIER. */
      prefix?: string;
      /** SecretEnvSource	The Secret to select from */
      secretRef?: SecretEnvSource;
  }/** @public */
  export declare interface ExecAction {
      /**
       * Command is the command line to execute inside the container.
       *
       * The working directory for the command is root ('/') in the container's filesystem.
       * The command is simply exec'd, it is not run inside a shell,
       * so traditional shell instructions ('|', etc) won't work.
       * To use a shell, you need to explicitly call out to that shell.
       *
       * Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
       */
      command: string[];
  }/** @public */
  export declare interface HTTPGetAction {
      /**
       * Host name to connect to, defaults to the pod IP.
       *
       * You probably want to set "Host" in httpHeaders instead.
       */
      host?: string;
      /** Custom headers to set in the request. HTTP allows repeated headers. */
      httpHeaders?: {
          name: string;
          value: string;
      }[];
      /** Path to access on the HTTP server. */
      path: string;
      /**
       * Name or number of the port to access on the container.
       *
       * Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
       */
      port: number | string;
      /**
       * Scheme to use for connecting to the host.
       *
       * @defaultValue HTTP.
       */
      scheme?: string;
  }/** @public */
  export declare interface TCPSocketAction {
      /** Host name to connect to, defaults to the pod IP. */
      host?: string;
      /**
       * Number or name of the port to access on the container.
       *
       * Number must be in the range 1 to 65535.
       * Name must be an IANA_SVC_NAME.
       */
      port: string | number;
  }/** @public */
  export declare interface Probe {
      /**
       * Exec specifies the action to take.
       *
       * Only one of exec, httpGet, or tcpSocket should be specified
       */
      exec?: ExecAction;
      /**
       * Minimum consecutive failures for the probe to be considered failed after having succeeded.
       *
       * Defaults to 3. Minimum value is 1.
       *
       * @defaultValue 3
       */
      failureThreshold?: number;
      /** Specifies the http request to perform. */
      httpGet?: HTTPGetAction;
      /**
       *  Seconds after the container has started before liveness probes are initiated.
       *  More info: {@link https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes}
       */
      initialDelaySeconds?: number;
      /** How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. */
      periodSeconds?: number;
      /**
       * Minimum consecutive successes for the probe to be considered successful after having failed.
       *
       * Must be 1 for liveness and startup. Minimum value is 1.
       *
       * @defaultValue 1
       */
      successThreshold?: number;
      /**
       * Specifies an action involving a TCP port.
       *
       * TCP hooks not yet supported
       */
      tcpSocket?: TCPSocketAction;
      /**
       * Number of seconds after which the probe times out.
       *
       * Defaults to 1 second. Minimum value is 1.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes}
       *
       * @defaultValue 1
       */
      timeoutSeconds?: number;
  }/** @public */
  export declare interface ResourceRequirements {
      /**
       * Limits describes the maximum amount of compute resources allowed.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/}
       */
      limits?: {
          [key: string]: any;
      };
      /**
       * Describes the minimum amount of compute resources required.
       *
       * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
       * otherwise to an implementation-defined value.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/}
       */
      requests?: {
          [key: string]: any;
      };
  }/** @public */
  export declare type Handler = {
      exec: ExecAction;
  } | {
      httpGet: HTTPGetAction;
  } | {
      tcpSocket: TCPSocketAction;
  };/** @public */
  export declare interface Lifecycle {
      /**
       * PostStart is called immediately after a container is created.
       *
       * If the handler fails, the container is terminated and restarted according to its restart policy.
       * Other management of the container blocks until the hook completes.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks}
       */
      postStart: Handler;
      /**
       * Called immediately before a container is terminated due to an API request or management event such as liveness/startup probe failure, preemption, resource contention, etc.
       *
       * The handler is not called if the container crashes or exits.
       * The reason for termination is passed to the handler.
       * The Pod's termination grace period countdown begins before the PreStop hooked is executed.
       * Regardless of the outcome of the handler, the container will eventually terminate within the Pod's termination grace period.
       * Other management of the container blocks until the hook completes or until the termination grace period is reached.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks}
       */
      preStop: Handler;
  }/** @public */
  export declare interface VolumeDevice {
      /** The path inside of the container that the device will be mapped to. */
      devicePath: string;
      /** name must match the name of a persistentVolumeClaim in the pod */
      name: string;
  }/**
   * Resource spec for a Kubernetes container.
   * See the Kubernetes
   * {@link https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#container-v1-core | API docs }
   * for more details.
   * @public
   */
  export declare interface ContainerSpec {
      /**
       * Arguments to the entrypoint.
       *
       * The docker image's CMD is used if this is not provided.
       * Variable references $(VAR_NAME) are expanded using the container's environment.
       * If a variable cannot be resolved, the reference in the input string will be unchanged.
       * The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME).
       * Escaped references will never be expanded, regardless of whether the variable exists or not.
       * Cannot be updated.
       * More info: {@link https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell}
       */
      args?: string[];
      /**
       * Entrypoint array.
       *
       * Not executed within a shell.
       * The docker image's ENTRYPOINT is used if this is not provided.
       * Variable references $(VAR_NAME) are expanded using the container's environment.
       * If a variable cannot be resolved, the reference in the input string will be unchanged.
       * The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME).
       * Escaped references will never be expanded, regardless of whether the variable exists or not.
       * Cannot be updated.
       * More info: {@link https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell}
       */
      command?: string[];
      /**
       * List of environment variables to set in the container. Cannot be updated.
       */
      env?: EnvVar[];
      /**
       * List of sources to populate environment variables in the container.
       *
       * The keys defined within a source must be a C_IDENTIFIER.
       * All invalid keys will be reported as an event when the container is starting.
       * When a key exists in multiple sources, the value associated with the last source will take precedence.
       * Values defined by an Env with a duplicate key will take precedence. Cannot be updated.
       */
      envFrom?: EnvFromSource[];
      /**
       * Docker image name.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/containers/images}
       *
       * This field is optional to allow higher level config management to default or override container
       * images in workload controllers like Deployments and StatefulSets.
       */
      image?: string;
      /**
       * Image pull policy.
       *
       * One of Always, Never, IfNotPresent.
       * Defaults to Always if :latest tag is specified,
       * or IfNotPresent otherwise.
       * Cannot be updated.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/containers/images#updating-images}
       */
      imagePullPolicy?: "Always" | "Never" | "IfNotPresent";
      /**
       * List of sources to populate environment variables in the container.
       *
       * The keys defined within a source must be a C_IDENTIFIER.
       * All invalid keys will be reported as an event when the container is starting.
       * When a key exists in multiple sources, the value associated with the last source will take precedence.
       * Values defined by an Env with a duplicate key will take precedence. Cannot be updated.
       */
      lifecycle?: Lifecycle;
      /**
       * Periodic probe of container liveness.
       *
       * Container will be restarted if the probe fails.
       * Cannot be updated.
       * More info: {@link https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes}
       */
      livenessProbe?: Probe;
      /**
       * Name of the container specified as a DNS_LABEL.
       *
       * Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated.
       */
      name: string;
      /**
       * List of ports to expose from the container.
       *
       * Exposing a port here gives the system additional information about the network connections a container uses,
       * but is primarily informational.
       * Not specifying a port here DOES NOT prevent that port from being exposed.
       * Any port which is listening on the default "0.0.0.0" address inside a container will be accessible from
       * the network.
       * Cannot be updated.
       */
      ports?: ContainerPort[];
      /**
       * Periodic probe of container service readiness.
       *
       * Container will be removed from service endpoints if the probe fails.
       * Cannot be updated.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes}
       */
      readinessProbe?: Probe;
      /**
       * Compute Resources required by this container.
       *
       * Cannot be updated.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/}
       */
      resources?: ResourceRequirements;
      /**
       * Security options the pod should run with.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/policy/security-context/}
       * More info: {@link https://kubernetes.io/docs/tasks/configure-pod-container/security-context/}
       */
      securityContext?: PodSecurityContext;
      /**
       * Indicates that the Pod has successfully initialized.
       *
       * If specified, no other probes are executed until this completes successfully.
       * If this probe fails, the Pod will be restarted, just as if the livenessProbe failed.
       * This can be used to provide different probe parameters at the beginning of a Pod's lifecycle,
       * when it might take a long time to load data or warm a cache, than during steady-state operation.
       *
       * This cannot be updated.
       * This is a beta feature enabled by the StartupProbe feature flag.
       * More info: {@link https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes}
       */
      startupProbe?: Probe;
      /**
       * Whether this container should allocate a buffer for stdin in the container runtime.
       *
       * If this is not set, reads from stdin in the container will always result in EOF. Default is false.
       */
      stdin?: boolean;
      /**
       * Whether the container runtime should close the stdin channel after it has been opened by a single attach.
       *
       * When stdin is true the stdin stream will remain open across multiple attach sessions.
       * If stdinOnce is set to true, stdin is opened on container start,
       * is empty until the first client attaches to stdin,
       * and then remains open and accepts data until the client disconnects,
       * at which time stdin is closed and remains closed until the container is restarted.
       * If this flag is false, a container processes that reads from stdin will never receive an EOF. Default is false
       */
      stdinOnce?: boolean;
      /**
       * Path at which the file to which the container's termination message will be written is mounted into the container's filesystem.
       *
       * Message written is intended to be brief final status, such as an assertion failure message.
       * Will be truncated by the node if greater than 4096 bytes.
       * The total message length across all containers will be limited to 12kb.
       * Defaults to /dev/termination-log. Cannot be updated.
       */
      terminationMessagePath?: string;
      /**
       * Indicate how the termination message should be populated.
       *
       * File will use the contents of terminationMessagePath to populate the container status
       * message on both success and failure. FallbackToLogsOnError will use the last chunk of
       * container log output if the termination message file is empty and the container exited
       * with an error.
       * The log output is limited to 2048 bytes or 80 lines, whichever is smaller.
       * Defaults to File.
       * Cannot be updated.
       *
       * @defaultValue File
       */
      terminationMessagePolicy?: "File" | "FallbackToLogsOnError";
      /**
       * Whether this container should allocate a TTY for itself, also requires 'stdin' to be true.
       *
       * @defaultValue false
       */
      tty?: boolean;
      /**
       * volumeDevices is the list of block devices to be used by the container.
       */
      volumeDevices?: VolumeDevice[];
      /** volumeDevices is the list of block devices to be used by the container. */
      volumeMounts?: VolumeMount[];
      /**
       * Container's working directory.
       *
       * If not specified, the container runtime's default will be used,
       * which might be configured in the container image.
       * Cannot be updated.
       */
      workingDir?: string;
  }/**
   * Props for the Kubernetes-specific {@link k8s.K8sContainer} component.
   * @public
   */
  export declare interface K8sContainerProps extends ContainerSpec {
  }/** @public */
  export declare interface ContainerPort {
      /**
       * Number of port to expose on the pod's IP address.
       * @remarks
       * This must be a valid integer port number, `0 < x < 65536`.
       */
      containerPort: number;
      /** What host IP to bind the external port to. */
      hostIP?: string;
      /**
       * Number of port to expose on the host.
       * @remarks
       * If specified, this must be a valid integer port number,
       * `0 < x < 65536`. If HostNetwork is specified,
       * this must match ContainerPort. Most containers do not need this.
       */
      hostPort?: number;
      /**
       * A unique-within-pod name for the container
       * @remarks
       * If specified, this must be an IANA_SVC_NAME and unique within the pod.
       * Each named port in a pod must have a unique name. Name for the port
       * that can be referred to by services.
       */
      name?: string;
      /** Protocol for port. Must be UDP or TCP. Defaults to "TCP". */
      protocol?: string;
  }/** @public */
  export declare type EnvVar = EnvVarSimple | EnvVarFrom;/** @public */
  export declare interface EnvVarSimple {
      /** Name of the environment variable. Must be a C_IDENTIFIER. */
      name: string;
      /**
       * Variable references $(VAR_NAME) are expanded using the previous defined
       * environment variables in the container and any service environment
       * variables. If a variable cannot be resolved, the reference in the input
       * string will be unchanged. The $(VAR_NAME) syntax can be escaped with a
       * double $$, ie: $$(VAR_NAME). Escaped references will never be expanded,
       * regardless of whether the variable exists or not. Defaults to "".
       */
      value: string;
  }/** @public */
  export declare interface EnvVarFrom {
      /** Source for the environment variable's value. Cannot be used if value is not empty. */
      valueFrom?: any;
  }/**
   * See {@link k8s.k8sContainerProps}.
   * @public
   */
  export declare type FromContainerProps = ReplaceT<ContainerProps, {
      image: string;
  }> & BuiltinProps;/**
   * Kubernetes-specific container.
   * @public
   */
  export declare class K8sContainer extends PrimitiveComponent<K8sContainerProps> {
      static defaultProps: {
          imagePullPolicy: string;
      };
      validate(): undefined;
  }/**
   * Props for {@link k8s.Container}.
   * @public
   */
  export declare interface ContainerProps extends SFCDeclProps<ContainerProps> {
      /**
       * Additional {@link k8s.K8sContainerProps}-specific props that should be
       * added to the instantiated {@link k8s.K8sContainer}.
       */
      k8sContainerProps?: Partial<K8sContainerProps>;
  }/**
   * Spec for {@link k8s.DaemonSet} for use in {@link k8s.Resource}
   *
   * @public
   */
  export declare type DaemonSetSpec = Exclude<DaemonSetProps, ResourceBase> & {
      template: PodTemplateSpec;
  };/**
   * Component for Kubernetes DaemonSet
   *
   * @public
   */
  export declare class DaemonSet extends DeferredComponent<DaemonSetProps> {
      static defaultProps: {
          metadata: {};
          minReadySeconds: number;
          revisionHistoryLimit: number;
          updateStrategy: {
              type: string;
              rollingUpdate: {
                  maxUnavailable: number;
              };
          };
      };
      constructor(props: DaemonSetProps);
      build(helpers: BuildHelpers): Adapt.JSX.Element;
      status(_observe: ObserveForStatus, buildData: BuildData): Promise<Adapt.Status | undefined>;
  }/** @internal */
  const daemonSetResourceInfo: {
      kind: string;
      deployedWhen: typeof deployedWhen;
      statusQuery: (props: ResourcePropsWithConfig, observe: ObserveForStatus, buildData: BuildData) => Promise<any>;
  };/** @public */
  export declare interface DeploymentUpdateStrategyRecreate {
      type: "Recreate";
  }/** @public */
  export declare interface RollingUpdateDeployment {
      /**
       * The maximum number of pods that can be scheduled above the desired number of pods.
       *
       * Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
       * This can not be 0 if MaxUnavailable is 0.
       * Absolute number is calculated from percentage by rounding up.
       * Defaults to 25%.
       *
       * @example
       * When this is set to 30%, the new ReplicaSet can be scaled up immediately when the rolling update starts,
       * such that the total number of old and new pods do not exceed 130% of desired pods. Once old pods have been
       * killed, new ReplicaSet can be scaled up further, ensuring that total number of pods running at any time
       * during the update is at most 130% of desired pods.
       */
      maxSurge?: number | string;
      /**
       * The maximum number of pods that can be unavailable during the update.
       *
       * Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
       * Absolute number is calculated from percentage by rounding down.
       * This can not be 0 if MaxSurge is 0. Defaults to 25%.
       *
       * @example
       * When this is set to 30%, the old ReplicaSet can be scaled down to 70% of desired pods
       * immediately when the rolling update starts. Once new pods are ready, old ReplicaSet
       * can be scaled down further, followed by scaling up the new ReplicaSet, ensuring that
       * the total number of pods available at all times during the update is at least 70% of
       * desired pods.
       */
      maxUnavailable?: number | string;
  }/**
   * Spec for {@link k8s.Deployment} for use in {@link k8s.Resource}
   *
   * @public
   */
  export declare type DeploymentSpec = Exclude<DeploymentProps, ResourceBase> & {
      template: PodTemplateSpec;
  };/**
   * Props for {@link k8s.Deployment}
   *
   * @public
   */
  export declare interface DeploymentProps extends WithChildren {
      /** Information about the k8s cluster (ip address, auth info, etc.) */
      config: ClusterInfo;
      /** k8s metadata */
      metadata: Metadata;
      /**
       * The minimum number of seconds for which a newly created pod should
       * be ready without any of its container crashing, for it to be considered
       * available. Defaults to 0 (pod will be considered available as soon as it is ready).
       */
      minReadySeconds: number;
      /** Indicates that the deployment is paused */
      paused: boolean;
      /**
       * The maximum time in seconds for a deployment to make progress before it is considered to be failed.
       *
       * The deployment controller will continue to process failed deployments and a condition with a
       * ProgressDeadlineExceeded reason will be surfaced in the deployment status. Note that progress
       * will not be estimated during the time a deployment is paused. Defaults to 600s.
       */
      progressDeadlineSeconds: number;
      /**
       * Number of desired pods.
       *
       * Defaults to 1. 0 is not allowed.
       *
       * @defaultValue 1
       */
      replicas: number;
      /**
       * The number of old ReplicaSets to retain to allow rollback.
       *
       * This is a pointer to distinguish between explicit zero and not specified. Defaults to 10.
       *
       * @defaultValue 10
       */
      revisionHistoryLimit: number;
      /**
       * Label selector for pods.
       *
       * Existing ReplicaSets whose pods are selected by this will be the ones affected by this deployment.
       * It must match the pod template's labels.
       *
       * @remarks
       *
       * With Adapt, this is optional.  If not specified, adapt will pick a selector that will work with the pods
       * it creates as part of this {@link k8s.Deployment}
       */
      selector?: LabelSelector;
      /**
       * An deployment strategy to use to replace existing pods with new ones
       */
      strategy: DeploymentUpdateStrategy;
  }/**
   * Component for Kubernetes Deployment
   *
   * @public
   */
  export declare class Deployment extends DeferredComponent<DeploymentProps> {
      static defaultProps: {
          metadata: {};
          paused: boolean;
          replicas: number;
          progressDeadlineSeconds: number;
          minReadySeconds: number;
          revisionHistoryLimit: number;
          strategy: {
              type: string;
              rollingUpdate: {
                  maxSurge: string;
                  maxUnavailable: string;
              };
          };
      };
      constructor(props: DeploymentProps);
      build(helpers: BuildHelpers): Adapt.JSX.Element | null;
      deployedWhen: () => true | Adapt.Waiting;
      status(_observe: ObserveForStatus, buildData: BuildData): Promise<Adapt.Status | undefined>;
  }/** @internal */
  const deploymentResourceInfo: {
      kind: string;
      deployedWhen: typeof deployedWhen;
      statusQuery: (props: ResourcePropsWithConfig, observe: ObserveForStatus, buildData: BuildData) => Promise<any>;
  };/**
   * Type assertion to see if an element is both a {@link k8s.Resource | Resource}
   * and a {@link @adpt/core#FinalElement | FinalElement}
   *
   * @param e - element to test
   * @returns `true` if e is both a FinalElement and a {@link k8s.Resource | Resource}, `false` otherwise
   *
   * @public
   */
  export declare function isResourceFinalElement(e: AdaptElement): e is FinalDomElement<ResourceProps & Adapt.BuiltinProps>;/**
   * Tests whether a ResourceProps is for a template object
   *
   * @public
   */
  export declare function isResourcePropsWithConfig(x: ResourceProps & Partial<BuiltinProps>): x is ResourcePropsWithConfig & Partial<BuiltinProps>;/**
   * Tests to see if an object is a {@link k8s.Resource} element
   * @param x - object to test
   * @returns true if object is an AdaptElement of type {@link k8s.Resource}
   *
   * @public
   */
  export declare function isResource(x: any): x is AdaptElement<ResourceProps>;/**
   * Primitive Component recognized by the k8s plugin to represent resources
   * @public
   */
  export declare class Resource extends Action<ResourceProps> {
      defaultProps: {
          apiVersion: "v1";
          con: false;
      };
      manifest_: Manifest;
      constructor(props: ResourceProps);
      validate(): "Resource elements cannot have children" | undefined;
      shouldAct(op: ChangeType, ctx: ActionContext): Promise<ShouldAct>;
      action(op: ChangeType, ctx: ActionContext): Promise<void>;
      deployedWhen: (goalStatus: GoalStatus, helpers: DeployHelpers) => Promise<true | Adapt.Waiting | Adapt.Waiting[]>;
      status(observe: ObserveForStatus, buildData: BuildData): Promise<any>;
      private mountedElement;
      private manifest;
  }/** @internal */
  export declare function makePodManifest(props: PodProps & BuiltinProps, data: {
      volumes?: Volume[];
      serviceAccountName?: string;
  }): {
      kind: string;
      metadata: Metadata;
      spec: PodSpec;
  };/**
   * Tests whether x is a Pod element
   *
   * @param x - value to test
   * @returns `true` if x is a Pod element, false otherwise
   *
   * @public
   */
  export declare function isPod(x: any): x is AdaptElement<PodProps>;/** @public */
  export declare interface NodeSelectorRequirement {
      /** The label key that the selector applies to. */
      key: string;
      /**
       * Represents a key's relationship to a set of values.
       *
       * Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
       */
      operator: "In" | "NotIn" | "Exists" | "DoesNotExist" | "Gt" | "Lt";
      /**
       * Values for operator
       *
       * If the operator is In or NotIn, the values array must be non-empty.
       * If the operator is Exists or DoesNotExist, the values array must be empty.
       * If the operator is Gt or Lt, the values array must have a single element,
       * which will be interpreted as an integer.
       * This array is replaced during a strategic merge patch.
       */
      values: string[];
  }/** @public */
  export declare interface NodeSelectorTerm {
      /** A list of node selector requirements by node's labels. */
      matchExpressions?: NodeSelectorRequirement[];
      /** A list of node selector requirements by node's fields. */
      matchFields?: NodeSelectorRequirement[];
  }/** @public */
  export declare interface PreferredSchedulingTerm {
      /**
       * A node selector term, associated with the corresponding weight.
       */
      preference: NodeSelectorTerm;
      /** Weight associated with matching the corresponding nodeSelectorTerm, in the range 1-100. */
      weight: number;
  }/** @public */
  export declare interface NodeSelector {
      /** A list of node selector terms. The terms are ORed */
      nodeSelectorTerms: NodeSelectorTerm[];
  }/** @public */
  export declare interface NodeAffinity {
      /** The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding "weight" to the sum if the node matches the corresponding matchExpressions; the node(s) with the highest sum are the most preferred. */
      preferredDuringSchedulingIgnoredDuringExecution?: PreferredSchedulingTerm[];
      /** If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to an update), the system may or may not try to eventually evict the pod from its node. */
      requiredDuringSchedulingIgnoredDuringExecution?: NodeSelector;
  }/** @public */
  export declare interface PodAffinityTerm {
      /**
       * Label query over a set of resources, in this case pods.
       */
      labelSelector: LabelSelector;
      /** Specifies which namespaces the labelSelector applies to (matches against); null or empty list means "this pod's namespace" */
      namespaces?: string[];
      /** This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed. */
      topologyKey: string;
  }/** @public */
  export declare interface WeightedPodAffinityTerm {
      /** A pod affinity term, associated with the corresponding weight. */
      podAffinityTerm: PodAffinityTerm;
      /**
       * weight associated with matching the corresponding podAffinityTerm, in the range 1-100.
       */
      weight: number;
  }/** @public */
  export declare interface PodAffinity {
      /**
       * The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions.
       *
       * The node that is most preferred is the one with the greatest sum of weights,
       * i.e. for each node that meets all of the scheduling requirements (resource request,
       * requiredDuringScheduling affinity expressions, etc.), compute a sum by iterating
       * through the elements of this field and adding "weight" to the sum if the node has pods
       * which matches the corresponding podAffinityTerm; the node(s) with the highest sum are the most preferred.
       */
      preferredDuringSchedulingIgnoredDuringExecution: WeightedPodAffinityTerm[];
      /**
       * If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node.
       *
       * If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system may or may not try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each podAffinityTerm are intersected, i.e. all terms must be satisfied.
       */
      requiredDuringSchedulingIgnoredDuringExecution: PodAffinityTerm[];
  }/** @public */
  export declare interface PodAntiAffinity {
      /** The scheduler will prefer to schedule pods to nodes that satisfy the anti-affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling anti-affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the node(s) with the highest sum are the most preferred. */
      preferredDuringSchedulingIgnoredDuringExecution: WeightedPodAffinityTerm[];
      /** If the anti-affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the anti-affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system may or may not try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each podAffinityTerm are intersected, i.e. all terms must be satisfied. */
      requiredDuringSchedulingIgnoredDuringExecution: PodAffinity;
  }/** @public */
  export declare interface Affinity {
      /** Describes node affinity scheduling rules for the pod. */
      nodeAffinity: NodeAffinity;
      /** Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)). */
      podAffinity: PodAffinity;
      /** PodAntiAffinity	Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)). */
      podAntiAffinity: PodAntiAffinity;
  }/** @public */
  export declare interface PodDNSConfigOption {
      name: string;
      value?: string;
  }/** @public */
  export declare interface PodDNSConfig {
      /**
       * A list of DNS name server IP addresses.
       *
       * This will be appended to the base nameservers generated from DNSPolicy. Duplicated nameservers will be removed.
       */
      nameservers: string[];
      /**
       * A list of DNS resolver options.
       *
       * This will be merged with the base options generated from DNSPolicy.
       * Duplicated entries will be removed.
       * Resolution options given in Options will override those that appear in the base DNSPolicy.
       */
      options: PodDNSConfigOption[];
      /**
       * A list of DNS search domains for host-name lookup.
       *
       * This will be appended to the base search paths generated from DNSPolicy. Duplicated search paths will be removed.
       */
      searches: string[];
  }/** @public */
  export declare interface PodReadinessGate {
      /** Refers to a condition in the pod's condition list with matching type. */
      conditionType: string;
  }/** @public */
  export declare interface SELinuxOptions {
      /** SELinux level label that applies to the container. */
      level: string;
      /** SELinux role label that applies to the container. */
      role: string;
      /** SELinux type label that applies to the container. */
      type: string;
      /** SELinux user label that applies to the container */
      user: string;
  }/** @public */
  export declare interface SeccompProfile {
      /**
       * Indicates a profile defined in a file on the node should be used.
       *
       * The profile must be preconfigured on the node to work.
       * Must be a descending path, relative to the kubelet's configured seccomp profile location.
       * Must only be set if type is "Localhost".
       */
      localhostProfile?: string;
      /**
       * Indicates which kind of seccomp profile will be applied.
       *
       * Valid options are:
       * * Localhost - a profile defined in a file on the node should be used.
       * * RuntimeDefault - the container runtime default profile should be used.
       * * Unconfined - no profile should be applied.
       */
      type: "Localhost" | "RuntimeDefault" | "Unconfined";
  }/** @public */
  export declare interface Sysctl {
      name: string;
      value: string;
  }/** @public */
  export declare interface WindowsSecurityContextOptions {
      /**
       * The GMSA admission webhook ({@link https://github.com/kubernetes-sigs/windows-gmsa}) inlines the contents of the GMSA credential spec named by the GMSACredentialSpecName field.
       */
      gmsaCredentialSpec?: string;
      /**
       * GMSACredentialSpecName is the name of the GMSA credential spec to use.
       */
      gmsaCredentialSpecName?: string;
      /**
       * The UserName in Windows to run the entrypoint of the container process.
       *
       * Defaults to the user specified in image metadata if unspecified. May also be set in PodSecurityContext.
       * If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
       */
      runAsUserName?: string;
  }/** @public */
  export declare interface PodSecurityContext {
      /**
       * A special supplemental group that applies to all containers in a pod.
       *
       * Some volume types allow the Kubelet to change the ownership of that volume to be owned by the pod:
       *
       * 1. The owning GID will be the FSGroup
       * 2. The setgid bit is set (new files created in the volume will be owned by FSGroup)
       * 3. The permission bits are OR'd with rw-rw----
       *
       * If unset, the Kubelet will not modify the ownership and permissions of any volume.
       */
      fsGroup?: number;
      /**
       * Defines behavior of changing ownership and permission of the volume before being exposed inside Pod.
       *
       * This field will only apply to volume types which support fsGroup based ownership(and permissions).
       * It will have no effect on ephemeral volume types such as: secret, configmaps and emptydir.
       * Valid values are "OnRootMismatch" and "Always". If not specified defaults to "Always".
       *
       * @defaultValue Always
       */
      fsGroupChangePolicy?: "OnRootMismatch" | "Always";
      /**
       * The GID to run the entrypoint of the container process.
       *
       * Uses runtime default if unset. May also be set in SecurityContext.
       * If set in both SecurityContext and PodSecurityContext, the value specified in
       * SecurityContext takes precedence for that container.
       */
      runAsGroup?: number;
      /**
       * Indicates that the container must run as a non-root user.
       *
       * If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and
       * fail to start the container if it does. If unset or false, no such validation will be performed.
       * May also be set in SecurityContext.
       * If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
       */
      runAsNonRoot?: boolean;
      /**
       * The UID to run the entrypoint of the container process.
       *
       * Defaults to user specified in image metadata if unspecified.
       * May also be set in SecurityContext.
       * If set in both SecurityContext and PodSecurityContext, the value specified in
       * SecurityContext takes precedence for that container.
       */
      runAsUser?: number;
      /**
       * The SELinux context to be applied to all containers.
       *
       * If unspecified, the container runtime will allocate a random SELinux context for each container.
       * May also be set in SecurityContext.
       * If set in both SecurityContext and PodSecurityContext, the value specified in
       * SecurityContext takes precedence for that container.
       */
      seLinuxOptions?: SELinuxOptions;
      /**
       * The seccomp options to use by the containers in this pod.
       */
      seccompProfile?: SeccompProfile;
      /**
       * 	A list of groups applied to the first process run in each container, in addition to the container's primary GID.
       *
       *  If unspecified, no groups will be added to any container.
       */
      supplementalGroups?: number[];
      /**
       * Sysctls hold a list of namespaced sysctls used for the pod.
       *
       * Pods with unsupported sysctls (by the container runtime) might fail to launch.
       */
      sysctls?: Sysctl[];
      /**
       * The Windows specific settings applied to all containers.
       *
       * If unspecified, the options within a container's SecurityContext will be used.
       * If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
       */
      windowsOptions: WindowsSecurityContextOptions;
  }/** @public */
  export declare interface Toleration {
      /**
       * Indicates the taint effect to match.
       *
       * Empty means match all taint effects.
       * When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
       */
      effect?: "NoSchedule" | "PreferNoSchedule" | "NoExecute";
      /**
       * The taint key that the toleration applies to.
       *
       * Empty means match all taint keys.
       * If the key is empty, operator must be Exists;
       * this combination means to match all values and all keys.
       */
      key?: string;
      /**
       * Represents a key's relationship to the value.
       *
       * Valid operators are Exists and Equal.
       * Defaults to Equal.
       * Exists is equivalent to wildcard for value, so that a pod can tolerate all taints of a particular category.
       *
       * @defaultValue Equal
       */
      operator?: "Exists" | "Equal";
      /**
       * Represents the period of time the toleration (which must be of effect NoExecute, otherwise this field is ignored) tolerates the taint.
       *
       * By default, it is not set, which means tolerate the taint forever (do not evict).
       * Zero and negative values will be treated as 0 (evict immediately) by the system.
       */
      tolerationSeconds?: number;
      /**
       * Value is the taint value the toleration matches to.
       *
       * If the operator is Exists, the value should be empty, otherwise just a regular string.
       */
      value?: string;
  }/** @public */
  export declare interface TopologySpreadConstraint {
      /**
       * Used to find matching pods.
       *
       * Pods that match this label selector are counted to determine the
       * number of pods in their corresponding topology domain.
       */
      labelSelector: LabelSelector;
      /**
       * Describes the degree to which pods may be unevenly distributed.
       *
       * When `whenUnsatisfiable=DoNotSchedule`, it is the maximum permitted
       * difference between the number of matching pods in the target topology
       * and the global minimum.
       * For example, in a 3-zone cluster, MaxSkew is set to 1, and pods with
       * the same labelSelector spread as 1/1/0: | zone1 | zone2 | zone3 | | P | P | |
       * - if MaxSkew is 1, incoming pod can only be scheduled to zone3 to become 1/1/1;
       *   scheduling it onto zone1(zone2) would make the ActualSkew(2-0) on zone1(zone2) violate MaxSkew(1).
       * - if MaxSkew is 2, incoming pod can be scheduled onto any zone.
       * When `whenUnsatisfiable=ScheduleAnyway`, it is used to give higher precedence to topologies that satisfy it.
       * It's a required field. Default value is 1 and 0 is not allowed.
       *
       * @example
       *
       * @defaultValue 1
       */
      maxSkew: number;
      /**
       * The key of node labels.
       *
       * Nodes that have a label with this key and identical values are considered to be in the same topology.
       * We consider each \<key, value\> as a "bucket", and try to put balanced number of pods into each bucket.
       * It's a required field.
       */
      topologyKey: string;
      /**
       * Indicates how to deal with a pod if it doesn't satisfy the spread constraint.
       *
       * - DoNotSchedule (default) tells the scheduler not to schedule it.
       * - ScheduleAnyway tells the scheduler to schedule the pod in any location,
       *   but giving higher precedence to topologies that would help reduce the skew.
       *
       * A constraint is considered "Unsatisfiable" for an incoming pod if and only if every possible
       * node assigment for that pod would violate "MaxSkew" on some topology.
       * For example, in a 3-zone cluster, MaxSkew is set to 1, and pods with the same labelSelector
       * spread as 3/1/1: | zone1 | zone2 | zone3 | | P P P | P | P | If WhenUnsatisfiable is set to DoNotSchedule,
       * incoming pod can only be scheduled to zone2(zone3) to become 3/2/1(3/1/2)
       * as ActualSkew(2-1) on zone2(zone3) satisfies MaxSkew(1).
       * In other words, the cluster can still be imbalanced, but scheduler won't make it
       * *more* imbalanced.
       *
       * It's a required field.
       */
      whenUnsatisfiable: string;
  }/** @public */
  export declare interface KeyToPath {
      /** The key to project. */
      key: string;
      /**
       * mode bits to use on this file,
       * Must be a value between 0 and 0777.
       * If not specified, the volume defaultMode will be used.
       * This might be in conflict with other options that affect the file mode, like fsGroup,
       * and the result can be other mode bits set.
       */
      mode?: number;
      /**
       * The relative path of the file to map the key to.
       *
       * May not be an absolute path. May not contain the path element '..'. May not start with the string '..'.
       */
      path: string;
  }/** @public */
  export declare interface ConfigMapVolumeSource {
      /**
       * mode bits to use on created files by default.
       *
       * Must be a value between 0 and 0777. Defaults to 0644.
       * Directories within the path are not affected by this setting.
       * This might be in conflict with other options that affect the file mode,
       * like fsGroup, and the result can be other mode bits set.
       */
      defaultMode?: number;
      /**
       * If unspecified, each key-value pair in the Data field of the referenced ConfigMap will be projected into the volume as a file whose name is the key and content is the value.
       *
       * If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present.
       * If a key is specified which is not present in the ConfigMap, the volume setup will error unless it is marked optional.
       * Paths must be relative and may not contain the '..' path or start with '..'.
       */
      items?: KeyToPath[];
      /**
       * Name of the referent.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names}
       */
      name: string | Handle;
      /** Specify whether the ConfigMap or its keys must be defined */
      optional?: boolean;
  }/** @public */
  export declare interface SecretVolumeSource {
      /**
       * mode bits to use on created files by default.
       *
       * Must be a value between 0 and 0777. Defaults to 0644.
       * Directories within the path are not affected by this setting.
       * This might be in conflict with other options that affect the file mode,
       * like fsGroup, and the result can be other mode bits set.
       */
      defaultMode?: number;
      /**
       * If unspecified, each key-value pair in the Data field of the referenced Secret will be projected into the volume as a file whose name is the key and content is the value.
       *
       * If specified, the listed keys will be projected into the specified paths,
       * and unlisted keys will not be present. If a key is specified which is not
       * present in the Secret, the volume setup will error unless it is marked optional.
       *
       * Paths must be relative and may not contain the '..' path or start with '..'.
       */
      items?: KeyToPath[];
      /** Specify whether the Secret or its keys must be defined */
      optional?: boolean;
      /**
       * Name of the secret in the pod's namespace to use.
       *
       *  More info: {@link https://kubernetes.io/docs/concepts/storage/volumes#secret}
       */
      secretName: string | Handle;
  }/** @public */
  export declare interface EmptyDirVolumeSource {
      /**
       * What type of storage medium should back this directory.
       *
       * The default is "" which means to use the node's default medium.
       * Must be an empty string (default) or Memory.
       * More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
       */
      medium: string;
      /**
       * Total amount of local storage required for this EmptyDir volume.
       *
       * The size limit is also applicable for memory medium.
       * The maximum usage on memory medium EmptyDir would be the minimum
       * value between the SizeLimit specified here and the sum of memory limits of all containers in a pod.
       * The default is nil which means that the limit is undefined.
       * More info: {@link http://kubernetes.io/docs/user-guide/volumes#emptydir}
       */
      sizeLimit: string;
  }/**
   * Volumes for {@link k8s.PodProps}
   *
   * @public
   */
  export declare interface Volume {
      /**
       * Volume's name.
       *
       * Must be a DNS_LABEL and unique within the pod.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names}
       */
      name: string;
      /**
       * Represents a configMap that should populate this volume
       */
      configMap?: ConfigMapVolumeSource;
      /**
       * EmptyDir represents a temporary directory that shares a pod's lifetime.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/storage/volumes#emptydir}
       *
       */
      emptyDir?: EmptyDirVolumeSource;
      /**
       * Represents a secret that should populate this volume.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/storage/volumes#secret}
       */
      secret?: SecretVolumeSource;
      /** Other k8s volume kinds not typed yet for \@adpt/cloud */
      [key: string]: any;
  }/**
   * Props for the {@link k8s.Pod} component
   *
   * @public
   */
  export declare interface PodProps extends WithChildren {
      /**
       *  True is this is a template for use in a controller, false otherwise
       *  @defaultValue false
       */
      isTemplate: boolean;
      /** Information about the k8s cluster (ip address, auth info, etc.) */
      config?: ClusterInfo;
      /** k8s metadata */
      metadata: Metadata;
      /**
       * Optional duration in seconds the pod may be active on the node relative to StartTime before the system will actively try to mark it failed and kill associated containers.
       *
       * Value must be a positive integer.
       */
      activeDeadlineSeconds?: number;
      /** If specified, the pod's scheduling constraints */
      affinity?: Affinity;
      /** AutomountServiceAccountToken indicates whether a service account token should be automatically mounted. */
      automountServiceAccountToken?: boolean;
      /**
       *  Specifies the DNS parameters of a pod.
       *
       *  Parameters specified here will be merged to the generated DNS configuration based on DNSPolicy.
       */
      dnsConfig?: PodDNSConfig;
      /**
       * Set DNS policy for the pod.
       *
       * Valid values are 'ClusterFirstWithHostNet', 'ClusterFirst', 'Default' or 'None'.
       * DNS parameters given in DNSConfig will be merged with the policy selected with DNSPolicy.
       * To have DNS options set along with hostNetwork, you have to specify DNS policy explicitly
       * to 'ClusterFirstWithHostNet'.
       *
       * @defaultValue ClusterFirst
       */
      dnsPolicy: "ClusterFirstWithHostNet" | "ClusterFirst" | "Default" | "None";
      /**
       * Indicates whether information about services should be injected into pod's environment variables matching the syntax of Docker links.
       *
       * @defaultValue true
       */
      enableServiceLinks: boolean;
      /**
       * An optional list of hosts and IPs that will be injected into the pod's hosts file if specified.
       *
       * This is only valid for non-hostNetwork pods.
       */
      hostAliases?: HostAlias[];
      /**
       * Use the host's ipc namespace.
       * @defaultValue false
       */
      hostIPC: boolean;
      /**
       * Host networking requested for this pod.
       *
       * Use the host's network namespace.
       * If this option is set, the ports that will be used must be specified. Default to false.
       */
      hostNetwork?: boolean;
      /**
       * Use the host's pid namespace.
       * @defaultValue false
       */
      hostPID: boolean;
      /**
       * Specifies the hostname of the Pod.
       *
       * If not specified, the pod's hostname will be set to a system-defined value.
       */
      hostname?: string;
      /**
       * List of references to secrets in the same namespace to use for pulling any of the images used by this PodSpec.
       *
       * If specified, these secrets will be passed to individual puller implementations for them to use.
       * For example, in the case of docker, only DockerConfig type secrets are honored.
       * More info: {@link https://kubernetes.io/docs/concepts/containers/images#specifying-imagepullsecrets-on-a-pod}
       */
      imagePullSecrets?: LocalObjectReference[];
      /**
       * A request to schedule this pod onto a specific node.
       *
       * If it is non-empty, the scheduler simply schedules this pod onto that node,
       * assuming that it fits resource requirements.
       */
      nodeName?: string;
      /**
       * A selector which must be true for the pod to fit on a node.
       *
       * Selector which must match a node's labels for the pod to be scheduled on that node.
       * More info: {@link https://kubernetes.io/docs/concepts/configuration/assign-pod-node/}
       */
      nodeSelector?: {
          [label: string]: boolean | string;
      };
      /**
       * Overhead represents the resource overhead associated with running a pod for a given RuntimeClass.
       *
       * This field will be autopopulated at admission time by the RuntimeClass admission controller.
       * If the RuntimeClass admission controller is enabled, overhead must not be set in Pod create requests.
       * The RuntimeClass admission controller will reject Pod create requests which have the overhead already set.
       * If RuntimeClass is configured and selected in the PodSpec, Overhead will be set to the value defined in
       * the corresponding RuntimeClass, otherwise it will remain unset and treated as zero.
       *
       * More info: {@link https://git.k8s.io/enhancements/keps/sig-node/20190226-pod-overhead.md}
       *
       * This field is alpha-level as of Kubernetes v1.16, and is only honored by servers that enable
       * the PodOverhead feature.
       * @alpha
       */
      overhead?: unknown;
      /**
       * PreemptionPolicy is the Policy for preempting pods with lower priority.
       *
       * This field is beta-level, gated by the NonPreemptingPriority feature-gate.
       *
       * @defaultValue PreemptLowerPriority
       * @beta
       */
      preemptionPolicy?: "Never" | "PreemptLowerPriority";
      /**
       * The priority various system components use this field to find the priority of the pod.
       *
       * When Priority Admission Controller is enabled, it prevents users from setting this field.
       * The admission controller populates this field from PriorityClassName.
       * The higher the value, the higher the priority.
       */
      priority?: number;
      /**
       * If specified, indicates the pod's priority.
       *
       * "system-node-critical" and "system-cluster-critical" are two special keywords which indicate the highest
       * priorities with the former being the highest priority. Any other name must be defined by creating a PriorityClass
       * object with that name. If not specified, the pod priority will be default or zero if there is no default.
       */
      priorityClassName?: string;
      /**
       *  If specified, all readiness gates will be evaluated for pod readiness.
       *
       *  A pod is ready when all its containers are ready AND all conditions specified
       *  in the readiness gates have status equal to "True"
       *
       *  More info: {@link https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#pod-readiness-gate}
       */
      readinessGates?: PodReadinessGate[];
      /**
       * Restart policy for all containers within the pod.
       *
       * One of Always, OnFailure, Never. Default to Always.
       * More info: {@link https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy}
       *
       * @defaultValue Always
       */
      restartPolicy: "Always" | "OnFailure" | "Never";
      /**
       * Refers to a RuntimeClass object in the node.k8s.io group, which should be used to run this pod.
       *
       * If no RuntimeClass resource matches the named class, the pod will not be run.
       * If unset or empty, the "legacy" RuntimeClass will be used, which is an implicit
       * class with an empty definition that uses the default runtime handler.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/containers/runtime-class/}
       *
       * This is a beta feature as of Kubernetes v1.14.
       */
      runtimeClassName?: string;
      /**
       *  If specified, the pod will be dispatched by specified scheduler.
       *  If not specified, the pod will be dispatched by default scheduler.
       */
      schedulerName?: string;
      /**
       * SecurityContext holds pod-level security attributes and common container settings.
       * See type description for default values of each field.
       *
       * @defaultValue \{\}
       */
      securityContext: PodSecurityContext;
      /**
       * ServiceAccountName is the name of the ServiceAccount to use to run this pod.
       * More info: {@link https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/}
       */
      serviceAccountName?: string | Handle;
      /**
       * If true the pod's hostname will be configured as the pod's FQDN, rather than the leaf name (the default).
       * In Linux containers, this means setting the FQDN in the hostname field of the kernel
       * (the nodename field of struct utsname).
       * In Windows containers, this means setting the registry value of hostname for the registry key
       * HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters to FQDN.
       * If a pod does not have FQDN, this has no effect.
       *
       * @defaultValue false
       */
      setHostnameAsFQDN?: boolean;
      /**
       * Share a single process namespace between all of the containers in a pod.
       * When this is set containers will be able to view and signal processes from other containers in the same pod,
       * and the first process in each container will not be assigned PID 1.
       * HostPID and ShareProcessNamespace cannot both be set.
       *
       * @defaultValue false
       */
      shareProcessNamespace: boolean;
      /**
       *  If specified, the fully qualified Pod hostname will be "\<hostname\>.\<subdomain\>.\<pod namespace\>.svc.\<cluster domain\>".
       *  If not specified, the pod will not have a domainname at all.
       */
      subdomain?: string;
      /**
       * Optional duration in seconds the pod needs to terminate gracefully.
       *
       * May be decreased in delete request. Value must be non-negative integer.
       * The value zero indicates delete immediately. If this value is nil, the default
       * grace period will be used instead. The grace period is the duration in seconds
       * after the processes running in the pod are sent a termination signal and the time
       * when the processes are forcibly halted with a kill signal. Set this value longer
       * than the expected cleanup time for your process. Defaults to 30 seconds.
       */
      terminationGracePeriodSeconds?: number;
      /** If specified, the pod's tolerations. */
      tolerations?: Toleration[];
      /**
       *  TopologySpreadConstraints describes how a group of pods ought to spread across topology domains.
       *
       *  Scheduler will schedule pods in a way which abides by the constraints. All topologySpreadConstraints are ANDed.
       */
      topologySpreadConstraints?: TopologySpreadConstraint[];
      /**
       * List of volumes that can be mounted by containers belonging to the pod.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/storage/volumes}
       */
      volumes?: Volume[];
  }/**
   * Component for Kubernetes Pods
   *
   * @public
   */
  export declare class Pod extends DeferredComponent<PodProps, ResolvedVolumes & ResolvedServiceAccountName> {
      static defaultProps: {
          isTemplate: boolean;
          metadata: {};
          dnsPolicy: string;
          enableServiceLinks: boolean;
          hostIPC: boolean;
          hostPID: boolean;
          restartPolicy: string;
          securityContext: {};
          shareProcessNamespace: boolean;
          terminationGracePeriodSeconds: number;
      };
      initialState(): {};
      build(helpers: BuildHelpers): Adapt.JSX.Element | null;
      status(_observe: ObserveForStatus, buildData: BuildData): Promise<Adapt.Status | undefined>;
  }/**
   * Spec for for Kubernetes Pods
   *
   * @public
   */
  export declare interface PodSpec extends Omit<PodProps, "config" | "metadata" | "isTemplate"> {
      containers: ContainerSpec[];
      terminationGracePeriodSeconds?: number;
  }/** @internal */
  const podResourceInfo: {
      kind: string;
      deployedWhen: typeof deployedWhen;
      statusQuery: (props: ResourcePropsWithConfig, observe: ObserveForStatus, buildData: BuildData) => Promise<any>;
  };/**
   * k8s Secret resource
   *
   * @param propsIn - props for Secret as specifed in {@link k8s.SecretProps}
   *
   * @public
   */
  export declare function Secret(propsIn: SFCDeclProps<SecretProps, typeof defaultProps>): Adapt.JSX.Element;/** @internal */
  const secretResourceInfo: {
      kind: string;
      deployedWhen: () => true;
      statusQuery: (props: ResourcePropsWithConfig, observe: ObserveForStatus, buildData: BuildData) => Promise<any>;
      makeManifest: (manifest: Manifest, elem: AdaptElement<ResourceProps>, _deployID: string) => {
          data: {
              [key: string]: string;
          } | undefined;
          stringData: {
              [key: string]: string;
          } | undefined;
          type: string | undefined;
          apiVersion: string; /**
           * stringData allows specifying non-binary secret data in string form.
           *
           * It is provided as a write-only convenience method. All keys and values are merged into the data field on write,
           * overwriting any existing values. It is never output when reading from the API.
           */
          kind: string;
          metadata: import("./manifest_support").MetadataInRequest;
          spec?: import("./DaemonSet").DaemonSetSpec | import("./common").CRSpec | import("./Pod").PodSpec | import("./Service").ServiceSpec | import("./Deployment").DeploymentSpec | undefined;
      };
  };/**
   * Convert {@link NetworkService} props to {@link k8s.Service} props
   * @param abstractProps - props to convert
   * @returns Kubernetes spec corresponding to `abstractProps`
   *
   * @internal
   */
  export declare function k8sServiceProps(abstractProps: NetworkServiceProps & BuiltinProps): Omit<ServiceProps, keyof ResourceBase>;/**
   * Native Kubernetes Service resource
   *
   * @remarks
   *
   * Implements the {@link NetworkServiceInstance} interface.
   *
   * @public
   */
  export declare function Service(propsIn: SFCDeclProps<ServiceProps, typeof defaultProps>): Adapt.JSX.Element;/** @public */
  export declare interface ServiceProps extends ServiceSpec {
      /** Legal configuration loaded from kubeconfig */
      config: ClusterInfo;
      metadata?: Metadata;
      selector?: Handle | EndpointSelector;
  }/** @public */
  export declare interface ServiceSpec {
      /**
       * Cluster IP for a {@link k8s.Service}
       *
       * @remarks
       * `clusterIP` is the IP address of the service and is usually assigned
       * randomly by the master. If an address is specified manually and is not
       * in use by others, it will be allocated to the service; otherwise,
       * creation of the service will fail. This field can not be changed through
       * updates. Valid values are "None", empty string (""), or a valid IP
       * address. "None" can be specified for headless services when proxying is
       * not required. Only applies to types ClusterIP, NodePort, and
       * LoadBalancer. Ignored if type is ExternalName.
       *
       * For more information, see the
       * {@link https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies |
       * Kubernetes documentation}.
       */
      clusterIP?: string;
      /**
       * A list of IP addresses for which nodes in the cluster
       * will also accept traffic for this service.
       *
       * @remarks
       * These IPs are not managed by
       * Kubernetes. The user is responsible for ensuring that traffic arrives at
       * a node with this IP. A common example is external load balancers that are
       * not part of the Kubernetes system.
       */
      externalIPs?: string[];
      /**
       * The external reference that kubedns or equivalent
       * will return as a CNAME record for this service.
       *
       * @remarks
       * No proxying will be involved. Must be a
       * {@link https://tools.ietf.org/html/rfc1123 | valid RFC-1123 hostname}
       * and requires Type to be ExternalName.
       */
      externalName?: string;
      /**
       * Denotes if this Service desires to route
       * external traffic to node-local or cluster-wide endpoints.
       *
       * @remarks
       * "Local" preserves the client source IP and avoids a second hop for
       * LoadBalancer and Nodeport type services, but risks potentially
       * imbalanced traffic spreading. "Cluster" obscures the client source IP
       * and may cause a second hop to another node, but should have good overall
       * load-spreading.
       */
      externalTrafficPolicy?: string;
      /**
       * Specifies the healthcheck nodePort for the service.
       *
       * @remarks
       * If not specified, HealthCheckNodePort is created by the service
       * api backend with the allocated nodePort. Will use user-specified nodePort
       * value if specified by the client. Only affects when Type is set to
       * LoadBalancer and ExternalTrafficPolicy is set to Local.
       */
      healthCheckNodePort?: number;
      /**
       * Only applies to Service Type: LoadBalancer. LoadBalancer will
       * get created with the IP specified in this field.
       *
       * @remarks
       * This feature depends on
       * whether the underlying cloud provider supports specifying the loadBalancerIP
       * when a load balancer is created. This field will be ignored if the
       * cloud provider does not support the feature.
       */
      loadBalancerIP?: string;
      /**
       * If specified and supported by the platform, this will
       * restrict traffic through the cloud provider load balancer
       * to the specified client IPs.
       *
       * @remarks
       * This field will be ignored if the cloud provider
       * does not support the feature.
       *
       * For more information, see the
       * {@link https://v1-17.docs.kubernetes.io/docs/tasks/access-application-cluster/configure-cloud-provider-firewall/ |
       * Kubernetes documentation}.
       */
      loadBalancerSourceRanges?: string[];
      /**
       * The list of ports that are exposed by this service.
       *
       * @remarks
       * For more information, see the
       * {@link https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies |
       * Kubernetes documentation}.
       */
      ports?: ServicePort[];
      /**
       * When set to true, indicates that
       * DNS implementations must publish the notReadyAddresses of subsets for the
       * Endpoints associated with the Service.
       *
       * @remarks
       * The default value is false. The
       * primary use case for setting this field is to use a StatefulSet's Headless
       * Service to propagate SRV records for its Pods without respect to their
       * readiness for purpose of peer discovery.
       */
      publishNotReadyAddresses?: boolean;
      /**
       * Route service traffic to pods with label keys and values
       * matching this selector.
       *
       * @remarks
       * If empty or not present, the service is assumed to
       * have an external process managing its endpoints, which Kubernetes will not
       * modify. Only applies to types ClusterIP, NodePort, and LoadBalancer.
       * Ignored if type is ExternalName.
       *
       * For more information, see the
       * {@link https://kubernetes.io/docs/concepts/services-networking/service/ |
       * Kubernetes documentation}.
       */
      selector?: EndpointSelector | object;
      /**
       * Used to maintain session affinity.
       *
       * @remarks
       * Possible values are:
       *
       * - `"ClientIP"`: Enables client IP based session affinity.
       *
       * - `"None"`: Disables session affinity.
       *
       * For more information, see the
       * {@link https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies |
       * Kubernetes documentation}.
       * @defaultValue `"None"`
       */
      sessionAffinity?: string;
      /**
       * Determines how the Service is exposed.
       *
       * @remarks
       * Valid options are:
       *
       * - `"ExternalName"`: maps to the specified externalName.
       *
       * - `"ClusterIP"`: allocates a cluster-internal IP address for load
       * balancing to endpoints. Endpoints are determined by the selector or if
       * that is not specified, by manual construction of an Endpoints object. If
       * clusterIP is "None", no virtual IP is allocated and the endpoints are
       * published as a set of endpoints rather than a stable IP.
       *
       * - `"NodePort"`: Builds on ClusterIP and allocates a port on every node
       * which routes to the clusterIP.
       *
       * - `"LoadBalancer"`: Builds on NodePort and creates an external load
       * balancer (if supported in the current cloud) which routes to the
       * clusterIP.
       *
       * For more information, see the
       * {@link https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services---service-types |
       * Kubernetes documentation}.
       * @defaultValue `"ClusterIP"`
       */
      type?: string;
  }/** @public */
  export declare interface ServicePort {
      /**
       * The name of this port within the service.
       *
       * @remarks
       * This must be a DNS_LABEL.
       * All ports within a ServiceSpec must have unique names.This maps to the
       * Name' field in EndpointPort objects. Optional if only one ServicePort is
       * defined on this service.
       */
      name?: string;
      /**
       * The port on each node on which this service is exposed when
       * type=NodePort or LoadBalancer.
       *
       * @remarks
       * Usually assigned by the system. If
       * specified, it will be allocated to the service if unused or else creation
       * of the service will fail.
       *
       * For more information, see the
       * {@link https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport |
       * Kubernetes documentation}.
       * @defaultValue Automatically allocates a port if the ServiceType of this
       * Service requires one.
       */
      nodePort?: number;
      /** The port that will be exposed by this service. */
      port?: number;
      /** The IP protocol for this port.Supports "TCP" and "UDP".Default is TCP. */
      protocol?: string;
      /**
       * Number or name of the port to access on the pods targeted by the
       * service.
       *
       * @remarks
       * Number must be in the range 1 to 65535. Name must be an
       * IANA_SVC_NAME. If this is a string, it will be looked up as a named port
       * in the target Pod's container ports. If this is not specified, the value
       * of the 'port' field is used (an identity map). This field is ignored for
       * services with clusterIP = None, and should be omitted or set equal to the
       * 'port' field.
       *
       * For more information, see the
       * {@link https://kubernetes.io/docs/concepts/services-networking/service/#defining-a-service |
       * Kubernetes documentation}.
       */
      targetPort?: number | string;
  }/** @internal */
  const serviceResourceInfo: {
      kind: string;
      deployedWhen: typeof deployedWhen;
      statusQuery: (props: ResourcePropsWithConfig, observe: ObserveForStatus, buildData: BuildData) => Promise<any>;
  };/**
   * k8s ServiceAccount resource
   *
   * @param propsIn - props for ServiceAccount as specifed in {@link k8s.ServiceAccountProps}
   *
   * @public
   */
  export declare function ServiceAccount(propsIn: SFCDeclProps<ServiceAccountProps, typeof defaultProps>): Adapt.JSX.Element;/** @public */
  export declare function isServiceAccountProps(p: ResourceProps): p is ResourceProps & ResourceServiceAccount;/** @internal */
  const serviceAccountResourceInfo: {
      kind: string;
      deployedWhen: () => true;
      statusQuery: (props: ResourcePropsWithConfig, observe: ObserveForStatus, buildData: BuildData) => Promise<any>;
      makeManifest: (manifest: Manifest, elem: AdaptElement<ResourceProps>, _deployID: string) => {
          automountServiceAccountToken: boolean | undefined;
          imagePullSecrets: {
              name: string;
          }[] | undefined;
          secrets: ObjectReference[] | undefined;
          apiVersion: string;
          kind: string;
          metadata: import("./manifest_support").MetadataInRequest;
          spec?: import("./DaemonSet").DaemonSetSpec | import("./common").CRSpec | import("./Pod").PodSpec | import("./Service").ServiceSpec | import("./Deployment").DeploymentSpec | undefined;
      };
  };/**
   * Props for {@link k8s.ServiceDeployment}
   *
   * @public
   */
  export declare interface ServiceDeploymentProps<T extends AllowableComponentProps = DeploymentProps> extends ServiceProps {
      config: ClusterInfo;
      serviceProps?: Partial<ServiceProps>;
      component: ComponentType<T>;
      componentProps: T;
      podProps?: Partial<PodProps>;
      containerProps?: Partial<OmitT<K8sContainerProps, "image">>;
  }/**
   * A component for mapping a group of abstract {@link Container}s and
   * {@link NetworkService}s to Kubernetes {@link k8s.Pod}s and
   * {@link k8s.K8sContainer}s.
   *
   * @remarks
   * This component is intended to be used to replace {@link Container} and
   * {@link NetworkService} components that are grouped together, as the
   * only children of a common parent in a pattern that looks like this:
   *
   * ```tsx
   * <Service>
   *   <Container ... />
   *   <Container ... />
   *   <NetworkService ... />
   * </Service>
   * ```
   *
   * `ServiceDeployment` would map those abstract components into corresponding
   * k8s components like this:
   * ```tsx
   * <Group>
   *   <docker.RegistryDockerImage ... /> //If props.config specifies a registry
   *   <k8s.Deployment ... >
   *     <Pod isTemplate>
   *       <k8s.K8sContainer ... />
   *     </Pod>
   *   </k8s.Deployment>
   *   <docker.RegistryDockerImage ... /> //If props.config specifies a registry
   *   <k8s.Deployment ... >
   *     <Pod isTemplate>
   *       <k8s.K8sContainer ... />
   *     </Pod>
   *   </k8s.Pod>
   *   <k8s.Service ... />
   * </Group>
   * ```
   * An example style rule to do this is:
   * ```tsx
   * {Adapt.rule((matchedProps) => {
   *     const { handle, ...remainingProps } = matchedProps;
   *     return <ServiceDeployment config={kubeconfig} {...remainingProps} />;
   * })}
   * ```
   * `ServiceDeployment` also requires the `config` prop which specifies
   * connection and authentication information for the Kubernetes cluster on
   * which these objects should be created.
   *
   * @public
   */
  export declare class ServiceDeployment<T extends AllowableComponentProps> extends DeferredComponent<ServiceDeploymentProps<T>> {
      static defaultProps: {
          component: typeof Deployment;
          componentProps: {
              replicas: number;
          };
      };
      build(helpers: BuildHelpers): Adapt.JSX.Element;
  }/** @public */
  export declare function computeNamespaceFromMetadata(metadata?: Metadata): string;/** @public */
  export declare function isLabelSelector(x: any): x is LabelSelector;/**
   * Kubernetes Kind
   *
   * @public
   */
  export declare type Kind = string;/** @public */
  export declare interface CRSpec {
      [key: string]: any;
  }/** @public */
  export declare type Spec = DaemonSetSpec | DeploymentSpec | PodSpec | ServiceSpec | CRSpec;/** @public */
  export declare interface Metadata {
      namespace?: string;
      labels?: {
          [key: string]: string;
      };
      annotations?: {
          [key: string]: string;
      };
  }/** @public */
  export declare type ResourceProps = {
      key: string;
  } & (ResourceClusterRole | ResourceClusterRoleBinding | ResourceDaemonSet | ResourcePod | ResourceService | ResourceServiceAccount | ResourceConfigMap | ResourceSecret | ResourceCR);/** @public */
  export declare type ResourcePropsWithConfig = ResourceProps & {
      config: ClusterInfo;
  };/** @public */
  export declare interface ResourceInfo {
      kind: Kind;
      statusQuery?: (props: ResourceProps, observe: ObserveForStatus, buildData: BuildData) => unknown | Promise<unknown>;
      specsEqual(actual: Spec, element: Spec): boolean;
  }/**
   * Holds the information needed to connect, authenticate, and run code in a kuberenetes cluster
   *
   * @public
   */
  export declare interface ClusterInfo {
      /** Javascript object formed by parsing a valid kubeconfig file */
      kubeconfig: Kubeconfig;
      /**
       * Registry to which Docker images used by the cluster in `kubeconfig` should be pushed and pulled
       *
       * @remarks
       * If `registryPrefix` is a string, it is assumed that the cluster can pull from the same string
       * that outsiders can push to.
       *
       * If `registryPrefix` is of the form `{ external: string, internal: string }` then the `external`
       * string will be used to push images, and the `internal` string will be used to pull images.
       *
       * Note(manishv)
       * This is a bit of a hack to allow one hostname or IP address to push images from outside
       * a particular environment (say k8s) and a different URL for that environment to pull
       * images.
       *
       * A good example of this is a k3s-dind (k3s docker-in-docker) instance of kubernetes where
       * a private registry is running on a docker network attached to the k3s-dind instance, but where we
       * want to push {@link docker.LocalDockerImage} built images to that registry.  Since
       * {@link docker.LocalDockerImage | LocalDockerImage} is outside the k3s-dind environment, it must
       * use a host accessible network to push to the registry.  However, since the k3s-dind instance sees
       * the registry from within Docker, it must use a different address to pull the images for use.
       *
       * Once network scopes are fully supported, this interface will change to whatever is appropriate.  It
       * is best if you can arrange to have the same URL or registry string work for all access regardless
       * of which network the registry, Adapt host, and ultimate container running environment uses.
       *
       */
      registryPrefix?: string | DockerSplitRegistryInfo;
  }/** @public */
  export declare interface ResourceBase {
      /**
       * config to connect to the k8s cluster
       *
       * required if isTemplate is false
       */
      config?: ClusterInfo;
      /**
       * Specifies whether this resource is just a template for use in a controller
       */
      isTemplate?: boolean;
      apiVersion?: string;
      kind: Kind;
      metadata?: Metadata;
  }/**
   * @public
   */
  export declare interface PolicyRule {
      /**
       * APIGroups is the name of the APIGroup that contains the resources.
       *
       * If multiple API groups are specified, any action requested against one
       * of the enumerated resources in any API group will be allowed.
       */
      apiGroups?: string[];
      /**
       * NonResourceURLs is a set of partial urls that a user should have access to.
       *
       * *s are allowed, but only as the full, final step in the path.
       * Since non-resource URLs are not namespaced, this field is only applicable
       * for ClusterRoles referenced from a ClusterRoleBinding.
       * Rules can either apply to API resources (such as "pods" or "secrets") or
       * non-resource URL paths (such as "/api"), but not both.
       */
      nonResourceURLs?: string[];
      /**
       * ResourceNames is an optional white list of names that the rule applies to.
       *
       * An empty set means that everything is allowed.
       */
      resourceNames?: string[];
      /**
       * Resources is a list of resources this rule applies to.
       *
       * ResourceAll represents all resources.
       */
      resources: string[];
      /**
       * Verbs is a list of Verbs that apply to ALL the ResourceKinds and
       * AttributeRestrictions contained in this rule.
       *
       * VerbAll represents all kinds.
       */
      verbs: string[];
  }/**
   * AggregationRule for {@link k8s.ClusterRole}
   *
   * @public
   */
  export declare interface AggregationRule {
      /**
       * ClusterRoleSelectors holds a list of selectors which will be used to
       * find ClusterRoles and create the rules.
       *
       * If any of the selectors match, then the ClusterRole's permissions will be added
       */
      clusterRoleSelector: LabelSelector;
  }/** @public */
  export declare interface ResourceClusterRole extends ResourceBase {
      apiVersion: "rbac.authorization.k8s.io/v1";
      kind: "ClusterRole";
      aggregationRule?: AggregationRule;
      rules?: PolicyRule[];
  }/**
   * RoleRef for {@link k8s.ResourceClusterRoleBinding}
   *
   * @public
   */
  export declare interface RoleRef {
      /** apiGroup is the group for the resource being referenced */
      apiGroup: string;
      /** kind is the type of resource being referenced */
      kind: string;
      /** Name is the name of resource being referenced */
      name: string;
  }/**
   * Subject for {@link k8s.ResourceClusterRoleBinding}
   *
   * @public
   */
  export declare interface Subject {
      /** apiGroup is the group for the object being referenced */
      apiGroup: string;
      /** kind is the type of object being referenced */
      kind: string;
      /**
       * Name of the object being referenced.
       */
      name: string;
      /**
       * Namespace of the referenced object.
       *
       * If the object kind is non-namespace, such as "User" or "Group", and this value
       * is not empty the Authorizer should report an error.
       */
      namespace?: string;
  }/** @public */
  export declare interface ResourceClusterRoleBinding extends ResourceBase {
      apiVersion: "rbac.authorization.k8s.io/v1";
      kind: "ClusterRoleBinding";
      roleRef: RoleRef;
      subjects: Subject[];
  }/** @public */
  export declare interface ResourceDaemonSet extends ResourceBase {
      apiVersion: "apps/v1";
      kind: "DaemonSet";
      spec: DaemonSetSpec;
  }/** @public */
  export declare interface ResourcePod extends ResourceBase {
      kind: "Pod";
      spec: PodSpec;
  }/** @public */
  export declare interface ResourceService extends ResourceBase {
      kind: "Service";
      spec: ServiceSpec;
  }/** @public */
  export declare interface ResourceServiceAccount extends ResourceBase {
      kind: "ServiceAccount";
      automountServiceAccountToken?: boolean;
      imagePullSecrets?: {
          name: string;
      }[];
      secrets?: ObjectReference[];
  }/** @public */
  export declare interface ResourceConfigMap extends ResourceBase {
      kind: "ConfigMap";
      binaryData?: {
          [key: string]: string;
      };
      data?: {
          [key: string]: string;
      };
      /** @beta */
      immutable?: boolean;
  }/** @public */
  export declare interface ResourceSecret extends ResourceBase {
      kind: "Secret";
      data?: {
          [key: string]: string;
      };
      stringData?: {
          [key: string]: string;
      };
      type?: string;
  }/** @public */
  export declare interface ResourceCR extends ResourceBase {
      kind: string;
      spec: CRSpec;
  }/** @public */
  export declare interface Kubeconfig {
      apiVersion?: "v1";
      kind: "Config";
      "current-context": string;
      contexts: {
          name: string;
          context: {
              cluster: string;
              user: string;
          };
      }[];
      clusters: {
          name: string;
          cluster: {
              "certificate-authority-data": string;
              server: string;
          };
      }[];
      preferences?: unknown;
      users: {
          name: string;
          user: {
              "client-certificate-data"?: string;
              "client-key-data"?: string;
              "username"?: string;
              "password"?: string;
          };
      }[];
  }/** @public */
  export declare interface LabelSelector {
      /**
       * matchExpressions is a list of label selector requirements. The requirements are ANDed.
       */
      matchExpressions?: LabelSelectorRequirement[];
      /**
       * matchLabels is a map of `{key,value}`pairs. A single `{key,value}` in the matchLabels map
       * is equivalent to an element of matchExpressions, whose key field is "key", the operator
       * is "In", and the values array contains only "value". The requirements are ANDed.
       */
      matchLabels?: {
          [key: string]: string;
      };
  }/** @public */
  export declare interface LocalObjectReference {
      /**
       * Name of the referent.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names}
       */
      name: string;
  }/**
   * PodTemplateSpec from k8s API
   *
   * @public
   */
  export declare interface PodTemplateSpec {
      /**
       * Standard object's metadata.
       * More Info: {@link https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata}
       */
      metadata: Metadata;
      /**
       * Specification of the desired behavior of the pod.
       * More Info: {@link https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status}
       */
      spec: PodSpec;
  }/**
   * ObjectReference from k8s API
   *
   * @public
   */
  export declare interface ObjectReference {
      /**
       * If referring to a piece of an object instead of an entire object,
       * this string should contain a valid JSON/Go field access statement,
       * such as desiredState.manifest.containers[2].
       *
       * For example, if the object reference is to a container within a pod,
       * this would take on a value like: "spec.containers\{name\}" (where "name"
       * refers to the name of the container that triggered the event) or if no
       * container name is specified "spec.containers[2]"
       * (container with index 2 in this pod).
       * This syntax is chosen only to have some well-defined way of referencing a
       * part of an object.
       */
      fieldPath: string;
      /**
       * Name of the referent.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names}
       *
       */
      name: string;
      /**
       * Namespace of the referent.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/}
       */
      namespace: string;
      /**
       * Specific resourceVersion to which this reference is made, if any.
       *
       * More info: {@link https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency}
       */
      resourceVersion: string;
      /**
       * UID of the referent.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids}
       */
      uid: string;
  }/**
   * Make a {@link k8s.ClusterInfo} object suitable for use with k8s resources
   *
   * @remarks
   *
   * This function will take a set of options and generate a {@link k8s.ClusterInfo}
   * object that contains the kubeconfig, registryPrefix for private images, and any other
   * relevant information for the cluster
   *
   * See {@link k8s.MakeClusterInfoOptions} for information on how the information
   * is computed.
   *
   * @returns A {@link k8s.ClusterInfo} object.
   *
   * @public
   */
  export declare function makeClusterInfo(options: MakeClusterInfoOptions): Promise<ClusterInfo>;/** @internal */
  export declare function isResourcePodTemplate(x: any): x is AdaptElement<ResourcePod>;/**
   * Hook that allows a prop to be either an array of handle to k8s resources and values
   *
   * @param initial - initial value of the prop, before the handles are be resolved
   * @param notReady - is a marker value to indicate that a handle's value isn't available yet
   * @param kinds - an array of legal k8s Kinds that a prop handle can point to
   * @param thisResourceName - the name of the resource using the hook, for error messages
   * @param propName - the name of the prop being resolved, again for error messages
   *
   * @returns A two element array, the first element is the current value, the second the update function
   *
   * This hook will start by returning the initial value and an update function that updates
   * the value the hook returns.  The update function takes 2 arguments - the prop value which
   * is an array with a mix of values and handles to be resolved, and a function that receives
   * the elements that any handles point to along with that elements props.  This function
   * can be passed by the caller of update to resolve handles as appropriate for the component.
   *
   * For example, {@link k8s.ClusterRoleBinding} uses this hook to resolve the subjects prop,
   * which is an array of other objects (typically {@link ServiceAccount}) that a particular
   * {@link k8s.ClusterRole} should point to.  When ClusterRoleBinding calls the update method,
   * it passes a function that will convert a {@link k8s.Resource} element of Kind `ServiceAccount`
   * to the underlying `Subject` object that kubernetes expects, namely
   * `{ apiGroup: "", kind: "ServiceAccount", name: resourceIdToName(elem, deployID), namespace: <element namespace> }`
   *
   * @example
   * ```
   * function MyResource({ serviceAccountNames }: { serviceAccountNames: (string | Handle)[]}) {
   *   const { deployID } = useBuildHelpers();
   *   const [ resolvedServiceAccountNames, updateSANs] = useResources({
   *      initial: [],
   *      notReady: null,
   *      kinds: ["ServiceAccount"],
   *      thisResourceName: "MyResources",
   *      propName: "serviceAccountNames",
   *   });
   *
   *   updateSANs(serviceAccountNames, (e, props) => {
   *      return {
   *        apiGroup: (e.metadata.apiVersion?.split("/")[0]) || "",
   *        name: resourceElementToName(e, deployID),
   *        namespace: props.metadata.namespace,
   *      }
   *   });
   *
   *   return null;
   * }
   * ```
   *
   * @beta
   */
  export declare function useResources<ValT, NotReadyT>({ initial, notReady, kinds, thisResourceName, propName, }: {
      initial: ValT[];
      notReady: NotReadyT;
      kinds: string[];
      thisResourceName: string;
      propName: string;
  }): [
      (ValT | NotReadyT)[],
      (props: (ValT | Handle)[], f: (e: AdaptMountedElement, props: ResourceProps) => Promise<ValT> | ValT) => void
  ];/**
   * Hook to allow conversion of a prop that could be a value or a handle
   *
   * This function behaves similarly to {@link k8s.useResources}, but works for
   * a prop that is either a Handle or a single value instead of an array of
   * Handles and values.
   *
   * See {@link k8s.useResources} for more detailed documentation.
   *
   * @beta
   */
  export declare function useResource<ValT, NotReadyT>(opts: {
      initial: ValT | NotReadyT;
      notReady: NotReadyT;
      kinds: string[];
      thisResourceName: string;
      propName: string;
  }): [
      ValT | NotReadyT,
      (prop: ValT | Handle, f: (e: AdaptMountedElement, props: ResourceProps) => Promise<ValT> | ValT) => void
  ];/**
   * Options for {@link k8s.makeClusterInfo}
   *
   * @public
   */
  export declare interface MakeClusterInfoOptions {
      /**
       * A Javascript Object representing a valid kubeconfig, or a YAML string, or a path to a kubeconfig file.
       *
       * @remarks
       * If this is a Javascript object, it will be treated like a parsed kubeconfig.  If this is a string,
       * {@link k8s.makeClusterInfo} will first attempt to parse it as JSON.  If that fails, it will attempt
       * to parse it as YAML.  If that fails it will treat the string as a path of configs (like with the `KUBECONFIG`
       * environment variable).
       *
       * If kubeconfig is missing {@link k8s.makeClusterInfo} will use the `KUBECONFIG` environment variable to build
       * a suitable config using `kubectl config view --flatten` and return that as the kubeconfig in the resulting
       * {@link k8s.ClusterInfo}
       */
      kubeconfig?: Kubeconfig | string;
      /**
       * URL to the docker registry that this cluster uses to pull private images.
       *
       * @remarks
       * This is identical to the `registryPrefix` field in {@link k8s.ClusterInfo}.  It will
       * be returned verbatim in the resulting {@link k8s.ClusterInfo} object.
       */
      registryPrefix?: string | DockerSplitRegistryInfo;
  }/**
   * k8s ClusterRole resource
   *
   * @param propsIn - props for ServiceAccount as specifed in {@link k8s.ClusterRoleProps}
   *
   * @public
   */
  export declare function ClusterRole(propsIn: SFCDeclProps<ClusterRoleProps, typeof defaultProps>): Adapt.JSX.Element;/** @public */
  export declare function isClusterRoleProps(props: ResourceProps): props is ResourceProps & ResourceClusterRole;/** @internal */
  const clusterRoleResourceInfo: {
      kind: string;
      deployedWhen: () => true;
      statusQuery: (props: ResourcePropsWithConfig, observe: ObserveForStatus, buildData: BuildData) => Promise<any>;
      makeManifest: (manifest: Manifest, elem: AdaptElement<ResourceProps>, _deployID: string) => {
          aggregationRule: AggregationRule | undefined;
          rules: PolicyRule[] | undefined;
          apiVersion: string;
          kind: string;
          metadata: import("./manifest_support").MetadataInRequest;
          spec?: import("./DaemonSet").DaemonSetSpec | import("./common").CRSpec | import("./Pod").PodSpec | import("./Service").ServiceSpec | import("./Deployment").DeploymentSpec | undefined;
      };
  };/**
   * k8s ClusterRoleBinding resource
   *
   * @param propsIn - props for ServiceAccount as specifed in {@link k8s.ClusterRoleBindingProps}
   *
   * @public
   */
  export declare function ClusterRoleBinding(propsIn: SFCDeclProps<ClusterRoleBindingProps, typeof defaultProps>): Adapt.JSX.Element | null;/** @internal */
  const clusterRoleBindingResourceInfo: {
      kind: string;
      deployedWhen: () => true;
      statusQuery: (props: ResourcePropsWithConfig, observe: ObserveForStatus, buildData: BuildData) => Promise<any>;
      makeManifest: (manifest: Manifest, elem: AdaptElement<ResourceProps>, _deployID: string) => {
          roleRef: RoleRef;
          subjects: Subject[];
          apiVersion: string;
          kind: string;
          metadata: import("./manifest_support").MetadataInRequest;
          spec?: import("./DaemonSet").DaemonSetSpec | import("./common").CRSpec | import("./Pod").PodSpec | import("./Service").ServiceSpec | import("./Deployment").DeploymentSpec | undefined;
      };
  };/**
   * k8s ConfigMap resource
   *
   * @param propsIn - props for ConfigMap as specifed in {@link k8s.ConfigMapProps}
   *
   * @public
   */
  export declare function ConfigMap(propsIn: SFCDeclProps<ConfigMapProps, typeof defaultProps>): Adapt.JSX.Element;/** @internal */
  const configMapResourceInfo: {
      kind: string;
      deployedWhen: () => true;
      statusQuery: (props: ResourcePropsWithConfig, observe: ObserveForStatus, buildData: BuildData) => Promise<any>;
      makeManifest: (manifest: Manifest, elem: AdaptElement<ResourceProps>, _deployID: string) => {
          data: {
              [key: string]: string;
          } | undefined;
          binaryData: {
              [key: string]: string;
          } | undefined;
          immutable: boolean | undefined;
          apiVersion: string;
          kind: string;
          metadata: import("./manifest_support").MetadataInRequest;
          spec?: import("./DaemonSet").DaemonSetSpec | import("./common").CRSpec | import("./Pod").PodSpec | import("./Service").ServiceSpec | import("./Deployment").DeploymentSpec | undefined;
      };
  };/**
   * Low level utility function to translate from the abstract {@link Container}
   * component props ({@link ContainerProps}) to {@link k8s.K8sContainerProps}
   * to be used in a {@link k8s.K8sContainer}.
   * @remarks
   * Note: The `image` property in the passed in {@link ContainerProps} must
   * be a `string`, not a `Handle`.
   * In most cases, it is preferable to use the {@link k8s.Container} component
   * instead, which is designed specifically to deal with this issue.
   *
   * @param abstractProps - The abstract {@link ContainerProps} to translate from.
   * @param k8sProps - Props that are specific to the {@link k8s.K8sContainer}
   *     component that should be merged into the resulting returned
   *     {@link k8s.K8sContainerProps} object.
   * @public
   */
  export declare function k8sContainerProps(abstractProps: FromContainerProps, k8sProps?: Partial<K8sContainerProps>): K8sContainerProps;/**
   * Tests whether an element is a {@link k8s.K8sContainer} element
   * @param x - element to test
   * @returns `true` if element is a {@link k8s.K8sContainer}, `false` otherwise
   *
   * @remarks
   * Acts as a TypeScript type assertion that will assert that `x` is `AdaptElement<K8sContainerProps>`
   *
   * @public
   */
  export declare function isK8sContainerElement(x: AdaptElement): x is AdaptElement<K8sContainerProps>;/**
   * Component that implements the abstract {@link Container} interface and
   * translates to a Kubernetes-specific {@link k8s.K8sContainer}.
   * @public
   */
  export declare function Container(props: ContainerProps): Adapt.JSX.Element | null;/** @public */
  export declare interface VolumeMount {
      /**
       * Path within the container at which the volume should be mounted.
       *
       * Must not contain ':'.
       */
      mountPath: string;
      /**
       * mountPropagation determines how mounts are propagated from the host to container and the other way around.
       *
       * When not set, MountPropagationNone is used. This field is beta in 1.10.
       *
       * @defaultValue MountPropagationNone
       */
      mountPropagation?: string;
      /** This must match the Name of a Volume. */
      name: string;
      /**
       * Mounted read-only if true, read-write otherwise (false or unspecified).
       *
       * @defaultValue false
       */
      readOnly?: boolean;
      /**
       * Path within the volume from which the container's volume should be mounted.
       *
       * Defaults to "" (volume's root).
       *
       * @defaultValue ""
       */
      subPath?: string;
      /**
       * Expanded path within the volume from which the container's volume should be mounted.
       *
       * Behaves similarly to SubPath but environment variable references $(VAR_NAME)
       * are expanded using the container's environment.
       *
       * Defaults to "" (volume's root).
       *
       * SubPathExpr and SubPath are mutually exclusive.
       *
       * @defaultValue ""
       */
      subPathExpr?: string;
  }/** @public */
  export declare interface ConfigMapEnvSource {
      /**
       * Name of the referent.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names}
       */
      name?: string;
      /**
       * Specify whether the ConfigMap must be defined
       */
      optional?: boolean;
  }/** @public */
  export declare interface SecretEnvSource {
      /**
       * Name of the referent.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names}
       */
      name?: string;
      /**
       * Specify whether the Secret must be defined
       */
      optional?: boolean;
  }/** @public */
  export declare interface EnvFromSource {
      /** The ConfigMap to select from */
      configMapRef?: ConfigMapEnvSource;
      /** An optional identifier to prepend to each key in the ConfigMap. Must be a C_IDENTIFIER. */
      prefix?: string;
      /** SecretEnvSource	The Secret to select from */
      secretRef?: SecretEnvSource;
  }/** @public */
  export declare interface ExecAction {
      /**
       * Command is the command line to execute inside the container.
       *
       * The working directory for the command is root ('/') in the container's filesystem.
       * The command is simply exec'd, it is not run inside a shell,
       * so traditional shell instructions ('|', etc) won't work.
       * To use a shell, you need to explicitly call out to that shell.
       *
       * Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
       */
      command: string[];
  }/** @public */
  export declare interface HTTPGetAction {
      /**
       * Host name to connect to, defaults to the pod IP.
       *
       * You probably want to set "Host" in httpHeaders instead.
       */
      host?: string;
      /** Custom headers to set in the request. HTTP allows repeated headers. */
      httpHeaders?: {
          name: string;
          value: string;
      }[];
      /** Path to access on the HTTP server. */
      path: string;
      /**
       * Name or number of the port to access on the container.
       *
       * Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
       */
      port: number | string;
      /**
       * Scheme to use for connecting to the host.
       *
       * @defaultValue HTTP.
       */
      scheme?: string;
  }/** @public */
  export declare interface TCPSocketAction {
      /** Host name to connect to, defaults to the pod IP. */
      host?: string;
      /**
       * Number or name of the port to access on the container.
       *
       * Number must be in the range 1 to 65535.
       * Name must be an IANA_SVC_NAME.
       */
      port: string | number;
  }/** @public */
  export declare interface Probe {
      /**
       * Exec specifies the action to take.
       *
       * Only one of exec, httpGet, or tcpSocket should be specified
       */
      exec?: ExecAction;
      /**
       * Minimum consecutive failures for the probe to be considered failed after having succeeded.
       *
       * Defaults to 3. Minimum value is 1.
       *
       * @defaultValue 3
       */
      failureThreshold?: number;
      /** Specifies the http request to perform. */
      httpGet?: HTTPGetAction;
      /**
       *  Seconds after the container has started before liveness probes are initiated.
       *  More info: {@link https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes}
       */
      initialDelaySeconds?: number;
      /** How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. */
      periodSeconds?: number;
      /**
       * Minimum consecutive successes for the probe to be considered successful after having failed.
       *
       * Must be 1 for liveness and startup. Minimum value is 1.
       *
       * @defaultValue 1
       */
      successThreshold?: number;
      /**
       * Specifies an action involving a TCP port.
       *
       * TCP hooks not yet supported
       */
      tcpSocket?: TCPSocketAction;
      /**
       * Number of seconds after which the probe times out.
       *
       * Defaults to 1 second. Minimum value is 1.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes}
       *
       * @defaultValue 1
       */
      timeoutSeconds?: number;
  }/** @public */
  export declare interface ResourceRequirements {
      /**
       * Limits describes the maximum amount of compute resources allowed.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/}
       */
      limits?: {
          [key: string]: any;
      };
      /**
       * Describes the minimum amount of compute resources required.
       *
       * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
       * otherwise to an implementation-defined value.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/}
       */
      requests?: {
          [key: string]: any;
      };
  }/** @public */
  export declare type Handler = {
      exec: ExecAction;
  } | {
      httpGet: HTTPGetAction;
  } | {
      tcpSocket: TCPSocketAction;
  };/** @public */
  export declare interface Lifecycle {
      /**
       * PostStart is called immediately after a container is created.
       *
       * If the handler fails, the container is terminated and restarted according to its restart policy.
       * Other management of the container blocks until the hook completes.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks}
       */
      postStart: Handler;
      /**
       * Called immediately before a container is terminated due to an API request or management event such as liveness/startup probe failure, preemption, resource contention, etc.
       *
       * The handler is not called if the container crashes or exits.
       * The reason for termination is passed to the handler.
       * The Pod's termination grace period countdown begins before the PreStop hooked is executed.
       * Regardless of the outcome of the handler, the container will eventually terminate within the Pod's termination grace period.
       * Other management of the container blocks until the hook completes or until the termination grace period is reached.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks}
       */
      preStop: Handler;
  }/** @public */
  export declare interface VolumeDevice {
      /** The path inside of the container that the device will be mapped to. */
      devicePath: string;
      /** name must match the name of a persistentVolumeClaim in the pod */
      name: string;
  }/**
   * Resource spec for a Kubernetes container.
   * See the Kubernetes
   * {@link https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#container-v1-core | API docs }
   * for more details.
   * @public
   */
  export declare interface ContainerSpec {
      /**
       * Arguments to the entrypoint.
       *
       * The docker image's CMD is used if this is not provided.
       * Variable references $(VAR_NAME) are expanded using the container's environment.
       * If a variable cannot be resolved, the reference in the input string will be unchanged.
       * The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME).
       * Escaped references will never be expanded, regardless of whether the variable exists or not.
       * Cannot be updated.
       * More info: {@link https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell}
       */
      args?: string[];
      /**
       * Entrypoint array.
       *
       * Not executed within a shell.
       * The docker image's ENTRYPOINT is used if this is not provided.
       * Variable references $(VAR_NAME) are expanded using the container's environment.
       * If a variable cannot be resolved, the reference in the input string will be unchanged.
       * The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME).
       * Escaped references will never be expanded, regardless of whether the variable exists or not.
       * Cannot be updated.
       * More info: {@link https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell}
       */
      command?: string[];
      /**
       * List of environment variables to set in the container. Cannot be updated.
       */
      env?: EnvVar[];
      /**
       * List of sources to populate environment variables in the container.
       *
       * The keys defined within a source must be a C_IDENTIFIER.
       * All invalid keys will be reported as an event when the container is starting.
       * When a key exists in multiple sources, the value associated with the last source will take precedence.
       * Values defined by an Env with a duplicate key will take precedence. Cannot be updated.
       */
      envFrom?: EnvFromSource[];
      /**
       * Docker image name.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/containers/images}
       *
       * This field is optional to allow higher level config management to default or override container
       * images in workload controllers like Deployments and StatefulSets.
       */
      image?: string;
      /**
       * Image pull policy.
       *
       * One of Always, Never, IfNotPresent.
       * Defaults to Always if :latest tag is specified,
       * or IfNotPresent otherwise.
       * Cannot be updated.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/containers/images#updating-images}
       */
      imagePullPolicy?: "Always" | "Never" | "IfNotPresent";
      /**
       * List of sources to populate environment variables in the container.
       *
       * The keys defined within a source must be a C_IDENTIFIER.
       * All invalid keys will be reported as an event when the container is starting.
       * When a key exists in multiple sources, the value associated with the last source will take precedence.
       * Values defined by an Env with a duplicate key will take precedence. Cannot be updated.
       */
      lifecycle?: Lifecycle;
      /**
       * Periodic probe of container liveness.
       *
       * Container will be restarted if the probe fails.
       * Cannot be updated.
       * More info: {@link https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes}
       */
      livenessProbe?: Probe;
      /**
       * Name of the container specified as a DNS_LABEL.
       *
       * Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated.
       */
      name: string;
      /**
       * List of ports to expose from the container.
       *
       * Exposing a port here gives the system additional information about the network connections a container uses,
       * but is primarily informational.
       * Not specifying a port here DOES NOT prevent that port from being exposed.
       * Any port which is listening on the default "0.0.0.0" address inside a container will be accessible from
       * the network.
       * Cannot be updated.
       */
      ports?: ContainerPort[];
      /**
       * Periodic probe of container service readiness.
       *
       * Container will be removed from service endpoints if the probe fails.
       * Cannot be updated.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes}
       */
      readinessProbe?: Probe;
      /**
       * Compute Resources required by this container.
       *
       * Cannot be updated.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/}
       */
      resources?: ResourceRequirements;
      /**
       * Security options the pod should run with.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/policy/security-context/}
       * More info: {@link https://kubernetes.io/docs/tasks/configure-pod-container/security-context/}
       */
      securityContext?: PodSecurityContext;
      /**
       * Indicates that the Pod has successfully initialized.
       *
       * If specified, no other probes are executed until this completes successfully.
       * If this probe fails, the Pod will be restarted, just as if the livenessProbe failed.
       * This can be used to provide different probe parameters at the beginning of a Pod's lifecycle,
       * when it might take a long time to load data or warm a cache, than during steady-state operation.
       *
       * This cannot be updated.
       * This is a beta feature enabled by the StartupProbe feature flag.
       * More info: {@link https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes}
       */
      startupProbe?: Probe;
      /**
       * Whether this container should allocate a buffer for stdin in the container runtime.
       *
       * If this is not set, reads from stdin in the container will always result in EOF. Default is false.
       */
      stdin?: boolean;
      /**
       * Whether the container runtime should close the stdin channel after it has been opened by a single attach.
       *
       * When stdin is true the stdin stream will remain open across multiple attach sessions.
       * If stdinOnce is set to true, stdin is opened on container start,
       * is empty until the first client attaches to stdin,
       * and then remains open and accepts data until the client disconnects,
       * at which time stdin is closed and remains closed until the container is restarted.
       * If this flag is false, a container processes that reads from stdin will never receive an EOF. Default is false
       */
      stdinOnce?: boolean;
      /**
       * Path at which the file to which the container's termination message will be written is mounted into the container's filesystem.
       *
       * Message written is intended to be brief final status, such as an assertion failure message.
       * Will be truncated by the node if greater than 4096 bytes.
       * The total message length across all containers will be limited to 12kb.
       * Defaults to /dev/termination-log. Cannot be updated.
       */
      terminationMessagePath?: string;
      /**
       * Indicate how the termination message should be populated.
       *
       * File will use the contents of terminationMessagePath to populate the container status
       * message on both success and failure. FallbackToLogsOnError will use the last chunk of
       * container log output if the termination message file is empty and the container exited
       * with an error.
       * The log output is limited to 2048 bytes or 80 lines, whichever is smaller.
       * Defaults to File.
       * Cannot be updated.
       *
       * @defaultValue File
       */
      terminationMessagePolicy?: "File" | "FallbackToLogsOnError";
      /**
       * Whether this container should allocate a TTY for itself, also requires 'stdin' to be true.
       *
       * @defaultValue false
       */
      tty?: boolean;
      /**
       * volumeDevices is the list of block devices to be used by the container.
       */
      volumeDevices?: VolumeDevice[];
      /** volumeDevices is the list of block devices to be used by the container. */
      volumeMounts?: VolumeMount[];
      /**
       * Container's working directory.
       *
       * If not specified, the container runtime's default will be used,
       * which might be configured in the container image.
       * Cannot be updated.
       */
      workingDir?: string;
  }/**
   * Props for the Kubernetes-specific {@link k8s.K8sContainer} component.
   * @public
   */
  export declare interface K8sContainerProps extends ContainerSpec {
  }/** @public */
  export declare interface ContainerPort {
      /**
       * Number of port to expose on the pod's IP address.
       * @remarks
       * This must be a valid integer port number, `0 < x < 65536`.
       */
      containerPort: number;
      /** What host IP to bind the external port to. */
      hostIP?: string;
      /**
       * Number of port to expose on the host.
       * @remarks
       * If specified, this must be a valid integer port number,
       * `0 < x < 65536`. If HostNetwork is specified,
       * this must match ContainerPort. Most containers do not need this.
       */
      hostPort?: number;
      /**
       * A unique-within-pod name for the container
       * @remarks
       * If specified, this must be an IANA_SVC_NAME and unique within the pod.
       * Each named port in a pod must have a unique name. Name for the port
       * that can be referred to by services.
       */
      name?: string;
      /** Protocol for port. Must be UDP or TCP. Defaults to "TCP". */
      protocol?: string;
  }/** @public */
  export declare type EnvVar = EnvVarSimple | EnvVarFrom;/** @public */
  export declare interface EnvVarSimple {
      /** Name of the environment variable. Must be a C_IDENTIFIER. */
      name: string;
      /**
       * Variable references $(VAR_NAME) are expanded using the previous defined
       * environment variables in the container and any service environment
       * variables. If a variable cannot be resolved, the reference in the input
       * string will be unchanged. The $(VAR_NAME) syntax can be escaped with a
       * double $$, ie: $$(VAR_NAME). Escaped references will never be expanded,
       * regardless of whether the variable exists or not. Defaults to "".
       */
      value: string;
  }/** @public */
  export declare interface EnvVarFrom {
      /** Source for the environment variable's value. Cannot be used if value is not empty. */
      valueFrom?: any;
  }/**
   * See {@link k8s.k8sContainerProps}.
   * @public
   */
  export declare type FromContainerProps = ReplaceT<ContainerProps, {
      image: string;
  }> & BuiltinProps;/**
   * Kubernetes-specific container.
   * @public
   */
  export declare class K8sContainer extends PrimitiveComponent<K8sContainerProps> {
      static defaultProps: {
          imagePullPolicy: string;
      };
      validate(): undefined;
  }/**
   * Props for {@link k8s.Container}.
   * @public
   */
  export declare interface ContainerProps extends SFCDeclProps<ContainerProps> {
      /**
       * Additional {@link k8s.K8sContainerProps}-specific props that should be
       * added to the instantiated {@link k8s.K8sContainer}.
       */
      k8sContainerProps?: Partial<K8sContainerProps>;
  }/**
   * Spec for {@link k8s.DaemonSet} for use in {@link k8s.Resource}
   *
   * @public
   */
  export declare type DaemonSetSpec = Exclude<DaemonSetProps, ResourceBase> & {
      template: PodTemplateSpec;
  };/**
   * Component for Kubernetes DaemonSet
   *
   * @public
   */
  export declare class DaemonSet extends DeferredComponent<DaemonSetProps> {
      static defaultProps: {
          metadata: {};
          minReadySeconds: number;
          revisionHistoryLimit: number;
          updateStrategy: {
              type: string;
              rollingUpdate: {
                  maxUnavailable: number;
              };
          };
      };
      constructor(props: DaemonSetProps);
      build(helpers: BuildHelpers): Adapt.JSX.Element;
      status(_observe: ObserveForStatus, buildData: BuildData): Promise<Adapt.Status | undefined>;
  }/** @internal */
  const daemonSetResourceInfo: {
      kind: string;
      deployedWhen: typeof deployedWhen;
      statusQuery: (props: ResourcePropsWithConfig, observe: ObserveForStatus, buildData: BuildData) => Promise<any>;
  };/** @public */
  export declare interface DeploymentUpdateStrategyRecreate {
      type: "Recreate";
  }/** @public */
  export declare interface RollingUpdateDeployment {
      /**
       * The maximum number of pods that can be scheduled above the desired number of pods.
       *
       * Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
       * This can not be 0 if MaxUnavailable is 0.
       * Absolute number is calculated from percentage by rounding up.
       * Defaults to 25%.
       *
       * @example
       * When this is set to 30%, the new ReplicaSet can be scaled up immediately when the rolling update starts,
       * such that the total number of old and new pods do not exceed 130% of desired pods. Once old pods have been
       * killed, new ReplicaSet can be scaled up further, ensuring that total number of pods running at any time
       * during the update is at most 130% of desired pods.
       */
      maxSurge?: number | string;
      /**
       * The maximum number of pods that can be unavailable during the update.
       *
       * Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
       * Absolute number is calculated from percentage by rounding down.
       * This can not be 0 if MaxSurge is 0. Defaults to 25%.
       *
       * @example
       * When this is set to 30%, the old ReplicaSet can be scaled down to 70% of desired pods
       * immediately when the rolling update starts. Once new pods are ready, old ReplicaSet
       * can be scaled down further, followed by scaling up the new ReplicaSet, ensuring that
       * the total number of pods available at all times during the update is at least 70% of
       * desired pods.
       */
      maxUnavailable?: number | string;
  }/**
   * Spec for {@link k8s.Deployment} for use in {@link k8s.Resource}
   *
   * @public
   */
  export declare type DeploymentSpec = Exclude<DeploymentProps, ResourceBase> & {
      template: PodTemplateSpec;
  };/**
   * Props for {@link k8s.Deployment}
   *
   * @public
   */
  export declare interface DeploymentProps extends WithChildren {
      /** Information about the k8s cluster (ip address, auth info, etc.) */
      config: ClusterInfo;
      /** k8s metadata */
      metadata: Metadata;
      /**
       * The minimum number of seconds for which a newly created pod should
       * be ready without any of its container crashing, for it to be considered
       * available. Defaults to 0 (pod will be considered available as soon as it is ready).
       */
      minReadySeconds: number;
      /** Indicates that the deployment is paused */
      paused: boolean;
      /**
       * The maximum time in seconds for a deployment to make progress before it is considered to be failed.
       *
       * The deployment controller will continue to process failed deployments and a condition with a
       * ProgressDeadlineExceeded reason will be surfaced in the deployment status. Note that progress
       * will not be estimated during the time a deployment is paused. Defaults to 600s.
       */
      progressDeadlineSeconds: number;
      /**
       * Number of desired pods.
       *
       * Defaults to 1. 0 is not allowed.
       *
       * @defaultValue 1
       */
      replicas: number;
      /**
       * The number of old ReplicaSets to retain to allow rollback.
       *
       * This is a pointer to distinguish between explicit zero and not specified. Defaults to 10.
       *
       * @defaultValue 10
       */
      revisionHistoryLimit: number;
      /**
       * Label selector for pods.
       *
       * Existing ReplicaSets whose pods are selected by this will be the ones affected by this deployment.
       * It must match the pod template's labels.
       *
       * @remarks
       *
       * With Adapt, this is optional.  If not specified, adapt will pick a selector that will work with the pods
       * it creates as part of this {@link k8s.Deployment}
       */
      selector?: LabelSelector;
      /**
       * An deployment strategy to use to replace existing pods with new ones
       */
      strategy: DeploymentUpdateStrategy;
  }/**
   * Component for Kubernetes Deployment
   *
   * @public
   */
  export declare class Deployment extends DeferredComponent<DeploymentProps> {
      static defaultProps: {
          metadata: {};
          paused: boolean;
          replicas: number;
          progressDeadlineSeconds: number;
          minReadySeconds: number;
          revisionHistoryLimit: number;
          strategy: {
              type: string;
              rollingUpdate: {
                  maxSurge: string;
                  maxUnavailable: string;
              };
          };
      };
      constructor(props: DeploymentProps);
      build(helpers: BuildHelpers): Adapt.JSX.Element | null;
      deployedWhen: () => true | Adapt.Waiting;
      status(_observe: ObserveForStatus, buildData: BuildData): Promise<Adapt.Status | undefined>;
  }/** @internal */
  const deploymentResourceInfo: {
      kind: string;
      deployedWhen: typeof deployedWhen;
      statusQuery: (props: ResourcePropsWithConfig, observe: ObserveForStatus, buildData: BuildData) => Promise<any>;
  };/**
   * Type assertion to see if an element is both a {@link k8s.Resource | Resource}
   * and a {@link @adpt/core#FinalElement | FinalElement}
   *
   * @param e - element to test
   * @returns `true` if e is both a FinalElement and a {@link k8s.Resource | Resource}, `false` otherwise
   *
   * @public
   */
  export declare function isResourceFinalElement(e: AdaptElement): e is FinalDomElement<ResourceProps & Adapt.BuiltinProps>;/**
   * Tests whether a ResourceProps is for a template object
   *
   * @public
   */
  export declare function isResourcePropsWithConfig(x: ResourceProps & Partial<BuiltinProps>): x is ResourcePropsWithConfig & Partial<BuiltinProps>;/**
   * Tests to see if an object is a {@link k8s.Resource} element
   * @param x - object to test
   * @returns true if object is an AdaptElement of type {@link k8s.Resource}
   *
   * @public
   */
  export declare function isResource(x: any): x is AdaptElement<ResourceProps>;/**
   * Primitive Component recognized by the k8s plugin to represent resources
   * @public
   */
  export declare class Resource extends Action<ResourceProps> {
      defaultProps: {
          apiVersion: "v1";
          con: false;
      };
      manifest_: Manifest;
      constructor(props: ResourceProps);
      validate(): "Resource elements cannot have children" | undefined;
      shouldAct(op: ChangeType, ctx: ActionContext): Promise<ShouldAct>;
      action(op: ChangeType, ctx: ActionContext): Promise<void>;
      deployedWhen: (goalStatus: GoalStatus, helpers: DeployHelpers) => Promise<true | Adapt.Waiting | Adapt.Waiting[]>;
      status(observe: ObserveForStatus, buildData: BuildData): Promise<any>;
      private mountedElement;
      private manifest;
  }/** @internal */
  export declare function makePodManifest(props: PodProps & BuiltinProps, data: {
      volumes?: Volume[];
      serviceAccountName?: string;
  }): {
      kind: string;
      metadata: Metadata;
      spec: PodSpec;
  };/**
   * Tests whether x is a Pod element
   *
   * @param x - value to test
   * @returns `true` if x is a Pod element, false otherwise
   *
   * @public
   */
  export declare function isPod(x: any): x is AdaptElement<PodProps>;/** @public */
  export declare interface NodeSelectorRequirement {
      /** The label key that the selector applies to. */
      key: string;
      /**
       * Represents a key's relationship to a set of values.
       *
       * Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
       */
      operator: "In" | "NotIn" | "Exists" | "DoesNotExist" | "Gt" | "Lt";
      /**
       * Values for operator
       *
       * If the operator is In or NotIn, the values array must be non-empty.
       * If the operator is Exists or DoesNotExist, the values array must be empty.
       * If the operator is Gt or Lt, the values array must have a single element,
       * which will be interpreted as an integer.
       * This array is replaced during a strategic merge patch.
       */
      values: string[];
  }/** @public */
  export declare interface NodeSelectorTerm {
      /** A list of node selector requirements by node's labels. */
      matchExpressions?: NodeSelectorRequirement[];
      /** A list of node selector requirements by node's fields. */
      matchFields?: NodeSelectorRequirement[];
  }/** @public */
  export declare interface PreferredSchedulingTerm {
      /**
       * A node selector term, associated with the corresponding weight.
       */
      preference: NodeSelectorTerm;
      /** Weight associated with matching the corresponding nodeSelectorTerm, in the range 1-100. */
      weight: number;
  }/** @public */
  export declare interface NodeSelector {
      /** A list of node selector terms. The terms are ORed */
      nodeSelectorTerms: NodeSelectorTerm[];
  }/** @public */
  export declare interface NodeAffinity {
      /** The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding "weight" to the sum if the node matches the corresponding matchExpressions; the node(s) with the highest sum are the most preferred. */
      preferredDuringSchedulingIgnoredDuringExecution?: PreferredSchedulingTerm[];
      /** If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to an update), the system may or may not try to eventually evict the pod from its node. */
      requiredDuringSchedulingIgnoredDuringExecution?: NodeSelector;
  }/** @public */
  export declare interface PodAffinityTerm {
      /**
       * Label query over a set of resources, in this case pods.
       */
      labelSelector: LabelSelector;
      /** Specifies which namespaces the labelSelector applies to (matches against); null or empty list means "this pod's namespace" */
      namespaces?: string[];
      /** This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed. */
      topologyKey: string;
  }/** @public */
  export declare interface WeightedPodAffinityTerm {
      /** A pod affinity term, associated with the corresponding weight. */
      podAffinityTerm: PodAffinityTerm;
      /**
       * weight associated with matching the corresponding podAffinityTerm, in the range 1-100.
       */
      weight: number;
  }/** @public */
  export declare interface PodAffinity {
      /**
       * The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions.
       *
       * The node that is most preferred is the one with the greatest sum of weights,
       * i.e. for each node that meets all of the scheduling requirements (resource request,
       * requiredDuringScheduling affinity expressions, etc.), compute a sum by iterating
       * through the elements of this field and adding "weight" to the sum if the node has pods
       * which matches the corresponding podAffinityTerm; the node(s) with the highest sum are the most preferred.
       */
      preferredDuringSchedulingIgnoredDuringExecution: WeightedPodAffinityTerm[];
      /**
       * If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node.
       *
       * If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system may or may not try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each podAffinityTerm are intersected, i.e. all terms must be satisfied.
       */
      requiredDuringSchedulingIgnoredDuringExecution: PodAffinityTerm[];
  }/** @public */
  export declare interface PodAntiAffinity {
      /** The scheduler will prefer to schedule pods to nodes that satisfy the anti-affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling anti-affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the node(s) with the highest sum are the most preferred. */
      preferredDuringSchedulingIgnoredDuringExecution: WeightedPodAffinityTerm[];
      /** If the anti-affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the anti-affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system may or may not try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each podAffinityTerm are intersected, i.e. all terms must be satisfied. */
      requiredDuringSchedulingIgnoredDuringExecution: PodAffinity;
  }/** @public */
  export declare interface Affinity {
      /** Describes node affinity scheduling rules for the pod. */
      nodeAffinity: NodeAffinity;
      /** Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)). */
      podAffinity: PodAffinity;
      /** PodAntiAffinity	Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)). */
      podAntiAffinity: PodAntiAffinity;
  }/** @public */
  export declare interface PodDNSConfigOption {
      name: string;
      value?: string;
  }/** @public */
  export declare interface PodDNSConfig {
      /**
       * A list of DNS name server IP addresses.
       *
       * This will be appended to the base nameservers generated from DNSPolicy. Duplicated nameservers will be removed.
       */
      nameservers: string[];
      /**
       * A list of DNS resolver options.
       *
       * This will be merged with the base options generated from DNSPolicy.
       * Duplicated entries will be removed.
       * Resolution options given in Options will override those that appear in the base DNSPolicy.
       */
      options: PodDNSConfigOption[];
      /**
       * A list of DNS search domains for host-name lookup.
       *
       * This will be appended to the base search paths generated from DNSPolicy. Duplicated search paths will be removed.
       */
      searches: string[];
  }/** @public */
  export declare interface PodReadinessGate {
      /** Refers to a condition in the pod's condition list with matching type. */
      conditionType: string;
  }/** @public */
  export declare interface SELinuxOptions {
      /** SELinux level label that applies to the container. */
      level: string;
      /** SELinux role label that applies to the container. */
      role: string;
      /** SELinux type label that applies to the container. */
      type: string;
      /** SELinux user label that applies to the container */
      user: string;
  }/** @public */
  export declare interface SeccompProfile {
      /**
       * Indicates a profile defined in a file on the node should be used.
       *
       * The profile must be preconfigured on the node to work.
       * Must be a descending path, relative to the kubelet's configured seccomp profile location.
       * Must only be set if type is "Localhost".
       */
      localhostProfile?: string;
      /**
       * Indicates which kind of seccomp profile will be applied.
       *
       * Valid options are:
       * * Localhost - a profile defined in a file on the node should be used.
       * * RuntimeDefault - the container runtime default profile should be used.
       * * Unconfined - no profile should be applied.
       */
      type: "Localhost" | "RuntimeDefault" | "Unconfined";
  }/** @public */
  export declare interface Sysctl {
      name: string;
      value: string;
  }/** @public */
  export declare interface WindowsSecurityContextOptions {
      /**
       * The GMSA admission webhook ({@link https://github.com/kubernetes-sigs/windows-gmsa}) inlines the contents of the GMSA credential spec named by the GMSACredentialSpecName field.
       */
      gmsaCredentialSpec?: string;
      /**
       * GMSACredentialSpecName is the name of the GMSA credential spec to use.
       */
      gmsaCredentialSpecName?: string;
      /**
       * The UserName in Windows to run the entrypoint of the container process.
       *
       * Defaults to the user specified in image metadata if unspecified. May also be set in PodSecurityContext.
       * If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
       */
      runAsUserName?: string;
  }/** @public */
  export declare interface PodSecurityContext {
      /**
       * A special supplemental group that applies to all containers in a pod.
       *
       * Some volume types allow the Kubelet to change the ownership of that volume to be owned by the pod:
       *
       * 1. The owning GID will be the FSGroup
       * 2. The setgid bit is set (new files created in the volume will be owned by FSGroup)
       * 3. The permission bits are OR'd with rw-rw----
       *
       * If unset, the Kubelet will not modify the ownership and permissions of any volume.
       */
      fsGroup?: number;
      /**
       * Defines behavior of changing ownership and permission of the volume before being exposed inside Pod.
       *
       * This field will only apply to volume types which support fsGroup based ownership(and permissions).
       * It will have no effect on ephemeral volume types such as: secret, configmaps and emptydir.
       * Valid values are "OnRootMismatch" and "Always". If not specified defaults to "Always".
       *
       * @defaultValue Always
       */
      fsGroupChangePolicy?: "OnRootMismatch" | "Always";
      /**
       * The GID to run the entrypoint of the container process.
       *
       * Uses runtime default if unset. May also be set in SecurityContext.
       * If set in both SecurityContext and PodSecurityContext, the value specified in
       * SecurityContext takes precedence for that container.
       */
      runAsGroup?: number;
      /**
       * Indicates that the container must run as a non-root user.
       *
       * If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and
       * fail to start the container if it does. If unset or false, no such validation will be performed.
       * May also be set in SecurityContext.
       * If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
       */
      runAsNonRoot?: boolean;
      /**
       * The UID to run the entrypoint of the container process.
       *
       * Defaults to user specified in image metadata if unspecified.
       * May also be set in SecurityContext.
       * If set in both SecurityContext and PodSecurityContext, the value specified in
       * SecurityContext takes precedence for that container.
       */
      runAsUser?: number;
      /**
       * The SELinux context to be applied to all containers.
       *
       * If unspecified, the container runtime will allocate a random SELinux context for each container.
       * May also be set in SecurityContext.
       * If set in both SecurityContext and PodSecurityContext, the value specified in
       * SecurityContext takes precedence for that container.
       */
      seLinuxOptions?: SELinuxOptions;
      /**
       * The seccomp options to use by the containers in this pod.
       */
      seccompProfile?: SeccompProfile;
      /**
       * 	A list of groups applied to the first process run in each container, in addition to the container's primary GID.
       *
       *  If unspecified, no groups will be added to any container.
       */
      supplementalGroups?: number[];
      /**
       * Sysctls hold a list of namespaced sysctls used for the pod.
       *
       * Pods with unsupported sysctls (by the container runtime) might fail to launch.
       */
      sysctls?: Sysctl[];
      /**
       * The Windows specific settings applied to all containers.
       *
       * If unspecified, the options within a container's SecurityContext will be used.
       * If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
       */
      windowsOptions: WindowsSecurityContextOptions;
  }/** @public */
  export declare interface Toleration {
      /**
       * Indicates the taint effect to match.
       *
       * Empty means match all taint effects.
       * When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
       */
      effect?: "NoSchedule" | "PreferNoSchedule" | "NoExecute";
      /**
       * The taint key that the toleration applies to.
       *
       * Empty means match all taint keys.
       * If the key is empty, operator must be Exists;
       * this combination means to match all values and all keys.
       */
      key?: string;
      /**
       * Represents a key's relationship to the value.
       *
       * Valid operators are Exists and Equal.
       * Defaults to Equal.
       * Exists is equivalent to wildcard for value, so that a pod can tolerate all taints of a particular category.
       *
       * @defaultValue Equal
       */
      operator?: "Exists" | "Equal";
      /**
       * Represents the period of time the toleration (which must be of effect NoExecute, otherwise this field is ignored) tolerates the taint.
       *
       * By default, it is not set, which means tolerate the taint forever (do not evict).
       * Zero and negative values will be treated as 0 (evict immediately) by the system.
       */
      tolerationSeconds?: number;
      /**
       * Value is the taint value the toleration matches to.
       *
       * If the operator is Exists, the value should be empty, otherwise just a regular string.
       */
      value?: string;
  }/** @public */
  export declare interface TopologySpreadConstraint {
      /**
       * Used to find matching pods.
       *
       * Pods that match this label selector are counted to determine the
       * number of pods in their corresponding topology domain.
       */
      labelSelector: LabelSelector;
      /**
       * Describes the degree to which pods may be unevenly distributed.
       *
       * When `whenUnsatisfiable=DoNotSchedule`, it is the maximum permitted
       * difference between the number of matching pods in the target topology
       * and the global minimum.
       * For example, in a 3-zone cluster, MaxSkew is set to 1, and pods with
       * the same labelSelector spread as 1/1/0: | zone1 | zone2 | zone3 | | P | P | |
       * - if MaxSkew is 1, incoming pod can only be scheduled to zone3 to become 1/1/1;
       *   scheduling it onto zone1(zone2) would make the ActualSkew(2-0) on zone1(zone2) violate MaxSkew(1).
       * - if MaxSkew is 2, incoming pod can be scheduled onto any zone.
       * When `whenUnsatisfiable=ScheduleAnyway`, it is used to give higher precedence to topologies that satisfy it.
       * It's a required field. Default value is 1 and 0 is not allowed.
       *
       * @example
       *
       * @defaultValue 1
       */
      maxSkew: number;
      /**
       * The key of node labels.
       *
       * Nodes that have a label with this key and identical values are considered to be in the same topology.
       * We consider each \<key, value\> as a "bucket", and try to put balanced number of pods into each bucket.
       * It's a required field.
       */
      topologyKey: string;
      /**
       * Indicates how to deal with a pod if it doesn't satisfy the spread constraint.
       *
       * - DoNotSchedule (default) tells the scheduler not to schedule it.
       * - ScheduleAnyway tells the scheduler to schedule the pod in any location,
       *   but giving higher precedence to topologies that would help reduce the skew.
       *
       * A constraint is considered "Unsatisfiable" for an incoming pod if and only if every possible
       * node assigment for that pod would violate "MaxSkew" on some topology.
       * For example, in a 3-zone cluster, MaxSkew is set to 1, and pods with the same labelSelector
       * spread as 3/1/1: | zone1 | zone2 | zone3 | | P P P | P | P | If WhenUnsatisfiable is set to DoNotSchedule,
       * incoming pod can only be scheduled to zone2(zone3) to become 3/2/1(3/1/2)
       * as ActualSkew(2-1) on zone2(zone3) satisfies MaxSkew(1).
       * In other words, the cluster can still be imbalanced, but scheduler won't make it
       * *more* imbalanced.
       *
       * It's a required field.
       */
      whenUnsatisfiable: string;
  }/** @public */
  export declare interface KeyToPath {
      /** The key to project. */
      key: string;
      /**
       * mode bits to use on this file,
       * Must be a value between 0 and 0777.
       * If not specified, the volume defaultMode will be used.
       * This might be in conflict with other options that affect the file mode, like fsGroup,
       * and the result can be other mode bits set.
       */
      mode?: number;
      /**
       * The relative path of the file to map the key to.
       *
       * May not be an absolute path. May not contain the path element '..'. May not start with the string '..'.
       */
      path: string;
  }/** @public */
  export declare interface ConfigMapVolumeSource {
      /**
       * mode bits to use on created files by default.
       *
       * Must be a value between 0 and 0777. Defaults to 0644.
       * Directories within the path are not affected by this setting.
       * This might be in conflict with other options that affect the file mode,
       * like fsGroup, and the result can be other mode bits set.
       */
      defaultMode?: number;
      /**
       * If unspecified, each key-value pair in the Data field of the referenced ConfigMap will be projected into the volume as a file whose name is the key and content is the value.
       *
       * If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present.
       * If a key is specified which is not present in the ConfigMap, the volume setup will error unless it is marked optional.
       * Paths must be relative and may not contain the '..' path or start with '..'.
       */
      items?: KeyToPath[];
      /**
       * Name of the referent.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names}
       */
      name: string | Handle;
      /** Specify whether the ConfigMap or its keys must be defined */
      optional?: boolean;
  }/** @public */
  export declare interface SecretVolumeSource {
      /**
       * mode bits to use on created files by default.
       *
       * Must be a value between 0 and 0777. Defaults to 0644.
       * Directories within the path are not affected by this setting.
       * This might be in conflict with other options that affect the file mode,
       * like fsGroup, and the result can be other mode bits set.
       */
      defaultMode?: number;
      /**
       * If unspecified, each key-value pair in the Data field of the referenced Secret will be projected into the volume as a file whose name is the key and content is the value.
       *
       * If specified, the listed keys will be projected into the specified paths,
       * and unlisted keys will not be present. If a key is specified which is not
       * present in the Secret, the volume setup will error unless it is marked optional.
       *
       * Paths must be relative and may not contain the '..' path or start with '..'.
       */
      items?: KeyToPath[];
      /** Specify whether the Secret or its keys must be defined */
      optional?: boolean;
      /**
       * Name of the secret in the pod's namespace to use.
       *
       *  More info: {@link https://kubernetes.io/docs/concepts/storage/volumes#secret}
       */
      secretName: string | Handle;
  }/** @public */
  export declare interface EmptyDirVolumeSource {
      /**
       * What type of storage medium should back this directory.
       *
       * The default is "" which means to use the node's default medium.
       * Must be an empty string (default) or Memory.
       * More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
       */
      medium: string;
      /**
       * Total amount of local storage required for this EmptyDir volume.
       *
       * The size limit is also applicable for memory medium.
       * The maximum usage on memory medium EmptyDir would be the minimum
       * value between the SizeLimit specified here and the sum of memory limits of all containers in a pod.
       * The default is nil which means that the limit is undefined.
       * More info: {@link http://kubernetes.io/docs/user-guide/volumes#emptydir}
       */
      sizeLimit: string;
  }/**
   * Volumes for {@link k8s.PodProps}
   *
   * @public
   */
  export declare interface Volume {
      /**
       * Volume's name.
       *
       * Must be a DNS_LABEL and unique within the pod.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names}
       */
      name: string;
      /**
       * Represents a configMap that should populate this volume
       */
      configMap?: ConfigMapVolumeSource;
      /**
       * EmptyDir represents a temporary directory that shares a pod's lifetime.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/storage/volumes#emptydir}
       *
       */
      emptyDir?: EmptyDirVolumeSource;
      /**
       * Represents a secret that should populate this volume.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/storage/volumes#secret}
       */
      secret?: SecretVolumeSource;
      /** Other k8s volume kinds not typed yet for \@adpt/cloud */
      [key: string]: any;
  }/**
   * Props for the {@link k8s.Pod} component
   *
   * @public
   */
  export declare interface PodProps extends WithChildren {
      /**
       *  True is this is a template for use in a controller, false otherwise
       *  @defaultValue false
       */
      isTemplate: boolean;
      /** Information about the k8s cluster (ip address, auth info, etc.) */
      config?: ClusterInfo;
      /** k8s metadata */
      metadata: Metadata;
      /**
       * Optional duration in seconds the pod may be active on the node relative to StartTime before the system will actively try to mark it failed and kill associated containers.
       *
       * Value must be a positive integer.
       */
      activeDeadlineSeconds?: number;
      /** If specified, the pod's scheduling constraints */
      affinity?: Affinity;
      /** AutomountServiceAccountToken indicates whether a service account token should be automatically mounted. */
      automountServiceAccountToken?: boolean;
      /**
       *  Specifies the DNS parameters of a pod.
       *
       *  Parameters specified here will be merged to the generated DNS configuration based on DNSPolicy.
       */
      dnsConfig?: PodDNSConfig;
      /**
       * Set DNS policy for the pod.
       *
       * Valid values are 'ClusterFirstWithHostNet', 'ClusterFirst', 'Default' or 'None'.
       * DNS parameters given in DNSConfig will be merged with the policy selected with DNSPolicy.
       * To have DNS options set along with hostNetwork, you have to specify DNS policy explicitly
       * to 'ClusterFirstWithHostNet'.
       *
       * @defaultValue ClusterFirst
       */
      dnsPolicy: "ClusterFirstWithHostNet" | "ClusterFirst" | "Default" | "None";
      /**
       * Indicates whether information about services should be injected into pod's environment variables matching the syntax of Docker links.
       *
       * @defaultValue true
       */
      enableServiceLinks: boolean;
      /**
       * An optional list of hosts and IPs that will be injected into the pod's hosts file if specified.
       *
       * This is only valid for non-hostNetwork pods.
       */
      hostAliases?: HostAlias[];
      /**
       * Use the host's ipc namespace.
       * @defaultValue false
       */
      hostIPC: boolean;
      /**
       * Host networking requested for this pod.
       *
       * Use the host's network namespace.
       * If this option is set, the ports that will be used must be specified. Default to false.
       */
      hostNetwork?: boolean;
      /**
       * Use the host's pid namespace.
       * @defaultValue false
       */
      hostPID: boolean;
      /**
       * Specifies the hostname of the Pod.
       *
       * If not specified, the pod's hostname will be set to a system-defined value.
       */
      hostname?: string;
      /**
       * List of references to secrets in the same namespace to use for pulling any of the images used by this PodSpec.
       *
       * If specified, these secrets will be passed to individual puller implementations for them to use.
       * For example, in the case of docker, only DockerConfig type secrets are honored.
       * More info: {@link https://kubernetes.io/docs/concepts/containers/images#specifying-imagepullsecrets-on-a-pod}
       */
      imagePullSecrets?: LocalObjectReference[];
      /**
       * A request to schedule this pod onto a specific node.
       *
       * If it is non-empty, the scheduler simply schedules this pod onto that node,
       * assuming that it fits resource requirements.
       */
      nodeName?: string;
      /**
       * A selector which must be true for the pod to fit on a node.
       *
       * Selector which must match a node's labels for the pod to be scheduled on that node.
       * More info: {@link https://kubernetes.io/docs/concepts/configuration/assign-pod-node/}
       */
      nodeSelector?: {
          [label: string]: boolean | string;
      };
      /**
       * Overhead represents the resource overhead associated with running a pod for a given RuntimeClass.
       *
       * This field will be autopopulated at admission time by the RuntimeClass admission controller.
       * If the RuntimeClass admission controller is enabled, overhead must not be set in Pod create requests.
       * The RuntimeClass admission controller will reject Pod create requests which have the overhead already set.
       * If RuntimeClass is configured and selected in the PodSpec, Overhead will be set to the value defined in
       * the corresponding RuntimeClass, otherwise it will remain unset and treated as zero.
       *
       * More info: {@link https://git.k8s.io/enhancements/keps/sig-node/20190226-pod-overhead.md}
       *
       * This field is alpha-level as of Kubernetes v1.16, and is only honored by servers that enable
       * the PodOverhead feature.
       * @alpha
       */
      overhead?: unknown;
      /**
       * PreemptionPolicy is the Policy for preempting pods with lower priority.
       *
       * This field is beta-level, gated by the NonPreemptingPriority feature-gate.
       *
       * @defaultValue PreemptLowerPriority
       * @beta
       */
      preemptionPolicy?: "Never" | "PreemptLowerPriority";
      /**
       * The priority various system components use this field to find the priority of the pod.
       *
       * When Priority Admission Controller is enabled, it prevents users from setting this field.
       * The admission controller populates this field from PriorityClassName.
       * The higher the value, the higher the priority.
       */
      priority?: number;
      /**
       * If specified, indicates the pod's priority.
       *
       * "system-node-critical" and "system-cluster-critical" are two special keywords which indicate the highest
       * priorities with the former being the highest priority. Any other name must be defined by creating a PriorityClass
       * object with that name. If not specified, the pod priority will be default or zero if there is no default.
       */
      priorityClassName?: string;
      /**
       *  If specified, all readiness gates will be evaluated for pod readiness.
       *
       *  A pod is ready when all its containers are ready AND all conditions specified
       *  in the readiness gates have status equal to "True"
       *
       *  More info: {@link https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#pod-readiness-gate}
       */
      readinessGates?: PodReadinessGate[];
      /**
       * Restart policy for all containers within the pod.
       *
       * One of Always, OnFailure, Never. Default to Always.
       * More info: {@link https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy}
       *
       * @defaultValue Always
       */
      restartPolicy: "Always" | "OnFailure" | "Never";
      /**
       * Refers to a RuntimeClass object in the node.k8s.io group, which should be used to run this pod.
       *
       * If no RuntimeClass resource matches the named class, the pod will not be run.
       * If unset or empty, the "legacy" RuntimeClass will be used, which is an implicit
       * class with an empty definition that uses the default runtime handler.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/containers/runtime-class/}
       *
       * This is a beta feature as of Kubernetes v1.14.
       */
      runtimeClassName?: string;
      /**
       *  If specified, the pod will be dispatched by specified scheduler.
       *  If not specified, the pod will be dispatched by default scheduler.
       */
      schedulerName?: string;
      /**
       * SecurityContext holds pod-level security attributes and common container settings.
       * See type description for default values of each field.
       *
       * @defaultValue \{\}
       */
      securityContext: PodSecurityContext;
      /**
       * ServiceAccountName is the name of the ServiceAccount to use to run this pod.
       * More info: {@link https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/}
       */
      serviceAccountName?: string | Handle;
      /**
       * If true the pod's hostname will be configured as the pod's FQDN, rather than the leaf name (the default).
       * In Linux containers, this means setting the FQDN in the hostname field of the kernel
       * (the nodename field of struct utsname).
       * In Windows containers, this means setting the registry value of hostname for the registry key
       * HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters to FQDN.
       * If a pod does not have FQDN, this has no effect.
       *
       * @defaultValue false
       */
      setHostnameAsFQDN?: boolean;
      /**
       * Share a single process namespace between all of the containers in a pod.
       * When this is set containers will be able to view and signal processes from other containers in the same pod,
       * and the first process in each container will not be assigned PID 1.
       * HostPID and ShareProcessNamespace cannot both be set.
       *
       * @defaultValue false
       */
      shareProcessNamespace: boolean;
      /**
       *  If specified, the fully qualified Pod hostname will be "\<hostname\>.\<subdomain\>.\<pod namespace\>.svc.\<cluster domain\>".
       *  If not specified, the pod will not have a domainname at all.
       */
      subdomain?: string;
      /**
       * Optional duration in seconds the pod needs to terminate gracefully.
       *
       * May be decreased in delete request. Value must be non-negative integer.
       * The value zero indicates delete immediately. If this value is nil, the default
       * grace period will be used instead. The grace period is the duration in seconds
       * after the processes running in the pod are sent a termination signal and the time
       * when the processes are forcibly halted with a kill signal. Set this value longer
       * than the expected cleanup time for your process. Defaults to 30 seconds.
       */
      terminationGracePeriodSeconds?: number;
      /** If specified, the pod's tolerations. */
      tolerations?: Toleration[];
      /**
       *  TopologySpreadConstraints describes how a group of pods ought to spread across topology domains.
       *
       *  Scheduler will schedule pods in a way which abides by the constraints. All topologySpreadConstraints are ANDed.
       */
      topologySpreadConstraints?: TopologySpreadConstraint[];
      /**
       * List of volumes that can be mounted by containers belonging to the pod.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/storage/volumes}
       */
      volumes?: Volume[];
  }/**
   * Component for Kubernetes Pods
   *
   * @public
   */
  export declare class Pod extends DeferredComponent<PodProps, ResolvedVolumes & ResolvedServiceAccountName> {
      static defaultProps: {
          isTemplate: boolean;
          metadata: {};
          dnsPolicy: string;
          enableServiceLinks: boolean;
          hostIPC: boolean;
          hostPID: boolean;
          restartPolicy: string;
          securityContext: {};
          shareProcessNamespace: boolean;
          terminationGracePeriodSeconds: number;
      };
      initialState(): {};
      build(helpers: BuildHelpers): Adapt.JSX.Element | null;
      status(_observe: ObserveForStatus, buildData: BuildData): Promise<Adapt.Status | undefined>;
  }/**
   * Spec for for Kubernetes Pods
   *
   * @public
   */
  export declare interface PodSpec extends Omit<PodProps, "config" | "metadata" | "isTemplate"> {
      containers: ContainerSpec[];
      terminationGracePeriodSeconds?: number;
  }/** @internal */
  const podResourceInfo: {
      kind: string;
      deployedWhen: typeof deployedWhen;
      statusQuery: (props: ResourcePropsWithConfig, observe: ObserveForStatus, buildData: BuildData) => Promise<any>;
  };/**
   * k8s Secret resource
   *
   * @param propsIn - props for Secret as specifed in {@link k8s.SecretProps}
   *
   * @public
   */
  export declare function Secret(propsIn: SFCDeclProps<SecretProps, typeof defaultProps>): Adapt.JSX.Element;/** @internal */
  const secretResourceInfo: {
      kind: string;
      deployedWhen: () => true;
      statusQuery: (props: ResourcePropsWithConfig, observe: ObserveForStatus, buildData: BuildData) => Promise<any>;
      makeManifest: (manifest: Manifest, elem: AdaptElement<ResourceProps>, _deployID: string) => {
          data: {
              [key: string]: string;
          } | undefined;
          stringData: {
              [key: string]: string;
          } | undefined;
          type: string | undefined;
          apiVersion: string; /**
           * stringData allows specifying non-binary secret data in string form.
           *
           * It is provided as a write-only convenience method. All keys and values are merged into the data field on write,
           * overwriting any existing values. It is never output when reading from the API.
           */
          kind: string;
          metadata: import("./manifest_support").MetadataInRequest;
          spec?: import("./DaemonSet").DaemonSetSpec | import("./common").CRSpec | import("./Pod").PodSpec | import("./Service").ServiceSpec | import("./Deployment").DeploymentSpec | undefined;
      };
  };/**
   * Convert {@link NetworkService} props to {@link k8s.Service} props
   * @param abstractProps - props to convert
   * @returns Kubernetes spec corresponding to `abstractProps`
   *
   * @internal
   */
  export declare function k8sServiceProps(abstractProps: NetworkServiceProps & BuiltinProps): Omit<ServiceProps, keyof ResourceBase>;/**
   * Native Kubernetes Service resource
   *
   * @remarks
   *
   * Implements the {@link NetworkServiceInstance} interface.
   *
   * @public
   */
  export declare function Service(propsIn: SFCDeclProps<ServiceProps, typeof defaultProps>): Adapt.JSX.Element;/** @public */
  export declare interface ServiceProps extends ServiceSpec {
      /** Legal configuration loaded from kubeconfig */
      config: ClusterInfo;
      metadata?: Metadata;
      selector?: Handle | EndpointSelector;
  }/** @public */
  export declare interface ServiceSpec {
      /**
       * Cluster IP for a {@link k8s.Service}
       *
       * @remarks
       * `clusterIP` is the IP address of the service and is usually assigned
       * randomly by the master. If an address is specified manually and is not
       * in use by others, it will be allocated to the service; otherwise,
       * creation of the service will fail. This field can not be changed through
       * updates. Valid values are "None", empty string (""), or a valid IP
       * address. "None" can be specified for headless services when proxying is
       * not required. Only applies to types ClusterIP, NodePort, and
       * LoadBalancer. Ignored if type is ExternalName.
       *
       * For more information, see the
       * {@link https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies |
       * Kubernetes documentation}.
       */
      clusterIP?: string;
      /**
       * A list of IP addresses for which nodes in the cluster
       * will also accept traffic for this service.
       *
       * @remarks
       * These IPs are not managed by
       * Kubernetes. The user is responsible for ensuring that traffic arrives at
       * a node with this IP. A common example is external load balancers that are
       * not part of the Kubernetes system.
       */
      externalIPs?: string[];
      /**
       * The external reference that kubedns or equivalent
       * will return as a CNAME record for this service.
       *
       * @remarks
       * No proxying will be involved. Must be a
       * {@link https://tools.ietf.org/html/rfc1123 | valid RFC-1123 hostname}
       * and requires Type to be ExternalName.
       */
      externalName?: string;
      /**
       * Denotes if this Service desires to route
       * external traffic to node-local or cluster-wide endpoints.
       *
       * @remarks
       * "Local" preserves the client source IP and avoids a second hop for
       * LoadBalancer and Nodeport type services, but risks potentially
       * imbalanced traffic spreading. "Cluster" obscures the client source IP
       * and may cause a second hop to another node, but should have good overall
       * load-spreading.
       */
      externalTrafficPolicy?: string;
      /**
       * Specifies the healthcheck nodePort for the service.
       *
       * @remarks
       * If not specified, HealthCheckNodePort is created by the service
       * api backend with the allocated nodePort. Will use user-specified nodePort
       * value if specified by the client. Only affects when Type is set to
       * LoadBalancer and ExternalTrafficPolicy is set to Local.
       */
      healthCheckNodePort?: number;
      /**
       * Only applies to Service Type: LoadBalancer. LoadBalancer will
       * get created with the IP specified in this field.
       *
       * @remarks
       * This feature depends on
       * whether the underlying cloud provider supports specifying the loadBalancerIP
       * when a load balancer is created. This field will be ignored if the
       * cloud provider does not support the feature.
       */
      loadBalancerIP?: string;
      /**
       * If specified and supported by the platform, this will
       * restrict traffic through the cloud provider load balancer
       * to the specified client IPs.
       *
       * @remarks
       * This field will be ignored if the cloud provider
       * does not support the feature.
       *
       * For more information, see the
       * {@link https://v1-17.docs.kubernetes.io/docs/tasks/access-application-cluster/configure-cloud-provider-firewall/ |
       * Kubernetes documentation}.
       */
      loadBalancerSourceRanges?: string[];
      /**
       * The list of ports that are exposed by this service.
       *
       * @remarks
       * For more information, see the
       * {@link https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies |
       * Kubernetes documentation}.
       */
      ports?: ServicePort[];
      /**
       * When set to true, indicates that
       * DNS implementations must publish the notReadyAddresses of subsets for the
       * Endpoints associated with the Service.
       *
       * @remarks
       * The default value is false. The
       * primary use case for setting this field is to use a StatefulSet's Headless
       * Service to propagate SRV records for its Pods without respect to their
       * readiness for purpose of peer discovery.
       */
      publishNotReadyAddresses?: boolean;
      /**
       * Route service traffic to pods with label keys and values
       * matching this selector.
       *
       * @remarks
       * If empty or not present, the service is assumed to
       * have an external process managing its endpoints, which Kubernetes will not
       * modify. Only applies to types ClusterIP, NodePort, and LoadBalancer.
       * Ignored if type is ExternalName.
       *
       * For more information, see the
       * {@link https://kubernetes.io/docs/concepts/services-networking/service/ |
       * Kubernetes documentation}.
       */
      selector?: EndpointSelector | object;
      /**
       * Used to maintain session affinity.
       *
       * @remarks
       * Possible values are:
       *
       * - `"ClientIP"`: Enables client IP based session affinity.
       *
       * - `"None"`: Disables session affinity.
       *
       * For more information, see the
       * {@link https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies |
       * Kubernetes documentation}.
       * @defaultValue `"None"`
       */
      sessionAffinity?: string;
      /**
       * Determines how the Service is exposed.
       *
       * @remarks
       * Valid options are:
       *
       * - `"ExternalName"`: maps to the specified externalName.
       *
       * - `"ClusterIP"`: allocates a cluster-internal IP address for load
       * balancing to endpoints. Endpoints are determined by the selector or if
       * that is not specified, by manual construction of an Endpoints object. If
       * clusterIP is "None", no virtual IP is allocated and the endpoints are
       * published as a set of endpoints rather than a stable IP.
       *
       * - `"NodePort"`: Builds on ClusterIP and allocates a port on every node
       * which routes to the clusterIP.
       *
       * - `"LoadBalancer"`: Builds on NodePort and creates an external load
       * balancer (if supported in the current cloud) which routes to the
       * clusterIP.
       *
       * For more information, see the
       * {@link https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services---service-types |
       * Kubernetes documentation}.
       * @defaultValue `"ClusterIP"`
       */
      type?: string;
  }/** @public */
  export declare interface ServicePort {
      /**
       * The name of this port within the service.
       *
       * @remarks
       * This must be a DNS_LABEL.
       * All ports within a ServiceSpec must have unique names.This maps to the
       * Name' field in EndpointPort objects. Optional if only one ServicePort is
       * defined on this service.
       */
      name?: string;
      /**
       * The port on each node on which this service is exposed when
       * type=NodePort or LoadBalancer.
       *
       * @remarks
       * Usually assigned by the system. If
       * specified, it will be allocated to the service if unused or else creation
       * of the service will fail.
       *
       * For more information, see the
       * {@link https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport |
       * Kubernetes documentation}.
       * @defaultValue Automatically allocates a port if the ServiceType of this
       * Service requires one.
       */
      nodePort?: number;
      /** The port that will be exposed by this service. */
      port?: number;
      /** The IP protocol for this port.Supports "TCP" and "UDP".Default is TCP. */
      protocol?: string;
      /**
       * Number or name of the port to access on the pods targeted by the
       * service.
       *
       * @remarks
       * Number must be in the range 1 to 65535. Name must be an
       * IANA_SVC_NAME. If this is a string, it will be looked up as a named port
       * in the target Pod's container ports. If this is not specified, the value
       * of the 'port' field is used (an identity map). This field is ignored for
       * services with clusterIP = None, and should be omitted or set equal to the
       * 'port' field.
       *
       * For more information, see the
       * {@link https://kubernetes.io/docs/concepts/services-networking/service/#defining-a-service |
       * Kubernetes documentation}.
       */
      targetPort?: number | string;
  }/** @internal */
  const serviceResourceInfo: {
      kind: string;
      deployedWhen: typeof deployedWhen;
      statusQuery: (props: ResourcePropsWithConfig, observe: ObserveForStatus, buildData: BuildData) => Promise<any>;
  };/**
   * k8s ServiceAccount resource
   *
   * @param propsIn - props for ServiceAccount as specifed in {@link k8s.ServiceAccountProps}
   *
   * @public
   */
  export declare function ServiceAccount(propsIn: SFCDeclProps<ServiceAccountProps, typeof defaultProps>): Adapt.JSX.Element;/** @public */
  export declare function isServiceAccountProps(p: ResourceProps): p is ResourceProps & ResourceServiceAccount;/** @internal */
  const serviceAccountResourceInfo: {
      kind: string;
      deployedWhen: () => true;
      statusQuery: (props: ResourcePropsWithConfig, observe: ObserveForStatus, buildData: BuildData) => Promise<any>;
      makeManifest: (manifest: Manifest, elem: AdaptElement<ResourceProps>, _deployID: string) => {
          automountServiceAccountToken: boolean | undefined;
          imagePullSecrets: {
              name: string;
          }[] | undefined;
          secrets: ObjectReference[] | undefined;
          apiVersion: string;
          kind: string;
          metadata: import("./manifest_support").MetadataInRequest;
          spec?: import("./DaemonSet").DaemonSetSpec | import("./common").CRSpec | import("./Pod").PodSpec | import("./Service").ServiceSpec | import("./Deployment").DeploymentSpec | undefined;
      };
  };/**
   * Props for {@link k8s.ServiceDeployment}
   *
   * @public
   */
  export declare interface ServiceDeploymentProps<T extends AllowableComponentProps = DeploymentProps> extends ServiceProps {
      config: ClusterInfo;
      serviceProps?: Partial<ServiceProps>;
      component: ComponentType<T>;
      componentProps: T;
      podProps?: Partial<PodProps>;
      containerProps?: Partial<OmitT<K8sContainerProps, "image">>;
  }/**
   * A component for mapping a group of abstract {@link Container}s and
   * {@link NetworkService}s to Kubernetes {@link k8s.Pod}s and
   * {@link k8s.K8sContainer}s.
   *
   * @remarks
   * This component is intended to be used to replace {@link Container} and
   * {@link NetworkService} components that are grouped together, as the
   * only children of a common parent in a pattern that looks like this:
   *
   * ```tsx
   * <Service>
   *   <Container ... />
   *   <Container ... />
   *   <NetworkService ... />
   * </Service>
   * ```
   *
   * `ServiceDeployment` would map those abstract components into corresponding
   * k8s components like this:
   * ```tsx
   * <Group>
   *   <docker.RegistryDockerImage ... /> //If props.config specifies a registry
   *   <k8s.Deployment ... >
   *     <Pod isTemplate>
   *       <k8s.K8sContainer ... />
   *     </Pod>
   *   </k8s.Deployment>
   *   <docker.RegistryDockerImage ... /> //If props.config specifies a registry
   *   <k8s.Deployment ... >
   *     <Pod isTemplate>
   *       <k8s.K8sContainer ... />
   *     </Pod>
   *   </k8s.Pod>
   *   <k8s.Service ... />
   * </Group>
   * ```
   * An example style rule to do this is:
   * ```tsx
   * {Adapt.rule((matchedProps) => {
   *     const { handle, ...remainingProps } = matchedProps;
   *     return <ServiceDeployment config={kubeconfig} {...remainingProps} />;
   * })}
   * ```
   * `ServiceDeployment` also requires the `config` prop which specifies
   * connection and authentication information for the Kubernetes cluster on
   * which these objects should be created.
   *
   * @public
   */
  export declare class ServiceDeployment<T extends AllowableComponentProps> extends DeferredComponent<ServiceDeploymentProps<T>> {
      static defaultProps: {
          component: typeof Deployment;
          componentProps: {
              replicas: number;
          };
      };
      build(helpers: BuildHelpers): Adapt.JSX.Element;
  }/** @public */
  export declare function computeNamespaceFromMetadata(metadata?: Metadata): string;/** @public */
  export declare function isLabelSelector(x: any): x is LabelSelector;/**
   * Kubernetes Kind
   *
   * @public
   */
  export declare type Kind = string;/** @public */
  export declare interface CRSpec {
      [key: string]: any;
  }/** @public */
  export declare type Spec = DaemonSetSpec | DeploymentSpec | PodSpec | ServiceSpec | CRSpec;/** @public */
  export declare interface Metadata {
      namespace?: string;
      labels?: {
          [key: string]: string;
      };
      annotations?: {
          [key: string]: string;
      };
  }/** @public */
  export declare type ResourceProps = {
      key: string;
  } & (ResourceClusterRole | ResourceClusterRoleBinding | ResourceDaemonSet | ResourcePod | ResourceService | ResourceServiceAccount | ResourceConfigMap | ResourceSecret | ResourceCR);/** @public */
  export declare type ResourcePropsWithConfig = ResourceProps & {
      config: ClusterInfo;
  };/** @public */
  export declare interface ResourceInfo {
      kind: Kind;
      statusQuery?: (props: ResourceProps, observe: ObserveForStatus, buildData: BuildData) => unknown | Promise<unknown>;
      specsEqual(actual: Spec, element: Spec): boolean;
  }/**
   * Holds the information needed to connect, authenticate, and run code in a kuberenetes cluster
   *
   * @public
   */
  export declare interface ClusterInfo {
      /** Javascript object formed by parsing a valid kubeconfig file */
      kubeconfig: Kubeconfig;
      /**
       * Registry to which Docker images used by the cluster in `kubeconfig` should be pushed and pulled
       *
       * @remarks
       * If `registryPrefix` is a string, it is assumed that the cluster can pull from the same string
       * that outsiders can push to.
       *
       * If `registryPrefix` is of the form `{ external: string, internal: string }` then the `external`
       * string will be used to push images, and the `internal` string will be used to pull images.
       *
       * Note(manishv)
       * This is a bit of a hack to allow one hostname or IP address to push images from outside
       * a particular environment (say k8s) and a different URL for that environment to pull
       * images.
       *
       * A good example of this is a k3s-dind (k3s docker-in-docker) instance of kubernetes where
       * a private registry is running on a docker network attached to the k3s-dind instance, but where we
       * want to push {@link docker.LocalDockerImage} built images to that registry.  Since
       * {@link docker.LocalDockerImage | LocalDockerImage} is outside the k3s-dind environment, it must
       * use a host accessible network to push to the registry.  However, since the k3s-dind instance sees
       * the registry from within Docker, it must use a different address to pull the images for use.
       *
       * Once network scopes are fully supported, this interface will change to whatever is appropriate.  It
       * is best if you can arrange to have the same URL or registry string work for all access regardless
       * of which network the registry, Adapt host, and ultimate container running environment uses.
       *
       */
      registryPrefix?: string | DockerSplitRegistryInfo;
  }/** @public */
  export declare interface ResourceBase {
      /**
       * config to connect to the k8s cluster
       *
       * required if isTemplate is false
       */
      config?: ClusterInfo;
      /**
       * Specifies whether this resource is just a template for use in a controller
       */
      isTemplate?: boolean;
      apiVersion?: string;
      kind: Kind;
      metadata?: Metadata;
  }/**
   * @public
   */
  export declare interface PolicyRule {
      /**
       * APIGroups is the name of the APIGroup that contains the resources.
       *
       * If multiple API groups are specified, any action requested against one
       * of the enumerated resources in any API group will be allowed.
       */
      apiGroups?: string[];
      /**
       * NonResourceURLs is a set of partial urls that a user should have access to.
       *
       * *s are allowed, but only as the full, final step in the path.
       * Since non-resource URLs are not namespaced, this field is only applicable
       * for ClusterRoles referenced from a ClusterRoleBinding.
       * Rules can either apply to API resources (such as "pods" or "secrets") or
       * non-resource URL paths (such as "/api"), but not both.
       */
      nonResourceURLs?: string[];
      /**
       * ResourceNames is an optional white list of names that the rule applies to.
       *
       * An empty set means that everything is allowed.
       */
      resourceNames?: string[];
      /**
       * Resources is a list of resources this rule applies to.
       *
       * ResourceAll represents all resources.
       */
      resources: string[];
      /**
       * Verbs is a list of Verbs that apply to ALL the ResourceKinds and
       * AttributeRestrictions contained in this rule.
       *
       * VerbAll represents all kinds.
       */
      verbs: string[];
  }/**
   * AggregationRule for {@link k8s.ClusterRole}
   *
   * @public
   */
  export declare interface AggregationRule {
      /**
       * ClusterRoleSelectors holds a list of selectors which will be used to
       * find ClusterRoles and create the rules.
       *
       * If any of the selectors match, then the ClusterRole's permissions will be added
       */
      clusterRoleSelector: LabelSelector;
  }/** @public */
  export declare interface ResourceClusterRole extends ResourceBase {
      apiVersion: "rbac.authorization.k8s.io/v1";
      kind: "ClusterRole";
      aggregationRule?: AggregationRule;
      rules?: PolicyRule[];
  }/**
   * RoleRef for {@link k8s.ResourceClusterRoleBinding}
   *
   * @public
   */
  export declare interface RoleRef {
      /** apiGroup is the group for the resource being referenced */
      apiGroup: string;
      /** kind is the type of resource being referenced */
      kind: string;
      /** Name is the name of resource being referenced */
      name: string;
  }/**
   * Subject for {@link k8s.ResourceClusterRoleBinding}
   *
   * @public
   */
  export declare interface Subject {
      /** apiGroup is the group for the object being referenced */
      apiGroup: string;
      /** kind is the type of object being referenced */
      kind: string;
      /**
       * Name of the object being referenced.
       */
      name: string;
      /**
       * Namespace of the referenced object.
       *
       * If the object kind is non-namespace, such as "User" or "Group", and this value
       * is not empty the Authorizer should report an error.
       */
      namespace?: string;
  }/** @public */
  export declare interface ResourceClusterRoleBinding extends ResourceBase {
      apiVersion: "rbac.authorization.k8s.io/v1";
      kind: "ClusterRoleBinding";
      roleRef: RoleRef;
      subjects: Subject[];
  }/** @public */
  export declare interface ResourceDaemonSet extends ResourceBase {
      apiVersion: "apps/v1";
      kind: "DaemonSet";
      spec: DaemonSetSpec;
  }/** @public */
  export declare interface ResourcePod extends ResourceBase {
      kind: "Pod";
      spec: PodSpec;
  }/** @public */
  export declare interface ResourceService extends ResourceBase {
      kind: "Service";
      spec: ServiceSpec;
  }/** @public */
  export declare interface ResourceServiceAccount extends ResourceBase {
      kind: "ServiceAccount";
      automountServiceAccountToken?: boolean;
      imagePullSecrets?: {
          name: string;
      }[];
      secrets?: ObjectReference[];
  }/** @public */
  export declare interface ResourceConfigMap extends ResourceBase {
      kind: "ConfigMap";
      binaryData?: {
          [key: string]: string;
      };
      data?: {
          [key: string]: string;
      };
      /** @beta */
      immutable?: boolean;
  }/** @public */
  export declare interface ResourceSecret extends ResourceBase {
      kind: "Secret";
      data?: {
          [key: string]: string;
      };
      stringData?: {
          [key: string]: string;
      };
      type?: string;
  }/** @public */
  export declare interface ResourceCR extends ResourceBase {
      kind: string;
      spec: CRSpec;
  }/** @public */
  export declare interface Kubeconfig {
      apiVersion?: "v1";
      kind: "Config";
      "current-context": string;
      contexts: {
          name: string;
          context: {
              cluster: string;
              user: string;
          };
      }[];
      clusters: {
          name: string;
          cluster: {
              "certificate-authority-data": string;
              server: string;
          };
      }[];
      preferences?: unknown;
      users: {
          name: string;
          user: {
              "client-certificate-data"?: string;
              "client-key-data"?: string;
              "username"?: string;
              "password"?: string;
          };
      }[];
  }/** @public */
  export declare interface LabelSelector {
      /**
       * matchExpressions is a list of label selector requirements. The requirements are ANDed.
       */
      matchExpressions?: LabelSelectorRequirement[];
      /**
       * matchLabels is a map of `{key,value}`pairs. A single `{key,value}` in the matchLabels map
       * is equivalent to an element of matchExpressions, whose key field is "key", the operator
       * is "In", and the values array contains only "value". The requirements are ANDed.
       */
      matchLabels?: {
          [key: string]: string;
      };
  }/** @public */
  export declare interface LocalObjectReference {
      /**
       * Name of the referent.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names}
       */
      name: string;
  }/**
   * PodTemplateSpec from k8s API
   *
   * @public
   */
  export declare interface PodTemplateSpec {
      /**
       * Standard object's metadata.
       * More Info: {@link https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata}
       */
      metadata: Metadata;
      /**
       * Specification of the desired behavior of the pod.
       * More Info: {@link https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status}
       */
      spec: PodSpec;
  }/**
   * ObjectReference from k8s API
   *
   * @public
   */
  export declare interface ObjectReference {
      /**
       * If referring to a piece of an object instead of an entire object,
       * this string should contain a valid JSON/Go field access statement,
       * such as desiredState.manifest.containers[2].
       *
       * For example, if the object reference is to a container within a pod,
       * this would take on a value like: "spec.containers\{name\}" (where "name"
       * refers to the name of the container that triggered the event) or if no
       * container name is specified "spec.containers[2]"
       * (container with index 2 in this pod).
       * This syntax is chosen only to have some well-defined way of referencing a
       * part of an object.
       */
      fieldPath: string;
      /**
       * Name of the referent.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names}
       *
       */
      name: string;
      /**
       * Namespace of the referent.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/}
       */
      namespace: string;
      /**
       * Specific resourceVersion to which this reference is made, if any.
       *
       * More info: {@link https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency}
       */
      resourceVersion: string;
      /**
       * UID of the referent.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids}
       */
      uid: string;
  }/**
   * Make a {@link k8s.ClusterInfo} object suitable for use with k8s resources
   *
   * @remarks
   *
   * This function will take a set of options and generate a {@link k8s.ClusterInfo}
   * object that contains the kubeconfig, registryPrefix for private images, and any other
   * relevant information for the cluster
   *
   * See {@link k8s.MakeClusterInfoOptions} for information on how the information
   * is computed.
   *
   * @returns A {@link k8s.ClusterInfo} object.
   *
   * @public
   */
  export declare function makeClusterInfo(options: MakeClusterInfoOptions): Promise<ClusterInfo>;/** @internal */
  export declare function isResourcePodTemplate(x: any): x is AdaptElement<ResourcePod>;/**
   * Hook that allows a prop to be either an array of handle to k8s resources and values
   *
   * @param initial - initial value of the prop, before the handles are be resolved
   * @param notReady - is a marker value to indicate that a handle's value isn't available yet
   * @param kinds - an array of legal k8s Kinds that a prop handle can point to
   * @param thisResourceName - the name of the resource using the hook, for error messages
   * @param propName - the name of the prop being resolved, again for error messages
   *
   * @returns A two element array, the first element is the current value, the second the update function
   *
   * This hook will start by returning the initial value and an update function that updates
   * the value the hook returns.  The update function takes 2 arguments - the prop value which
   * is an array with a mix of values and handles to be resolved, and a function that receives
   * the elements that any handles point to along with that elements props.  This function
   * can be passed by the caller of update to resolve handles as appropriate for the component.
   *
   * For example, {@link k8s.ClusterRoleBinding} uses this hook to resolve the subjects prop,
   * which is an array of other objects (typically {@link ServiceAccount}) that a particular
   * {@link k8s.ClusterRole} should point to.  When ClusterRoleBinding calls the update method,
   * it passes a function that will convert a {@link k8s.Resource} element of Kind `ServiceAccount`
   * to the underlying `Subject` object that kubernetes expects, namely
   * `{ apiGroup: "", kind: "ServiceAccount", name: resourceIdToName(elem, deployID), namespace: <element namespace> }`
   *
   * @example
   * ```
   * function MyResource({ serviceAccountNames }: { serviceAccountNames: (string | Handle)[]}) {
   *   const { deployID } = useBuildHelpers();
   *   const [ resolvedServiceAccountNames, updateSANs] = useResources({
   *      initial: [],
   *      notReady: null,
   *      kinds: ["ServiceAccount"],
   *      thisResourceName: "MyResources",
   *      propName: "serviceAccountNames",
   *   });
   *
   *   updateSANs(serviceAccountNames, (e, props) => {
   *      return {
   *        apiGroup: (e.metadata.apiVersion?.split("/")[0]) || "",
   *        name: resourceElementToName(e, deployID),
   *        namespace: props.metadata.namespace,
   *      }
   *   });
   *
   *   return null;
   * }
   * ```
   *
   * @beta
   */
  export declare function useResources<ValT, NotReadyT>({ initial, notReady, kinds, thisResourceName, propName, }: {
      initial: ValT[];
      notReady: NotReadyT;
      kinds: string[];
      thisResourceName: string;
      propName: string;
  }): [
      (ValT | NotReadyT)[],
      (props: (ValT | Handle)[], f: (e: AdaptMountedElement, props: ResourceProps) => Promise<ValT> | ValT) => void
  ];/**
   * Hook to allow conversion of a prop that could be a value or a handle
   *
   * This function behaves similarly to {@link k8s.useResources}, but works for
   * a prop that is either a Handle or a single value instead of an array of
   * Handles and values.
   *
   * See {@link k8s.useResources} for more detailed documentation.
   *
   * @beta
   */
  export declare function useResource<ValT, NotReadyT>(opts: {
      initial: ValT | NotReadyT;
      notReady: NotReadyT;
      kinds: string[];
      thisResourceName: string;
      propName: string;
  }): [
      ValT | NotReadyT,
      (prop: ValT | Handle, f: (e: AdaptMountedElement, props: ResourceProps) => Promise<ValT> | ValT) => void
  ];/**
   * Options for {@link k8s.makeClusterInfo}
   *
   * @public
   */
  export declare interface MakeClusterInfoOptions {
      /**
       * A Javascript Object representing a valid kubeconfig, or a YAML string, or a path to a kubeconfig file.
       *
       * @remarks
       * If this is a Javascript object, it will be treated like a parsed kubeconfig.  If this is a string,
       * {@link k8s.makeClusterInfo} will first attempt to parse it as JSON.  If that fails, it will attempt
       * to parse it as YAML.  If that fails it will treat the string as a path of configs (like with the `KUBECONFIG`
       * environment variable).
       *
       * If kubeconfig is missing {@link k8s.makeClusterInfo} will use the `KUBECONFIG` environment variable to build
       * a suitable config using `kubectl config view --flatten` and return that as the kubeconfig in the resulting
       * {@link k8s.ClusterInfo}
       */
      kubeconfig?: Kubeconfig | string;
      /**
       * URL to the docker registry that this cluster uses to pull private images.
       *
       * @remarks
       * This is identical to the `registryPrefix` field in {@link k8s.ClusterInfo}.  It will
       * be returned verbatim in the resulting {@link k8s.ClusterInfo} object.
       */
      registryPrefix?: string | DockerSplitRegistryInfo;
  }/**
   * k8s ClusterRole resource
   *
   * @param propsIn - props for ServiceAccount as specifed in {@link k8s.ClusterRoleProps}
   *
   * @public
   */
  export declare function ClusterRole(propsIn: SFCDeclProps<ClusterRoleProps, typeof defaultProps>): Adapt.JSX.Element;/** @public */
  export declare function isClusterRoleProps(props: ResourceProps): props is ResourceProps & ResourceClusterRole;/** @internal */
  const clusterRoleResourceInfo: {
      kind: string;
      deployedWhen: () => true;
      statusQuery: (props: ResourcePropsWithConfig, observe: ObserveForStatus, buildData: BuildData) => Promise<any>;
      makeManifest: (manifest: Manifest, elem: AdaptElement<ResourceProps>, _deployID: string) => {
          aggregationRule: AggregationRule | undefined;
          rules: PolicyRule[] | undefined;
          apiVersion: string;
          kind: string;
          metadata: import("./manifest_support").MetadataInRequest;
          spec?: import("./DaemonSet").DaemonSetSpec | import("./common").CRSpec | import("./Pod").PodSpec | import("./Service").ServiceSpec | import("./Deployment").DeploymentSpec | undefined;
      };
  };/**
   * k8s ClusterRoleBinding resource
   *
   * @param propsIn - props for ServiceAccount as specifed in {@link k8s.ClusterRoleBindingProps}
   *
   * @public
   */
  export declare function ClusterRoleBinding(propsIn: SFCDeclProps<ClusterRoleBindingProps, typeof defaultProps>): Adapt.JSX.Element | null;/** @internal */
  const clusterRoleBindingResourceInfo: {
      kind: string;
      deployedWhen: () => true;
      statusQuery: (props: ResourcePropsWithConfig, observe: ObserveForStatus, buildData: BuildData) => Promise<any>;
      makeManifest: (manifest: Manifest, elem: AdaptElement<ResourceProps>, _deployID: string) => {
          roleRef: RoleRef;
          subjects: Subject[];
          apiVersion: string;
          kind: string;
          metadata: import("./manifest_support").MetadataInRequest;
          spec?: import("./DaemonSet").DaemonSetSpec | import("./common").CRSpec | import("./Pod").PodSpec | import("./Service").ServiceSpec | import("./Deployment").DeploymentSpec | undefined;
      };
  };/**
   * k8s ConfigMap resource
   *
   * @param propsIn - props for ConfigMap as specifed in {@link k8s.ConfigMapProps}
   *
   * @public
   */
  export declare function ConfigMap(propsIn: SFCDeclProps<ConfigMapProps, typeof defaultProps>): Adapt.JSX.Element;/** @internal */
  const configMapResourceInfo: {
      kind: string;
      deployedWhen: () => true;
      statusQuery: (props: ResourcePropsWithConfig, observe: ObserveForStatus, buildData: BuildData) => Promise<any>;
      makeManifest: (manifest: Manifest, elem: AdaptElement<ResourceProps>, _deployID: string) => {
          data: {
              [key: string]: string;
          } | undefined;
          binaryData: {
              [key: string]: string;
          } | undefined;
          immutable: boolean | undefined;
          apiVersion: string;
          kind: string;
          metadata: import("./manifest_support").MetadataInRequest;
          spec?: import("./DaemonSet").DaemonSetSpec | import("./common").CRSpec | import("./Pod").PodSpec | import("./Service").ServiceSpec | import("./Deployment").DeploymentSpec | undefined;
      };
  };/**
   * Low level utility function to translate from the abstract {@link Container}
   * component props ({@link ContainerProps}) to {@link k8s.K8sContainerProps}
   * to be used in a {@link k8s.K8sContainer}.
   * @remarks
   * Note: The `image` property in the passed in {@link ContainerProps} must
   * be a `string`, not a `Handle`.
   * In most cases, it is preferable to use the {@link k8s.Container} component
   * instead, which is designed specifically to deal with this issue.
   *
   * @param abstractProps - The abstract {@link ContainerProps} to translate from.
   * @param k8sProps - Props that are specific to the {@link k8s.K8sContainer}
   *     component that should be merged into the resulting returned
   *     {@link k8s.K8sContainerProps} object.
   * @public
   */
  export declare function k8sContainerProps(abstractProps: FromContainerProps, k8sProps?: Partial<K8sContainerProps>): K8sContainerProps;/**
   * Tests whether an element is a {@link k8s.K8sContainer} element
   * @param x - element to test
   * @returns `true` if element is a {@link k8s.K8sContainer}, `false` otherwise
   *
   * @remarks
   * Acts as a TypeScript type assertion that will assert that `x` is `AdaptElement<K8sContainerProps>`
   *
   * @public
   */
  export declare function isK8sContainerElement(x: AdaptElement): x is AdaptElement<K8sContainerProps>;/**
   * Component that implements the abstract {@link Container} interface and
   * translates to a Kubernetes-specific {@link k8s.K8sContainer}.
   * @public
   */
  export declare function Container(props: ContainerProps): Adapt.JSX.Element | null;/** @public */
  export declare interface VolumeMount {
      /**
       * Path within the container at which the volume should be mounted.
       *
       * Must not contain ':'.
       */
      mountPath: string;
      /**
       * mountPropagation determines how mounts are propagated from the host to container and the other way around.
       *
       * When not set, MountPropagationNone is used. This field is beta in 1.10.
       *
       * @defaultValue MountPropagationNone
       */
      mountPropagation?: string;
      /** This must match the Name of a Volume. */
      name: string;
      /**
       * Mounted read-only if true, read-write otherwise (false or unspecified).
       *
       * @defaultValue false
       */
      readOnly?: boolean;
      /**
       * Path within the volume from which the container's volume should be mounted.
       *
       * Defaults to "" (volume's root).
       *
       * @defaultValue ""
       */
      subPath?: string;
      /**
       * Expanded path within the volume from which the container's volume should be mounted.
       *
       * Behaves similarly to SubPath but environment variable references $(VAR_NAME)
       * are expanded using the container's environment.
       *
       * Defaults to "" (volume's root).
       *
       * SubPathExpr and SubPath are mutually exclusive.
       *
       * @defaultValue ""
       */
      subPathExpr?: string;
  }/** @public */
  export declare interface ConfigMapEnvSource {
      /**
       * Name of the referent.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names}
       */
      name?: string;
      /**
       * Specify whether the ConfigMap must be defined
       */
      optional?: boolean;
  }/** @public */
  export declare interface SecretEnvSource {
      /**
       * Name of the referent.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names}
       */
      name?: string;
      /**
       * Specify whether the Secret must be defined
       */
      optional?: boolean;
  }/** @public */
  export declare interface EnvFromSource {
      /** The ConfigMap to select from */
      configMapRef?: ConfigMapEnvSource;
      /** An optional identifier to prepend to each key in the ConfigMap. Must be a C_IDENTIFIER. */
      prefix?: string;
      /** SecretEnvSource	The Secret to select from */
      secretRef?: SecretEnvSource;
  }/** @public */
  export declare interface ExecAction {
      /**
       * Command is the command line to execute inside the container.
       *
       * The working directory for the command is root ('/') in the container's filesystem.
       * The command is simply exec'd, it is not run inside a shell,
       * so traditional shell instructions ('|', etc) won't work.
       * To use a shell, you need to explicitly call out to that shell.
       *
       * Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
       */
      command: string[];
  }/** @public */
  export declare interface HTTPGetAction {
      /**
       * Host name to connect to, defaults to the pod IP.
       *
       * You probably want to set "Host" in httpHeaders instead.
       */
      host?: string;
      /** Custom headers to set in the request. HTTP allows repeated headers. */
      httpHeaders?: {
          name: string;
          value: string;
      }[];
      /** Path to access on the HTTP server. */
      path: string;
      /**
       * Name or number of the port to access on the container.
       *
       * Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
       */
      port: number | string;
      /**
       * Scheme to use for connecting to the host.
       *
       * @defaultValue HTTP.
       */
      scheme?: string;
  }/** @public */
  export declare interface TCPSocketAction {
      /** Host name to connect to, defaults to the pod IP. */
      host?: string;
      /**
       * Number or name of the port to access on the container.
       *
       * Number must be in the range 1 to 65535.
       * Name must be an IANA_SVC_NAME.
       */
      port: string | number;
  }/** @public */
  export declare interface Probe {
      /**
       * Exec specifies the action to take.
       *
       * Only one of exec, httpGet, or tcpSocket should be specified
       */
      exec?: ExecAction;
      /**
       * Minimum consecutive failures for the probe to be considered failed after having succeeded.
       *
       * Defaults to 3. Minimum value is 1.
       *
       * @defaultValue 3
       */
      failureThreshold?: number;
      /** Specifies the http request to perform. */
      httpGet?: HTTPGetAction;
      /**
       *  Seconds after the container has started before liveness probes are initiated.
       *  More info: {@link https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes}
       */
      initialDelaySeconds?: number;
      /** How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. */
      periodSeconds?: number;
      /**
       * Minimum consecutive successes for the probe to be considered successful after having failed.
       *
       * Must be 1 for liveness and startup. Minimum value is 1.
       *
       * @defaultValue 1
       */
      successThreshold?: number;
      /**
       * Specifies an action involving a TCP port.
       *
       * TCP hooks not yet supported
       */
      tcpSocket?: TCPSocketAction;
      /**
       * Number of seconds after which the probe times out.
       *
       * Defaults to 1 second. Minimum value is 1.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes}
       *
       * @defaultValue 1
       */
      timeoutSeconds?: number;
  }/** @public */
  export declare interface ResourceRequirements {
      /**
       * Limits describes the maximum amount of compute resources allowed.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/}
       */
      limits?: {
          [key: string]: any;
      };
      /**
       * Describes the minimum amount of compute resources required.
       *
       * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
       * otherwise to an implementation-defined value.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/}
       */
      requests?: {
          [key: string]: any;
      };
  }/** @public */
  export declare type Handler = {
      exec: ExecAction;
  } | {
      httpGet: HTTPGetAction;
  } | {
      tcpSocket: TCPSocketAction;
  };/** @public */
  export declare interface Lifecycle {
      /**
       * PostStart is called immediately after a container is created.
       *
       * If the handler fails, the container is terminated and restarted according to its restart policy.
       * Other management of the container blocks until the hook completes.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks}
       */
      postStart: Handler;
      /**
       * Called immediately before a container is terminated due to an API request or management event such as liveness/startup probe failure, preemption, resource contention, etc.
       *
       * The handler is not called if the container crashes or exits.
       * The reason for termination is passed to the handler.
       * The Pod's termination grace period countdown begins before the PreStop hooked is executed.
       * Regardless of the outcome of the handler, the container will eventually terminate within the Pod's termination grace period.
       * Other management of the container blocks until the hook completes or until the termination grace period is reached.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks}
       */
      preStop: Handler;
  }/** @public */
  export declare interface VolumeDevice {
      /** The path inside of the container that the device will be mapped to. */
      devicePath: string;
      /** name must match the name of a persistentVolumeClaim in the pod */
      name: string;
  }/**
   * Resource spec for a Kubernetes container.
   * See the Kubernetes
   * {@link https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#container-v1-core | API docs }
   * for more details.
   * @public
   */
  export declare interface ContainerSpec {
      /**
       * Arguments to the entrypoint.
       *
       * The docker image's CMD is used if this is not provided.
       * Variable references $(VAR_NAME) are expanded using the container's environment.
       * If a variable cannot be resolved, the reference in the input string will be unchanged.
       * The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME).
       * Escaped references will never be expanded, regardless of whether the variable exists or not.
       * Cannot be updated.
       * More info: {@link https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell}
       */
      args?: string[];
      /**
       * Entrypoint array.
       *
       * Not executed within a shell.
       * The docker image's ENTRYPOINT is used if this is not provided.
       * Variable references $(VAR_NAME) are expanded using the container's environment.
       * If a variable cannot be resolved, the reference in the input string will be unchanged.
       * The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME).
       * Escaped references will never be expanded, regardless of whether the variable exists or not.
       * Cannot be updated.
       * More info: {@link https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell}
       */
      command?: string[];
      /**
       * List of environment variables to set in the container. Cannot be updated.
       */
      env?: EnvVar[];
      /**
       * List of sources to populate environment variables in the container.
       *
       * The keys defined within a source must be a C_IDENTIFIER.
       * All invalid keys will be reported as an event when the container is starting.
       * When a key exists in multiple sources, the value associated with the last source will take precedence.
       * Values defined by an Env with a duplicate key will take precedence. Cannot be updated.
       */
      envFrom?: EnvFromSource[];
      /**
       * Docker image name.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/containers/images}
       *
       * This field is optional to allow higher level config management to default or override container
       * images in workload controllers like Deployments and StatefulSets.
       */
      image?: string;
      /**
       * Image pull policy.
       *
       * One of Always, Never, IfNotPresent.
       * Defaults to Always if :latest tag is specified,
       * or IfNotPresent otherwise.
       * Cannot be updated.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/containers/images#updating-images}
       */
      imagePullPolicy?: "Always" | "Never" | "IfNotPresent";
      /**
       * List of sources to populate environment variables in the container.
       *
       * The keys defined within a source must be a C_IDENTIFIER.
       * All invalid keys will be reported as an event when the container is starting.
       * When a key exists in multiple sources, the value associated with the last source will take precedence.
       * Values defined by an Env with a duplicate key will take precedence. Cannot be updated.
       */
      lifecycle?: Lifecycle;
      /**
       * Periodic probe of container liveness.
       *
       * Container will be restarted if the probe fails.
       * Cannot be updated.
       * More info: {@link https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes}
       */
      livenessProbe?: Probe;
      /**
       * Name of the container specified as a DNS_LABEL.
       *
       * Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated.
       */
      name: string;
      /**
       * List of ports to expose from the container.
       *
       * Exposing a port here gives the system additional information about the network connections a container uses,
       * but is primarily informational.
       * Not specifying a port here DOES NOT prevent that port from being exposed.
       * Any port which is listening on the default "0.0.0.0" address inside a container will be accessible from
       * the network.
       * Cannot be updated.
       */
      ports?: ContainerPort[];
      /**
       * Periodic probe of container service readiness.
       *
       * Container will be removed from service endpoints if the probe fails.
       * Cannot be updated.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes}
       */
      readinessProbe?: Probe;
      /**
       * Compute Resources required by this container.
       *
       * Cannot be updated.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/}
       */
      resources?: ResourceRequirements;
      /**
       * Security options the pod should run with.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/policy/security-context/}
       * More info: {@link https://kubernetes.io/docs/tasks/configure-pod-container/security-context/}
       */
      securityContext?: PodSecurityContext;
      /**
       * Indicates that the Pod has successfully initialized.
       *
       * If specified, no other probes are executed until this completes successfully.
       * If this probe fails, the Pod will be restarted, just as if the livenessProbe failed.
       * This can be used to provide different probe parameters at the beginning of a Pod's lifecycle,
       * when it might take a long time to load data or warm a cache, than during steady-state operation.
       *
       * This cannot be updated.
       * This is a beta feature enabled by the StartupProbe feature flag.
       * More info: {@link https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes}
       */
      startupProbe?: Probe;
      /**
       * Whether this container should allocate a buffer for stdin in the container runtime.
       *
       * If this is not set, reads from stdin in the container will always result in EOF. Default is false.
       */
      stdin?: boolean;
      /**
       * Whether the container runtime should close the stdin channel after it has been opened by a single attach.
       *
       * When stdin is true the stdin stream will remain open across multiple attach sessions.
       * If stdinOnce is set to true, stdin is opened on container start,
       * is empty until the first client attaches to stdin,
       * and then remains open and accepts data until the client disconnects,
       * at which time stdin is closed and remains closed until the container is restarted.
       * If this flag is false, a container processes that reads from stdin will never receive an EOF. Default is false
       */
      stdinOnce?: boolean;
      /**
       * Path at which the file to which the container's termination message will be written is mounted into the container's filesystem.
       *
       * Message written is intended to be brief final status, such as an assertion failure message.
       * Will be truncated by the node if greater than 4096 bytes.
       * The total message length across all containers will be limited to 12kb.
       * Defaults to /dev/termination-log. Cannot be updated.
       */
      terminationMessagePath?: string;
      /**
       * Indicate how the termination message should be populated.
       *
       * File will use the contents of terminationMessagePath to populate the container status
       * message on both success and failure. FallbackToLogsOnError will use the last chunk of
       * container log output if the termination message file is empty and the container exited
       * with an error.
       * The log output is limited to 2048 bytes or 80 lines, whichever is smaller.
       * Defaults to File.
       * Cannot be updated.
       *
       * @defaultValue File
       */
      terminationMessagePolicy?: "File" | "FallbackToLogsOnError";
      /**
       * Whether this container should allocate a TTY for itself, also requires 'stdin' to be true.
       *
       * @defaultValue false
       */
      tty?: boolean;
      /**
       * volumeDevices is the list of block devices to be used by the container.
       */
      volumeDevices?: VolumeDevice[];
      /** volumeDevices is the list of block devices to be used by the container. */
      volumeMounts?: VolumeMount[];
      /**
       * Container's working directory.
       *
       * If not specified, the container runtime's default will be used,
       * which might be configured in the container image.
       * Cannot be updated.
       */
      workingDir?: string;
  }/**
   * Props for the Kubernetes-specific {@link k8s.K8sContainer} component.
   * @public
   */
  export declare interface K8sContainerProps extends ContainerSpec {
  }/** @public */
  export declare interface ContainerPort {
      /**
       * Number of port to expose on the pod's IP address.
       * @remarks
       * This must be a valid integer port number, `0 < x < 65536`.
       */
      containerPort: number;
      /** What host IP to bind the external port to. */
      hostIP?: string;
      /**
       * Number of port to expose on the host.
       * @remarks
       * If specified, this must be a valid integer port number,
       * `0 < x < 65536`. If HostNetwork is specified,
       * this must match ContainerPort. Most containers do not need this.
       */
      hostPort?: number;
      /**
       * A unique-within-pod name for the container
       * @remarks
       * If specified, this must be an IANA_SVC_NAME and unique within the pod.
       * Each named port in a pod must have a unique name. Name for the port
       * that can be referred to by services.
       */
      name?: string;
      /** Protocol for port. Must be UDP or TCP. Defaults to "TCP". */
      protocol?: string;
  }/** @public */
  export declare type EnvVar = EnvVarSimple | EnvVarFrom;/** @public */
  export declare interface EnvVarSimple {
      /** Name of the environment variable. Must be a C_IDENTIFIER. */
      name: string;
      /**
       * Variable references $(VAR_NAME) are expanded using the previous defined
       * environment variables in the container and any service environment
       * variables. If a variable cannot be resolved, the reference in the input
       * string will be unchanged. The $(VAR_NAME) syntax can be escaped with a
       * double $$, ie: $$(VAR_NAME). Escaped references will never be expanded,
       * regardless of whether the variable exists or not. Defaults to "".
       */
      value: string;
  }/** @public */
  export declare interface EnvVarFrom {
      /** Source for the environment variable's value. Cannot be used if value is not empty. */
      valueFrom?: any;
  }/**
   * See {@link k8s.k8sContainerProps}.
   * @public
   */
  export declare type FromContainerProps = ReplaceT<ContainerProps, {
      image: string;
  }> & BuiltinProps;/**
   * Kubernetes-specific container.
   * @public
   */
  export declare class K8sContainer extends PrimitiveComponent<K8sContainerProps> {
      static defaultProps: {
          imagePullPolicy: string;
      };
      validate(): undefined;
  }/**
   * Props for {@link k8s.Container}.
   * @public
   */
  export declare interface ContainerProps extends SFCDeclProps<ContainerProps> {
      /**
       * Additional {@link k8s.K8sContainerProps}-specific props that should be
       * added to the instantiated {@link k8s.K8sContainer}.
       */
      k8sContainerProps?: Partial<K8sContainerProps>;
  }/**
   * Spec for {@link k8s.DaemonSet} for use in {@link k8s.Resource}
   *
   * @public
   */
  export declare type DaemonSetSpec = Exclude<DaemonSetProps, ResourceBase> & {
      template: PodTemplateSpec;
  };/**
   * Component for Kubernetes DaemonSet
   *
   * @public
   */
  export declare class DaemonSet extends DeferredComponent<DaemonSetProps> {
      static defaultProps: {
          metadata: {};
          minReadySeconds: number;
          revisionHistoryLimit: number;
          updateStrategy: {
              type: string;
              rollingUpdate: {
                  maxUnavailable: number;
              };
          };
      };
      constructor(props: DaemonSetProps);
      build(helpers: BuildHelpers): Adapt.JSX.Element;
      status(_observe: ObserveForStatus, buildData: BuildData): Promise<Adapt.Status | undefined>;
  }/** @internal */
  const daemonSetResourceInfo: {
      kind: string;
      deployedWhen: typeof deployedWhen;
      statusQuery: (props: ResourcePropsWithConfig, observe: ObserveForStatus, buildData: BuildData) => Promise<any>;
  };/** @public */
  export declare interface DeploymentUpdateStrategyRecreate {
      type: "Recreate";
  }/** @public */
  export declare interface RollingUpdateDeployment {
      /**
       * The maximum number of pods that can be scheduled above the desired number of pods.
       *
       * Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
       * This can not be 0 if MaxUnavailable is 0.
       * Absolute number is calculated from percentage by rounding up.
       * Defaults to 25%.
       *
       * @example
       * When this is set to 30%, the new ReplicaSet can be scaled up immediately when the rolling update starts,
       * such that the total number of old and new pods do not exceed 130% of desired pods. Once old pods have been
       * killed, new ReplicaSet can be scaled up further, ensuring that total number of pods running at any time
       * during the update is at most 130% of desired pods.
       */
      maxSurge?: number | string;
      /**
       * The maximum number of pods that can be unavailable during the update.
       *
       * Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
       * Absolute number is calculated from percentage by rounding down.
       * This can not be 0 if MaxSurge is 0. Defaults to 25%.
       *
       * @example
       * When this is set to 30%, the old ReplicaSet can be scaled down to 70% of desired pods
       * immediately when the rolling update starts. Once new pods are ready, old ReplicaSet
       * can be scaled down further, followed by scaling up the new ReplicaSet, ensuring that
       * the total number of pods available at all times during the update is at least 70% of
       * desired pods.
       */
      maxUnavailable?: number | string;
  }/**
   * Spec for {@link k8s.Deployment} for use in {@link k8s.Resource}
   *
   * @public
   */
  export declare type DeploymentSpec = Exclude<DeploymentProps, ResourceBase> & {
      template: PodTemplateSpec;
  };/**
   * Props for {@link k8s.Deployment}
   *
   * @public
   */
  export declare interface DeploymentProps extends WithChildren {
      /** Information about the k8s cluster (ip address, auth info, etc.) */
      config: ClusterInfo;
      /** k8s metadata */
      metadata: Metadata;
      /**
       * The minimum number of seconds for which a newly created pod should
       * be ready without any of its container crashing, for it to be considered
       * available. Defaults to 0 (pod will be considered available as soon as it is ready).
       */
      minReadySeconds: number;
      /** Indicates that the deployment is paused */
      paused: boolean;
      /**
       * The maximum time in seconds for a deployment to make progress before it is considered to be failed.
       *
       * The deployment controller will continue to process failed deployments and a condition with a
       * ProgressDeadlineExceeded reason will be surfaced in the deployment status. Note that progress
       * will not be estimated during the time a deployment is paused. Defaults to 600s.
       */
      progressDeadlineSeconds: number;
      /**
       * Number of desired pods.
       *
       * Defaults to 1. 0 is not allowed.
       *
       * @defaultValue 1
       */
      replicas: number;
      /**
       * The number of old ReplicaSets to retain to allow rollback.
       *
       * This is a pointer to distinguish between explicit zero and not specified. Defaults to 10.
       *
       * @defaultValue 10
       */
      revisionHistoryLimit: number;
      /**
       * Label selector for pods.
       *
       * Existing ReplicaSets whose pods are selected by this will be the ones affected by this deployment.
       * It must match the pod template's labels.
       *
       * @remarks
       *
       * With Adapt, this is optional.  If not specified, adapt will pick a selector that will work with the pods
       * it creates as part of this {@link k8s.Deployment}
       */
      selector?: LabelSelector;
      /**
       * An deployment strategy to use to replace existing pods with new ones
       */
      strategy: DeploymentUpdateStrategy;
  }/**
   * Component for Kubernetes Deployment
   *
   * @public
   */
  export declare class Deployment extends DeferredComponent<DeploymentProps> {
      static defaultProps: {
          metadata: {};
          paused: boolean;
          replicas: number;
          progressDeadlineSeconds: number;
          minReadySeconds: number;
          revisionHistoryLimit: number;
          strategy: {
              type: string;
              rollingUpdate: {
                  maxSurge: string;
                  maxUnavailable: string;
              };
          };
      };
      constructor(props: DeploymentProps);
      build(helpers: BuildHelpers): Adapt.JSX.Element | null;
      deployedWhen: () => true | Adapt.Waiting;
      status(_observe: ObserveForStatus, buildData: BuildData): Promise<Adapt.Status | undefined>;
  }/** @internal */
  const deploymentResourceInfo: {
      kind: string;
      deployedWhen: typeof deployedWhen;
      statusQuery: (props: ResourcePropsWithConfig, observe: ObserveForStatus, buildData: BuildData) => Promise<any>;
  };/**
   * Type assertion to see if an element is both a {@link k8s.Resource | Resource}
   * and a {@link @adpt/core#FinalElement | FinalElement}
   *
   * @param e - element to test
   * @returns `true` if e is both a FinalElement and a {@link k8s.Resource | Resource}, `false` otherwise
   *
   * @public
   */
  export declare function isResourceFinalElement(e: AdaptElement): e is FinalDomElement<ResourceProps & Adapt.BuiltinProps>;/**
   * Tests whether a ResourceProps is for a template object
   *
   * @public
   */
  export declare function isResourcePropsWithConfig(x: ResourceProps & Partial<BuiltinProps>): x is ResourcePropsWithConfig & Partial<BuiltinProps>;/**
   * Tests to see if an object is a {@link k8s.Resource} element
   * @param x - object to test
   * @returns true if object is an AdaptElement of type {@link k8s.Resource}
   *
   * @public
   */
  export declare function isResource(x: any): x is AdaptElement<ResourceProps>;/**
   * Primitive Component recognized by the k8s plugin to represent resources
   * @public
   */
  export declare class Resource extends Action<ResourceProps> {
      defaultProps: {
          apiVersion: "v1";
          con: false;
      };
      manifest_: Manifest;
      constructor(props: ResourceProps);
      validate(): "Resource elements cannot have children" | undefined;
      shouldAct(op: ChangeType, ctx: ActionContext): Promise<ShouldAct>;
      action(op: ChangeType, ctx: ActionContext): Promise<void>;
      deployedWhen: (goalStatus: GoalStatus, helpers: DeployHelpers) => Promise<true | Adapt.Waiting | Adapt.Waiting[]>;
      status(observe: ObserveForStatus, buildData: BuildData): Promise<any>;
      private mountedElement;
      private manifest;
  }/** @internal */
  export declare function makePodManifest(props: PodProps & BuiltinProps, data: {
      volumes?: Volume[];
      serviceAccountName?: string;
  }): {
      kind: string;
      metadata: Metadata;
      spec: PodSpec;
  };/**
   * Tests whether x is a Pod element
   *
   * @param x - value to test
   * @returns `true` if x is a Pod element, false otherwise
   *
   * @public
   */
  export declare function isPod(x: any): x is AdaptElement<PodProps>;/** @public */
  export declare interface NodeSelectorRequirement {
      /** The label key that the selector applies to. */
      key: string;
      /**
       * Represents a key's relationship to a set of values.
       *
       * Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
       */
      operator: "In" | "NotIn" | "Exists" | "DoesNotExist" | "Gt" | "Lt";
      /**
       * Values for operator
       *
       * If the operator is In or NotIn, the values array must be non-empty.
       * If the operator is Exists or DoesNotExist, the values array must be empty.
       * If the operator is Gt or Lt, the values array must have a single element,
       * which will be interpreted as an integer.
       * This array is replaced during a strategic merge patch.
       */
      values: string[];
  }/** @public */
  export declare interface NodeSelectorTerm {
      /** A list of node selector requirements by node's labels. */
      matchExpressions?: NodeSelectorRequirement[];
      /** A list of node selector requirements by node's fields. */
      matchFields?: NodeSelectorRequirement[];
  }/** @public */
  export declare interface PreferredSchedulingTerm {
      /**
       * A node selector term, associated with the corresponding weight.
       */
      preference: NodeSelectorTerm;
      /** Weight associated with matching the corresponding nodeSelectorTerm, in the range 1-100. */
      weight: number;
  }/** @public */
  export declare interface NodeSelector {
      /** A list of node selector terms. The terms are ORed */
      nodeSelectorTerms: NodeSelectorTerm[];
  }/** @public */
  export declare interface NodeAffinity {
      /** The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding "weight" to the sum if the node matches the corresponding matchExpressions; the node(s) with the highest sum are the most preferred. */
      preferredDuringSchedulingIgnoredDuringExecution?: PreferredSchedulingTerm[];
      /** If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to an update), the system may or may not try to eventually evict the pod from its node. */
      requiredDuringSchedulingIgnoredDuringExecution?: NodeSelector;
  }/** @public */
  export declare interface PodAffinityTerm {
      /**
       * Label query over a set of resources, in this case pods.
       */
      labelSelector: LabelSelector;
      /** Specifies which namespaces the labelSelector applies to (matches against); null or empty list means "this pod's namespace" */
      namespaces?: string[];
      /** This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed. */
      topologyKey: string;
  }/** @public */
  export declare interface WeightedPodAffinityTerm {
      /** A pod affinity term, associated with the corresponding weight. */
      podAffinityTerm: PodAffinityTerm;
      /**
       * weight associated with matching the corresponding podAffinityTerm, in the range 1-100.
       */
      weight: number;
  }/** @public */
  export declare interface PodAffinity {
      /**
       * The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions.
       *
       * The node that is most preferred is the one with the greatest sum of weights,
       * i.e. for each node that meets all of the scheduling requirements (resource request,
       * requiredDuringScheduling affinity expressions, etc.), compute a sum by iterating
       * through the elements of this field and adding "weight" to the sum if the node has pods
       * which matches the corresponding podAffinityTerm; the node(s) with the highest sum are the most preferred.
       */
      preferredDuringSchedulingIgnoredDuringExecution: WeightedPodAffinityTerm[];
      /**
       * If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node.
       *
       * If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system may or may not try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each podAffinityTerm are intersected, i.e. all terms must be satisfied.
       */
      requiredDuringSchedulingIgnoredDuringExecution: PodAffinityTerm[];
  }/** @public */
  export declare interface PodAntiAffinity {
      /** The scheduler will prefer to schedule pods to nodes that satisfy the anti-affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling anti-affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the node(s) with the highest sum are the most preferred. */
      preferredDuringSchedulingIgnoredDuringExecution: WeightedPodAffinityTerm[];
      /** If the anti-affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the anti-affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system may or may not try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each podAffinityTerm are intersected, i.e. all terms must be satisfied. */
      requiredDuringSchedulingIgnoredDuringExecution: PodAffinity;
  }/** @public */
  export declare interface Affinity {
      /** Describes node affinity scheduling rules for the pod. */
      nodeAffinity: NodeAffinity;
      /** Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)). */
      podAffinity: PodAffinity;
      /** PodAntiAffinity	Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)). */
      podAntiAffinity: PodAntiAffinity;
  }/** @public */
  export declare interface PodDNSConfigOption {
      name: string;
      value?: string;
  }/** @public */
  export declare interface PodDNSConfig {
      /**
       * A list of DNS name server IP addresses.
       *
       * This will be appended to the base nameservers generated from DNSPolicy. Duplicated nameservers will be removed.
       */
      nameservers: string[];
      /**
       * A list of DNS resolver options.
       *
       * This will be merged with the base options generated from DNSPolicy.
       * Duplicated entries will be removed.
       * Resolution options given in Options will override those that appear in the base DNSPolicy.
       */
      options: PodDNSConfigOption[];
      /**
       * A list of DNS search domains for host-name lookup.
       *
       * This will be appended to the base search paths generated from DNSPolicy. Duplicated search paths will be removed.
       */
      searches: string[];
  }/** @public */
  export declare interface PodReadinessGate {
      /** Refers to a condition in the pod's condition list with matching type. */
      conditionType: string;
  }/** @public */
  export declare interface SELinuxOptions {
      /** SELinux level label that applies to the container. */
      level: string;
      /** SELinux role label that applies to the container. */
      role: string;
      /** SELinux type label that applies to the container. */
      type: string;
      /** SELinux user label that applies to the container */
      user: string;
  }/** @public */
  export declare interface SeccompProfile {
      /**
       * Indicates a profile defined in a file on the node should be used.
       *
       * The profile must be preconfigured on the node to work.
       * Must be a descending path, relative to the kubelet's configured seccomp profile location.
       * Must only be set if type is "Localhost".
       */
      localhostProfile?: string;
      /**
       * Indicates which kind of seccomp profile will be applied.
       *
       * Valid options are:
       * * Localhost - a profile defined in a file on the node should be used.
       * * RuntimeDefault - the container runtime default profile should be used.
       * * Unconfined - no profile should be applied.
       */
      type: "Localhost" | "RuntimeDefault" | "Unconfined";
  }/** @public */
  export declare interface Sysctl {
      name: string;
      value: string;
  }/** @public */
  export declare interface WindowsSecurityContextOptions {
      /**
       * The GMSA admission webhook ({@link https://github.com/kubernetes-sigs/windows-gmsa}) inlines the contents of the GMSA credential spec named by the GMSACredentialSpecName field.
       */
      gmsaCredentialSpec?: string;
      /**
       * GMSACredentialSpecName is the name of the GMSA credential spec to use.
       */
      gmsaCredentialSpecName?: string;
      /**
       * The UserName in Windows to run the entrypoint of the container process.
       *
       * Defaults to the user specified in image metadata if unspecified. May also be set in PodSecurityContext.
       * If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
       */
      runAsUserName?: string;
  }/** @public */
  export declare interface PodSecurityContext {
      /**
       * A special supplemental group that applies to all containers in a pod.
       *
       * Some volume types allow the Kubelet to change the ownership of that volume to be owned by the pod:
       *
       * 1. The owning GID will be the FSGroup
       * 2. The setgid bit is set (new files created in the volume will be owned by FSGroup)
       * 3. The permission bits are OR'd with rw-rw----
       *
       * If unset, the Kubelet will not modify the ownership and permissions of any volume.
       */
      fsGroup?: number;
      /**
       * Defines behavior of changing ownership and permission of the volume before being exposed inside Pod.
       *
       * This field will only apply to volume types which support fsGroup based ownership(and permissions).
       * It will have no effect on ephemeral volume types such as: secret, configmaps and emptydir.
       * Valid values are "OnRootMismatch" and "Always". If not specified defaults to "Always".
       *
       * @defaultValue Always
       */
      fsGroupChangePolicy?: "OnRootMismatch" | "Always";
      /**
       * The GID to run the entrypoint of the container process.
       *
       * Uses runtime default if unset. May also be set in SecurityContext.
       * If set in both SecurityContext and PodSecurityContext, the value specified in
       * SecurityContext takes precedence for that container.
       */
      runAsGroup?: number;
      /**
       * Indicates that the container must run as a non-root user.
       *
       * If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and
       * fail to start the container if it does. If unset or false, no such validation will be performed.
       * May also be set in SecurityContext.
       * If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
       */
      runAsNonRoot?: boolean;
      /**
       * The UID to run the entrypoint of the container process.
       *
       * Defaults to user specified in image metadata if unspecified.
       * May also be set in SecurityContext.
       * If set in both SecurityContext and PodSecurityContext, the value specified in
       * SecurityContext takes precedence for that container.
       */
      runAsUser?: number;
      /**
       * The SELinux context to be applied to all containers.
       *
       * If unspecified, the container runtime will allocate a random SELinux context for each container.
       * May also be set in SecurityContext.
       * If set in both SecurityContext and PodSecurityContext, the value specified in
       * SecurityContext takes precedence for that container.
       */
      seLinuxOptions?: SELinuxOptions;
      /**
       * The seccomp options to use by the containers in this pod.
       */
      seccompProfile?: SeccompProfile;
      /**
       * 	A list of groups applied to the first process run in each container, in addition to the container's primary GID.
       *
       *  If unspecified, no groups will be added to any container.
       */
      supplementalGroups?: number[];
      /**
       * Sysctls hold a list of namespaced sysctls used for the pod.
       *
       * Pods with unsupported sysctls (by the container runtime) might fail to launch.
       */
      sysctls?: Sysctl[];
      /**
       * The Windows specific settings applied to all containers.
       *
       * If unspecified, the options within a container's SecurityContext will be used.
       * If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
       */
      windowsOptions: WindowsSecurityContextOptions;
  }/** @public */
  export declare interface Toleration {
      /**
       * Indicates the taint effect to match.
       *
       * Empty means match all taint effects.
       * When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
       */
      effect?: "NoSchedule" | "PreferNoSchedule" | "NoExecute";
      /**
       * The taint key that the toleration applies to.
       *
       * Empty means match all taint keys.
       * If the key is empty, operator must be Exists;
       * this combination means to match all values and all keys.
       */
      key?: string;
      /**
       * Represents a key's relationship to the value.
       *
       * Valid operators are Exists and Equal.
       * Defaults to Equal.
       * Exists is equivalent to wildcard for value, so that a pod can tolerate all taints of a particular category.
       *
       * @defaultValue Equal
       */
      operator?: "Exists" | "Equal";
      /**
       * Represents the period of time the toleration (which must be of effect NoExecute, otherwise this field is ignored) tolerates the taint.
       *
       * By default, it is not set, which means tolerate the taint forever (do not evict).
       * Zero and negative values will be treated as 0 (evict immediately) by the system.
       */
      tolerationSeconds?: number;
      /**
       * Value is the taint value the toleration matches to.
       *
       * If the operator is Exists, the value should be empty, otherwise just a regular string.
       */
      value?: string;
  }/** @public */
  export declare interface TopologySpreadConstraint {
      /**
       * Used to find matching pods.
       *
       * Pods that match this label selector are counted to determine the
       * number of pods in their corresponding topology domain.
       */
      labelSelector: LabelSelector;
      /**
       * Describes the degree to which pods may be unevenly distributed.
       *
       * When `whenUnsatisfiable=DoNotSchedule`, it is the maximum permitted
       * difference between the number of matching pods in the target topology
       * and the global minimum.
       * For example, in a 3-zone cluster, MaxSkew is set to 1, and pods with
       * the same labelSelector spread as 1/1/0: | zone1 | zone2 | zone3 | | P | P | |
       * - if MaxSkew is 1, incoming pod can only be scheduled to zone3 to become 1/1/1;
       *   scheduling it onto zone1(zone2) would make the ActualSkew(2-0) on zone1(zone2) violate MaxSkew(1).
       * - if MaxSkew is 2, incoming pod can be scheduled onto any zone.
       * When `whenUnsatisfiable=ScheduleAnyway`, it is used to give higher precedence to topologies that satisfy it.
       * It's a required field. Default value is 1 and 0 is not allowed.
       *
       * @example
       *
       * @defaultValue 1
       */
      maxSkew: number;
      /**
       * The key of node labels.
       *
       * Nodes that have a label with this key and identical values are considered to be in the same topology.
       * We consider each \<key, value\> as a "bucket", and try to put balanced number of pods into each bucket.
       * It's a required field.
       */
      topologyKey: string;
      /**
       * Indicates how to deal with a pod if it doesn't satisfy the spread constraint.
       *
       * - DoNotSchedule (default) tells the scheduler not to schedule it.
       * - ScheduleAnyway tells the scheduler to schedule the pod in any location,
       *   but giving higher precedence to topologies that would help reduce the skew.
       *
       * A constraint is considered "Unsatisfiable" for an incoming pod if and only if every possible
       * node assigment for that pod would violate "MaxSkew" on some topology.
       * For example, in a 3-zone cluster, MaxSkew is set to 1, and pods with the same labelSelector
       * spread as 3/1/1: | zone1 | zone2 | zone3 | | P P P | P | P | If WhenUnsatisfiable is set to DoNotSchedule,
       * incoming pod can only be scheduled to zone2(zone3) to become 3/2/1(3/1/2)
       * as ActualSkew(2-1) on zone2(zone3) satisfies MaxSkew(1).
       * In other words, the cluster can still be imbalanced, but scheduler won't make it
       * *more* imbalanced.
       *
       * It's a required field.
       */
      whenUnsatisfiable: string;
  }/** @public */
  export declare interface KeyToPath {
      /** The key to project. */
      key: string;
      /**
       * mode bits to use on this file,
       * Must be a value between 0 and 0777.
       * If not specified, the volume defaultMode will be used.
       * This might be in conflict with other options that affect the file mode, like fsGroup,
       * and the result can be other mode bits set.
       */
      mode?: number;
      /**
       * The relative path of the file to map the key to.
       *
       * May not be an absolute path. May not contain the path element '..'. May not start with the string '..'.
       */
      path: string;
  }/** @public */
  export declare interface ConfigMapVolumeSource {
      /**
       * mode bits to use on created files by default.
       *
       * Must be a value between 0 and 0777. Defaults to 0644.
       * Directories within the path are not affected by this setting.
       * This might be in conflict with other options that affect the file mode,
       * like fsGroup, and the result can be other mode bits set.
       */
      defaultMode?: number;
      /**
       * If unspecified, each key-value pair in the Data field of the referenced ConfigMap will be projected into the volume as a file whose name is the key and content is the value.
       *
       * If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present.
       * If a key is specified which is not present in the ConfigMap, the volume setup will error unless it is marked optional.
       * Paths must be relative and may not contain the '..' path or start with '..'.
       */
      items?: KeyToPath[];
      /**
       * Name of the referent.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names}
       */
      name: string | Handle;
      /** Specify whether the ConfigMap or its keys must be defined */
      optional?: boolean;
  }/** @public */
  export declare interface SecretVolumeSource {
      /**
       * mode bits to use on created files by default.
       *
       * Must be a value between 0 and 0777. Defaults to 0644.
       * Directories within the path are not affected by this setting.
       * This might be in conflict with other options that affect the file mode,
       * like fsGroup, and the result can be other mode bits set.
       */
      defaultMode?: number;
      /**
       * If unspecified, each key-value pair in the Data field of the referenced Secret will be projected into the volume as a file whose name is the key and content is the value.
       *
       * If specified, the listed keys will be projected into the specified paths,
       * and unlisted keys will not be present. If a key is specified which is not
       * present in the Secret, the volume setup will error unless it is marked optional.
       *
       * Paths must be relative and may not contain the '..' path or start with '..'.
       */
      items?: KeyToPath[];
      /** Specify whether the Secret or its keys must be defined */
      optional?: boolean;
      /**
       * Name of the secret in the pod's namespace to use.
       *
       *  More info: {@link https://kubernetes.io/docs/concepts/storage/volumes#secret}
       */
      secretName: string | Handle;
  }/** @public */
  export declare interface EmptyDirVolumeSource {
      /**
       * What type of storage medium should back this directory.
       *
       * The default is "" which means to use the node's default medium.
       * Must be an empty string (default) or Memory.
       * More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
       */
      medium: string;
      /**
       * Total amount of local storage required for this EmptyDir volume.
       *
       * The size limit is also applicable for memory medium.
       * The maximum usage on memory medium EmptyDir would be the minimum
       * value between the SizeLimit specified here and the sum of memory limits of all containers in a pod.
       * The default is nil which means that the limit is undefined.
       * More info: {@link http://kubernetes.io/docs/user-guide/volumes#emptydir}
       */
      sizeLimit: string;
  }/**
   * Volumes for {@link k8s.PodProps}
   *
   * @public
   */
  export declare interface Volume {
      /**
       * Volume's name.
       *
       * Must be a DNS_LABEL and unique within the pod.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names}
       */
      name: string;
      /**
       * Represents a configMap that should populate this volume
       */
      configMap?: ConfigMapVolumeSource;
      /**
       * EmptyDir represents a temporary directory that shares a pod's lifetime.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/storage/volumes#emptydir}
       *
       */
      emptyDir?: EmptyDirVolumeSource;
      /**
       * Represents a secret that should populate this volume.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/storage/volumes#secret}
       */
      secret?: SecretVolumeSource;
      /** Other k8s volume kinds not typed yet for \@adpt/cloud */
      [key: string]: any;
  }/**
   * Props for the {@link k8s.Pod} component
   *
   * @public
   */
  export declare interface PodProps extends WithChildren {
      /**
       *  True is this is a template for use in a controller, false otherwise
       *  @defaultValue false
       */
      isTemplate: boolean;
      /** Information about the k8s cluster (ip address, auth info, etc.) */
      config?: ClusterInfo;
      /** k8s metadata */
      metadata: Metadata;
      /**
       * Optional duration in seconds the pod may be active on the node relative to StartTime before the system will actively try to mark it failed and kill associated containers.
       *
       * Value must be a positive integer.
       */
      activeDeadlineSeconds?: number;
      /** If specified, the pod's scheduling constraints */
      affinity?: Affinity;
      /** AutomountServiceAccountToken indicates whether a service account token should be automatically mounted. */
      automountServiceAccountToken?: boolean;
      /**
       *  Specifies the DNS parameters of a pod.
       *
       *  Parameters specified here will be merged to the generated DNS configuration based on DNSPolicy.
       */
      dnsConfig?: PodDNSConfig;
      /**
       * Set DNS policy for the pod.
       *
       * Valid values are 'ClusterFirstWithHostNet', 'ClusterFirst', 'Default' or 'None'.
       * DNS parameters given in DNSConfig will be merged with the policy selected with DNSPolicy.
       * To have DNS options set along with hostNetwork, you have to specify DNS policy explicitly
       * to 'ClusterFirstWithHostNet'.
       *
       * @defaultValue ClusterFirst
       */
      dnsPolicy: "ClusterFirstWithHostNet" | "ClusterFirst" | "Default" | "None";
      /**
       * Indicates whether information about services should be injected into pod's environment variables matching the syntax of Docker links.
       *
       * @defaultValue true
       */
      enableServiceLinks: boolean;
      /**
       * An optional list of hosts and IPs that will be injected into the pod's hosts file if specified.
       *
       * This is only valid for non-hostNetwork pods.
       */
      hostAliases?: HostAlias[];
      /**
       * Use the host's ipc namespace.
       * @defaultValue false
       */
      hostIPC: boolean;
      /**
       * Host networking requested for this pod.
       *
       * Use the host's network namespace.
       * If this option is set, the ports that will be used must be specified. Default to false.
       */
      hostNetwork?: boolean;
      /**
       * Use the host's pid namespace.
       * @defaultValue false
       */
      hostPID: boolean;
      /**
       * Specifies the hostname of the Pod.
       *
       * If not specified, the pod's hostname will be set to a system-defined value.
       */
      hostname?: string;
      /**
       * List of references to secrets in the same namespace to use for pulling any of the images used by this PodSpec.
       *
       * If specified, these secrets will be passed to individual puller implementations for them to use.
       * For example, in the case of docker, only DockerConfig type secrets are honored.
       * More info: {@link https://kubernetes.io/docs/concepts/containers/images#specifying-imagepullsecrets-on-a-pod}
       */
      imagePullSecrets?: LocalObjectReference[];
      /**
       * A request to schedule this pod onto a specific node.
       *
       * If it is non-empty, the scheduler simply schedules this pod onto that node,
       * assuming that it fits resource requirements.
       */
      nodeName?: string;
      /**
       * A selector which must be true for the pod to fit on a node.
       *
       * Selector which must match a node's labels for the pod to be scheduled on that node.
       * More info: {@link https://kubernetes.io/docs/concepts/configuration/assign-pod-node/}
       */
      nodeSelector?: {
          [label: string]: boolean | string;
      };
      /**
       * Overhead represents the resource overhead associated with running a pod for a given RuntimeClass.
       *
       * This field will be autopopulated at admission time by the RuntimeClass admission controller.
       * If the RuntimeClass admission controller is enabled, overhead must not be set in Pod create requests.
       * The RuntimeClass admission controller will reject Pod create requests which have the overhead already set.
       * If RuntimeClass is configured and selected in the PodSpec, Overhead will be set to the value defined in
       * the corresponding RuntimeClass, otherwise it will remain unset and treated as zero.
       *
       * More info: {@link https://git.k8s.io/enhancements/keps/sig-node/20190226-pod-overhead.md}
       *
       * This field is alpha-level as of Kubernetes v1.16, and is only honored by servers that enable
       * the PodOverhead feature.
       * @alpha
       */
      overhead?: unknown;
      /**
       * PreemptionPolicy is the Policy for preempting pods with lower priority.
       *
       * This field is beta-level, gated by the NonPreemptingPriority feature-gate.
       *
       * @defaultValue PreemptLowerPriority
       * @beta
       */
      preemptionPolicy?: "Never" | "PreemptLowerPriority";
      /**
       * The priority various system components use this field to find the priority of the pod.
       *
       * When Priority Admission Controller is enabled, it prevents users from setting this field.
       * The admission controller populates this field from PriorityClassName.
       * The higher the value, the higher the priority.
       */
      priority?: number;
      /**
       * If specified, indicates the pod's priority.
       *
       * "system-node-critical" and "system-cluster-critical" are two special keywords which indicate the highest
       * priorities with the former being the highest priority. Any other name must be defined by creating a PriorityClass
       * object with that name. If not specified, the pod priority will be default or zero if there is no default.
       */
      priorityClassName?: string;
      /**
       *  If specified, all readiness gates will be evaluated for pod readiness.
       *
       *  A pod is ready when all its containers are ready AND all conditions specified
       *  in the readiness gates have status equal to "True"
       *
       *  More info: {@link https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#pod-readiness-gate}
       */
      readinessGates?: PodReadinessGate[];
      /**
       * Restart policy for all containers within the pod.
       *
       * One of Always, OnFailure, Never. Default to Always.
       * More info: {@link https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy}
       *
       * @defaultValue Always
       */
      restartPolicy: "Always" | "OnFailure" | "Never";
      /**
       * Refers to a RuntimeClass object in the node.k8s.io group, which should be used to run this pod.
       *
       * If no RuntimeClass resource matches the named class, the pod will not be run.
       * If unset or empty, the "legacy" RuntimeClass will be used, which is an implicit
       * class with an empty definition that uses the default runtime handler.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/containers/runtime-class/}
       *
       * This is a beta feature as of Kubernetes v1.14.
       */
      runtimeClassName?: string;
      /**
       *  If specified, the pod will be dispatched by specified scheduler.
       *  If not specified, the pod will be dispatched by default scheduler.
       */
      schedulerName?: string;
      /**
       * SecurityContext holds pod-level security attributes and common container settings.
       * See type description for default values of each field.
       *
       * @defaultValue \{\}
       */
      securityContext: PodSecurityContext;
      /**
       * ServiceAccountName is the name of the ServiceAccount to use to run this pod.
       * More info: {@link https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/}
       */
      serviceAccountName?: string | Handle;
      /**
       * If true the pod's hostname will be configured as the pod's FQDN, rather than the leaf name (the default).
       * In Linux containers, this means setting the FQDN in the hostname field of the kernel
       * (the nodename field of struct utsname).
       * In Windows containers, this means setting the registry value of hostname for the registry key
       * HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters to FQDN.
       * If a pod does not have FQDN, this has no effect.
       *
       * @defaultValue false
       */
      setHostnameAsFQDN?: boolean;
      /**
       * Share a single process namespace between all of the containers in a pod.
       * When this is set containers will be able to view and signal processes from other containers in the same pod,
       * and the first process in each container will not be assigned PID 1.
       * HostPID and ShareProcessNamespace cannot both be set.
       *
       * @defaultValue false
       */
      shareProcessNamespace: boolean;
      /**
       *  If specified, the fully qualified Pod hostname will be "\<hostname\>.\<subdomain\>.\<pod namespace\>.svc.\<cluster domain\>".
       *  If not specified, the pod will not have a domainname at all.
       */
      subdomain?: string;
      /**
       * Optional duration in seconds the pod needs to terminate gracefully.
       *
       * May be decreased in delete request. Value must be non-negative integer.
       * The value zero indicates delete immediately. If this value is nil, the default
       * grace period will be used instead. The grace period is the duration in seconds
       * after the processes running in the pod are sent a termination signal and the time
       * when the processes are forcibly halted with a kill signal. Set this value longer
       * than the expected cleanup time for your process. Defaults to 30 seconds.
       */
      terminationGracePeriodSeconds?: number;
      /** If specified, the pod's tolerations. */
      tolerations?: Toleration[];
      /**
       *  TopologySpreadConstraints describes how a group of pods ought to spread across topology domains.
       *
       *  Scheduler will schedule pods in a way which abides by the constraints. All topologySpreadConstraints are ANDed.
       */
      topologySpreadConstraints?: TopologySpreadConstraint[];
      /**
       * List of volumes that can be mounted by containers belonging to the pod.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/storage/volumes}
       */
      volumes?: Volume[];
  }/**
   * Component for Kubernetes Pods
   *
   * @public
   */
  export declare class Pod extends DeferredComponent<PodProps, ResolvedVolumes & ResolvedServiceAccountName> {
      static defaultProps: {
          isTemplate: boolean;
          metadata: {};
          dnsPolicy: string;
          enableServiceLinks: boolean;
          hostIPC: boolean;
          hostPID: boolean;
          restartPolicy: string;
          securityContext: {};
          shareProcessNamespace: boolean;
          terminationGracePeriodSeconds: number;
      };
      initialState(): {};
      build(helpers: BuildHelpers): Adapt.JSX.Element | null;
      status(_observe: ObserveForStatus, buildData: BuildData): Promise<Adapt.Status | undefined>;
  }/**
   * Spec for for Kubernetes Pods
   *
   * @public
   */
  export declare interface PodSpec extends Omit<PodProps, "config" | "metadata" | "isTemplate"> {
      containers: ContainerSpec[];
      terminationGracePeriodSeconds?: number;
  }/** @internal */
  const podResourceInfo: {
      kind: string;
      deployedWhen: typeof deployedWhen;
      statusQuery: (props: ResourcePropsWithConfig, observe: ObserveForStatus, buildData: BuildData) => Promise<any>;
  };/**
   * k8s Secret resource
   *
   * @param propsIn - props for Secret as specifed in {@link k8s.SecretProps}
   *
   * @public
   */
  export declare function Secret(propsIn: SFCDeclProps<SecretProps, typeof defaultProps>): Adapt.JSX.Element;/** @internal */
  const secretResourceInfo: {
      kind: string;
      deployedWhen: () => true;
      statusQuery: (props: ResourcePropsWithConfig, observe: ObserveForStatus, buildData: BuildData) => Promise<any>;
      makeManifest: (manifest: Manifest, elem: AdaptElement<ResourceProps>, _deployID: string) => {
          data: {
              [key: string]: string;
          } | undefined;
          stringData: {
              [key: string]: string;
          } | undefined;
          type: string | undefined;
          apiVersion: string; /**
           * stringData allows specifying non-binary secret data in string form.
           *
           * It is provided as a write-only convenience method. All keys and values are merged into the data field on write,
           * overwriting any existing values. It is never output when reading from the API.
           */
          kind: string;
          metadata: import("./manifest_support").MetadataInRequest;
          spec?: import("./DaemonSet").DaemonSetSpec | import("./common").CRSpec | import("./Pod").PodSpec | import("./Service").ServiceSpec | import("./Deployment").DeploymentSpec | undefined;
      };
  };/**
   * Convert {@link NetworkService} props to {@link k8s.Service} props
   * @param abstractProps - props to convert
   * @returns Kubernetes spec corresponding to `abstractProps`
   *
   * @internal
   */
  export declare function k8sServiceProps(abstractProps: NetworkServiceProps & BuiltinProps): Omit<ServiceProps, keyof ResourceBase>;/**
   * Native Kubernetes Service resource
   *
   * @remarks
   *
   * Implements the {@link NetworkServiceInstance} interface.
   *
   * @public
   */
  export declare function Service(propsIn: SFCDeclProps<ServiceProps, typeof defaultProps>): Adapt.JSX.Element;/** @public */
  export declare interface ServiceProps extends ServiceSpec {
      /** Legal configuration loaded from kubeconfig */
      config: ClusterInfo;
      metadata?: Metadata;
      selector?: Handle | EndpointSelector;
  }/** @public */
  export declare interface ServiceSpec {
      /**
       * Cluster IP for a {@link k8s.Service}
       *
       * @remarks
       * `clusterIP` is the IP address of the service and is usually assigned
       * randomly by the master. If an address is specified manually and is not
       * in use by others, it will be allocated to the service; otherwise,
       * creation of the service will fail. This field can not be changed through
       * updates. Valid values are "None", empty string (""), or a valid IP
       * address. "None" can be specified for headless services when proxying is
       * not required. Only applies to types ClusterIP, NodePort, and
       * LoadBalancer. Ignored if type is ExternalName.
       *
       * For more information, see the
       * {@link https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies |
       * Kubernetes documentation}.
       */
      clusterIP?: string;
      /**
       * A list of IP addresses for which nodes in the cluster
       * will also accept traffic for this service.
       *
       * @remarks
       * These IPs are not managed by
       * Kubernetes. The user is responsible for ensuring that traffic arrives at
       * a node with this IP. A common example is external load balancers that are
       * not part of the Kubernetes system.
       */
      externalIPs?: string[];
      /**
       * The external reference that kubedns or equivalent
       * will return as a CNAME record for this service.
       *
       * @remarks
       * No proxying will be involved. Must be a
       * {@link https://tools.ietf.org/html/rfc1123 | valid RFC-1123 hostname}
       * and requires Type to be ExternalName.
       */
      externalName?: string;
      /**
       * Denotes if this Service desires to route
       * external traffic to node-local or cluster-wide endpoints.
       *
       * @remarks
       * "Local" preserves the client source IP and avoids a second hop for
       * LoadBalancer and Nodeport type services, but risks potentially
       * imbalanced traffic spreading. "Cluster" obscures the client source IP
       * and may cause a second hop to another node, but should have good overall
       * load-spreading.
       */
      externalTrafficPolicy?: string;
      /**
       * Specifies the healthcheck nodePort for the service.
       *
       * @remarks
       * If not specified, HealthCheckNodePort is created by the service
       * api backend with the allocated nodePort. Will use user-specified nodePort
       * value if specified by the client. Only affects when Type is set to
       * LoadBalancer and ExternalTrafficPolicy is set to Local.
       */
      healthCheckNodePort?: number;
      /**
       * Only applies to Service Type: LoadBalancer. LoadBalancer will
       * get created with the IP specified in this field.
       *
       * @remarks
       * This feature depends on
       * whether the underlying cloud provider supports specifying the loadBalancerIP
       * when a load balancer is created. This field will be ignored if the
       * cloud provider does not support the feature.
       */
      loadBalancerIP?: string;
      /**
       * If specified and supported by the platform, this will
       * restrict traffic through the cloud provider load balancer
       * to the specified client IPs.
       *
       * @remarks
       * This field will be ignored if the cloud provider
       * does not support the feature.
       *
       * For more information, see the
       * {@link https://v1-17.docs.kubernetes.io/docs/tasks/access-application-cluster/configure-cloud-provider-firewall/ |
       * Kubernetes documentation}.
       */
      loadBalancerSourceRanges?: string[];
      /**
       * The list of ports that are exposed by this service.
       *
       * @remarks
       * For more information, see the
       * {@link https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies |
       * Kubernetes documentation}.
       */
      ports?: ServicePort[];
      /**
       * When set to true, indicates that
       * DNS implementations must publish the notReadyAddresses of subsets for the
       * Endpoints associated with the Service.
       *
       * @remarks
       * The default value is false. The
       * primary use case for setting this field is to use a StatefulSet's Headless
       * Service to propagate SRV records for its Pods without respect to their
       * readiness for purpose of peer discovery.
       */
      publishNotReadyAddresses?: boolean;
      /**
       * Route service traffic to pods with label keys and values
       * matching this selector.
       *
       * @remarks
       * If empty or not present, the service is assumed to
       * have an external process managing its endpoints, which Kubernetes will not
       * modify. Only applies to types ClusterIP, NodePort, and LoadBalancer.
       * Ignored if type is ExternalName.
       *
       * For more information, see the
       * {@link https://kubernetes.io/docs/concepts/services-networking/service/ |
       * Kubernetes documentation}.
       */
      selector?: EndpointSelector | object;
      /**
       * Used to maintain session affinity.
       *
       * @remarks
       * Possible values are:
       *
       * - `"ClientIP"`: Enables client IP based session affinity.
       *
       * - `"None"`: Disables session affinity.
       *
       * For more information, see the
       * {@link https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies |
       * Kubernetes documentation}.
       * @defaultValue `"None"`
       */
      sessionAffinity?: string;
      /**
       * Determines how the Service is exposed.
       *
       * @remarks
       * Valid options are:
       *
       * - `"ExternalName"`: maps to the specified externalName.
       *
       * - `"ClusterIP"`: allocates a cluster-internal IP address for load
       * balancing to endpoints. Endpoints are determined by the selector or if
       * that is not specified, by manual construction of an Endpoints object. If
       * clusterIP is "None", no virtual IP is allocated and the endpoints are
       * published as a set of endpoints rather than a stable IP.
       *
       * - `"NodePort"`: Builds on ClusterIP and allocates a port on every node
       * which routes to the clusterIP.
       *
       * - `"LoadBalancer"`: Builds on NodePort and creates an external load
       * balancer (if supported in the current cloud) which routes to the
       * clusterIP.
       *
       * For more information, see the
       * {@link https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services---service-types |
       * Kubernetes documentation}.
       * @defaultValue `"ClusterIP"`
       */
      type?: string;
  }/** @public */
  export declare interface ServicePort {
      /**
       * The name of this port within the service.
       *
       * @remarks
       * This must be a DNS_LABEL.
       * All ports within a ServiceSpec must have unique names.This maps to the
       * Name' field in EndpointPort objects. Optional if only one ServicePort is
       * defined on this service.
       */
      name?: string;
      /**
       * The port on each node on which this service is exposed when
       * type=NodePort or LoadBalancer.
       *
       * @remarks
       * Usually assigned by the system. If
       * specified, it will be allocated to the service if unused or else creation
       * of the service will fail.
       *
       * For more information, see the
       * {@link https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport |
       * Kubernetes documentation}.
       * @defaultValue Automatically allocates a port if the ServiceType of this
       * Service requires one.
       */
      nodePort?: number;
      /** The port that will be exposed by this service. */
      port?: number;
      /** The IP protocol for this port.Supports "TCP" and "UDP".Default is TCP. */
      protocol?: string;
      /**
       * Number or name of the port to access on the pods targeted by the
       * service.
       *
       * @remarks
       * Number must be in the range 1 to 65535. Name must be an
       * IANA_SVC_NAME. If this is a string, it will be looked up as a named port
       * in the target Pod's container ports. If this is not specified, the value
       * of the 'port' field is used (an identity map). This field is ignored for
       * services with clusterIP = None, and should be omitted or set equal to the
       * 'port' field.
       *
       * For more information, see the
       * {@link https://kubernetes.io/docs/concepts/services-networking/service/#defining-a-service |
       * Kubernetes documentation}.
       */
      targetPort?: number | string;
  }/** @internal */
  const serviceResourceInfo: {
      kind: string;
      deployedWhen: typeof deployedWhen;
      statusQuery: (props: ResourcePropsWithConfig, observe: ObserveForStatus, buildData: BuildData) => Promise<any>;
  };/**
   * k8s ServiceAccount resource
   *
   * @param propsIn - props for ServiceAccount as specifed in {@link k8s.ServiceAccountProps}
   *
   * @public
   */
  export declare function ServiceAccount(propsIn: SFCDeclProps<ServiceAccountProps, typeof defaultProps>): Adapt.JSX.Element;/** @public */
  export declare function isServiceAccountProps(p: ResourceProps): p is ResourceProps & ResourceServiceAccount;/** @internal */
  const serviceAccountResourceInfo: {
      kind: string;
      deployedWhen: () => true;
      statusQuery: (props: ResourcePropsWithConfig, observe: ObserveForStatus, buildData: BuildData) => Promise<any>;
      makeManifest: (manifest: Manifest, elem: AdaptElement<ResourceProps>, _deployID: string) => {
          automountServiceAccountToken: boolean | undefined;
          imagePullSecrets: {
              name: string;
          }[] | undefined;
          secrets: ObjectReference[] | undefined;
          apiVersion: string;
          kind: string;
          metadata: import("./manifest_support").MetadataInRequest;
          spec?: import("./DaemonSet").DaemonSetSpec | import("./common").CRSpec | import("./Pod").PodSpec | import("./Service").ServiceSpec | import("./Deployment").DeploymentSpec | undefined;
      };
  };/**
   * Props for {@link k8s.ServiceDeployment}
   *
   * @public
   */
  export declare interface ServiceDeploymentProps<T extends AllowableComponentProps = DeploymentProps> extends ServiceProps {
      config: ClusterInfo;
      serviceProps?: Partial<ServiceProps>;
      component: ComponentType<T>;
      componentProps: T;
      podProps?: Partial<PodProps>;
      containerProps?: Partial<OmitT<K8sContainerProps, "image">>;
  }/**
   * A component for mapping a group of abstract {@link Container}s and
   * {@link NetworkService}s to Kubernetes {@link k8s.Pod}s and
   * {@link k8s.K8sContainer}s.
   *
   * @remarks
   * This component is intended to be used to replace {@link Container} and
   * {@link NetworkService} components that are grouped together, as the
   * only children of a common parent in a pattern that looks like this:
   *
   * ```tsx
   * <Service>
   *   <Container ... />
   *   <Container ... />
   *   <NetworkService ... />
   * </Service>
   * ```
   *
   * `ServiceDeployment` would map those abstract components into corresponding
   * k8s components like this:
   * ```tsx
   * <Group>
   *   <docker.RegistryDockerImage ... /> //If props.config specifies a registry
   *   <k8s.Deployment ... >
   *     <Pod isTemplate>
   *       <k8s.K8sContainer ... />
   *     </Pod>
   *   </k8s.Deployment>
   *   <docker.RegistryDockerImage ... /> //If props.config specifies a registry
   *   <k8s.Deployment ... >
   *     <Pod isTemplate>
   *       <k8s.K8sContainer ... />
   *     </Pod>
   *   </k8s.Pod>
   *   <k8s.Service ... />
   * </Group>
   * ```
   * An example style rule to do this is:
   * ```tsx
   * {Adapt.rule((matchedProps) => {
   *     const { handle, ...remainingProps } = matchedProps;
   *     return <ServiceDeployment config={kubeconfig} {...remainingProps} />;
   * })}
   * ```
   * `ServiceDeployment` also requires the `config` prop which specifies
   * connection and authentication information for the Kubernetes cluster on
   * which these objects should be created.
   *
   * @public
   */
  export declare class ServiceDeployment<T extends AllowableComponentProps> extends DeferredComponent<ServiceDeploymentProps<T>> {
      static defaultProps: {
          component: typeof Deployment;
          componentProps: {
              replicas: number;
          };
      };
      build(helpers: BuildHelpers): Adapt.JSX.Element;
  }/** @public */
  export declare function computeNamespaceFromMetadata(metadata?: Metadata): string;/** @public */
  export declare function isLabelSelector(x: any): x is LabelSelector;/**
   * Kubernetes Kind
   *
   * @public
   */
  export declare type Kind = string;/** @public */
  export declare interface CRSpec {
      [key: string]: any;
  }/** @public */
  export declare type Spec = DaemonSetSpec | DeploymentSpec | PodSpec | ServiceSpec | CRSpec;/** @public */
  export declare interface Metadata {
      namespace?: string;
      labels?: {
          [key: string]: string;
      };
      annotations?: {
          [key: string]: string;
      };
  }/** @public */
  export declare type ResourceProps = {
      key: string;
  } & (ResourceClusterRole | ResourceClusterRoleBinding | ResourceDaemonSet | ResourcePod | ResourceService | ResourceServiceAccount | ResourceConfigMap | ResourceSecret | ResourceCR);/** @public */
  export declare type ResourcePropsWithConfig = ResourceProps & {
      config: ClusterInfo;
  };/** @public */
  export declare interface ResourceInfo {
      kind: Kind;
      statusQuery?: (props: ResourceProps, observe: ObserveForStatus, buildData: BuildData) => unknown | Promise<unknown>;
      specsEqual(actual: Spec, element: Spec): boolean;
  }/**
   * Holds the information needed to connect, authenticate, and run code in a kuberenetes cluster
   *
   * @public
   */
  export declare interface ClusterInfo {
      /** Javascript object formed by parsing a valid kubeconfig file */
      kubeconfig: Kubeconfig;
      /**
       * Registry to which Docker images used by the cluster in `kubeconfig` should be pushed and pulled
       *
       * @remarks
       * If `registryPrefix` is a string, it is assumed that the cluster can pull from the same string
       * that outsiders can push to.
       *
       * If `registryPrefix` is of the form `{ external: string, internal: string }` then the `external`
       * string will be used to push images, and the `internal` string will be used to pull images.
       *
       * Note(manishv)
       * This is a bit of a hack to allow one hostname or IP address to push images from outside
       * a particular environment (say k8s) and a different URL for that environment to pull
       * images.
       *
       * A good example of this is a k3s-dind (k3s docker-in-docker) instance of kubernetes where
       * a private registry is running on a docker network attached to the k3s-dind instance, but where we
       * want to push {@link docker.LocalDockerImage} built images to that registry.  Since
       * {@link docker.LocalDockerImage | LocalDockerImage} is outside the k3s-dind environment, it must
       * use a host accessible network to push to the registry.  However, since the k3s-dind instance sees
       * the registry from within Docker, it must use a different address to pull the images for use.
       *
       * Once network scopes are fully supported, this interface will change to whatever is appropriate.  It
       * is best if you can arrange to have the same URL or registry string work for all access regardless
       * of which network the registry, Adapt host, and ultimate container running environment uses.
       *
       */
      registryPrefix?: string | DockerSplitRegistryInfo;
  }/** @public */
  export declare interface ResourceBase {
      /**
       * config to connect to the k8s cluster
       *
       * required if isTemplate is false
       */
      config?: ClusterInfo;
      /**
       * Specifies whether this resource is just a template for use in a controller
       */
      isTemplate?: boolean;
      apiVersion?: string;
      kind: Kind;
      metadata?: Metadata;
  }/**
   * @public
   */
  export declare interface PolicyRule {
      /**
       * APIGroups is the name of the APIGroup that contains the resources.
       *
       * If multiple API groups are specified, any action requested against one
       * of the enumerated resources in any API group will be allowed.
       */
      apiGroups?: string[];
      /**
       * NonResourceURLs is a set of partial urls that a user should have access to.
       *
       * *s are allowed, but only as the full, final step in the path.
       * Since non-resource URLs are not namespaced, this field is only applicable
       * for ClusterRoles referenced from a ClusterRoleBinding.
       * Rules can either apply to API resources (such as "pods" or "secrets") or
       * non-resource URL paths (such as "/api"), but not both.
       */
      nonResourceURLs?: string[];
      /**
       * ResourceNames is an optional white list of names that the rule applies to.
       *
       * An empty set means that everything is allowed.
       */
      resourceNames?: string[];
      /**
       * Resources is a list of resources this rule applies to.
       *
       * ResourceAll represents all resources.
       */
      resources: string[];
      /**
       * Verbs is a list of Verbs that apply to ALL the ResourceKinds and
       * AttributeRestrictions contained in this rule.
       *
       * VerbAll represents all kinds.
       */
      verbs: string[];
  }/**
   * AggregationRule for {@link k8s.ClusterRole}
   *
   * @public
   */
  export declare interface AggregationRule {
      /**
       * ClusterRoleSelectors holds a list of selectors which will be used to
       * find ClusterRoles and create the rules.
       *
       * If any of the selectors match, then the ClusterRole's permissions will be added
       */
      clusterRoleSelector: LabelSelector;
  }/** @public */
  export declare interface ResourceClusterRole extends ResourceBase {
      apiVersion: "rbac.authorization.k8s.io/v1";
      kind: "ClusterRole";
      aggregationRule?: AggregationRule;
      rules?: PolicyRule[];
  }/**
   * RoleRef for {@link k8s.ResourceClusterRoleBinding}
   *
   * @public
   */
  export declare interface RoleRef {
      /** apiGroup is the group for the resource being referenced */
      apiGroup: string;
      /** kind is the type of resource being referenced */
      kind: string;
      /** Name is the name of resource being referenced */
      name: string;
  }/**
   * Subject for {@link k8s.ResourceClusterRoleBinding}
   *
   * @public
   */
  export declare interface Subject {
      /** apiGroup is the group for the object being referenced */
      apiGroup: string;
      /** kind is the type of object being referenced */
      kind: string;
      /**
       * Name of the object being referenced.
       */
      name: string;
      /**
       * Namespace of the referenced object.
       *
       * If the object kind is non-namespace, such as "User" or "Group", and this value
       * is not empty the Authorizer should report an error.
       */
      namespace?: string;
  }/** @public */
  export declare interface ResourceClusterRoleBinding extends ResourceBase {
      apiVersion: "rbac.authorization.k8s.io/v1";
      kind: "ClusterRoleBinding";
      roleRef: RoleRef;
      subjects: Subject[];
  }/** @public */
  export declare interface ResourceDaemonSet extends ResourceBase {
      apiVersion: "apps/v1";
      kind: "DaemonSet";
      spec: DaemonSetSpec;
  }/** @public */
  export declare interface ResourcePod extends ResourceBase {
      kind: "Pod";
      spec: PodSpec;
  }/** @public */
  export declare interface ResourceService extends ResourceBase {
      kind: "Service";
      spec: ServiceSpec;
  }/** @public */
  export declare interface ResourceServiceAccount extends ResourceBase {
      kind: "ServiceAccount";
      automountServiceAccountToken?: boolean;
      imagePullSecrets?: {
          name: string;
      }[];
      secrets?: ObjectReference[];
  }/** @public */
  export declare interface ResourceConfigMap extends ResourceBase {
      kind: "ConfigMap";
      binaryData?: {
          [key: string]: string;
      };
      data?: {
          [key: string]: string;
      };
      /** @beta */
      immutable?: boolean;
  }/** @public */
  export declare interface ResourceSecret extends ResourceBase {
      kind: "Secret";
      data?: {
          [key: string]: string;
      };
      stringData?: {
          [key: string]: string;
      };
      type?: string;
  }/** @public */
  export declare interface ResourceCR extends ResourceBase {
      kind: string;
      spec: CRSpec;
  }/** @public */
  export declare interface Kubeconfig {
      apiVersion?: "v1";
      kind: "Config";
      "current-context": string;
      contexts: {
          name: string;
          context: {
              cluster: string;
              user: string;
          };
      }[];
      clusters: {
          name: string;
          cluster: {
              "certificate-authority-data": string;
              server: string;
          };
      }[];
      preferences?: unknown;
      users: {
          name: string;
          user: {
              "client-certificate-data"?: string;
              "client-key-data"?: string;
              "username"?: string;
              "password"?: string;
          };
      }[];
  }/** @public */
  export declare interface LabelSelector {
      /**
       * matchExpressions is a list of label selector requirements. The requirements are ANDed.
       */
      matchExpressions?: LabelSelectorRequirement[];
      /**
       * matchLabels is a map of `{key,value}`pairs. A single `{key,value}` in the matchLabels map
       * is equivalent to an element of matchExpressions, whose key field is "key", the operator
       * is "In", and the values array contains only "value". The requirements are ANDed.
       */
      matchLabels?: {
          [key: string]: string;
      };
  }/** @public */
  export declare interface LocalObjectReference {
      /**
       * Name of the referent.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names}
       */
      name: string;
  }/**
   * PodTemplateSpec from k8s API
   *
   * @public
   */
  export declare interface PodTemplateSpec {
      /**
       * Standard object's metadata.
       * More Info: {@link https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata}
       */
      metadata: Metadata;
      /**
       * Specification of the desired behavior of the pod.
       * More Info: {@link https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status}
       */
      spec: PodSpec;
  }/**
   * ObjectReference from k8s API
   *
   * @public
   */
  export declare interface ObjectReference {
      /**
       * If referring to a piece of an object instead of an entire object,
       * this string should contain a valid JSON/Go field access statement,
       * such as desiredState.manifest.containers[2].
       *
       * For example, if the object reference is to a container within a pod,
       * this would take on a value like: "spec.containers\{name\}" (where "name"
       * refers to the name of the container that triggered the event) or if no
       * container name is specified "spec.containers[2]"
       * (container with index 2 in this pod).
       * This syntax is chosen only to have some well-defined way of referencing a
       * part of an object.
       */
      fieldPath: string;
      /**
       * Name of the referent.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names}
       *
       */
      name: string;
      /**
       * Namespace of the referent.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/}
       */
      namespace: string;
      /**
       * Specific resourceVersion to which this reference is made, if any.
       *
       * More info: {@link https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency}
       */
      resourceVersion: string;
      /**
       * UID of the referent.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids}
       */
      uid: string;
  }/**
   * Make a {@link k8s.ClusterInfo} object suitable for use with k8s resources
   *
   * @remarks
   *
   * This function will take a set of options and generate a {@link k8s.ClusterInfo}
   * object that contains the kubeconfig, registryPrefix for private images, and any other
   * relevant information for the cluster
   *
   * See {@link k8s.MakeClusterInfoOptions} for information on how the information
   * is computed.
   *
   * @returns A {@link k8s.ClusterInfo} object.
   *
   * @public
   */
  export declare function makeClusterInfo(options: MakeClusterInfoOptions): Promise<ClusterInfo>;/** @internal */
  export declare function isResourcePodTemplate(x: any): x is AdaptElement<ResourcePod>;/**
   * Hook that allows a prop to be either an array of handle to k8s resources and values
   *
   * @param initial - initial value of the prop, before the handles are be resolved
   * @param notReady - is a marker value to indicate that a handle's value isn't available yet
   * @param kinds - an array of legal k8s Kinds that a prop handle can point to
   * @param thisResourceName - the name of the resource using the hook, for error messages
   * @param propName - the name of the prop being resolved, again for error messages
   *
   * @returns A two element array, the first element is the current value, the second the update function
   *
   * This hook will start by returning the initial value and an update function that updates
   * the value the hook returns.  The update function takes 2 arguments - the prop value which
   * is an array with a mix of values and handles to be resolved, and a function that receives
   * the elements that any handles point to along with that elements props.  This function
   * can be passed by the caller of update to resolve handles as appropriate for the component.
   *
   * For example, {@link k8s.ClusterRoleBinding} uses this hook to resolve the subjects prop,
   * which is an array of other objects (typically {@link ServiceAccount}) that a particular
   * {@link k8s.ClusterRole} should point to.  When ClusterRoleBinding calls the update method,
   * it passes a function that will convert a {@link k8s.Resource} element of Kind `ServiceAccount`
   * to the underlying `Subject` object that kubernetes expects, namely
   * `{ apiGroup: "", kind: "ServiceAccount", name: resourceIdToName(elem, deployID), namespace: <element namespace> }`
   *
   * @example
   * ```
   * function MyResource({ serviceAccountNames }: { serviceAccountNames: (string | Handle)[]}) {
   *   const { deployID } = useBuildHelpers();
   *   const [ resolvedServiceAccountNames, updateSANs] = useResources({
   *      initial: [],
   *      notReady: null,
   *      kinds: ["ServiceAccount"],
   *      thisResourceName: "MyResources",
   *      propName: "serviceAccountNames",
   *   });
   *
   *   updateSANs(serviceAccountNames, (e, props) => {
   *      return {
   *        apiGroup: (e.metadata.apiVersion?.split("/")[0]) || "",
   *        name: resourceElementToName(e, deployID),
   *        namespace: props.metadata.namespace,
   *      }
   *   });
   *
   *   return null;
   * }
   * ```
   *
   * @beta
   */
  export declare function useResources<ValT, NotReadyT>({ initial, notReady, kinds, thisResourceName, propName, }: {
      initial: ValT[];
      notReady: NotReadyT;
      kinds: string[];
      thisResourceName: string;
      propName: string;
  }): [
      (ValT | NotReadyT)[],
      (props: (ValT | Handle)[], f: (e: AdaptMountedElement, props: ResourceProps) => Promise<ValT> | ValT) => void
  ];/**
   * Hook to allow conversion of a prop that could be a value or a handle
   *
   * This function behaves similarly to {@link k8s.useResources}, but works for
   * a prop that is either a Handle or a single value instead of an array of
   * Handles and values.
   *
   * See {@link k8s.useResources} for more detailed documentation.
   *
   * @beta
   */
  export declare function useResource<ValT, NotReadyT>(opts: {
      initial: ValT | NotReadyT;
      notReady: NotReadyT;
      kinds: string[];
      thisResourceName: string;
      propName: string;
  }): [
      ValT | NotReadyT,
      (prop: ValT | Handle, f: (e: AdaptMountedElement, props: ResourceProps) => Promise<ValT> | ValT) => void
  ];/**
   * Options for {@link k8s.makeClusterInfo}
   *
   * @public
   */
  export declare interface MakeClusterInfoOptions {
      /**
       * A Javascript Object representing a valid kubeconfig, or a YAML string, or a path to a kubeconfig file.
       *
       * @remarks
       * If this is a Javascript object, it will be treated like a parsed kubeconfig.  If this is a string,
       * {@link k8s.makeClusterInfo} will first attempt to parse it as JSON.  If that fails, it will attempt
       * to parse it as YAML.  If that fails it will treat the string as a path of configs (like with the `KUBECONFIG`
       * environment variable).
       *
       * If kubeconfig is missing {@link k8s.makeClusterInfo} will use the `KUBECONFIG` environment variable to build
       * a suitable config using `kubectl config view --flatten` and return that as the kubeconfig in the resulting
       * {@link k8s.ClusterInfo}
       */
      kubeconfig?: Kubeconfig | string;
      /**
       * URL to the docker registry that this cluster uses to pull private images.
       *
       * @remarks
       * This is identical to the `registryPrefix` field in {@link k8s.ClusterInfo}.  It will
       * be returned verbatim in the resulting {@link k8s.ClusterInfo} object.
       */
      registryPrefix?: string | DockerSplitRegistryInfo;
  }/**
   * k8s ClusterRole resource
   *
   * @param propsIn - props for ServiceAccount as specifed in {@link k8s.ClusterRoleProps}
   *
   * @public
   */
  export declare function ClusterRole(propsIn: SFCDeclProps<ClusterRoleProps, typeof defaultProps>): Adapt.JSX.Element;/** @public */
  export declare function isClusterRoleProps(props: ResourceProps): props is ResourceProps & ResourceClusterRole;/** @internal */
  const clusterRoleResourceInfo: {
      kind: string;
      deployedWhen: () => true;
      statusQuery: (props: ResourcePropsWithConfig, observe: ObserveForStatus, buildData: BuildData) => Promise<any>;
      makeManifest: (manifest: Manifest, elem: AdaptElement<ResourceProps>, _deployID: string) => {
          aggregationRule: AggregationRule | undefined;
          rules: PolicyRule[] | undefined;
          apiVersion: string;
          kind: string;
          metadata: import("./manifest_support").MetadataInRequest;
          spec?: import("./DaemonSet").DaemonSetSpec | import("./common").CRSpec | import("./Pod").PodSpec | import("./Service").ServiceSpec | import("./Deployment").DeploymentSpec | undefined;
      };
  };/**
   * k8s ClusterRoleBinding resource
   *
   * @param propsIn - props for ServiceAccount as specifed in {@link k8s.ClusterRoleBindingProps}
   *
   * @public
   */
  export declare function ClusterRoleBinding(propsIn: SFCDeclProps<ClusterRoleBindingProps, typeof defaultProps>): Adapt.JSX.Element | null;/** @internal */
  const clusterRoleBindingResourceInfo: {
      kind: string;
      deployedWhen: () => true;
      statusQuery: (props: ResourcePropsWithConfig, observe: ObserveForStatus, buildData: BuildData) => Promise<any>;
      makeManifest: (manifest: Manifest, elem: AdaptElement<ResourceProps>, _deployID: string) => {
          roleRef: RoleRef;
          subjects: Subject[];
          apiVersion: string;
          kind: string;
          metadata: import("./manifest_support").MetadataInRequest;
          spec?: import("./DaemonSet").DaemonSetSpec | import("./common").CRSpec | import("./Pod").PodSpec | import("./Service").ServiceSpec | import("./Deployment").DeploymentSpec | undefined;
      };
  };/**
   * k8s ConfigMap resource
   *
   * @param propsIn - props for ConfigMap as specifed in {@link k8s.ConfigMapProps}
   *
   * @public
   */
  export declare function ConfigMap(propsIn: SFCDeclProps<ConfigMapProps, typeof defaultProps>): Adapt.JSX.Element;/** @internal */
  const configMapResourceInfo: {
      kind: string;
      deployedWhen: () => true;
      statusQuery: (props: ResourcePropsWithConfig, observe: ObserveForStatus, buildData: BuildData) => Promise<any>;
      makeManifest: (manifest: Manifest, elem: AdaptElement<ResourceProps>, _deployID: string) => {
          data: {
              [key: string]: string;
          } | undefined;
          binaryData: {
              [key: string]: string;
          } | undefined;
          immutable: boolean | undefined;
          apiVersion: string;
          kind: string;
          metadata: import("./manifest_support").MetadataInRequest;
          spec?: import("./DaemonSet").DaemonSetSpec | import("./common").CRSpec | import("./Pod").PodSpec | import("./Service").ServiceSpec | import("./Deployment").DeploymentSpec | undefined;
      };
  };/**
   * Low level utility function to translate from the abstract {@link Container}
   * component props ({@link ContainerProps}) to {@link k8s.K8sContainerProps}
   * to be used in a {@link k8s.K8sContainer}.
   * @remarks
   * Note: The `image` property in the passed in {@link ContainerProps} must
   * be a `string`, not a `Handle`.
   * In most cases, it is preferable to use the {@link k8s.Container} component
   * instead, which is designed specifically to deal with this issue.
   *
   * @param abstractProps - The abstract {@link ContainerProps} to translate from.
   * @param k8sProps - Props that are specific to the {@link k8s.K8sContainer}
   *     component that should be merged into the resulting returned
   *     {@link k8s.K8sContainerProps} object.
   * @public
   */
  export declare function k8sContainerProps(abstractProps: FromContainerProps, k8sProps?: Partial<K8sContainerProps>): K8sContainerProps;/**
   * Tests whether an element is a {@link k8s.K8sContainer} element
   * @param x - element to test
   * @returns `true` if element is a {@link k8s.K8sContainer}, `false` otherwise
   *
   * @remarks
   * Acts as a TypeScript type assertion that will assert that `x` is `AdaptElement<K8sContainerProps>`
   *
   * @public
   */
  export declare function isK8sContainerElement(x: AdaptElement): x is AdaptElement<K8sContainerProps>;/**
   * Component that implements the abstract {@link Container} interface and
   * translates to a Kubernetes-specific {@link k8s.K8sContainer}.
   * @public
   */
  export declare function Container(props: ContainerProps): Adapt.JSX.Element | null;/** @public */
  export declare interface VolumeMount {
      /**
       * Path within the container at which the volume should be mounted.
       *
       * Must not contain ':'.
       */
      mountPath: string;
      /**
       * mountPropagation determines how mounts are propagated from the host to container and the other way around.
       *
       * When not set, MountPropagationNone is used. This field is beta in 1.10.
       *
       * @defaultValue MountPropagationNone
       */
      mountPropagation?: string;
      /** This must match the Name of a Volume. */
      name: string;
      /**
       * Mounted read-only if true, read-write otherwise (false or unspecified).
       *
       * @defaultValue false
       */
      readOnly?: boolean;
      /**
       * Path within the volume from which the container's volume should be mounted.
       *
       * Defaults to "" (volume's root).
       *
       * @defaultValue ""
       */
      subPath?: string;
      /**
       * Expanded path within the volume from which the container's volume should be mounted.
       *
       * Behaves similarly to SubPath but environment variable references $(VAR_NAME)
       * are expanded using the container's environment.
       *
       * Defaults to "" (volume's root).
       *
       * SubPathExpr and SubPath are mutually exclusive.
       *
       * @defaultValue ""
       */
      subPathExpr?: string;
  }/** @public */
  export declare interface ConfigMapEnvSource {
      /**
       * Name of the referent.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names}
       */
      name?: string;
      /**
       * Specify whether the ConfigMap must be defined
       */
      optional?: boolean;
  }/** @public */
  export declare interface SecretEnvSource {
      /**
       * Name of the referent.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names}
       */
      name?: string;
      /**
       * Specify whether the Secret must be defined
       */
      optional?: boolean;
  }/** @public */
  export declare interface EnvFromSource {
      /** The ConfigMap to select from */
      configMapRef?: ConfigMapEnvSource;
      /** An optional identifier to prepend to each key in the ConfigMap. Must be a C_IDENTIFIER. */
      prefix?: string;
      /** SecretEnvSource	The Secret to select from */
      secretRef?: SecretEnvSource;
  }/** @public */
  export declare interface ExecAction {
      /**
       * Command is the command line to execute inside the container.
       *
       * The working directory for the command is root ('/') in the container's filesystem.
       * The command is simply exec'd, it is not run inside a shell,
       * so traditional shell instructions ('|', etc) won't work.
       * To use a shell, you need to explicitly call out to that shell.
       *
       * Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
       */
      command: string[];
  }/** @public */
  export declare interface HTTPGetAction {
      /**
       * Host name to connect to, defaults to the pod IP.
       *
       * You probably want to set "Host" in httpHeaders instead.
       */
      host?: string;
      /** Custom headers to set in the request. HTTP allows repeated headers. */
      httpHeaders?: {
          name: string;
          value: string;
      }[];
      /** Path to access on the HTTP server. */
      path: string;
      /**
       * Name or number of the port to access on the container.
       *
       * Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
       */
      port: number | string;
      /**
       * Scheme to use for connecting to the host.
       *
       * @defaultValue HTTP.
       */
      scheme?: string;
  }/** @public */
  export declare interface TCPSocketAction {
      /** Host name to connect to, defaults to the pod IP. */
      host?: string;
      /**
       * Number or name of the port to access on the container.
       *
       * Number must be in the range 1 to 65535.
       * Name must be an IANA_SVC_NAME.
       */
      port: string | number;
  }/** @public */
  export declare interface Probe {
      /**
       * Exec specifies the action to take.
       *
       * Only one of exec, httpGet, or tcpSocket should be specified
       */
      exec?: ExecAction;
      /**
       * Minimum consecutive failures for the probe to be considered failed after having succeeded.
       *
       * Defaults to 3. Minimum value is 1.
       *
       * @defaultValue 3
       */
      failureThreshold?: number;
      /** Specifies the http request to perform. */
      httpGet?: HTTPGetAction;
      /**
       *  Seconds after the container has started before liveness probes are initiated.
       *  More info: {@link https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes}
       */
      initialDelaySeconds?: number;
      /** How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. */
      periodSeconds?: number;
      /**
       * Minimum consecutive successes for the probe to be considered successful after having failed.
       *
       * Must be 1 for liveness and startup. Minimum value is 1.
       *
       * @defaultValue 1
       */
      successThreshold?: number;
      /**
       * Specifies an action involving a TCP port.
       *
       * TCP hooks not yet supported
       */
      tcpSocket?: TCPSocketAction;
      /**
       * Number of seconds after which the probe times out.
       *
       * Defaults to 1 second. Minimum value is 1.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes}
       *
       * @defaultValue 1
       */
      timeoutSeconds?: number;
  }/** @public */
  export declare interface ResourceRequirements {
      /**
       * Limits describes the maximum amount of compute resources allowed.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/}
       */
      limits?: {
          [key: string]: any;
      };
      /**
       * Describes the minimum amount of compute resources required.
       *
       * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
       * otherwise to an implementation-defined value.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/}
       */
      requests?: {
          [key: string]: any;
      };
  }/** @public */
  export declare type Handler = {
      exec: ExecAction;
  } | {
      httpGet: HTTPGetAction;
  } | {
      tcpSocket: TCPSocketAction;
  };/** @public */
  export declare interface Lifecycle {
      /**
       * PostStart is called immediately after a container is created.
       *
       * If the handler fails, the container is terminated and restarted according to its restart policy.
       * Other management of the container blocks until the hook completes.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks}
       */
      postStart: Handler;
      /**
       * Called immediately before a container is terminated due to an API request or management event such as liveness/startup probe failure, preemption, resource contention, etc.
       *
       * The handler is not called if the container crashes or exits.
       * The reason for termination is passed to the handler.
       * The Pod's termination grace period countdown begins before the PreStop hooked is executed.
       * Regardless of the outcome of the handler, the container will eventually terminate within the Pod's termination grace period.
       * Other management of the container blocks until the hook completes or until the termination grace period is reached.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks}
       */
      preStop: Handler;
  }/** @public */
  export declare interface VolumeDevice {
      /** The path inside of the container that the device will be mapped to. */
      devicePath: string;
      /** name must match the name of a persistentVolumeClaim in the pod */
      name: string;
  }/**
   * Resource spec for a Kubernetes container.
   * See the Kubernetes
   * {@link https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#container-v1-core | API docs }
   * for more details.
   * @public
   */
  export declare interface ContainerSpec {
      /**
       * Arguments to the entrypoint.
       *
       * The docker image's CMD is used if this is not provided.
       * Variable references $(VAR_NAME) are expanded using the container's environment.
       * If a variable cannot be resolved, the reference in the input string will be unchanged.
       * The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME).
       * Escaped references will never be expanded, regardless of whether the variable exists or not.
       * Cannot be updated.
       * More info: {@link https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell}
       */
      args?: string[];
      /**
       * Entrypoint array.
       *
       * Not executed within a shell.
       * The docker image's ENTRYPOINT is used if this is not provided.
       * Variable references $(VAR_NAME) are expanded using the container's environment.
       * If a variable cannot be resolved, the reference in the input string will be unchanged.
       * The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME).
       * Escaped references will never be expanded, regardless of whether the variable exists or not.
       * Cannot be updated.
       * More info: {@link https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell}
       */
      command?: string[];
      /**
       * List of environment variables to set in the container. Cannot be updated.
       */
      env?: EnvVar[];
      /**
       * List of sources to populate environment variables in the container.
       *
       * The keys defined within a source must be a C_IDENTIFIER.
       * All invalid keys will be reported as an event when the container is starting.
       * When a key exists in multiple sources, the value associated with the last source will take precedence.
       * Values defined by an Env with a duplicate key will take precedence. Cannot be updated.
       */
      envFrom?: EnvFromSource[];
      /**
       * Docker image name.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/containers/images}
       *
       * This field is optional to allow higher level config management to default or override container
       * images in workload controllers like Deployments and StatefulSets.
       */
      image?: string;
      /**
       * Image pull policy.
       *
       * One of Always, Never, IfNotPresent.
       * Defaults to Always if :latest tag is specified,
       * or IfNotPresent otherwise.
       * Cannot be updated.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/containers/images#updating-images}
       */
      imagePullPolicy?: "Always" | "Never" | "IfNotPresent";
      /**
       * List of sources to populate environment variables in the container.
       *
       * The keys defined within a source must be a C_IDENTIFIER.
       * All invalid keys will be reported as an event when the container is starting.
       * When a key exists in multiple sources, the value associated with the last source will take precedence.
       * Values defined by an Env with a duplicate key will take precedence. Cannot be updated.
       */
      lifecycle?: Lifecycle;
      /**
       * Periodic probe of container liveness.
       *
       * Container will be restarted if the probe fails.
       * Cannot be updated.
       * More info: {@link https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes}
       */
      livenessProbe?: Probe;
      /**
       * Name of the container specified as a DNS_LABEL.
       *
       * Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated.
       */
      name: string;
      /**
       * List of ports to expose from the container.
       *
       * Exposing a port here gives the system additional information about the network connections a container uses,
       * but is primarily informational.
       * Not specifying a port here DOES NOT prevent that port from being exposed.
       * Any port which is listening on the default "0.0.0.0" address inside a container will be accessible from
       * the network.
       * Cannot be updated.
       */
      ports?: ContainerPort[];
      /**
       * Periodic probe of container service readiness.
       *
       * Container will be removed from service endpoints if the probe fails.
       * Cannot be updated.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes}
       */
      readinessProbe?: Probe;
      /**
       * Compute Resources required by this container.
       *
       * Cannot be updated.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/}
       */
      resources?: ResourceRequirements;
      /**
       * Security options the pod should run with.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/policy/security-context/}
       * More info: {@link https://kubernetes.io/docs/tasks/configure-pod-container/security-context/}
       */
      securityContext?: PodSecurityContext;
      /**
       * Indicates that the Pod has successfully initialized.
       *
       * If specified, no other probes are executed until this completes successfully.
       * If this probe fails, the Pod will be restarted, just as if the livenessProbe failed.
       * This can be used to provide different probe parameters at the beginning of a Pod's lifecycle,
       * when it might take a long time to load data or warm a cache, than during steady-state operation.
       *
       * This cannot be updated.
       * This is a beta feature enabled by the StartupProbe feature flag.
       * More info: {@link https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes}
       */
      startupProbe?: Probe;
      /**
       * Whether this container should allocate a buffer for stdin in the container runtime.
       *
       * If this is not set, reads from stdin in the container will always result in EOF. Default is false.
       */
      stdin?: boolean;
      /**
       * Whether the container runtime should close the stdin channel after it has been opened by a single attach.
       *
       * When stdin is true the stdin stream will remain open across multiple attach sessions.
       * If stdinOnce is set to true, stdin is opened on container start,
       * is empty until the first client attaches to stdin,
       * and then remains open and accepts data until the client disconnects,
       * at which time stdin is closed and remains closed until the container is restarted.
       * If this flag is false, a container processes that reads from stdin will never receive an EOF. Default is false
       */
      stdinOnce?: boolean;
      /**
       * Path at which the file to which the container's termination message will be written is mounted into the container's filesystem.
       *
       * Message written is intended to be brief final status, such as an assertion failure message.
       * Will be truncated by the node if greater than 4096 bytes.
       * The total message length across all containers will be limited to 12kb.
       * Defaults to /dev/termination-log. Cannot be updated.
       */
      terminationMessagePath?: string;
      /**
       * Indicate how the termination message should be populated.
       *
       * File will use the contents of terminationMessagePath to populate the container status
       * message on both success and failure. FallbackToLogsOnError will use the last chunk of
       * container log output if the termination message file is empty and the container exited
       * with an error.
       * The log output is limited to 2048 bytes or 80 lines, whichever is smaller.
       * Defaults to File.
       * Cannot be updated.
       *
       * @defaultValue File
       */
      terminationMessagePolicy?: "File" | "FallbackToLogsOnError";
      /**
       * Whether this container should allocate a TTY for itself, also requires 'stdin' to be true.
       *
       * @defaultValue false
       */
      tty?: boolean;
      /**
       * volumeDevices is the list of block devices to be used by the container.
       */
      volumeDevices?: VolumeDevice[];
      /** volumeDevices is the list of block devices to be used by the container. */
      volumeMounts?: VolumeMount[];
      /**
       * Container's working directory.
       *
       * If not specified, the container runtime's default will be used,
       * which might be configured in the container image.
       * Cannot be updated.
       */
      workingDir?: string;
  }/**
   * Props for the Kubernetes-specific {@link k8s.K8sContainer} component.
   * @public
   */
  export declare interface K8sContainerProps extends ContainerSpec {
  }/** @public */
  export declare interface ContainerPort {
      /**
       * Number of port to expose on the pod's IP address.
       * @remarks
       * This must be a valid integer port number, `0 < x < 65536`.
       */
      containerPort: number;
      /** What host IP to bind the external port to. */
      hostIP?: string;
      /**
       * Number of port to expose on the host.
       * @remarks
       * If specified, this must be a valid integer port number,
       * `0 < x < 65536`. If HostNetwork is specified,
       * this must match ContainerPort. Most containers do not need this.
       */
      hostPort?: number;
      /**
       * A unique-within-pod name for the container
       * @remarks
       * If specified, this must be an IANA_SVC_NAME and unique within the pod.
       * Each named port in a pod must have a unique name. Name for the port
       * that can be referred to by services.
       */
      name?: string;
      /** Protocol for port. Must be UDP or TCP. Defaults to "TCP". */
      protocol?: string;
  }/** @public */
  export declare type EnvVar = EnvVarSimple | EnvVarFrom;/** @public */
  export declare interface EnvVarSimple {
      /** Name of the environment variable. Must be a C_IDENTIFIER. */
      name: string;
      /**
       * Variable references $(VAR_NAME) are expanded using the previous defined
       * environment variables in the container and any service environment
       * variables. If a variable cannot be resolved, the reference in the input
       * string will be unchanged. The $(VAR_NAME) syntax can be escaped with a
       * double $$, ie: $$(VAR_NAME). Escaped references will never be expanded,
       * regardless of whether the variable exists or not. Defaults to "".
       */
      value: string;
  }/** @public */
  export declare interface EnvVarFrom {
      /** Source for the environment variable's value. Cannot be used if value is not empty. */
      valueFrom?: any;
  }/**
   * See {@link k8s.k8sContainerProps}.
   * @public
   */
  export declare type FromContainerProps = ReplaceT<ContainerProps, {
      image: string;
  }> & BuiltinProps;/**
   * Kubernetes-specific container.
   * @public
   */
  export declare class K8sContainer extends PrimitiveComponent<K8sContainerProps> {
      static defaultProps: {
          imagePullPolicy: string;
      };
      validate(): undefined;
  }/**
   * Props for {@link k8s.Container}.
   * @public
   */
  export declare interface ContainerProps extends SFCDeclProps<ContainerProps> {
      /**
       * Additional {@link k8s.K8sContainerProps}-specific props that should be
       * added to the instantiated {@link k8s.K8sContainer}.
       */
      k8sContainerProps?: Partial<K8sContainerProps>;
  }/**
   * Spec for {@link k8s.DaemonSet} for use in {@link k8s.Resource}
   *
   * @public
   */
  export declare type DaemonSetSpec = Exclude<DaemonSetProps, ResourceBase> & {
      template: PodTemplateSpec;
  };/**
   * Component for Kubernetes DaemonSet
   *
   * @public
   */
  export declare class DaemonSet extends DeferredComponent<DaemonSetProps> {
      static defaultProps: {
          metadata: {};
          minReadySeconds: number;
          revisionHistoryLimit: number;
          updateStrategy: {
              type: string;
              rollingUpdate: {
                  maxUnavailable: number;
              };
          };
      };
      constructor(props: DaemonSetProps);
      build(helpers: BuildHelpers): Adapt.JSX.Element;
      status(_observe: ObserveForStatus, buildData: BuildData): Promise<Adapt.Status | undefined>;
  }/** @internal */
  const daemonSetResourceInfo: {
      kind: string;
      deployedWhen: typeof deployedWhen;
      statusQuery: (props: ResourcePropsWithConfig, observe: ObserveForStatus, buildData: BuildData) => Promise<any>;
  };/** @public */
  export declare interface DeploymentUpdateStrategyRecreate {
      type: "Recreate";
  }/** @public */
  export declare interface RollingUpdateDeployment {
      /**
       * The maximum number of pods that can be scheduled above the desired number of pods.
       *
       * Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
       * This can not be 0 if MaxUnavailable is 0.
       * Absolute number is calculated from percentage by rounding up.
       * Defaults to 25%.
       *
       * @example
       * When this is set to 30%, the new ReplicaSet can be scaled up immediately when the rolling update starts,
       * such that the total number of old and new pods do not exceed 130% of desired pods. Once old pods have been
       * killed, new ReplicaSet can be scaled up further, ensuring that total number of pods running at any time
       * during the update is at most 130% of desired pods.
       */
      maxSurge?: number | string;
      /**
       * The maximum number of pods that can be unavailable during the update.
       *
       * Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
       * Absolute number is calculated from percentage by rounding down.
       * This can not be 0 if MaxSurge is 0. Defaults to 25%.
       *
       * @example
       * When this is set to 30%, the old ReplicaSet can be scaled down to 70% of desired pods
       * immediately when the rolling update starts. Once new pods are ready, old ReplicaSet
       * can be scaled down further, followed by scaling up the new ReplicaSet, ensuring that
       * the total number of pods available at all times during the update is at least 70% of
       * desired pods.
       */
      maxUnavailable?: number | string;
  }/**
   * Spec for {@link k8s.Deployment} for use in {@link k8s.Resource}
   *
   * @public
   */
  export declare type DeploymentSpec = Exclude<DeploymentProps, ResourceBase> & {
      template: PodTemplateSpec;
  };/**
   * Props for {@link k8s.Deployment}
   *
   * @public
   */
  export declare interface DeploymentProps extends WithChildren {
      /** Information about the k8s cluster (ip address, auth info, etc.) */
      config: ClusterInfo;
      /** k8s metadata */
      metadata: Metadata;
      /**
       * The minimum number of seconds for which a newly created pod should
       * be ready without any of its container crashing, for it to be considered
       * available. Defaults to 0 (pod will be considered available as soon as it is ready).
       */
      minReadySeconds: number;
      /** Indicates that the deployment is paused */
      paused: boolean;
      /**
       * The maximum time in seconds for a deployment to make progress before it is considered to be failed.
       *
       * The deployment controller will continue to process failed deployments and a condition with a
       * ProgressDeadlineExceeded reason will be surfaced in the deployment status. Note that progress
       * will not be estimated during the time a deployment is paused. Defaults to 600s.
       */
      progressDeadlineSeconds: number;
      /**
       * Number of desired pods.
       *
       * Defaults to 1. 0 is not allowed.
       *
       * @defaultValue 1
       */
      replicas: number;
      /**
       * The number of old ReplicaSets to retain to allow rollback.
       *
       * This is a pointer to distinguish between explicit zero and not specified. Defaults to 10.
       *
       * @defaultValue 10
       */
      revisionHistoryLimit: number;
      /**
       * Label selector for pods.
       *
       * Existing ReplicaSets whose pods are selected by this will be the ones affected by this deployment.
       * It must match the pod template's labels.
       *
       * @remarks
       *
       * With Adapt, this is optional.  If not specified, adapt will pick a selector that will work with the pods
       * it creates as part of this {@link k8s.Deployment}
       */
      selector?: LabelSelector;
      /**
       * An deployment strategy to use to replace existing pods with new ones
       */
      strategy: DeploymentUpdateStrategy;
  }/**
   * Component for Kubernetes Deployment
   *
   * @public
   */
  export declare class Deployment extends DeferredComponent<DeploymentProps> {
      static defaultProps: {
          metadata: {};
          paused: boolean;
          replicas: number;
          progressDeadlineSeconds: number;
          minReadySeconds: number;
          revisionHistoryLimit: number;
          strategy: {
              type: string;
              rollingUpdate: {
                  maxSurge: string;
                  maxUnavailable: string;
              };
          };
      };
      constructor(props: DeploymentProps);
      build(helpers: BuildHelpers): Adapt.JSX.Element | null;
      deployedWhen: () => true | Adapt.Waiting;
      status(_observe: ObserveForStatus, buildData: BuildData): Promise<Adapt.Status | undefined>;
  }/** @internal */
  const deploymentResourceInfo: {
      kind: string;
      deployedWhen: typeof deployedWhen;
      statusQuery: (props: ResourcePropsWithConfig, observe: ObserveForStatus, buildData: BuildData) => Promise<any>;
  };/**
   * Type assertion to see if an element is both a {@link k8s.Resource | Resource}
   * and a {@link @adpt/core#FinalElement | FinalElement}
   *
   * @param e - element to test
   * @returns `true` if e is both a FinalElement and a {@link k8s.Resource | Resource}, `false` otherwise
   *
   * @public
   */
  export declare function isResourceFinalElement(e: AdaptElement): e is FinalDomElement<ResourceProps & Adapt.BuiltinProps>;/**
   * Tests whether a ResourceProps is for a template object
   *
   * @public
   */
  export declare function isResourcePropsWithConfig(x: ResourceProps & Partial<BuiltinProps>): x is ResourcePropsWithConfig & Partial<BuiltinProps>;/**
   * Tests to see if an object is a {@link k8s.Resource} element
   * @param x - object to test
   * @returns true if object is an AdaptElement of type {@link k8s.Resource}
   *
   * @public
   */
  export declare function isResource(x: any): x is AdaptElement<ResourceProps>;/**
   * Primitive Component recognized by the k8s plugin to represent resources
   * @public
   */
  export declare class Resource extends Action<ResourceProps> {
      defaultProps: {
          apiVersion: "v1";
          con: false;
      };
      manifest_: Manifest;
      constructor(props: ResourceProps);
      validate(): "Resource elements cannot have children" | undefined;
      shouldAct(op: ChangeType, ctx: ActionContext): Promise<ShouldAct>;
      action(op: ChangeType, ctx: ActionContext): Promise<void>;
      deployedWhen: (goalStatus: GoalStatus, helpers: DeployHelpers) => Promise<true | Adapt.Waiting | Adapt.Waiting[]>;
      status(observe: ObserveForStatus, buildData: BuildData): Promise<any>;
      private mountedElement;
      private manifest;
  }/** @internal */
  export declare function makePodManifest(props: PodProps & BuiltinProps, data: {
      volumes?: Volume[];
      serviceAccountName?: string;
  }): {
      kind: string;
      metadata: Metadata;
      spec: PodSpec;
  };/**
   * Tests whether x is a Pod element
   *
   * @param x - value to test
   * @returns `true` if x is a Pod element, false otherwise
   *
   * @public
   */
  export declare function isPod(x: any): x is AdaptElement<PodProps>;/** @public */
  export declare interface NodeSelectorRequirement {
      /** The label key that the selector applies to. */
      key: string;
      /**
       * Represents a key's relationship to a set of values.
       *
       * Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
       */
      operator: "In" | "NotIn" | "Exists" | "DoesNotExist" | "Gt" | "Lt";
      /**
       * Values for operator
       *
       * If the operator is In or NotIn, the values array must be non-empty.
       * If the operator is Exists or DoesNotExist, the values array must be empty.
       * If the operator is Gt or Lt, the values array must have a single element,
       * which will be interpreted as an integer.
       * This array is replaced during a strategic merge patch.
       */
      values: string[];
  }/** @public */
  export declare interface NodeSelectorTerm {
      /** A list of node selector requirements by node's labels. */
      matchExpressions?: NodeSelectorRequirement[];
      /** A list of node selector requirements by node's fields. */
      matchFields?: NodeSelectorRequirement[];
  }/** @public */
  export declare interface PreferredSchedulingTerm {
      /**
       * A node selector term, associated with the corresponding weight.
       */
      preference: NodeSelectorTerm;
      /** Weight associated with matching the corresponding nodeSelectorTerm, in the range 1-100. */
      weight: number;
  }/** @public */
  export declare interface NodeSelector {
      /** A list of node selector terms. The terms are ORed */
      nodeSelectorTerms: NodeSelectorTerm[];
  }/** @public */
  export declare interface NodeAffinity {
      /** The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding "weight" to the sum if the node matches the corresponding matchExpressions; the node(s) with the highest sum are the most preferred. */
      preferredDuringSchedulingIgnoredDuringExecution?: PreferredSchedulingTerm[];
      /** If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to an update), the system may or may not try to eventually evict the pod from its node. */
      requiredDuringSchedulingIgnoredDuringExecution?: NodeSelector;
  }/** @public */
  export declare interface PodAffinityTerm {
      /**
       * Label query over a set of resources, in this case pods.
       */
      labelSelector: LabelSelector;
      /** Specifies which namespaces the labelSelector applies to (matches against); null or empty list means "this pod's namespace" */
      namespaces?: string[];
      /** This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed. */
      topologyKey: string;
  }/** @public */
  export declare interface WeightedPodAffinityTerm {
      /** A pod affinity term, associated with the corresponding weight. */
      podAffinityTerm: PodAffinityTerm;
      /**
       * weight associated with matching the corresponding podAffinityTerm, in the range 1-100.
       */
      weight: number;
  }/** @public */
  export declare interface PodAffinity {
      /**
       * The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions.
       *
       * The node that is most preferred is the one with the greatest sum of weights,
       * i.e. for each node that meets all of the scheduling requirements (resource request,
       * requiredDuringScheduling affinity expressions, etc.), compute a sum by iterating
       * through the elements of this field and adding "weight" to the sum if the node has pods
       * which matches the corresponding podAffinityTerm; the node(s) with the highest sum are the most preferred.
       */
      preferredDuringSchedulingIgnoredDuringExecution: WeightedPodAffinityTerm[];
      /**
       * If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node.
       *
       * If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system may or may not try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each podAffinityTerm are intersected, i.e. all terms must be satisfied.
       */
      requiredDuringSchedulingIgnoredDuringExecution: PodAffinityTerm[];
  }/** @public */
  export declare interface PodAntiAffinity {
      /** The scheduler will prefer to schedule pods to nodes that satisfy the anti-affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling anti-affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the node(s) with the highest sum are the most preferred. */
      preferredDuringSchedulingIgnoredDuringExecution: WeightedPodAffinityTerm[];
      /** If the anti-affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the anti-affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system may or may not try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each podAffinityTerm are intersected, i.e. all terms must be satisfied. */
      requiredDuringSchedulingIgnoredDuringExecution: PodAffinity;
  }/** @public */
  export declare interface Affinity {
      /** Describes node affinity scheduling rules for the pod. */
      nodeAffinity: NodeAffinity;
      /** Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)). */
      podAffinity: PodAffinity;
      /** PodAntiAffinity	Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)). */
      podAntiAffinity: PodAntiAffinity;
  }/** @public */
  export declare interface PodDNSConfigOption {
      name: string;
      value?: string;
  }/** @public */
  export declare interface PodDNSConfig {
      /**
       * A list of DNS name server IP addresses.
       *
       * This will be appended to the base nameservers generated from DNSPolicy. Duplicated nameservers will be removed.
       */
      nameservers: string[];
      /**
       * A list of DNS resolver options.
       *
       * This will be merged with the base options generated from DNSPolicy.
       * Duplicated entries will be removed.
       * Resolution options given in Options will override those that appear in the base DNSPolicy.
       */
      options: PodDNSConfigOption[];
      /**
       * A list of DNS search domains for host-name lookup.
       *
       * This will be appended to the base search paths generated from DNSPolicy. Duplicated search paths will be removed.
       */
      searches: string[];
  }/** @public */
  export declare interface PodReadinessGate {
      /** Refers to a condition in the pod's condition list with matching type. */
      conditionType: string;
  }/** @public */
  export declare interface SELinuxOptions {
      /** SELinux level label that applies to the container. */
      level: string;
      /** SELinux role label that applies to the container. */
      role: string;
      /** SELinux type label that applies to the container. */
      type: string;
      /** SELinux user label that applies to the container */
      user: string;
  }/** @public */
  export declare interface SeccompProfile {
      /**
       * Indicates a profile defined in a file on the node should be used.
       *
       * The profile must be preconfigured on the node to work.
       * Must be a descending path, relative to the kubelet's configured seccomp profile location.
       * Must only be set if type is "Localhost".
       */
      localhostProfile?: string;
      /**
       * Indicates which kind of seccomp profile will be applied.
       *
       * Valid options are:
       * * Localhost - a profile defined in a file on the node should be used.
       * * RuntimeDefault - the container runtime default profile should be used.
       * * Unconfined - no profile should be applied.
       */
      type: "Localhost" | "RuntimeDefault" | "Unconfined";
  }/** @public */
  export declare interface Sysctl {
      name: string;
      value: string;
  }/** @public */
  export declare interface WindowsSecurityContextOptions {
      /**
       * The GMSA admission webhook ({@link https://github.com/kubernetes-sigs/windows-gmsa}) inlines the contents of the GMSA credential spec named by the GMSACredentialSpecName field.
       */
      gmsaCredentialSpec?: string;
      /**
       * GMSACredentialSpecName is the name of the GMSA credential spec to use.
       */
      gmsaCredentialSpecName?: string;
      /**
       * The UserName in Windows to run the entrypoint of the container process.
       *
       * Defaults to the user specified in image metadata if unspecified. May also be set in PodSecurityContext.
       * If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
       */
      runAsUserName?: string;
  }/** @public */
  export declare interface PodSecurityContext {
      /**
       * A special supplemental group that applies to all containers in a pod.
       *
       * Some volume types allow the Kubelet to change the ownership of that volume to be owned by the pod:
       *
       * 1. The owning GID will be the FSGroup
       * 2. The setgid bit is set (new files created in the volume will be owned by FSGroup)
       * 3. The permission bits are OR'd with rw-rw----
       *
       * If unset, the Kubelet will not modify the ownership and permissions of any volume.
       */
      fsGroup?: number;
      /**
       * Defines behavior of changing ownership and permission of the volume before being exposed inside Pod.
       *
       * This field will only apply to volume types which support fsGroup based ownership(and permissions).
       * It will have no effect on ephemeral volume types such as: secret, configmaps and emptydir.
       * Valid values are "OnRootMismatch" and "Always". If not specified defaults to "Always".
       *
       * @defaultValue Always
       */
      fsGroupChangePolicy?: "OnRootMismatch" | "Always";
      /**
       * The GID to run the entrypoint of the container process.
       *
       * Uses runtime default if unset. May also be set in SecurityContext.
       * If set in both SecurityContext and PodSecurityContext, the value specified in
       * SecurityContext takes precedence for that container.
       */
      runAsGroup?: number;
      /**
       * Indicates that the container must run as a non-root user.
       *
       * If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and
       * fail to start the container if it does. If unset or false, no such validation will be performed.
       * May also be set in SecurityContext.
       * If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
       */
      runAsNonRoot?: boolean;
      /**
       * The UID to run the entrypoint of the container process.
       *
       * Defaults to user specified in image metadata if unspecified.
       * May also be set in SecurityContext.
       * If set in both SecurityContext and PodSecurityContext, the value specified in
       * SecurityContext takes precedence for that container.
       */
      runAsUser?: number;
      /**
       * The SELinux context to be applied to all containers.
       *
       * If unspecified, the container runtime will allocate a random SELinux context for each container.
       * May also be set in SecurityContext.
       * If set in both SecurityContext and PodSecurityContext, the value specified in
       * SecurityContext takes precedence for that container.
       */
      seLinuxOptions?: SELinuxOptions;
      /**
       * The seccomp options to use by the containers in this pod.
       */
      seccompProfile?: SeccompProfile;
      /**
       * 	A list of groups applied to the first process run in each container, in addition to the container's primary GID.
       *
       *  If unspecified, no groups will be added to any container.
       */
      supplementalGroups?: number[];
      /**
       * Sysctls hold a list of namespaced sysctls used for the pod.
       *
       * Pods with unsupported sysctls (by the container runtime) might fail to launch.
       */
      sysctls?: Sysctl[];
      /**
       * The Windows specific settings applied to all containers.
       *
       * If unspecified, the options within a container's SecurityContext will be used.
       * If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
       */
      windowsOptions: WindowsSecurityContextOptions;
  }/** @public */
  export declare interface Toleration {
      /**
       * Indicates the taint effect to match.
       *
       * Empty means match all taint effects.
       * When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
       */
      effect?: "NoSchedule" | "PreferNoSchedule" | "NoExecute";
      /**
       * The taint key that the toleration applies to.
       *
       * Empty means match all taint keys.
       * If the key is empty, operator must be Exists;
       * this combination means to match all values and all keys.
       */
      key?: string;
      /**
       * Represents a key's relationship to the value.
       *
       * Valid operators are Exists and Equal.
       * Defaults to Equal.
       * Exists is equivalent to wildcard for value, so that a pod can tolerate all taints of a particular category.
       *
       * @defaultValue Equal
       */
      operator?: "Exists" | "Equal";
      /**
       * Represents the period of time the toleration (which must be of effect NoExecute, otherwise this field is ignored) tolerates the taint.
       *
       * By default, it is not set, which means tolerate the taint forever (do not evict).
       * Zero and negative values will be treated as 0 (evict immediately) by the system.
       */
      tolerationSeconds?: number;
      /**
       * Value is the taint value the toleration matches to.
       *
       * If the operator is Exists, the value should be empty, otherwise just a regular string.
       */
      value?: string;
  }/** @public */
  export declare interface TopologySpreadConstraint {
      /**
       * Used to find matching pods.
       *
       * Pods that match this label selector are counted to determine the
       * number of pods in their corresponding topology domain.
       */
      labelSelector: LabelSelector;
      /**
       * Describes the degree to which pods may be unevenly distributed.
       *
       * When `whenUnsatisfiable=DoNotSchedule`, it is the maximum permitted
       * difference between the number of matching pods in the target topology
       * and the global minimum.
       * For example, in a 3-zone cluster, MaxSkew is set to 1, and pods with
       * the same labelSelector spread as 1/1/0: | zone1 | zone2 | zone3 | | P | P | |
       * - if MaxSkew is 1, incoming pod can only be scheduled to zone3 to become 1/1/1;
       *   scheduling it onto zone1(zone2) would make the ActualSkew(2-0) on zone1(zone2) violate MaxSkew(1).
       * - if MaxSkew is 2, incoming pod can be scheduled onto any zone.
       * When `whenUnsatisfiable=ScheduleAnyway`, it is used to give higher precedence to topologies that satisfy it.
       * It's a required field. Default value is 1 and 0 is not allowed.
       *
       * @example
       *
       * @defaultValue 1
       */
      maxSkew: number;
      /**
       * The key of node labels.
       *
       * Nodes that have a label with this key and identical values are considered to be in the same topology.
       * We consider each \<key, value\> as a "bucket", and try to put balanced number of pods into each bucket.
       * It's a required field.
       */
      topologyKey: string;
      /**
       * Indicates how to deal with a pod if it doesn't satisfy the spread constraint.
       *
       * - DoNotSchedule (default) tells the scheduler not to schedule it.
       * - ScheduleAnyway tells the scheduler to schedule the pod in any location,
       *   but giving higher precedence to topologies that would help reduce the skew.
       *
       * A constraint is considered "Unsatisfiable" for an incoming pod if and only if every possible
       * node assigment for that pod would violate "MaxSkew" on some topology.
       * For example, in a 3-zone cluster, MaxSkew is set to 1, and pods with the same labelSelector
       * spread as 3/1/1: | zone1 | zone2 | zone3 | | P P P | P | P | If WhenUnsatisfiable is set to DoNotSchedule,
       * incoming pod can only be scheduled to zone2(zone3) to become 3/2/1(3/1/2)
       * as ActualSkew(2-1) on zone2(zone3) satisfies MaxSkew(1).
       * In other words, the cluster can still be imbalanced, but scheduler won't make it
       * *more* imbalanced.
       *
       * It's a required field.
       */
      whenUnsatisfiable: string;
  }/** @public */
  export declare interface KeyToPath {
      /** The key to project. */
      key: string;
      /**
       * mode bits to use on this file,
       * Must be a value between 0 and 0777.
       * If not specified, the volume defaultMode will be used.
       * This might be in conflict with other options that affect the file mode, like fsGroup,
       * and the result can be other mode bits set.
       */
      mode?: number;
      /**
       * The relative path of the file to map the key to.
       *
       * May not be an absolute path. May not contain the path element '..'. May not start with the string '..'.
       */
      path: string;
  }/** @public */
  export declare interface ConfigMapVolumeSource {
      /**
       * mode bits to use on created files by default.
       *
       * Must be a value between 0 and 0777. Defaults to 0644.
       * Directories within the path are not affected by this setting.
       * This might be in conflict with other options that affect the file mode,
       * like fsGroup, and the result can be other mode bits set.
       */
      defaultMode?: number;
      /**
       * If unspecified, each key-value pair in the Data field of the referenced ConfigMap will be projected into the volume as a file whose name is the key and content is the value.
       *
       * If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present.
       * If a key is specified which is not present in the ConfigMap, the volume setup will error unless it is marked optional.
       * Paths must be relative and may not contain the '..' path or start with '..'.
       */
      items?: KeyToPath[];
      /**
       * Name of the referent.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names}
       */
      name: string | Handle;
      /** Specify whether the ConfigMap or its keys must be defined */
      optional?: boolean;
  }/** @public */
  export declare interface SecretVolumeSource {
      /**
       * mode bits to use on created files by default.
       *
       * Must be a value between 0 and 0777. Defaults to 0644.
       * Directories within the path are not affected by this setting.
       * This might be in conflict with other options that affect the file mode,
       * like fsGroup, and the result can be other mode bits set.
       */
      defaultMode?: number;
      /**
       * If unspecified, each key-value pair in the Data field of the referenced Secret will be projected into the volume as a file whose name is the key and content is the value.
       *
       * If specified, the listed keys will be projected into the specified paths,
       * and unlisted keys will not be present. If a key is specified which is not
       * present in the Secret, the volume setup will error unless it is marked optional.
       *
       * Paths must be relative and may not contain the '..' path or start with '..'.
       */
      items?: KeyToPath[];
      /** Specify whether the Secret or its keys must be defined */
      optional?: boolean;
      /**
       * Name of the secret in the pod's namespace to use.
       *
       *  More info: {@link https://kubernetes.io/docs/concepts/storage/volumes#secret}
       */
      secretName: string | Handle;
  }/** @public */
  export declare interface EmptyDirVolumeSource {
      /**
       * What type of storage medium should back this directory.
       *
       * The default is "" which means to use the node's default medium.
       * Must be an empty string (default) or Memory.
       * More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
       */
      medium: string;
      /**
       * Total amount of local storage required for this EmptyDir volume.
       *
       * The size limit is also applicable for memory medium.
       * The maximum usage on memory medium EmptyDir would be the minimum
       * value between the SizeLimit specified here and the sum of memory limits of all containers in a pod.
       * The default is nil which means that the limit is undefined.
       * More info: {@link http://kubernetes.io/docs/user-guide/volumes#emptydir}
       */
      sizeLimit: string;
  }/**
   * Volumes for {@link k8s.PodProps}
   *
   * @public
   */
  export declare interface Volume {
      /**
       * Volume's name.
       *
       * Must be a DNS_LABEL and unique within the pod.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names}
       */
      name: string;
      /**
       * Represents a configMap that should populate this volume
       */
      configMap?: ConfigMapVolumeSource;
      /**
       * EmptyDir represents a temporary directory that shares a pod's lifetime.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/storage/volumes#emptydir}
       *
       */
      emptyDir?: EmptyDirVolumeSource;
      /**
       * Represents a secret that should populate this volume.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/storage/volumes#secret}
       */
      secret?: SecretVolumeSource;
      /** Other k8s volume kinds not typed yet for \@adpt/cloud */
      [key: string]: any;
  }/**
   * Props for the {@link k8s.Pod} component
   *
   * @public
   */
  export declare interface PodProps extends WithChildren {
      /**
       *  True is this is a template for use in a controller, false otherwise
       *  @defaultValue false
       */
      isTemplate: boolean;
      /** Information about the k8s cluster (ip address, auth info, etc.) */
      config?: ClusterInfo;
      /** k8s metadata */
      metadata: Metadata;
      /**
       * Optional duration in seconds the pod may be active on the node relative to StartTime before the system will actively try to mark it failed and kill associated containers.
       *
       * Value must be a positive integer.
       */
      activeDeadlineSeconds?: number;
      /** If specified, the pod's scheduling constraints */
      affinity?: Affinity;
      /** AutomountServiceAccountToken indicates whether a service account token should be automatically mounted. */
      automountServiceAccountToken?: boolean;
      /**
       *  Specifies the DNS parameters of a pod.
       *
       *  Parameters specified here will be merged to the generated DNS configuration based on DNSPolicy.
       */
      dnsConfig?: PodDNSConfig;
      /**
       * Set DNS policy for the pod.
       *
       * Valid values are 'ClusterFirstWithHostNet', 'ClusterFirst', 'Default' or 'None'.
       * DNS parameters given in DNSConfig will be merged with the policy selected with DNSPolicy.
       * To have DNS options set along with hostNetwork, you have to specify DNS policy explicitly
       * to 'ClusterFirstWithHostNet'.
       *
       * @defaultValue ClusterFirst
       */
      dnsPolicy: "ClusterFirstWithHostNet" | "ClusterFirst" | "Default" | "None";
      /**
       * Indicates whether information about services should be injected into pod's environment variables matching the syntax of Docker links.
       *
       * @defaultValue true
       */
      enableServiceLinks: boolean;
      /**
       * An optional list of hosts and IPs that will be injected into the pod's hosts file if specified.
       *
       * This is only valid for non-hostNetwork pods.
       */
      hostAliases?: HostAlias[];
      /**
       * Use the host's ipc namespace.
       * @defaultValue false
       */
      hostIPC: boolean;
      /**
       * Host networking requested for this pod.
       *
       * Use the host's network namespace.
       * If this option is set, the ports that will be used must be specified. Default to false.
       */
      hostNetwork?: boolean;
      /**
       * Use the host's pid namespace.
       * @defaultValue false
       */
      hostPID: boolean;
      /**
       * Specifies the hostname of the Pod.
       *
       * If not specified, the pod's hostname will be set to a system-defined value.
       */
      hostname?: string;
      /**
       * List of references to secrets in the same namespace to use for pulling any of the images used by this PodSpec.
       *
       * If specified, these secrets will be passed to individual puller implementations for them to use.
       * For example, in the case of docker, only DockerConfig type secrets are honored.
       * More info: {@link https://kubernetes.io/docs/concepts/containers/images#specifying-imagepullsecrets-on-a-pod}
       */
      imagePullSecrets?: LocalObjectReference[];
      /**
       * A request to schedule this pod onto a specific node.
       *
       * If it is non-empty, the scheduler simply schedules this pod onto that node,
       * assuming that it fits resource requirements.
       */
      nodeName?: string;
      /**
       * A selector which must be true for the pod to fit on a node.
       *
       * Selector which must match a node's labels for the pod to be scheduled on that node.
       * More info: {@link https://kubernetes.io/docs/concepts/configuration/assign-pod-node/}
       */
      nodeSelector?: {
          [label: string]: boolean | string;
      };
      /**
       * Overhead represents the resource overhead associated with running a pod for a given RuntimeClass.
       *
       * This field will be autopopulated at admission time by the RuntimeClass admission controller.
       * If the RuntimeClass admission controller is enabled, overhead must not be set in Pod create requests.
       * The RuntimeClass admission controller will reject Pod create requests which have the overhead already set.
       * If RuntimeClass is configured and selected in the PodSpec, Overhead will be set to the value defined in
       * the corresponding RuntimeClass, otherwise it will remain unset and treated as zero.
       *
       * More info: {@link https://git.k8s.io/enhancements/keps/sig-node/20190226-pod-overhead.md}
       *
       * This field is alpha-level as of Kubernetes v1.16, and is only honored by servers that enable
       * the PodOverhead feature.
       * @alpha
       */
      overhead?: unknown;
      /**
       * PreemptionPolicy is the Policy for preempting pods with lower priority.
       *
       * This field is beta-level, gated by the NonPreemptingPriority feature-gate.
       *
       * @defaultValue PreemptLowerPriority
       * @beta
       */
      preemptionPolicy?: "Never" | "PreemptLowerPriority";
      /**
       * The priority various system components use this field to find the priority of the pod.
       *
       * When Priority Admission Controller is enabled, it prevents users from setting this field.
       * The admission controller populates this field from PriorityClassName.
       * The higher the value, the higher the priority.
       */
      priority?: number;
      /**
       * If specified, indicates the pod's priority.
       *
       * "system-node-critical" and "system-cluster-critical" are two special keywords which indicate the highest
       * priorities with the former being the highest priority. Any other name must be defined by creating a PriorityClass
       * object with that name. If not specified, the pod priority will be default or zero if there is no default.
       */
      priorityClassName?: string;
      /**
       *  If specified, all readiness gates will be evaluated for pod readiness.
       *
       *  A pod is ready when all its containers are ready AND all conditions specified
       *  in the readiness gates have status equal to "True"
       *
       *  More info: {@link https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#pod-readiness-gate}
       */
      readinessGates?: PodReadinessGate[];
      /**
       * Restart policy for all containers within the pod.
       *
       * One of Always, OnFailure, Never. Default to Always.
       * More info: {@link https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy}
       *
       * @defaultValue Always
       */
      restartPolicy: "Always" | "OnFailure" | "Never";
      /**
       * Refers to a RuntimeClass object in the node.k8s.io group, which should be used to run this pod.
       *
       * If no RuntimeClass resource matches the named class, the pod will not be run.
       * If unset or empty, the "legacy" RuntimeClass will be used, which is an implicit
       * class with an empty definition that uses the default runtime handler.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/containers/runtime-class/}
       *
       * This is a beta feature as of Kubernetes v1.14.
       */
      runtimeClassName?: string;
      /**
       *  If specified, the pod will be dispatched by specified scheduler.
       *  If not specified, the pod will be dispatched by default scheduler.
       */
      schedulerName?: string;
      /**
       * SecurityContext holds pod-level security attributes and common container settings.
       * See type description for default values of each field.
       *
       * @defaultValue \{\}
       */
      securityContext: PodSecurityContext;
      /**
       * ServiceAccountName is the name of the ServiceAccount to use to run this pod.
       * More info: {@link https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/}
       */
      serviceAccountName?: string | Handle;
      /**
       * If true the pod's hostname will be configured as the pod's FQDN, rather than the leaf name (the default).
       * In Linux containers, this means setting the FQDN in the hostname field of the kernel
       * (the nodename field of struct utsname).
       * In Windows containers, this means setting the registry value of hostname for the registry key
       * HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters to FQDN.
       * If a pod does not have FQDN, this has no effect.
       *
       * @defaultValue false
       */
      setHostnameAsFQDN?: boolean;
      /**
       * Share a single process namespace between all of the containers in a pod.
       * When this is set containers will be able to view and signal processes from other containers in the same pod,
       * and the first process in each container will not be assigned PID 1.
       * HostPID and ShareProcessNamespace cannot both be set.
       *
       * @defaultValue false
       */
      shareProcessNamespace: boolean;
      /**
       *  If specified, the fully qualified Pod hostname will be "\<hostname\>.\<subdomain\>.\<pod namespace\>.svc.\<cluster domain\>".
       *  If not specified, the pod will not have a domainname at all.
       */
      subdomain?: string;
      /**
       * Optional duration in seconds the pod needs to terminate gracefully.
       *
       * May be decreased in delete request. Value must be non-negative integer.
       * The value zero indicates delete immediately. If this value is nil, the default
       * grace period will be used instead. The grace period is the duration in seconds
       * after the processes running in the pod are sent a termination signal and the time
       * when the processes are forcibly halted with a kill signal. Set this value longer
       * than the expected cleanup time for your process. Defaults to 30 seconds.
       */
      terminationGracePeriodSeconds?: number;
      /** If specified, the pod's tolerations. */
      tolerations?: Toleration[];
      /**
       *  TopologySpreadConstraints describes how a group of pods ought to spread across topology domains.
       *
       *  Scheduler will schedule pods in a way which abides by the constraints. All topologySpreadConstraints are ANDed.
       */
      topologySpreadConstraints?: TopologySpreadConstraint[];
      /**
       * List of volumes that can be mounted by containers belonging to the pod.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/storage/volumes}
       */
      volumes?: Volume[];
  }/**
   * Component for Kubernetes Pods
   *
   * @public
   */
  export declare class Pod extends DeferredComponent<PodProps, ResolvedVolumes & ResolvedServiceAccountName> {
      static defaultProps: {
          isTemplate: boolean;
          metadata: {};
          dnsPolicy: string;
          enableServiceLinks: boolean;
          hostIPC: boolean;
          hostPID: boolean;
          restartPolicy: string;
          securityContext: {};
          shareProcessNamespace: boolean;
          terminationGracePeriodSeconds: number;
      };
      initialState(): {};
      build(helpers: BuildHelpers): Adapt.JSX.Element | null;
      status(_observe: ObserveForStatus, buildData: BuildData): Promise<Adapt.Status | undefined>;
  }/**
   * Spec for for Kubernetes Pods
   *
   * @public
   */
  export declare interface PodSpec extends Omit<PodProps, "config" | "metadata" | "isTemplate"> {
      containers: ContainerSpec[];
      terminationGracePeriodSeconds?: number;
  }/** @internal */
  const podResourceInfo: {
      kind: string;
      deployedWhen: typeof deployedWhen;
      statusQuery: (props: ResourcePropsWithConfig, observe: ObserveForStatus, buildData: BuildData) => Promise<any>;
  };/**
   * k8s Secret resource
   *
   * @param propsIn - props for Secret as specifed in {@link k8s.SecretProps}
   *
   * @public
   */
  export declare function Secret(propsIn: SFCDeclProps<SecretProps, typeof defaultProps>): Adapt.JSX.Element;/** @internal */
  const secretResourceInfo: {
      kind: string;
      deployedWhen: () => true;
      statusQuery: (props: ResourcePropsWithConfig, observe: ObserveForStatus, buildData: BuildData) => Promise<any>;
      makeManifest: (manifest: Manifest, elem: AdaptElement<ResourceProps>, _deployID: string) => {
          data: {
              [key: string]: string;
          } | undefined;
          stringData: {
              [key: string]: string;
          } | undefined;
          type: string | undefined;
          apiVersion: string; /**
           * stringData allows specifying non-binary secret data in string form.
           *
           * It is provided as a write-only convenience method. All keys and values are merged into the data field on write,
           * overwriting any existing values. It is never output when reading from the API.
           */
          kind: string;
          metadata: import("./manifest_support").MetadataInRequest;
          spec?: import("./DaemonSet").DaemonSetSpec | import("./common").CRSpec | import("./Pod").PodSpec | import("./Service").ServiceSpec | import("./Deployment").DeploymentSpec | undefined;
      };
  };/**
   * Convert {@link NetworkService} props to {@link k8s.Service} props
   * @param abstractProps - props to convert
   * @returns Kubernetes spec corresponding to `abstractProps`
   *
   * @internal
   */
  export declare function k8sServiceProps(abstractProps: NetworkServiceProps & BuiltinProps): Omit<ServiceProps, keyof ResourceBase>;/**
   * Native Kubernetes Service resource
   *
   * @remarks
   *
   * Implements the {@link NetworkServiceInstance} interface.
   *
   * @public
   */
  export declare function Service(propsIn: SFCDeclProps<ServiceProps, typeof defaultProps>): Adapt.JSX.Element;/** @public */
  export declare interface ServiceProps extends ServiceSpec {
      /** Legal configuration loaded from kubeconfig */
      config: ClusterInfo;
      metadata?: Metadata;
      selector?: Handle | EndpointSelector;
  }/** @public */
  export declare interface ServiceSpec {
      /**
       * Cluster IP for a {@link k8s.Service}
       *
       * @remarks
       * `clusterIP` is the IP address of the service and is usually assigned
       * randomly by the master. If an address is specified manually and is not
       * in use by others, it will be allocated to the service; otherwise,
       * creation of the service will fail. This field can not be changed through
       * updates. Valid values are "None", empty string (""), or a valid IP
       * address. "None" can be specified for headless services when proxying is
       * not required. Only applies to types ClusterIP, NodePort, and
       * LoadBalancer. Ignored if type is ExternalName.
       *
       * For more information, see the
       * {@link https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies |
       * Kubernetes documentation}.
       */
      clusterIP?: string;
      /**
       * A list of IP addresses for which nodes in the cluster
       * will also accept traffic for this service.
       *
       * @remarks
       * These IPs are not managed by
       * Kubernetes. The user is responsible for ensuring that traffic arrives at
       * a node with this IP. A common example is external load balancers that are
       * not part of the Kubernetes system.
       */
      externalIPs?: string[];
      /**
       * The external reference that kubedns or equivalent
       * will return as a CNAME record for this service.
       *
       * @remarks
       * No proxying will be involved. Must be a
       * {@link https://tools.ietf.org/html/rfc1123 | valid RFC-1123 hostname}
       * and requires Type to be ExternalName.
       */
      externalName?: string;
      /**
       * Denotes if this Service desires to route
       * external traffic to node-local or cluster-wide endpoints.
       *
       * @remarks
       * "Local" preserves the client source IP and avoids a second hop for
       * LoadBalancer and Nodeport type services, but risks potentially
       * imbalanced traffic spreading. "Cluster" obscures the client source IP
       * and may cause a second hop to another node, but should have good overall
       * load-spreading.
       */
      externalTrafficPolicy?: string;
      /**
       * Specifies the healthcheck nodePort for the service.
       *
       * @remarks
       * If not specified, HealthCheckNodePort is created by the service
       * api backend with the allocated nodePort. Will use user-specified nodePort
       * value if specified by the client. Only affects when Type is set to
       * LoadBalancer and ExternalTrafficPolicy is set to Local.
       */
      healthCheckNodePort?: number;
      /**
       * Only applies to Service Type: LoadBalancer. LoadBalancer will
       * get created with the IP specified in this field.
       *
       * @remarks
       * This feature depends on
       * whether the underlying cloud provider supports specifying the loadBalancerIP
       * when a load balancer is created. This field will be ignored if the
       * cloud provider does not support the feature.
       */
      loadBalancerIP?: string;
      /**
       * If specified and supported by the platform, this will
       * restrict traffic through the cloud provider load balancer
       * to the specified client IPs.
       *
       * @remarks
       * This field will be ignored if the cloud provider
       * does not support the feature.
       *
       * For more information, see the
       * {@link https://v1-17.docs.kubernetes.io/docs/tasks/access-application-cluster/configure-cloud-provider-firewall/ |
       * Kubernetes documentation}.
       */
      loadBalancerSourceRanges?: string[];
      /**
       * The list of ports that are exposed by this service.
       *
       * @remarks
       * For more information, see the
       * {@link https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies |
       * Kubernetes documentation}.
       */
      ports?: ServicePort[];
      /**
       * When set to true, indicates that
       * DNS implementations must publish the notReadyAddresses of subsets for the
       * Endpoints associated with the Service.
       *
       * @remarks
       * The default value is false. The
       * primary use case for setting this field is to use a StatefulSet's Headless
       * Service to propagate SRV records for its Pods without respect to their
       * readiness for purpose of peer discovery.
       */
      publishNotReadyAddresses?: boolean;
      /**
       * Route service traffic to pods with label keys and values
       * matching this selector.
       *
       * @remarks
       * If empty or not present, the service is assumed to
       * have an external process managing its endpoints, which Kubernetes will not
       * modify. Only applies to types ClusterIP, NodePort, and LoadBalancer.
       * Ignored if type is ExternalName.
       *
       * For more information, see the
       * {@link https://kubernetes.io/docs/concepts/services-networking/service/ |
       * Kubernetes documentation}.
       */
      selector?: EndpointSelector | object;
      /**
       * Used to maintain session affinity.
       *
       * @remarks
       * Possible values are:
       *
       * - `"ClientIP"`: Enables client IP based session affinity.
       *
       * - `"None"`: Disables session affinity.
       *
       * For more information, see the
       * {@link https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies |
       * Kubernetes documentation}.
       * @defaultValue `"None"`
       */
      sessionAffinity?: string;
      /**
       * Determines how the Service is exposed.
       *
       * @remarks
       * Valid options are:
       *
       * - `"ExternalName"`: maps to the specified externalName.
       *
       * - `"ClusterIP"`: allocates a cluster-internal IP address for load
       * balancing to endpoints. Endpoints are determined by the selector or if
       * that is not specified, by manual construction of an Endpoints object. If
       * clusterIP is "None", no virtual IP is allocated and the endpoints are
       * published as a set of endpoints rather than a stable IP.
       *
       * - `"NodePort"`: Builds on ClusterIP and allocates a port on every node
       * which routes to the clusterIP.
       *
       * - `"LoadBalancer"`: Builds on NodePort and creates an external load
       * balancer (if supported in the current cloud) which routes to the
       * clusterIP.
       *
       * For more information, see the
       * {@link https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services---service-types |
       * Kubernetes documentation}.
       * @defaultValue `"ClusterIP"`
       */
      type?: string;
  }/** @public */
  export declare interface ServicePort {
      /**
       * The name of this port within the service.
       *
       * @remarks
       * This must be a DNS_LABEL.
       * All ports within a ServiceSpec must have unique names.This maps to the
       * Name' field in EndpointPort objects. Optional if only one ServicePort is
       * defined on this service.
       */
      name?: string;
      /**
       * The port on each node on which this service is exposed when
       * type=NodePort or LoadBalancer.
       *
       * @remarks
       * Usually assigned by the system. If
       * specified, it will be allocated to the service if unused or else creation
       * of the service will fail.
       *
       * For more information, see the
       * {@link https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport |
       * Kubernetes documentation}.
       * @defaultValue Automatically allocates a port if the ServiceType of this
       * Service requires one.
       */
      nodePort?: number;
      /** The port that will be exposed by this service. */
      port?: number;
      /** The IP protocol for this port.Supports "TCP" and "UDP".Default is TCP. */
      protocol?: string;
      /**
       * Number or name of the port to access on the pods targeted by the
       * service.
       *
       * @remarks
       * Number must be in the range 1 to 65535. Name must be an
       * IANA_SVC_NAME. If this is a string, it will be looked up as a named port
       * in the target Pod's container ports. If this is not specified, the value
       * of the 'port' field is used (an identity map). This field is ignored for
       * services with clusterIP = None, and should be omitted or set equal to the
       * 'port' field.
       *
       * For more information, see the
       * {@link https://kubernetes.io/docs/concepts/services-networking/service/#defining-a-service |
       * Kubernetes documentation}.
       */
      targetPort?: number | string;
  }/** @internal */
  const serviceResourceInfo: {
      kind: string;
      deployedWhen: typeof deployedWhen;
      statusQuery: (props: ResourcePropsWithConfig, observe: ObserveForStatus, buildData: BuildData) => Promise<any>;
  };/**
   * k8s ServiceAccount resource
   *
   * @param propsIn - props for ServiceAccount as specifed in {@link k8s.ServiceAccountProps}
   *
   * @public
   */
  export declare function ServiceAccount(propsIn: SFCDeclProps<ServiceAccountProps, typeof defaultProps>): Adapt.JSX.Element;/** @public */
  export declare function isServiceAccountProps(p: ResourceProps): p is ResourceProps & ResourceServiceAccount;/** @internal */
  const serviceAccountResourceInfo: {
      kind: string;
      deployedWhen: () => true;
      statusQuery: (props: ResourcePropsWithConfig, observe: ObserveForStatus, buildData: BuildData) => Promise<any>;
      makeManifest: (manifest: Manifest, elem: AdaptElement<ResourceProps>, _deployID: string) => {
          automountServiceAccountToken: boolean | undefined;
          imagePullSecrets: {
              name: string;
          }[] | undefined;
          secrets: ObjectReference[] | undefined;
          apiVersion: string;
          kind: string;
          metadata: import("./manifest_support").MetadataInRequest;
          spec?: import("./DaemonSet").DaemonSetSpec | import("./common").CRSpec | import("./Pod").PodSpec | import("./Service").ServiceSpec | import("./Deployment").DeploymentSpec | undefined;
      };
  };/**
   * Props for {@link k8s.ServiceDeployment}
   *
   * @public
   */
  export declare interface ServiceDeploymentProps<T extends AllowableComponentProps = DeploymentProps> extends ServiceProps {
      config: ClusterInfo;
      serviceProps?: Partial<ServiceProps>;
      component: ComponentType<T>;
      componentProps: T;
      podProps?: Partial<PodProps>;
      containerProps?: Partial<OmitT<K8sContainerProps, "image">>;
  }/**
   * A component for mapping a group of abstract {@link Container}s and
   * {@link NetworkService}s to Kubernetes {@link k8s.Pod}s and
   * {@link k8s.K8sContainer}s.
   *
   * @remarks
   * This component is intended to be used to replace {@link Container} and
   * {@link NetworkService} components that are grouped together, as the
   * only children of a common parent in a pattern that looks like this:
   *
   * ```tsx
   * <Service>
   *   <Container ... />
   *   <Container ... />
   *   <NetworkService ... />
   * </Service>
   * ```
   *
   * `ServiceDeployment` would map those abstract components into corresponding
   * k8s components like this:
   * ```tsx
   * <Group>
   *   <docker.RegistryDockerImage ... /> //If props.config specifies a registry
   *   <k8s.Deployment ... >
   *     <Pod isTemplate>
   *       <k8s.K8sContainer ... />
   *     </Pod>
   *   </k8s.Deployment>
   *   <docker.RegistryDockerImage ... /> //If props.config specifies a registry
   *   <k8s.Deployment ... >
   *     <Pod isTemplate>
   *       <k8s.K8sContainer ... />
   *     </Pod>
   *   </k8s.Pod>
   *   <k8s.Service ... />
   * </Group>
   * ```
   * An example style rule to do this is:
   * ```tsx
   * {Adapt.rule((matchedProps) => {
   *     const { handle, ...remainingProps } = matchedProps;
   *     return <ServiceDeployment config={kubeconfig} {...remainingProps} />;
   * })}
   * ```
   * `ServiceDeployment` also requires the `config` prop which specifies
   * connection and authentication information for the Kubernetes cluster on
   * which these objects should be created.
   *
   * @public
   */
  export declare class ServiceDeployment<T extends AllowableComponentProps> extends DeferredComponent<ServiceDeploymentProps<T>> {
      static defaultProps: {
          component: typeof Deployment;
          componentProps: {
              replicas: number;
          };
      };
      build(helpers: BuildHelpers): Adapt.JSX.Element;
  }/** @public */
  export declare function computeNamespaceFromMetadata(metadata?: Metadata): string;/** @public */
  export declare function isLabelSelector(x: any): x is LabelSelector;/**
   * Kubernetes Kind
   *
   * @public
   */
  export declare type Kind = string;/** @public */
  export declare interface CRSpec {
      [key: string]: any;
  }/** @public */
  export declare type Spec = DaemonSetSpec | DeploymentSpec | PodSpec | ServiceSpec | CRSpec;/** @public */
  export declare interface Metadata {
      namespace?: string;
      labels?: {
          [key: string]: string;
      };
      annotations?: {
          [key: string]: string;
      };
  }/** @public */
  export declare type ResourceProps = {
      key: string;
  } & (ResourceClusterRole | ResourceClusterRoleBinding | ResourceDaemonSet | ResourcePod | ResourceService | ResourceServiceAccount | ResourceConfigMap | ResourceSecret | ResourceCR);/** @public */
  export declare type ResourcePropsWithConfig = ResourceProps & {
      config: ClusterInfo;
  };/** @public */
  export declare interface ResourceInfo {
      kind: Kind;
      statusQuery?: (props: ResourceProps, observe: ObserveForStatus, buildData: BuildData) => unknown | Promise<unknown>;
      specsEqual(actual: Spec, element: Spec): boolean;
  }/**
   * Holds the information needed to connect, authenticate, and run code in a kuberenetes cluster
   *
   * @public
   */
  export declare interface ClusterInfo {
      /** Javascript object formed by parsing a valid kubeconfig file */
      kubeconfig: Kubeconfig;
      /**
       * Registry to which Docker images used by the cluster in `kubeconfig` should be pushed and pulled
       *
       * @remarks
       * If `registryPrefix` is a string, it is assumed that the cluster can pull from the same string
       * that outsiders can push to.
       *
       * If `registryPrefix` is of the form `{ external: string, internal: string }` then the `external`
       * string will be used to push images, and the `internal` string will be used to pull images.
       *
       * Note(manishv)
       * This is a bit of a hack to allow one hostname or IP address to push images from outside
       * a particular environment (say k8s) and a different URL for that environment to pull
       * images.
       *
       * A good example of this is a k3s-dind (k3s docker-in-docker) instance of kubernetes where
       * a private registry is running on a docker network attached to the k3s-dind instance, but where we
       * want to push {@link docker.LocalDockerImage} built images to that registry.  Since
       * {@link docker.LocalDockerImage | LocalDockerImage} is outside the k3s-dind environment, it must
       * use a host accessible network to push to the registry.  However, since the k3s-dind instance sees
       * the registry from within Docker, it must use a different address to pull the images for use.
       *
       * Once network scopes are fully supported, this interface will change to whatever is appropriate.  It
       * is best if you can arrange to have the same URL or registry string work for all access regardless
       * of which network the registry, Adapt host, and ultimate container running environment uses.
       *
       */
      registryPrefix?: string | DockerSplitRegistryInfo;
  }/** @public */
  export declare interface ResourceBase {
      /**
       * config to connect to the k8s cluster
       *
       * required if isTemplate is false
       */
      config?: ClusterInfo;
      /**
       * Specifies whether this resource is just a template for use in a controller
       */
      isTemplate?: boolean;
      apiVersion?: string;
      kind: Kind;
      metadata?: Metadata;
  }/**
   * @public
   */
  export declare interface PolicyRule {
      /**
       * APIGroups is the name of the APIGroup that contains the resources.
       *
       * If multiple API groups are specified, any action requested against one
       * of the enumerated resources in any API group will be allowed.
       */
      apiGroups?: string[];
      /**
       * NonResourceURLs is a set of partial urls that a user should have access to.
       *
       * *s are allowed, but only as the full, final step in the path.
       * Since non-resource URLs are not namespaced, this field is only applicable
       * for ClusterRoles referenced from a ClusterRoleBinding.
       * Rules can either apply to API resources (such as "pods" or "secrets") or
       * non-resource URL paths (such as "/api"), but not both.
       */
      nonResourceURLs?: string[];
      /**
       * ResourceNames is an optional white list of names that the rule applies to.
       *
       * An empty set means that everything is allowed.
       */
      resourceNames?: string[];
      /**
       * Resources is a list of resources this rule applies to.
       *
       * ResourceAll represents all resources.
       */
      resources: string[];
      /**
       * Verbs is a list of Verbs that apply to ALL the ResourceKinds and
       * AttributeRestrictions contained in this rule.
       *
       * VerbAll represents all kinds.
       */
      verbs: string[];
  }/**
   * AggregationRule for {@link k8s.ClusterRole}
   *
   * @public
   */
  export declare interface AggregationRule {
      /**
       * ClusterRoleSelectors holds a list of selectors which will be used to
       * find ClusterRoles and create the rules.
       *
       * If any of the selectors match, then the ClusterRole's permissions will be added
       */
      clusterRoleSelector: LabelSelector;
  }/** @public */
  export declare interface ResourceClusterRole extends ResourceBase {
      apiVersion: "rbac.authorization.k8s.io/v1";
      kind: "ClusterRole";
      aggregationRule?: AggregationRule;
      rules?: PolicyRule[];
  }/**
   * RoleRef for {@link k8s.ResourceClusterRoleBinding}
   *
   * @public
   */
  export declare interface RoleRef {
      /** apiGroup is the group for the resource being referenced */
      apiGroup: string;
      /** kind is the type of resource being referenced */
      kind: string;
      /** Name is the name of resource being referenced */
      name: string;
  }/**
   * Subject for {@link k8s.ResourceClusterRoleBinding}
   *
   * @public
   */
  export declare interface Subject {
      /** apiGroup is the group for the object being referenced */
      apiGroup: string;
      /** kind is the type of object being referenced */
      kind: string;
      /**
       * Name of the object being referenced.
       */
      name: string;
      /**
       * Namespace of the referenced object.
       *
       * If the object kind is non-namespace, such as "User" or "Group", and this value
       * is not empty the Authorizer should report an error.
       */
      namespace?: string;
  }/** @public */
  export declare interface ResourceClusterRoleBinding extends ResourceBase {
      apiVersion: "rbac.authorization.k8s.io/v1";
      kind: "ClusterRoleBinding";
      roleRef: RoleRef;
      subjects: Subject[];
  }/** @public */
  export declare interface ResourceDaemonSet extends ResourceBase {
      apiVersion: "apps/v1";
      kind: "DaemonSet";
      spec: DaemonSetSpec;
  }/** @public */
  export declare interface ResourcePod extends ResourceBase {
      kind: "Pod";
      spec: PodSpec;
  }/** @public */
  export declare interface ResourceService extends ResourceBase {
      kind: "Service";
      spec: ServiceSpec;
  }/** @public */
  export declare interface ResourceServiceAccount extends ResourceBase {
      kind: "ServiceAccount";
      automountServiceAccountToken?: boolean;
      imagePullSecrets?: {
          name: string;
      }[];
      secrets?: ObjectReference[];
  }/** @public */
  export declare interface ResourceConfigMap extends ResourceBase {
      kind: "ConfigMap";
      binaryData?: {
          [key: string]: string;
      };
      data?: {
          [key: string]: string;
      };
      /** @beta */
      immutable?: boolean;
  }/** @public */
  export declare interface ResourceSecret extends ResourceBase {
      kind: "Secret";
      data?: {
          [key: string]: string;
      };
      stringData?: {
          [key: string]: string;
      };
      type?: string;
  }/** @public */
  export declare interface ResourceCR extends ResourceBase {
      kind: string;
      spec: CRSpec;
  }/** @public */
  export declare interface Kubeconfig {
      apiVersion?: "v1";
      kind: "Config";
      "current-context": string;
      contexts: {
          name: string;
          context: {
              cluster: string;
              user: string;
          };
      }[];
      clusters: {
          name: string;
          cluster: {
              "certificate-authority-data": string;
              server: string;
          };
      }[];
      preferences?: unknown;
      users: {
          name: string;
          user: {
              "client-certificate-data"?: string;
              "client-key-data"?: string;
              "username"?: string;
              "password"?: string;
          };
      }[];
  }/** @public */
  export declare interface LabelSelector {
      /**
       * matchExpressions is a list of label selector requirements. The requirements are ANDed.
       */
      matchExpressions?: LabelSelectorRequirement[];
      /**
       * matchLabels is a map of `{key,value}`pairs. A single `{key,value}` in the matchLabels map
       * is equivalent to an element of matchExpressions, whose key field is "key", the operator
       * is "In", and the values array contains only "value". The requirements are ANDed.
       */
      matchLabels?: {
          [key: string]: string;
      };
  }/** @public */
  export declare interface LocalObjectReference {
      /**
       * Name of the referent.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names}
       */
      name: string;
  }/**
   * PodTemplateSpec from k8s API
   *
   * @public
   */
  export declare interface PodTemplateSpec {
      /**
       * Standard object's metadata.
       * More Info: {@link https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata}
       */
      metadata: Metadata;
      /**
       * Specification of the desired behavior of the pod.
       * More Info: {@link https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status}
       */
      spec: PodSpec;
  }/**
   * ObjectReference from k8s API
   *
   * @public
   */
  export declare interface ObjectReference {
      /**
       * If referring to a piece of an object instead of an entire object,
       * this string should contain a valid JSON/Go field access statement,
       * such as desiredState.manifest.containers[2].
       *
       * For example, if the object reference is to a container within a pod,
       * this would take on a value like: "spec.containers\{name\}" (where "name"
       * refers to the name of the container that triggered the event) or if no
       * container name is specified "spec.containers[2]"
       * (container with index 2 in this pod).
       * This syntax is chosen only to have some well-defined way of referencing a
       * part of an object.
       */
      fieldPath: string;
      /**
       * Name of the referent.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names}
       *
       */
      name: string;
      /**
       * Namespace of the referent.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/}
       */
      namespace: string;
      /**
       * Specific resourceVersion to which this reference is made, if any.
       *
       * More info: {@link https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency}
       */
      resourceVersion: string;
      /**
       * UID of the referent.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids}
       */
      uid: string;
  }/**
   * Make a {@link k8s.ClusterInfo} object suitable for use with k8s resources
   *
   * @remarks
   *
   * This function will take a set of options and generate a {@link k8s.ClusterInfo}
   * object that contains the kubeconfig, registryPrefix for private images, and any other
   * relevant information for the cluster
   *
   * See {@link k8s.MakeClusterInfoOptions} for information on how the information
   * is computed.
   *
   * @returns A {@link k8s.ClusterInfo} object.
   *
   * @public
   */
  export declare function makeClusterInfo(options: MakeClusterInfoOptions): Promise<ClusterInfo>;/** @internal */
  export declare function isResourcePodTemplate(x: any): x is AdaptElement<ResourcePod>;/**
   * Hook that allows a prop to be either an array of handle to k8s resources and values
   *
   * @param initial - initial value of the prop, before the handles are be resolved
   * @param notReady - is a marker value to indicate that a handle's value isn't available yet
   * @param kinds - an array of legal k8s Kinds that a prop handle can point to
   * @param thisResourceName - the name of the resource using the hook, for error messages
   * @param propName - the name of the prop being resolved, again for error messages
   *
   * @returns A two element array, the first element is the current value, the second the update function
   *
   * This hook will start by returning the initial value and an update function that updates
   * the value the hook returns.  The update function takes 2 arguments - the prop value which
   * is an array with a mix of values and handles to be resolved, and a function that receives
   * the elements that any handles point to along with that elements props.  This function
   * can be passed by the caller of update to resolve handles as appropriate for the component.
   *
   * For example, {@link k8s.ClusterRoleBinding} uses this hook to resolve the subjects prop,
   * which is an array of other objects (typically {@link ServiceAccount}) that a particular
   * {@link k8s.ClusterRole} should point to.  When ClusterRoleBinding calls the update method,
   * it passes a function that will convert a {@link k8s.Resource} element of Kind `ServiceAccount`
   * to the underlying `Subject` object that kubernetes expects, namely
   * `{ apiGroup: "", kind: "ServiceAccount", name: resourceIdToName(elem, deployID), namespace: <element namespace> }`
   *
   * @example
   * ```
   * function MyResource({ serviceAccountNames }: { serviceAccountNames: (string | Handle)[]}) {
   *   const { deployID } = useBuildHelpers();
   *   const [ resolvedServiceAccountNames, updateSANs] = useResources({
   *      initial: [],
   *      notReady: null,
   *      kinds: ["ServiceAccount"],
   *      thisResourceName: "MyResources",
   *      propName: "serviceAccountNames",
   *   });
   *
   *   updateSANs(serviceAccountNames, (e, props) => {
   *      return {
   *        apiGroup: (e.metadata.apiVersion?.split("/")[0]) || "",
   *        name: resourceElementToName(e, deployID),
   *        namespace: props.metadata.namespace,
   *      }
   *   });
   *
   *   return null;
   * }
   * ```
   *
   * @beta
   */
  export declare function useResources<ValT, NotReadyT>({ initial, notReady, kinds, thisResourceName, propName, }: {
      initial: ValT[];
      notReady: NotReadyT;
      kinds: string[];
      thisResourceName: string;
      propName: string;
  }): [
      (ValT | NotReadyT)[],
      (props: (ValT | Handle)[], f: (e: AdaptMountedElement, props: ResourceProps) => Promise<ValT> | ValT) => void
  ];/**
   * Hook to allow conversion of a prop that could be a value or a handle
   *
   * This function behaves similarly to {@link k8s.useResources}, but works for
   * a prop that is either a Handle or a single value instead of an array of
   * Handles and values.
   *
   * See {@link k8s.useResources} for more detailed documentation.
   *
   * @beta
   */
  export declare function useResource<ValT, NotReadyT>(opts: {
      initial: ValT | NotReadyT;
      notReady: NotReadyT;
      kinds: string[];
      thisResourceName: string;
      propName: string;
  }): [
      ValT | NotReadyT,
      (prop: ValT | Handle, f: (e: AdaptMountedElement, props: ResourceProps) => Promise<ValT> | ValT) => void
  ];/**
   * Options for {@link k8s.makeClusterInfo}
   *
   * @public
   */
  export declare interface MakeClusterInfoOptions {
      /**
       * A Javascript Object representing a valid kubeconfig, or a YAML string, or a path to a kubeconfig file.
       *
       * @remarks
       * If this is a Javascript object, it will be treated like a parsed kubeconfig.  If this is a string,
       * {@link k8s.makeClusterInfo} will first attempt to parse it as JSON.  If that fails, it will attempt
       * to parse it as YAML.  If that fails it will treat the string as a path of configs (like with the `KUBECONFIG`
       * environment variable).
       *
       * If kubeconfig is missing {@link k8s.makeClusterInfo} will use the `KUBECONFIG` environment variable to build
       * a suitable config using `kubectl config view --flatten` and return that as the kubeconfig in the resulting
       * {@link k8s.ClusterInfo}
       */
      kubeconfig?: Kubeconfig | string;
      /**
       * URL to the docker registry that this cluster uses to pull private images.
       *
       * @remarks
       * This is identical to the `registryPrefix` field in {@link k8s.ClusterInfo}.  It will
       * be returned verbatim in the resulting {@link k8s.ClusterInfo} object.
       */
      registryPrefix?: string | DockerSplitRegistryInfo;
  }/**
   * k8s ClusterRole resource
   *
   * @param propsIn - props for ServiceAccount as specifed in {@link k8s.ClusterRoleProps}
   *
   * @public
   */
  export declare function ClusterRole(propsIn: SFCDeclProps<ClusterRoleProps, typeof defaultProps>): Adapt.JSX.Element;/** @public */
  export declare function isClusterRoleProps(props: ResourceProps): props is ResourceProps & ResourceClusterRole;/** @internal */
  const clusterRoleResourceInfo: {
      kind: string;
      deployedWhen: () => true;
      statusQuery: (props: ResourcePropsWithConfig, observe: ObserveForStatus, buildData: BuildData) => Promise<any>;
      makeManifest: (manifest: Manifest, elem: AdaptElement<ResourceProps>, _deployID: string) => {
          aggregationRule: AggregationRule | undefined;
          rules: PolicyRule[] | undefined;
          apiVersion: string;
          kind: string;
          metadata: import("./manifest_support").MetadataInRequest;
          spec?: import("./DaemonSet").DaemonSetSpec | import("./common").CRSpec | import("./Pod").PodSpec | import("./Service").ServiceSpec | import("./Deployment").DeploymentSpec | undefined;
      };
  };/**
   * k8s ClusterRoleBinding resource
   *
   * @param propsIn - props for ServiceAccount as specifed in {@link k8s.ClusterRoleBindingProps}
   *
   * @public
   */
  export declare function ClusterRoleBinding(propsIn: SFCDeclProps<ClusterRoleBindingProps, typeof defaultProps>): Adapt.JSX.Element | null;/** @internal */
  const clusterRoleBindingResourceInfo: {
      kind: string;
      deployedWhen: () => true;
      statusQuery: (props: ResourcePropsWithConfig, observe: ObserveForStatus, buildData: BuildData) => Promise<any>;
      makeManifest: (manifest: Manifest, elem: AdaptElement<ResourceProps>, _deployID: string) => {
          roleRef: RoleRef;
          subjects: Subject[];
          apiVersion: string;
          kind: string;
          metadata: import("./manifest_support").MetadataInRequest;
          spec?: import("./DaemonSet").DaemonSetSpec | import("./common").CRSpec | import("./Pod").PodSpec | import("./Service").ServiceSpec | import("./Deployment").DeploymentSpec | undefined;
      };
  };/**
   * k8s ConfigMap resource
   *
   * @param propsIn - props for ConfigMap as specifed in {@link k8s.ConfigMapProps}
   *
   * @public
   */
  export declare function ConfigMap(propsIn: SFCDeclProps<ConfigMapProps, typeof defaultProps>): Adapt.JSX.Element;/** @internal */
  const configMapResourceInfo: {
      kind: string;
      deployedWhen: () => true;
      statusQuery: (props: ResourcePropsWithConfig, observe: ObserveForStatus, buildData: BuildData) => Promise<any>;
      makeManifest: (manifest: Manifest, elem: AdaptElement<ResourceProps>, _deployID: string) => {
          data: {
              [key: string]: string;
          } | undefined;
          binaryData: {
              [key: string]: string;
          } | undefined;
          immutable: boolean | undefined;
          apiVersion: string;
          kind: string;
          metadata: import("./manifest_support").MetadataInRequest;
          spec?: import("./DaemonSet").DaemonSetSpec | import("./common").CRSpec | import("./Pod").PodSpec | import("./Service").ServiceSpec | import("./Deployment").DeploymentSpec | undefined;
      };
  };/**
   * Low level utility function to translate from the abstract {@link Container}
   * component props ({@link ContainerProps}) to {@link k8s.K8sContainerProps}
   * to be used in a {@link k8s.K8sContainer}.
   * @remarks
   * Note: The `image` property in the passed in {@link ContainerProps} must
   * be a `string`, not a `Handle`.
   * In most cases, it is preferable to use the {@link k8s.Container} component
   * instead, which is designed specifically to deal with this issue.
   *
   * @param abstractProps - The abstract {@link ContainerProps} to translate from.
   * @param k8sProps - Props that are specific to the {@link k8s.K8sContainer}
   *     component that should be merged into the resulting returned
   *     {@link k8s.K8sContainerProps} object.
   * @public
   */
  export declare function k8sContainerProps(abstractProps: FromContainerProps, k8sProps?: Partial<K8sContainerProps>): K8sContainerProps;/**
   * Tests whether an element is a {@link k8s.K8sContainer} element
   * @param x - element to test
   * @returns `true` if element is a {@link k8s.K8sContainer}, `false` otherwise
   *
   * @remarks
   * Acts as a TypeScript type assertion that will assert that `x` is `AdaptElement<K8sContainerProps>`
   *
   * @public
   */
  export declare function isK8sContainerElement(x: AdaptElement): x is AdaptElement<K8sContainerProps>;/**
   * Component that implements the abstract {@link Container} interface and
   * translates to a Kubernetes-specific {@link k8s.K8sContainer}.
   * @public
   */
  export declare function Container(props: ContainerProps): Adapt.JSX.Element | null;/** @public */
  export declare interface VolumeMount {
      /**
       * Path within the container at which the volume should be mounted.
       *
       * Must not contain ':'.
       */
      mountPath: string;
      /**
       * mountPropagation determines how mounts are propagated from the host to container and the other way around.
       *
       * When not set, MountPropagationNone is used. This field is beta in 1.10.
       *
       * @defaultValue MountPropagationNone
       */
      mountPropagation?: string;
      /** This must match the Name of a Volume. */
      name: string;
      /**
       * Mounted read-only if true, read-write otherwise (false or unspecified).
       *
       * @defaultValue false
       */
      readOnly?: boolean;
      /**
       * Path within the volume from which the container's volume should be mounted.
       *
       * Defaults to "" (volume's root).
       *
       * @defaultValue ""
       */
      subPath?: string;
      /**
       * Expanded path within the volume from which the container's volume should be mounted.
       *
       * Behaves similarly to SubPath but environment variable references $(VAR_NAME)
       * are expanded using the container's environment.
       *
       * Defaults to "" (volume's root).
       *
       * SubPathExpr and SubPath are mutually exclusive.
       *
       * @defaultValue ""
       */
      subPathExpr?: string;
  }/** @public */
  export declare interface ConfigMapEnvSource {
      /**
       * Name of the referent.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names}
       */
      name?: string;
      /**
       * Specify whether the ConfigMap must be defined
       */
      optional?: boolean;
  }/** @public */
  export declare interface SecretEnvSource {
      /**
       * Name of the referent.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names}
       */
      name?: string;
      /**
       * Specify whether the Secret must be defined
       */
      optional?: boolean;
  }/** @public */
  export declare interface EnvFromSource {
      /** The ConfigMap to select from */
      configMapRef?: ConfigMapEnvSource;
      /** An optional identifier to prepend to each key in the ConfigMap. Must be a C_IDENTIFIER. */
      prefix?: string;
      /** SecretEnvSource	The Secret to select from */
      secretRef?: SecretEnvSource;
  }/** @public */
  export declare interface ExecAction {
      /**
       * Command is the command line to execute inside the container.
       *
       * The working directory for the command is root ('/') in the container's filesystem.
       * The command is simply exec'd, it is not run inside a shell,
       * so traditional shell instructions ('|', etc) won't work.
       * To use a shell, you need to explicitly call out to that shell.
       *
       * Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
       */
      command: string[];
  }/** @public */
  export declare interface HTTPGetAction {
      /**
       * Host name to connect to, defaults to the pod IP.
       *
       * You probably want to set "Host" in httpHeaders instead.
       */
      host?: string;
      /** Custom headers to set in the request. HTTP allows repeated headers. */
      httpHeaders?: {
          name: string;
          value: string;
      }[];
      /** Path to access on the HTTP server. */
      path: string;
      /**
       * Name or number of the port to access on the container.
       *
       * Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
       */
      port: number | string;
      /**
       * Scheme to use for connecting to the host.
       *
       * @defaultValue HTTP.
       */
      scheme?: string;
  }/** @public */
  export declare interface TCPSocketAction {
      /** Host name to connect to, defaults to the pod IP. */
      host?: string;
      /**
       * Number or name of the port to access on the container.
       *
       * Number must be in the range 1 to 65535.
       * Name must be an IANA_SVC_NAME.
       */
      port: string | number;
  }/** @public */
  export declare interface Probe {
      /**
       * Exec specifies the action to take.
       *
       * Only one of exec, httpGet, or tcpSocket should be specified
       */
      exec?: ExecAction;
      /**
       * Minimum consecutive failures for the probe to be considered failed after having succeeded.
       *
       * Defaults to 3. Minimum value is 1.
       *
       * @defaultValue 3
       */
      failureThreshold?: number;
      /** Specifies the http request to perform. */
      httpGet?: HTTPGetAction;
      /**
       *  Seconds after the container has started before liveness probes are initiated.
       *  More info: {@link https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes}
       */
      initialDelaySeconds?: number;
      /** How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. */
      periodSeconds?: number;
      /**
       * Minimum consecutive successes for the probe to be considered successful after having failed.
       *
       * Must be 1 for liveness and startup. Minimum value is 1.
       *
       * @defaultValue 1
       */
      successThreshold?: number;
      /**
       * Specifies an action involving a TCP port.
       *
       * TCP hooks not yet supported
       */
      tcpSocket?: TCPSocketAction;
      /**
       * Number of seconds after which the probe times out.
       *
       * Defaults to 1 second. Minimum value is 1.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes}
       *
       * @defaultValue 1
       */
      timeoutSeconds?: number;
  }/** @public */
  export declare interface ResourceRequirements {
      /**
       * Limits describes the maximum amount of compute resources allowed.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/}
       */
      limits?: {
          [key: string]: any;
      };
      /**
       * Describes the minimum amount of compute resources required.
       *
       * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
       * otherwise to an implementation-defined value.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/}
       */
      requests?: {
          [key: string]: any;
      };
  }/** @public */
  export declare type Handler = {
      exec: ExecAction;
  } | {
      httpGet: HTTPGetAction;
  } | {
      tcpSocket: TCPSocketAction;
  };/** @public */
  export declare interface Lifecycle {
      /**
       * PostStart is called immediately after a container is created.
       *
       * If the handler fails, the container is terminated and restarted according to its restart policy.
       * Other management of the container blocks until the hook completes.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks}
       */
      postStart: Handler;
      /**
       * Called immediately before a container is terminated due to an API request or management event such as liveness/startup probe failure, preemption, resource contention, etc.
       *
       * The handler is not called if the container crashes or exits.
       * The reason for termination is passed to the handler.
       * The Pod's termination grace period countdown begins before the PreStop hooked is executed.
       * Regardless of the outcome of the handler, the container will eventually terminate within the Pod's termination grace period.
       * Other management of the container blocks until the hook completes or until the termination grace period is reached.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks}
       */
      preStop: Handler;
  }/** @public */
  export declare interface VolumeDevice {
      /** The path inside of the container that the device will be mapped to. */
      devicePath: string;
      /** name must match the name of a persistentVolumeClaim in the pod */
      name: string;
  }/**
   * Resource spec for a Kubernetes container.
   * See the Kubernetes
   * {@link https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#container-v1-core | API docs }
   * for more details.
   * @public
   */
  export declare interface ContainerSpec {
      /**
       * Arguments to the entrypoint.
       *
       * The docker image's CMD is used if this is not provided.
       * Variable references $(VAR_NAME) are expanded using the container's environment.
       * If a variable cannot be resolved, the reference in the input string will be unchanged.
       * The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME).
       * Escaped references will never be expanded, regardless of whether the variable exists or not.
       * Cannot be updated.
       * More info: {@link https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell}
       */
      args?: string[];
      /**
       * Entrypoint array.
       *
       * Not executed within a shell.
       * The docker image's ENTRYPOINT is used if this is not provided.
       * Variable references $(VAR_NAME) are expanded using the container's environment.
       * If a variable cannot be resolved, the reference in the input string will be unchanged.
       * The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME).
       * Escaped references will never be expanded, regardless of whether the variable exists or not.
       * Cannot be updated.
       * More info: {@link https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell}
       */
      command?: string[];
      /**
       * List of environment variables to set in the container. Cannot be updated.
       */
      env?: EnvVar[];
      /**
       * List of sources to populate environment variables in the container.
       *
       * The keys defined within a source must be a C_IDENTIFIER.
       * All invalid keys will be reported as an event when the container is starting.
       * When a key exists in multiple sources, the value associated with the last source will take precedence.
       * Values defined by an Env with a duplicate key will take precedence. Cannot be updated.
       */
      envFrom?: EnvFromSource[];
      /**
       * Docker image name.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/containers/images}
       *
       * This field is optional to allow higher level config management to default or override container
       * images in workload controllers like Deployments and StatefulSets.
       */
      image?: string;
      /**
       * Image pull policy.
       *
       * One of Always, Never, IfNotPresent.
       * Defaults to Always if :latest tag is specified,
       * or IfNotPresent otherwise.
       * Cannot be updated.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/containers/images#updating-images}
       */
      imagePullPolicy?: "Always" | "Never" | "IfNotPresent";
      /**
       * List of sources to populate environment variables in the container.
       *
       * The keys defined within a source must be a C_IDENTIFIER.
       * All invalid keys will be reported as an event when the container is starting.
       * When a key exists in multiple sources, the value associated with the last source will take precedence.
       * Values defined by an Env with a duplicate key will take precedence. Cannot be updated.
       */
      lifecycle?: Lifecycle;
      /**
       * Periodic probe of container liveness.
       *
       * Container will be restarted if the probe fails.
       * Cannot be updated.
       * More info: {@link https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes}
       */
      livenessProbe?: Probe;
      /**
       * Name of the container specified as a DNS_LABEL.
       *
       * Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated.
       */
      name: string;
      /**
       * List of ports to expose from the container.
       *
       * Exposing a port here gives the system additional information about the network connections a container uses,
       * but is primarily informational.
       * Not specifying a port here DOES NOT prevent that port from being exposed.
       * Any port which is listening on the default "0.0.0.0" address inside a container will be accessible from
       * the network.
       * Cannot be updated.
       */
      ports?: ContainerPort[];
      /**
       * Periodic probe of container service readiness.
       *
       * Container will be removed from service endpoints if the probe fails.
       * Cannot be updated.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes}
       */
      readinessProbe?: Probe;
      /**
       * Compute Resources required by this container.
       *
       * Cannot be updated.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/}
       */
      resources?: ResourceRequirements;
      /**
       * Security options the pod should run with.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/policy/security-context/}
       * More info: {@link https://kubernetes.io/docs/tasks/configure-pod-container/security-context/}
       */
      securityContext?: PodSecurityContext;
      /**
       * Indicates that the Pod has successfully initialized.
       *
       * If specified, no other probes are executed until this completes successfully.
       * If this probe fails, the Pod will be restarted, just as if the livenessProbe failed.
       * This can be used to provide different probe parameters at the beginning of a Pod's lifecycle,
       * when it might take a long time to load data or warm a cache, than during steady-state operation.
       *
       * This cannot be updated.
       * This is a beta feature enabled by the StartupProbe feature flag.
       * More info: {@link https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes}
       */
      startupProbe?: Probe;
      /**
       * Whether this container should allocate a buffer for stdin in the container runtime.
       *
       * If this is not set, reads from stdin in the container will always result in EOF. Default is false.
       */
      stdin?: boolean;
      /**
       * Whether the container runtime should close the stdin channel after it has been opened by a single attach.
       *
       * When stdin is true the stdin stream will remain open across multiple attach sessions.
       * If stdinOnce is set to true, stdin is opened on container start,
       * is empty until the first client attaches to stdin,
       * and then remains open and accepts data until the client disconnects,
       * at which time stdin is closed and remains closed until the container is restarted.
       * If this flag is false, a container processes that reads from stdin will never receive an EOF. Default is false
       */
      stdinOnce?: boolean;
      /**
       * Path at which the file to which the container's termination message will be written is mounted into the container's filesystem.
       *
       * Message written is intended to be brief final status, such as an assertion failure message.
       * Will be truncated by the node if greater than 4096 bytes.
       * The total message length across all containers will be limited to 12kb.
       * Defaults to /dev/termination-log. Cannot be updated.
       */
      terminationMessagePath?: string;
      /**
       * Indicate how the termination message should be populated.
       *
       * File will use the contents of terminationMessagePath to populate the container status
       * message on both success and failure. FallbackToLogsOnError will use the last chunk of
       * container log output if the termination message file is empty and the container exited
       * with an error.
       * The log output is limited to 2048 bytes or 80 lines, whichever is smaller.
       * Defaults to File.
       * Cannot be updated.
       *
       * @defaultValue File
       */
      terminationMessagePolicy?: "File" | "FallbackToLogsOnError";
      /**
       * Whether this container should allocate a TTY for itself, also requires 'stdin' to be true.
       *
       * @defaultValue false
       */
      tty?: boolean;
      /**
       * volumeDevices is the list of block devices to be used by the container.
       */
      volumeDevices?: VolumeDevice[];
      /** volumeDevices is the list of block devices to be used by the container. */
      volumeMounts?: VolumeMount[];
      /**
       * Container's working directory.
       *
       * If not specified, the container runtime's default will be used,
       * which might be configured in the container image.
       * Cannot be updated.
       */
      workingDir?: string;
  }/**
   * Props for the Kubernetes-specific {@link k8s.K8sContainer} component.
   * @public
   */
  export declare interface K8sContainerProps extends ContainerSpec {
  }/** @public */
  export declare interface ContainerPort {
      /**
       * Number of port to expose on the pod's IP address.
       * @remarks
       * This must be a valid integer port number, `0 < x < 65536`.
       */
      containerPort: number;
      /** What host IP to bind the external port to. */
      hostIP?: string;
      /**
       * Number of port to expose on the host.
       * @remarks
       * If specified, this must be a valid integer port number,
       * `0 < x < 65536`. If HostNetwork is specified,
       * this must match ContainerPort. Most containers do not need this.
       */
      hostPort?: number;
      /**
       * A unique-within-pod name for the container
       * @remarks
       * If specified, this must be an IANA_SVC_NAME and unique within the pod.
       * Each named port in a pod must have a unique name. Name for the port
       * that can be referred to by services.
       */
      name?: string;
      /** Protocol for port. Must be UDP or TCP. Defaults to "TCP". */
      protocol?: string;
  }/** @public */
  export declare type EnvVar = EnvVarSimple | EnvVarFrom;/** @public */
  export declare interface EnvVarSimple {
      /** Name of the environment variable. Must be a C_IDENTIFIER. */
      name: string;
      /**
       * Variable references $(VAR_NAME) are expanded using the previous defined
       * environment variables in the container and any service environment
       * variables. If a variable cannot be resolved, the reference in the input
       * string will be unchanged. The $(VAR_NAME) syntax can be escaped with a
       * double $$, ie: $$(VAR_NAME). Escaped references will never be expanded,
       * regardless of whether the variable exists or not. Defaults to "".
       */
      value: string;
  }/** @public */
  export declare interface EnvVarFrom {
      /** Source for the environment variable's value. Cannot be used if value is not empty. */
      valueFrom?: any;
  }/**
   * See {@link k8s.k8sContainerProps}.
   * @public
   */
  export declare type FromContainerProps = ReplaceT<ContainerProps, {
      image: string;
  }> & BuiltinProps;/**
   * Kubernetes-specific container.
   * @public
   */
  export declare class K8sContainer extends PrimitiveComponent<K8sContainerProps> {
      static defaultProps: {
          imagePullPolicy: string;
      };
      validate(): undefined;
  }/**
   * Props for {@link k8s.Container}.
   * @public
   */
  export declare interface ContainerProps extends SFCDeclProps<ContainerProps> {
      /**
       * Additional {@link k8s.K8sContainerProps}-specific props that should be
       * added to the instantiated {@link k8s.K8sContainer}.
       */
      k8sContainerProps?: Partial<K8sContainerProps>;
  }/**
   * Spec for {@link k8s.DaemonSet} for use in {@link k8s.Resource}
   *
   * @public
   */
  export declare type DaemonSetSpec = Exclude<DaemonSetProps, ResourceBase> & {
      template: PodTemplateSpec;
  };/**
   * Component for Kubernetes DaemonSet
   *
   * @public
   */
  export declare class DaemonSet extends DeferredComponent<DaemonSetProps> {
      static defaultProps: {
          metadata: {};
          minReadySeconds: number;
          revisionHistoryLimit: number;
          updateStrategy: {
              type: string;
              rollingUpdate: {
                  maxUnavailable: number;
              };
          };
      };
      constructor(props: DaemonSetProps);
      build(helpers: BuildHelpers): Adapt.JSX.Element;
      status(_observe: ObserveForStatus, buildData: BuildData): Promise<Adapt.Status | undefined>;
  }/** @internal */
  const daemonSetResourceInfo: {
      kind: string;
      deployedWhen: typeof deployedWhen;
      statusQuery: (props: ResourcePropsWithConfig, observe: ObserveForStatus, buildData: BuildData) => Promise<any>;
  };/** @public */
  export declare interface DeploymentUpdateStrategyRecreate {
      type: "Recreate";
  }/** @public */
  export declare interface RollingUpdateDeployment {
      /**
       * The maximum number of pods that can be scheduled above the desired number of pods.
       *
       * Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
       * This can not be 0 if MaxUnavailable is 0.
       * Absolute number is calculated from percentage by rounding up.
       * Defaults to 25%.
       *
       * @example
       * When this is set to 30%, the new ReplicaSet can be scaled up immediately when the rolling update starts,
       * such that the total number of old and new pods do not exceed 130% of desired pods. Once old pods have been
       * killed, new ReplicaSet can be scaled up further, ensuring that total number of pods running at any time
       * during the update is at most 130% of desired pods.
       */
      maxSurge?: number | string;
      /**
       * The maximum number of pods that can be unavailable during the update.
       *
       * Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
       * Absolute number is calculated from percentage by rounding down.
       * This can not be 0 if MaxSurge is 0. Defaults to 25%.
       *
       * @example
       * When this is set to 30%, the old ReplicaSet can be scaled down to 70% of desired pods
       * immediately when the rolling update starts. Once new pods are ready, old ReplicaSet
       * can be scaled down further, followed by scaling up the new ReplicaSet, ensuring that
       * the total number of pods available at all times during the update is at least 70% of
       * desired pods.
       */
      maxUnavailable?: number | string;
  }/**
   * Spec for {@link k8s.Deployment} for use in {@link k8s.Resource}
   *
   * @public
   */
  export declare type DeploymentSpec = Exclude<DeploymentProps, ResourceBase> & {
      template: PodTemplateSpec;
  };/**
   * Props for {@link k8s.Deployment}
   *
   * @public
   */
  export declare interface DeploymentProps extends WithChildren {
      /** Information about the k8s cluster (ip address, auth info, etc.) */
      config: ClusterInfo;
      /** k8s metadata */
      metadata: Metadata;
      /**
       * The minimum number of seconds for which a newly created pod should
       * be ready without any of its container crashing, for it to be considered
       * available. Defaults to 0 (pod will be considered available as soon as it is ready).
       */
      minReadySeconds: number;
      /** Indicates that the deployment is paused */
      paused: boolean;
      /**
       * The maximum time in seconds for a deployment to make progress before it is considered to be failed.
       *
       * The deployment controller will continue to process failed deployments and a condition with a
       * ProgressDeadlineExceeded reason will be surfaced in the deployment status. Note that progress
       * will not be estimated during the time a deployment is paused. Defaults to 600s.
       */
      progressDeadlineSeconds: number;
      /**
       * Number of desired pods.
       *
       * Defaults to 1. 0 is not allowed.
       *
       * @defaultValue 1
       */
      replicas: number;
      /**
       * The number of old ReplicaSets to retain to allow rollback.
       *
       * This is a pointer to distinguish between explicit zero and not specified. Defaults to 10.
       *
       * @defaultValue 10
       */
      revisionHistoryLimit: number;
      /**
       * Label selector for pods.
       *
       * Existing ReplicaSets whose pods are selected by this will be the ones affected by this deployment.
       * It must match the pod template's labels.
       *
       * @remarks
       *
       * With Adapt, this is optional.  If not specified, adapt will pick a selector that will work with the pods
       * it creates as part of this {@link k8s.Deployment}
       */
      selector?: LabelSelector;
      /**
       * An deployment strategy to use to replace existing pods with new ones
       */
      strategy: DeploymentUpdateStrategy;
  }/**
   * Component for Kubernetes Deployment
   *
   * @public
   */
  export declare class Deployment extends DeferredComponent<DeploymentProps> {
      static defaultProps: {
          metadata: {};
          paused: boolean;
          replicas: number;
          progressDeadlineSeconds: number;
          minReadySeconds: number;
          revisionHistoryLimit: number;
          strategy: {
              type: string;
              rollingUpdate: {
                  maxSurge: string;
                  maxUnavailable: string;
              };
          };
      };
      constructor(props: DeploymentProps);
      build(helpers: BuildHelpers): Adapt.JSX.Element | null;
      deployedWhen: () => true | Adapt.Waiting;
      status(_observe: ObserveForStatus, buildData: BuildData): Promise<Adapt.Status | undefined>;
  }/** @internal */
  const deploymentResourceInfo: {
      kind: string;
      deployedWhen: typeof deployedWhen;
      statusQuery: (props: ResourcePropsWithConfig, observe: ObserveForStatus, buildData: BuildData) => Promise<any>;
  };/**
   * Type assertion to see if an element is both a {@link k8s.Resource | Resource}
   * and a {@link @adpt/core#FinalElement | FinalElement}
   *
   * @param e - element to test
   * @returns `true` if e is both a FinalElement and a {@link k8s.Resource | Resource}, `false` otherwise
   *
   * @public
   */
  export declare function isResourceFinalElement(e: AdaptElement): e is FinalDomElement<ResourceProps & Adapt.BuiltinProps>;/**
   * Tests whether a ResourceProps is for a template object
   *
   * @public
   */
  export declare function isResourcePropsWithConfig(x: ResourceProps & Partial<BuiltinProps>): x is ResourcePropsWithConfig & Partial<BuiltinProps>;/**
   * Tests to see if an object is a {@link k8s.Resource} element
   * @param x - object to test
   * @returns true if object is an AdaptElement of type {@link k8s.Resource}
   *
   * @public
   */
  export declare function isResource(x: any): x is AdaptElement<ResourceProps>;/**
   * Primitive Component recognized by the k8s plugin to represent resources
   * @public
   */
  export declare class Resource extends Action<ResourceProps> {
      defaultProps: {
          apiVersion: "v1";
          con: false;
      };
      manifest_: Manifest;
      constructor(props: ResourceProps);
      validate(): "Resource elements cannot have children" | undefined;
      shouldAct(op: ChangeType, ctx: ActionContext): Promise<ShouldAct>;
      action(op: ChangeType, ctx: ActionContext): Promise<void>;
      deployedWhen: (goalStatus: GoalStatus, helpers: DeployHelpers) => Promise<true | Adapt.Waiting | Adapt.Waiting[]>;
      status(observe: ObserveForStatus, buildData: BuildData): Promise<any>;
      private mountedElement;
      private manifest;
  }/** @internal */
  export declare function makePodManifest(props: PodProps & BuiltinProps, data: {
      volumes?: Volume[];
      serviceAccountName?: string;
  }): {
      kind: string;
      metadata: Metadata;
      spec: PodSpec;
  };/**
   * Tests whether x is a Pod element
   *
   * @param x - value to test
   * @returns `true` if x is a Pod element, false otherwise
   *
   * @public
   */
  export declare function isPod(x: any): x is AdaptElement<PodProps>;/** @public */
  export declare interface NodeSelectorRequirement {
      /** The label key that the selector applies to. */
      key: string;
      /**
       * Represents a key's relationship to a set of values.
       *
       * Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
       */
      operator: "In" | "NotIn" | "Exists" | "DoesNotExist" | "Gt" | "Lt";
      /**
       * Values for operator
       *
       * If the operator is In or NotIn, the values array must be non-empty.
       * If the operator is Exists or DoesNotExist, the values array must be empty.
       * If the operator is Gt or Lt, the values array must have a single element,
       * which will be interpreted as an integer.
       * This array is replaced during a strategic merge patch.
       */
      values: string[];
  }/** @public */
  export declare interface NodeSelectorTerm {
      /** A list of node selector requirements by node's labels. */
      matchExpressions?: NodeSelectorRequirement[];
      /** A list of node selector requirements by node's fields. */
      matchFields?: NodeSelectorRequirement[];
  }/** @public */
  export declare interface PreferredSchedulingTerm {
      /**
       * A node selector term, associated with the corresponding weight.
       */
      preference: NodeSelectorTerm;
      /** Weight associated with matching the corresponding nodeSelectorTerm, in the range 1-100. */
      weight: number;
  }/** @public */
  export declare interface NodeSelector {
      /** A list of node selector terms. The terms are ORed */
      nodeSelectorTerms: NodeSelectorTerm[];
  }/** @public */
  export declare interface NodeAffinity {
      /** The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding "weight" to the sum if the node matches the corresponding matchExpressions; the node(s) with the highest sum are the most preferred. */
      preferredDuringSchedulingIgnoredDuringExecution?: PreferredSchedulingTerm[];
      /** If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to an update), the system may or may not try to eventually evict the pod from its node. */
      requiredDuringSchedulingIgnoredDuringExecution?: NodeSelector;
  }/** @public */
  export declare interface PodAffinityTerm {
      /**
       * Label query over a set of resources, in this case pods.
       */
      labelSelector: LabelSelector;
      /** Specifies which namespaces the labelSelector applies to (matches against); null or empty list means "this pod's namespace" */
      namespaces?: string[];
      /** This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed. */
      topologyKey: string;
  }/** @public */
  export declare interface WeightedPodAffinityTerm {
      /** A pod affinity term, associated with the corresponding weight. */
      podAffinityTerm: PodAffinityTerm;
      /**
       * weight associated with matching the corresponding podAffinityTerm, in the range 1-100.
       */
      weight: number;
  }/** @public */
  export declare interface PodAffinity {
      /**
       * The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions.
       *
       * The node that is most preferred is the one with the greatest sum of weights,
       * i.e. for each node that meets all of the scheduling requirements (resource request,
       * requiredDuringScheduling affinity expressions, etc.), compute a sum by iterating
       * through the elements of this field and adding "weight" to the sum if the node has pods
       * which matches the corresponding podAffinityTerm; the node(s) with the highest sum are the most preferred.
       */
      preferredDuringSchedulingIgnoredDuringExecution: WeightedPodAffinityTerm[];
      /**
       * If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node.
       *
       * If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system may or may not try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each podAffinityTerm are intersected, i.e. all terms must be satisfied.
       */
      requiredDuringSchedulingIgnoredDuringExecution: PodAffinityTerm[];
  }/** @public */
  export declare interface PodAntiAffinity {
      /** The scheduler will prefer to schedule pods to nodes that satisfy the anti-affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling anti-affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the node(s) with the highest sum are the most preferred. */
      preferredDuringSchedulingIgnoredDuringExecution: WeightedPodAffinityTerm[];
      /** If the anti-affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the anti-affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system may or may not try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each podAffinityTerm are intersected, i.e. all terms must be satisfied. */
      requiredDuringSchedulingIgnoredDuringExecution: PodAffinity;
  }/** @public */
  export declare interface Affinity {
      /** Describes node affinity scheduling rules for the pod. */
      nodeAffinity: NodeAffinity;
      /** Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)). */
      podAffinity: PodAffinity;
      /** PodAntiAffinity	Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)). */
      podAntiAffinity: PodAntiAffinity;
  }/** @public */
  export declare interface PodDNSConfigOption {
      name: string;
      value?: string;
  }/** @public */
  export declare interface PodDNSConfig {
      /**
       * A list of DNS name server IP addresses.
       *
       * This will be appended to the base nameservers generated from DNSPolicy. Duplicated nameservers will be removed.
       */
      nameservers: string[];
      /**
       * A list of DNS resolver options.
       *
       * This will be merged with the base options generated from DNSPolicy.
       * Duplicated entries will be removed.
       * Resolution options given in Options will override those that appear in the base DNSPolicy.
       */
      options: PodDNSConfigOption[];
      /**
       * A list of DNS search domains for host-name lookup.
       *
       * This will be appended to the base search paths generated from DNSPolicy. Duplicated search paths will be removed.
       */
      searches: string[];
  }/** @public */
  export declare interface PodReadinessGate {
      /** Refers to a condition in the pod's condition list with matching type. */
      conditionType: string;
  }/** @public */
  export declare interface SELinuxOptions {
      /** SELinux level label that applies to the container. */
      level: string;
      /** SELinux role label that applies to the container. */
      role: string;
      /** SELinux type label that applies to the container. */
      type: string;
      /** SELinux user label that applies to the container */
      user: string;
  }/** @public */
  export declare interface SeccompProfile {
      /**
       * Indicates a profile defined in a file on the node should be used.
       *
       * The profile must be preconfigured on the node to work.
       * Must be a descending path, relative to the kubelet's configured seccomp profile location.
       * Must only be set if type is "Localhost".
       */
      localhostProfile?: string;
      /**
       * Indicates which kind of seccomp profile will be applied.
       *
       * Valid options are:
       * * Localhost - a profile defined in a file on the node should be used.
       * * RuntimeDefault - the container runtime default profile should be used.
       * * Unconfined - no profile should be applied.
       */
      type: "Localhost" | "RuntimeDefault" | "Unconfined";
  }/** @public */
  export declare interface Sysctl {
      name: string;
      value: string;
  }/** @public */
  export declare interface WindowsSecurityContextOptions {
      /**
       * The GMSA admission webhook ({@link https://github.com/kubernetes-sigs/windows-gmsa}) inlines the contents of the GMSA credential spec named by the GMSACredentialSpecName field.
       */
      gmsaCredentialSpec?: string;
      /**
       * GMSACredentialSpecName is the name of the GMSA credential spec to use.
       */
      gmsaCredentialSpecName?: string;
      /**
       * The UserName in Windows to run the entrypoint of the container process.
       *
       * Defaults to the user specified in image metadata if unspecified. May also be set in PodSecurityContext.
       * If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
       */
      runAsUserName?: string;
  }/** @public */
  export declare interface PodSecurityContext {
      /**
       * A special supplemental group that applies to all containers in a pod.
       *
       * Some volume types allow the Kubelet to change the ownership of that volume to be owned by the pod:
       *
       * 1. The owning GID will be the FSGroup
       * 2. The setgid bit is set (new files created in the volume will be owned by FSGroup)
       * 3. The permission bits are OR'd with rw-rw----
       *
       * If unset, the Kubelet will not modify the ownership and permissions of any volume.
       */
      fsGroup?: number;
      /**
       * Defines behavior of changing ownership and permission of the volume before being exposed inside Pod.
       *
       * This field will only apply to volume types which support fsGroup based ownership(and permissions).
       * It will have no effect on ephemeral volume types such as: secret, configmaps and emptydir.
       * Valid values are "OnRootMismatch" and "Always". If not specified defaults to "Always".
       *
       * @defaultValue Always
       */
      fsGroupChangePolicy?: "OnRootMismatch" | "Always";
      /**
       * The GID to run the entrypoint of the container process.
       *
       * Uses runtime default if unset. May also be set in SecurityContext.
       * If set in both SecurityContext and PodSecurityContext, the value specified in
       * SecurityContext takes precedence for that container.
       */
      runAsGroup?: number;
      /**
       * Indicates that the container must run as a non-root user.
       *
       * If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and
       * fail to start the container if it does. If unset or false, no such validation will be performed.
       * May also be set in SecurityContext.
       * If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
       */
      runAsNonRoot?: boolean;
      /**
       * The UID to run the entrypoint of the container process.
       *
       * Defaults to user specified in image metadata if unspecified.
       * May also be set in SecurityContext.
       * If set in both SecurityContext and PodSecurityContext, the value specified in
       * SecurityContext takes precedence for that container.
       */
      runAsUser?: number;
      /**
       * The SELinux context to be applied to all containers.
       *
       * If unspecified, the container runtime will allocate a random SELinux context for each container.
       * May also be set in SecurityContext.
       * If set in both SecurityContext and PodSecurityContext, the value specified in
       * SecurityContext takes precedence for that container.
       */
      seLinuxOptions?: SELinuxOptions;
      /**
       * The seccomp options to use by the containers in this pod.
       */
      seccompProfile?: SeccompProfile;
      /**
       * 	A list of groups applied to the first process run in each container, in addition to the container's primary GID.
       *
       *  If unspecified, no groups will be added to any container.
       */
      supplementalGroups?: number[];
      /**
       * Sysctls hold a list of namespaced sysctls used for the pod.
       *
       * Pods with unsupported sysctls (by the container runtime) might fail to launch.
       */
      sysctls?: Sysctl[];
      /**
       * The Windows specific settings applied to all containers.
       *
       * If unspecified, the options within a container's SecurityContext will be used.
       * If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
       */
      windowsOptions: WindowsSecurityContextOptions;
  }/** @public */
  export declare interface Toleration {
      /**
       * Indicates the taint effect to match.
       *
       * Empty means match all taint effects.
       * When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
       */
      effect?: "NoSchedule" | "PreferNoSchedule" | "NoExecute";
      /**
       * The taint key that the toleration applies to.
       *
       * Empty means match all taint keys.
       * If the key is empty, operator must be Exists;
       * this combination means to match all values and all keys.
       */
      key?: string;
      /**
       * Represents a key's relationship to the value.
       *
       * Valid operators are Exists and Equal.
       * Defaults to Equal.
       * Exists is equivalent to wildcard for value, so that a pod can tolerate all taints of a particular category.
       *
       * @defaultValue Equal
       */
      operator?: "Exists" | "Equal";
      /**
       * Represents the period of time the toleration (which must be of effect NoExecute, otherwise this field is ignored) tolerates the taint.
       *
       * By default, it is not set, which means tolerate the taint forever (do not evict).
       * Zero and negative values will be treated as 0 (evict immediately) by the system.
       */
      tolerationSeconds?: number;
      /**
       * Value is the taint value the toleration matches to.
       *
       * If the operator is Exists, the value should be empty, otherwise just a regular string.
       */
      value?: string;
  }/** @public */
  export declare interface TopologySpreadConstraint {
      /**
       * Used to find matching pods.
       *
       * Pods that match this label selector are counted to determine the
       * number of pods in their corresponding topology domain.
       */
      labelSelector: LabelSelector;
      /**
       * Describes the degree to which pods may be unevenly distributed.
       *
       * When `whenUnsatisfiable=DoNotSchedule`, it is the maximum permitted
       * difference between the number of matching pods in the target topology
       * and the global minimum.
       * For example, in a 3-zone cluster, MaxSkew is set to 1, and pods with
       * the same labelSelector spread as 1/1/0: | zone1 | zone2 | zone3 | | P | P | |
       * - if MaxSkew is 1, incoming pod can only be scheduled to zone3 to become 1/1/1;
       *   scheduling it onto zone1(zone2) would make the ActualSkew(2-0) on zone1(zone2) violate MaxSkew(1).
       * - if MaxSkew is 2, incoming pod can be scheduled onto any zone.
       * When `whenUnsatisfiable=ScheduleAnyway`, it is used to give higher precedence to topologies that satisfy it.
       * It's a required field. Default value is 1 and 0 is not allowed.
       *
       * @example
       *
       * @defaultValue 1
       */
      maxSkew: number;
      /**
       * The key of node labels.
       *
       * Nodes that have a label with this key and identical values are considered to be in the same topology.
       * We consider each \<key, value\> as a "bucket", and try to put balanced number of pods into each bucket.
       * It's a required field.
       */
      topologyKey: string;
      /**
       * Indicates how to deal with a pod if it doesn't satisfy the spread constraint.
       *
       * - DoNotSchedule (default) tells the scheduler not to schedule it.
       * - ScheduleAnyway tells the scheduler to schedule the pod in any location,
       *   but giving higher precedence to topologies that would help reduce the skew.
       *
       * A constraint is considered "Unsatisfiable" for an incoming pod if and only if every possible
       * node assigment for that pod would violate "MaxSkew" on some topology.
       * For example, in a 3-zone cluster, MaxSkew is set to 1, and pods with the same labelSelector
       * spread as 3/1/1: | zone1 | zone2 | zone3 | | P P P | P | P | If WhenUnsatisfiable is set to DoNotSchedule,
       * incoming pod can only be scheduled to zone2(zone3) to become 3/2/1(3/1/2)
       * as ActualSkew(2-1) on zone2(zone3) satisfies MaxSkew(1).
       * In other words, the cluster can still be imbalanced, but scheduler won't make it
       * *more* imbalanced.
       *
       * It's a required field.
       */
      whenUnsatisfiable: string;
  }/** @public */
  export declare interface KeyToPath {
      /** The key to project. */
      key: string;
      /**
       * mode bits to use on this file,
       * Must be a value between 0 and 0777.
       * If not specified, the volume defaultMode will be used.
       * This might be in conflict with other options that affect the file mode, like fsGroup,
       * and the result can be other mode bits set.
       */
      mode?: number;
      /**
       * The relative path of the file to map the key to.
       *
       * May not be an absolute path. May not contain the path element '..'. May not start with the string '..'.
       */
      path: string;
  }/** @public */
  export declare interface ConfigMapVolumeSource {
      /**
       * mode bits to use on created files by default.
       *
       * Must be a value between 0 and 0777. Defaults to 0644.
       * Directories within the path are not affected by this setting.
       * This might be in conflict with other options that affect the file mode,
       * like fsGroup, and the result can be other mode bits set.
       */
      defaultMode?: number;
      /**
       * If unspecified, each key-value pair in the Data field of the referenced ConfigMap will be projected into the volume as a file whose name is the key and content is the value.
       *
       * If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present.
       * If a key is specified which is not present in the ConfigMap, the volume setup will error unless it is marked optional.
       * Paths must be relative and may not contain the '..' path or start with '..'.
       */
      items?: KeyToPath[];
      /**
       * Name of the referent.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names}
       */
      name: string | Handle;
      /** Specify whether the ConfigMap or its keys must be defined */
      optional?: boolean;
  }/** @public */
  export declare interface SecretVolumeSource {
      /**
       * mode bits to use on created files by default.
       *
       * Must be a value between 0 and 0777. Defaults to 0644.
       * Directories within the path are not affected by this setting.
       * This might be in conflict with other options that affect the file mode,
       * like fsGroup, and the result can be other mode bits set.
       */
      defaultMode?: number;
      /**
       * If unspecified, each key-value pair in the Data field of the referenced Secret will be projected into the volume as a file whose name is the key and content is the value.
       *
       * If specified, the listed keys will be projected into the specified paths,
       * and unlisted keys will not be present. If a key is specified which is not
       * present in the Secret, the volume setup will error unless it is marked optional.
       *
       * Paths must be relative and may not contain the '..' path or start with '..'.
       */
      items?: KeyToPath[];
      /** Specify whether the Secret or its keys must be defined */
      optional?: boolean;
      /**
       * Name of the secret in the pod's namespace to use.
       *
       *  More info: {@link https://kubernetes.io/docs/concepts/storage/volumes#secret}
       */
      secretName: string | Handle;
  }/** @public */
  export declare interface EmptyDirVolumeSource {
      /**
       * What type of storage medium should back this directory.
       *
       * The default is "" which means to use the node's default medium.
       * Must be an empty string (default) or Memory.
       * More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
       */
      medium: string;
      /**
       * Total amount of local storage required for this EmptyDir volume.
       *
       * The size limit is also applicable for memory medium.
       * The maximum usage on memory medium EmptyDir would be the minimum
       * value between the SizeLimit specified here and the sum of memory limits of all containers in a pod.
       * The default is nil which means that the limit is undefined.
       * More info: {@link http://kubernetes.io/docs/user-guide/volumes#emptydir}
       */
      sizeLimit: string;
  }/**
   * Volumes for {@link k8s.PodProps}
   *
   * @public
   */
  export declare interface Volume {
      /**
       * Volume's name.
       *
       * Must be a DNS_LABEL and unique within the pod.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names}
       */
      name: string;
      /**
       * Represents a configMap that should populate this volume
       */
      configMap?: ConfigMapVolumeSource;
      /**
       * EmptyDir represents a temporary directory that shares a pod's lifetime.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/storage/volumes#emptydir}
       *
       */
      emptyDir?: EmptyDirVolumeSource;
      /**
       * Represents a secret that should populate this volume.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/storage/volumes#secret}
       */
      secret?: SecretVolumeSource;
      /** Other k8s volume kinds not typed yet for \@adpt/cloud */
      [key: string]: any;
  }/**
   * Props for the {@link k8s.Pod} component
   *
   * @public
   */
  export declare interface PodProps extends WithChildren {
      /**
       *  True is this is a template for use in a controller, false otherwise
       *  @defaultValue false
       */
      isTemplate: boolean;
      /** Information about the k8s cluster (ip address, auth info, etc.) */
      config?: ClusterInfo;
      /** k8s metadata */
      metadata: Metadata;
      /**
       * Optional duration in seconds the pod may be active on the node relative to StartTime before the system will actively try to mark it failed and kill associated containers.
       *
       * Value must be a positive integer.
       */
      activeDeadlineSeconds?: number;
      /** If specified, the pod's scheduling constraints */
      affinity?: Affinity;
      /** AutomountServiceAccountToken indicates whether a service account token should be automatically mounted. */
      automountServiceAccountToken?: boolean;
      /**
       *  Specifies the DNS parameters of a pod.
       *
       *  Parameters specified here will be merged to the generated DNS configuration based on DNSPolicy.
       */
      dnsConfig?: PodDNSConfig;
      /**
       * Set DNS policy for the pod.
       *
       * Valid values are 'ClusterFirstWithHostNet', 'ClusterFirst', 'Default' or 'None'.
       * DNS parameters given in DNSConfig will be merged with the policy selected with DNSPolicy.
       * To have DNS options set along with hostNetwork, you have to specify DNS policy explicitly
       * to 'ClusterFirstWithHostNet'.
       *
       * @defaultValue ClusterFirst
       */
      dnsPolicy: "ClusterFirstWithHostNet" | "ClusterFirst" | "Default" | "None";
      /**
       * Indicates whether information about services should be injected into pod's environment variables matching the syntax of Docker links.
       *
       * @defaultValue true
       */
      enableServiceLinks: boolean;
      /**
       * An optional list of hosts and IPs that will be injected into the pod's hosts file if specified.
       *
       * This is only valid for non-hostNetwork pods.
       */
      hostAliases?: HostAlias[];
      /**
       * Use the host's ipc namespace.
       * @defaultValue false
       */
      hostIPC: boolean;
      /**
       * Host networking requested for this pod.
       *
       * Use the host's network namespace.
       * If this option is set, the ports that will be used must be specified. Default to false.
       */
      hostNetwork?: boolean;
      /**
       * Use the host's pid namespace.
       * @defaultValue false
       */
      hostPID: boolean;
      /**
       * Specifies the hostname of the Pod.
       *
       * If not specified, the pod's hostname will be set to a system-defined value.
       */
      hostname?: string;
      /**
       * List of references to secrets in the same namespace to use for pulling any of the images used by this PodSpec.
       *
       * If specified, these secrets will be passed to individual puller implementations for them to use.
       * For example, in the case of docker, only DockerConfig type secrets are honored.
       * More info: {@link https://kubernetes.io/docs/concepts/containers/images#specifying-imagepullsecrets-on-a-pod}
       */
      imagePullSecrets?: LocalObjectReference[];
      /**
       * A request to schedule this pod onto a specific node.
       *
       * If it is non-empty, the scheduler simply schedules this pod onto that node,
       * assuming that it fits resource requirements.
       */
      nodeName?: string;
      /**
       * A selector which must be true for the pod to fit on a node.
       *
       * Selector which must match a node's labels for the pod to be scheduled on that node.
       * More info: {@link https://kubernetes.io/docs/concepts/configuration/assign-pod-node/}
       */
      nodeSelector?: {
          [label: string]: boolean | string;
      };
      /**
       * Overhead represents the resource overhead associated with running a pod for a given RuntimeClass.
       *
       * This field will be autopopulated at admission time by the RuntimeClass admission controller.
       * If the RuntimeClass admission controller is enabled, overhead must not be set in Pod create requests.
       * The RuntimeClass admission controller will reject Pod create requests which have the overhead already set.
       * If RuntimeClass is configured and selected in the PodSpec, Overhead will be set to the value defined in
       * the corresponding RuntimeClass, otherwise it will remain unset and treated as zero.
       *
       * More info: {@link https://git.k8s.io/enhancements/keps/sig-node/20190226-pod-overhead.md}
       *
       * This field is alpha-level as of Kubernetes v1.16, and is only honored by servers that enable
       * the PodOverhead feature.
       * @alpha
       */
      overhead?: unknown;
      /**
       * PreemptionPolicy is the Policy for preempting pods with lower priority.
       *
       * This field is beta-level, gated by the NonPreemptingPriority feature-gate.
       *
       * @defaultValue PreemptLowerPriority
       * @beta
       */
      preemptionPolicy?: "Never" | "PreemptLowerPriority";
      /**
       * The priority various system components use this field to find the priority of the pod.
       *
       * When Priority Admission Controller is enabled, it prevents users from setting this field.
       * The admission controller populates this field from PriorityClassName.
       * The higher the value, the higher the priority.
       */
      priority?: number;
      /**
       * If specified, indicates the pod's priority.
       *
       * "system-node-critical" and "system-cluster-critical" are two special keywords which indicate the highest
       * priorities with the former being the highest priority. Any other name must be defined by creating a PriorityClass
       * object with that name. If not specified, the pod priority will be default or zero if there is no default.
       */
      priorityClassName?: string;
      /**
       *  If specified, all readiness gates will be evaluated for pod readiness.
       *
       *  A pod is ready when all its containers are ready AND all conditions specified
       *  in the readiness gates have status equal to "True"
       *
       *  More info: {@link https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#pod-readiness-gate}
       */
      readinessGates?: PodReadinessGate[];
      /**
       * Restart policy for all containers within the pod.
       *
       * One of Always, OnFailure, Never. Default to Always.
       * More info: {@link https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy}
       *
       * @defaultValue Always
       */
      restartPolicy: "Always" | "OnFailure" | "Never";
      /**
       * Refers to a RuntimeClass object in the node.k8s.io group, which should be used to run this pod.
       *
       * If no RuntimeClass resource matches the named class, the pod will not be run.
       * If unset or empty, the "legacy" RuntimeClass will be used, which is an implicit
       * class with an empty definition that uses the default runtime handler.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/containers/runtime-class/}
       *
       * This is a beta feature as of Kubernetes v1.14.
       */
      runtimeClassName?: string;
      /**
       *  If specified, the pod will be dispatched by specified scheduler.
       *  If not specified, the pod will be dispatched by default scheduler.
       */
      schedulerName?: string;
      /**
       * SecurityContext holds pod-level security attributes and common container settings.
       * See type description for default values of each field.
       *
       * @defaultValue \{\}
       */
      securityContext: PodSecurityContext;
      /**
       * ServiceAccountName is the name of the ServiceAccount to use to run this pod.
       * More info: {@link https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/}
       */
      serviceAccountName?: string | Handle;
      /**
       * If true the pod's hostname will be configured as the pod's FQDN, rather than the leaf name (the default).
       * In Linux containers, this means setting the FQDN in the hostname field of the kernel
       * (the nodename field of struct utsname).
       * In Windows containers, this means setting the registry value of hostname for the registry key
       * HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters to FQDN.
       * If a pod does not have FQDN, this has no effect.
       *
       * @defaultValue false
       */
      setHostnameAsFQDN?: boolean;
      /**
       * Share a single process namespace between all of the containers in a pod.
       * When this is set containers will be able to view and signal processes from other containers in the same pod,
       * and the first process in each container will not be assigned PID 1.
       * HostPID and ShareProcessNamespace cannot both be set.
       *
       * @defaultValue false
       */
      shareProcessNamespace: boolean;
      /**
       *  If specified, the fully qualified Pod hostname will be "\<hostname\>.\<subdomain\>.\<pod namespace\>.svc.\<cluster domain\>".
       *  If not specified, the pod will not have a domainname at all.
       */
      subdomain?: string;
      /**
       * Optional duration in seconds the pod needs to terminate gracefully.
       *
       * May be decreased in delete request. Value must be non-negative integer.
       * The value zero indicates delete immediately. If this value is nil, the default
       * grace period will be used instead. The grace period is the duration in seconds
       * after the processes running in the pod are sent a termination signal and the time
       * when the processes are forcibly halted with a kill signal. Set this value longer
       * than the expected cleanup time for your process. Defaults to 30 seconds.
       */
      terminationGracePeriodSeconds?: number;
      /** If specified, the pod's tolerations. */
      tolerations?: Toleration[];
      /**
       *  TopologySpreadConstraints describes how a group of pods ought to spread across topology domains.
       *
       *  Scheduler will schedule pods in a way which abides by the constraints. All topologySpreadConstraints are ANDed.
       */
      topologySpreadConstraints?: TopologySpreadConstraint[];
      /**
       * List of volumes that can be mounted by containers belonging to the pod.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/storage/volumes}
       */
      volumes?: Volume[];
  }/**
   * Component for Kubernetes Pods
   *
   * @public
   */
  export declare class Pod extends DeferredComponent<PodProps, ResolvedVolumes & ResolvedServiceAccountName> {
      static defaultProps: {
          isTemplate: boolean;
          metadata: {};
          dnsPolicy: string;
          enableServiceLinks: boolean;
          hostIPC: boolean;
          hostPID: boolean;
          restartPolicy: string;
          securityContext: {};
          shareProcessNamespace: boolean;
          terminationGracePeriodSeconds: number;
      };
      initialState(): {};
      build(helpers: BuildHelpers): Adapt.JSX.Element | null;
      status(_observe: ObserveForStatus, buildData: BuildData): Promise<Adapt.Status | undefined>;
  }/**
   * Spec for for Kubernetes Pods
   *
   * @public
   */
  export declare interface PodSpec extends Omit<PodProps, "config" | "metadata" | "isTemplate"> {
      containers: ContainerSpec[];
      terminationGracePeriodSeconds?: number;
  }/** @internal */
  const podResourceInfo: {
      kind: string;
      deployedWhen: typeof deployedWhen;
      statusQuery: (props: ResourcePropsWithConfig, observe: ObserveForStatus, buildData: BuildData) => Promise<any>;
  };/**
   * k8s Secret resource
   *
   * @param propsIn - props for Secret as specifed in {@link k8s.SecretProps}
   *
   * @public
   */
  export declare function Secret(propsIn: SFCDeclProps<SecretProps, typeof defaultProps>): Adapt.JSX.Element;/** @internal */
  const secretResourceInfo: {
      kind: string;
      deployedWhen: () => true;
      statusQuery: (props: ResourcePropsWithConfig, observe: ObserveForStatus, buildData: BuildData) => Promise<any>;
      makeManifest: (manifest: Manifest, elem: AdaptElement<ResourceProps>, _deployID: string) => {
          data: {
              [key: string]: string;
          } | undefined;
          stringData: {
              [key: string]: string;
          } | undefined;
          type: string | undefined;
          apiVersion: string; /**
           * stringData allows specifying non-binary secret data in string form.
           *
           * It is provided as a write-only convenience method. All keys and values are merged into the data field on write,
           * overwriting any existing values. It is never output when reading from the API.
           */
          kind: string;
          metadata: import("./manifest_support").MetadataInRequest;
          spec?: import("./DaemonSet").DaemonSetSpec | import("./common").CRSpec | import("./Pod").PodSpec | import("./Service").ServiceSpec | import("./Deployment").DeploymentSpec | undefined;
      };
  };/**
   * Convert {@link NetworkService} props to {@link k8s.Service} props
   * @param abstractProps - props to convert
   * @returns Kubernetes spec corresponding to `abstractProps`
   *
   * @internal
   */
  export declare function k8sServiceProps(abstractProps: NetworkServiceProps & BuiltinProps): Omit<ServiceProps, keyof ResourceBase>;/**
   * Native Kubernetes Service resource
   *
   * @remarks
   *
   * Implements the {@link NetworkServiceInstance} interface.
   *
   * @public
   */
  export declare function Service(propsIn: SFCDeclProps<ServiceProps, typeof defaultProps>): Adapt.JSX.Element;/** @public */
  export declare interface ServiceProps extends ServiceSpec {
      /** Legal configuration loaded from kubeconfig */
      config: ClusterInfo;
      metadata?: Metadata;
      selector?: Handle | EndpointSelector;
  }/** @public */
  export declare interface ServiceSpec {
      /**
       * Cluster IP for a {@link k8s.Service}
       *
       * @remarks
       * `clusterIP` is the IP address of the service and is usually assigned
       * randomly by the master. If an address is specified manually and is not
       * in use by others, it will be allocated to the service; otherwise,
       * creation of the service will fail. This field can not be changed through
       * updates. Valid values are "None", empty string (""), or a valid IP
       * address. "None" can be specified for headless services when proxying is
       * not required. Only applies to types ClusterIP, NodePort, and
       * LoadBalancer. Ignored if type is ExternalName.
       *
       * For more information, see the
       * {@link https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies |
       * Kubernetes documentation}.
       */
      clusterIP?: string;
      /**
       * A list of IP addresses for which nodes in the cluster
       * will also accept traffic for this service.
       *
       * @remarks
       * These IPs are not managed by
       * Kubernetes. The user is responsible for ensuring that traffic arrives at
       * a node with this IP. A common example is external load balancers that are
       * not part of the Kubernetes system.
       */
      externalIPs?: string[];
      /**
       * The external reference that kubedns or equivalent
       * will return as a CNAME record for this service.
       *
       * @remarks
       * No proxying will be involved. Must be a
       * {@link https://tools.ietf.org/html/rfc1123 | valid RFC-1123 hostname}
       * and requires Type to be ExternalName.
       */
      externalName?: string;
      /**
       * Denotes if this Service desires to route
       * external traffic to node-local or cluster-wide endpoints.
       *
       * @remarks
       * "Local" preserves the client source IP and avoids a second hop for
       * LoadBalancer and Nodeport type services, but risks potentially
       * imbalanced traffic spreading. "Cluster" obscures the client source IP
       * and may cause a second hop to another node, but should have good overall
       * load-spreading.
       */
      externalTrafficPolicy?: string;
      /**
       * Specifies the healthcheck nodePort for the service.
       *
       * @remarks
       * If not specified, HealthCheckNodePort is created by the service
       * api backend with the allocated nodePort. Will use user-specified nodePort
       * value if specified by the client. Only affects when Type is set to
       * LoadBalancer and ExternalTrafficPolicy is set to Local.
       */
      healthCheckNodePort?: number;
      /**
       * Only applies to Service Type: LoadBalancer. LoadBalancer will
       * get created with the IP specified in this field.
       *
       * @remarks
       * This feature depends on
       * whether the underlying cloud provider supports specifying the loadBalancerIP
       * when a load balancer is created. This field will be ignored if the
       * cloud provider does not support the feature.
       */
      loadBalancerIP?: string;
      /**
       * If specified and supported by the platform, this will
       * restrict traffic through the cloud provider load balancer
       * to the specified client IPs.
       *
       * @remarks
       * This field will be ignored if the cloud provider
       * does not support the feature.
       *
       * For more information, see the
       * {@link https://v1-17.docs.kubernetes.io/docs/tasks/access-application-cluster/configure-cloud-provider-firewall/ |
       * Kubernetes documentation}.
       */
      loadBalancerSourceRanges?: string[];
      /**
       * The list of ports that are exposed by this service.
       *
       * @remarks
       * For more information, see the
       * {@link https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies |
       * Kubernetes documentation}.
       */
      ports?: ServicePort[];
      /**
       * When set to true, indicates that
       * DNS implementations must publish the notReadyAddresses of subsets for the
       * Endpoints associated with the Service.
       *
       * @remarks
       * The default value is false. The
       * primary use case for setting this field is to use a StatefulSet's Headless
       * Service to propagate SRV records for its Pods without respect to their
       * readiness for purpose of peer discovery.
       */
      publishNotReadyAddresses?: boolean;
      /**
       * Route service traffic to pods with label keys and values
       * matching this selector.
       *
       * @remarks
       * If empty or not present, the service is assumed to
       * have an external process managing its endpoints, which Kubernetes will not
       * modify. Only applies to types ClusterIP, NodePort, and LoadBalancer.
       * Ignored if type is ExternalName.
       *
       * For more information, see the
       * {@link https://kubernetes.io/docs/concepts/services-networking/service/ |
       * Kubernetes documentation}.
       */
      selector?: EndpointSelector | object;
      /**
       * Used to maintain session affinity.
       *
       * @remarks
       * Possible values are:
       *
       * - `"ClientIP"`: Enables client IP based session affinity.
       *
       * - `"None"`: Disables session affinity.
       *
       * For more information, see the
       * {@link https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies |
       * Kubernetes documentation}.
       * @defaultValue `"None"`
       */
      sessionAffinity?: string;
      /**
       * Determines how the Service is exposed.
       *
       * @remarks
       * Valid options are:
       *
       * - `"ExternalName"`: maps to the specified externalName.
       *
       * - `"ClusterIP"`: allocates a cluster-internal IP address for load
       * balancing to endpoints. Endpoints are determined by the selector or if
       * that is not specified, by manual construction of an Endpoints object. If
       * clusterIP is "None", no virtual IP is allocated and the endpoints are
       * published as a set of endpoints rather than a stable IP.
       *
       * - `"NodePort"`: Builds on ClusterIP and allocates a port on every node
       * which routes to the clusterIP.
       *
       * - `"LoadBalancer"`: Builds on NodePort and creates an external load
       * balancer (if supported in the current cloud) which routes to the
       * clusterIP.
       *
       * For more information, see the
       * {@link https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services---service-types |
       * Kubernetes documentation}.
       * @defaultValue `"ClusterIP"`
       */
      type?: string;
  }/** @public */
  export declare interface ServicePort {
      /**
       * The name of this port within the service.
       *
       * @remarks
       * This must be a DNS_LABEL.
       * All ports within a ServiceSpec must have unique names.This maps to the
       * Name' field in EndpointPort objects. Optional if only one ServicePort is
       * defined on this service.
       */
      name?: string;
      /**
       * The port on each node on which this service is exposed when
       * type=NodePort or LoadBalancer.
       *
       * @remarks
       * Usually assigned by the system. If
       * specified, it will be allocated to the service if unused or else creation
       * of the service will fail.
       *
       * For more information, see the
       * {@link https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport |
       * Kubernetes documentation}.
       * @defaultValue Automatically allocates a port if the ServiceType of this
       * Service requires one.
       */
      nodePort?: number;
      /** The port that will be exposed by this service. */
      port?: number;
      /** The IP protocol for this port.Supports "TCP" and "UDP".Default is TCP. */
      protocol?: string;
      /**
       * Number or name of the port to access on the pods targeted by the
       * service.
       *
       * @remarks
       * Number must be in the range 1 to 65535. Name must be an
       * IANA_SVC_NAME. If this is a string, it will be looked up as a named port
       * in the target Pod's container ports. If this is not specified, the value
       * of the 'port' field is used (an identity map). This field is ignored for
       * services with clusterIP = None, and should be omitted or set equal to the
       * 'port' field.
       *
       * For more information, see the
       * {@link https://kubernetes.io/docs/concepts/services-networking/service/#defining-a-service |
       * Kubernetes documentation}.
       */
      targetPort?: number | string;
  }/** @internal */
  const serviceResourceInfo: {
      kind: string;
      deployedWhen: typeof deployedWhen;
      statusQuery: (props: ResourcePropsWithConfig, observe: ObserveForStatus, buildData: BuildData) => Promise<any>;
  };/**
   * k8s ServiceAccount resource
   *
   * @param propsIn - props for ServiceAccount as specifed in {@link k8s.ServiceAccountProps}
   *
   * @public
   */
  export declare function ServiceAccount(propsIn: SFCDeclProps<ServiceAccountProps, typeof defaultProps>): Adapt.JSX.Element;/** @public */
  export declare function isServiceAccountProps(p: ResourceProps): p is ResourceProps & ResourceServiceAccount;/** @internal */
  const serviceAccountResourceInfo: {
      kind: string;
      deployedWhen: () => true;
      statusQuery: (props: ResourcePropsWithConfig, observe: ObserveForStatus, buildData: BuildData) => Promise<any>;
      makeManifest: (manifest: Manifest, elem: AdaptElement<ResourceProps>, _deployID: string) => {
          automountServiceAccountToken: boolean | undefined;
          imagePullSecrets: {
              name: string;
          }[] | undefined;
          secrets: ObjectReference[] | undefined;
          apiVersion: string;
          kind: string;
          metadata: import("./manifest_support").MetadataInRequest;
          spec?: import("./DaemonSet").DaemonSetSpec | import("./common").CRSpec | import("./Pod").PodSpec | import("./Service").ServiceSpec | import("./Deployment").DeploymentSpec | undefined;
      };
  };/**
   * Props for {@link k8s.ServiceDeployment}
   *
   * @public
   */
  export declare interface ServiceDeploymentProps<T extends AllowableComponentProps = DeploymentProps> extends ServiceProps {
      config: ClusterInfo;
      serviceProps?: Partial<ServiceProps>;
      component: ComponentType<T>;
      componentProps: T;
      podProps?: Partial<PodProps>;
      containerProps?: Partial<OmitT<K8sContainerProps, "image">>;
  }/**
   * A component for mapping a group of abstract {@link Container}s and
   * {@link NetworkService}s to Kubernetes {@link k8s.Pod}s and
   * {@link k8s.K8sContainer}s.
   *
   * @remarks
   * This component is intended to be used to replace {@link Container} and
   * {@link NetworkService} components that are grouped together, as the
   * only children of a common parent in a pattern that looks like this:
   *
   * ```tsx
   * <Service>
   *   <Container ... />
   *   <Container ... />
   *   <NetworkService ... />
   * </Service>
   * ```
   *
   * `ServiceDeployment` would map those abstract components into corresponding
   * k8s components like this:
   * ```tsx
   * <Group>
   *   <docker.RegistryDockerImage ... /> //If props.config specifies a registry
   *   <k8s.Deployment ... >
   *     <Pod isTemplate>
   *       <k8s.K8sContainer ... />
   *     </Pod>
   *   </k8s.Deployment>
   *   <docker.RegistryDockerImage ... /> //If props.config specifies a registry
   *   <k8s.Deployment ... >
   *     <Pod isTemplate>
   *       <k8s.K8sContainer ... />
   *     </Pod>
   *   </k8s.Pod>
   *   <k8s.Service ... />
   * </Group>
   * ```
   * An example style rule to do this is:
   * ```tsx
   * {Adapt.rule((matchedProps) => {
   *     const { handle, ...remainingProps } = matchedProps;
   *     return <ServiceDeployment config={kubeconfig} {...remainingProps} />;
   * })}
   * ```
   * `ServiceDeployment` also requires the `config` prop which specifies
   * connection and authentication information for the Kubernetes cluster on
   * which these objects should be created.
   *
   * @public
   */
  export declare class ServiceDeployment<T extends AllowableComponentProps> extends DeferredComponent<ServiceDeploymentProps<T>> {
      static defaultProps: {
          component: typeof Deployment;
          componentProps: {
              replicas: number;
          };
      };
      build(helpers: BuildHelpers): Adapt.JSX.Element;
  }/** @public */
  export declare function computeNamespaceFromMetadata(metadata?: Metadata): string;/** @public */
  export declare function isLabelSelector(x: any): x is LabelSelector;/**
   * Kubernetes Kind
   *
   * @public
   */
  export declare type Kind = string;/** @public */
  export declare interface CRSpec {
      [key: string]: any;
  }/** @public */
  export declare type Spec = DaemonSetSpec | DeploymentSpec | PodSpec | ServiceSpec | CRSpec;/** @public */
  export declare interface Metadata {
      namespace?: string;
      labels?: {
          [key: string]: string;
      };
      annotations?: {
          [key: string]: string;
      };
  }/** @public */
  export declare type ResourceProps = {
      key: string;
  } & (ResourceClusterRole | ResourceClusterRoleBinding | ResourceDaemonSet | ResourcePod | ResourceService | ResourceServiceAccount | ResourceConfigMap | ResourceSecret | ResourceCR);/** @public */
  export declare type ResourcePropsWithConfig = ResourceProps & {
      config: ClusterInfo;
  };/** @public */
  export declare interface ResourceInfo {
      kind: Kind;
      statusQuery?: (props: ResourceProps, observe: ObserveForStatus, buildData: BuildData) => unknown | Promise<unknown>;
      specsEqual(actual: Spec, element: Spec): boolean;
  }/**
   * Holds the information needed to connect, authenticate, and run code in a kuberenetes cluster
   *
   * @public
   */
  export declare interface ClusterInfo {
      /** Javascript object formed by parsing a valid kubeconfig file */
      kubeconfig: Kubeconfig;
      /**
       * Registry to which Docker images used by the cluster in `kubeconfig` should be pushed and pulled
       *
       * @remarks
       * If `registryPrefix` is a string, it is assumed that the cluster can pull from the same string
       * that outsiders can push to.
       *
       * If `registryPrefix` is of the form `{ external: string, internal: string }` then the `external`
       * string will be used to push images, and the `internal` string will be used to pull images.
       *
       * Note(manishv)
       * This is a bit of a hack to allow one hostname or IP address to push images from outside
       * a particular environment (say k8s) and a different URL for that environment to pull
       * images.
       *
       * A good example of this is a k3s-dind (k3s docker-in-docker) instance of kubernetes where
       * a private registry is running on a docker network attached to the k3s-dind instance, but where we
       * want to push {@link docker.LocalDockerImage} built images to that registry.  Since
       * {@link docker.LocalDockerImage | LocalDockerImage} is outside the k3s-dind environment, it must
       * use a host accessible network to push to the registry.  However, since the k3s-dind instance sees
       * the registry from within Docker, it must use a different address to pull the images for use.
       *
       * Once network scopes are fully supported, this interface will change to whatever is appropriate.  It
       * is best if you can arrange to have the same URL or registry string work for all access regardless
       * of which network the registry, Adapt host, and ultimate container running environment uses.
       *
       */
      registryPrefix?: string | DockerSplitRegistryInfo;
  }/** @public */
  export declare interface ResourceBase {
      /**
       * config to connect to the k8s cluster
       *
       * required if isTemplate is false
       */
      config?: ClusterInfo;
      /**
       * Specifies whether this resource is just a template for use in a controller
       */
      isTemplate?: boolean;
      apiVersion?: string;
      kind: Kind;
      metadata?: Metadata;
  }/**
   * @public
   */
  export declare interface PolicyRule {
      /**
       * APIGroups is the name of the APIGroup that contains the resources.
       *
       * If multiple API groups are specified, any action requested against one
       * of the enumerated resources in any API group will be allowed.
       */
      apiGroups?: string[];
      /**
       * NonResourceURLs is a set of partial urls that a user should have access to.
       *
       * *s are allowed, but only as the full, final step in the path.
       * Since non-resource URLs are not namespaced, this field is only applicable
       * for ClusterRoles referenced from a ClusterRoleBinding.
       * Rules can either apply to API resources (such as "pods" or "secrets") or
       * non-resource URL paths (such as "/api"), but not both.
       */
      nonResourceURLs?: string[];
      /**
       * ResourceNames is an optional white list of names that the rule applies to.
       *
       * An empty set means that everything is allowed.
       */
      resourceNames?: string[];
      /**
       * Resources is a list of resources this rule applies to.
       *
       * ResourceAll represents all resources.
       */
      resources: string[];
      /**
       * Verbs is a list of Verbs that apply to ALL the ResourceKinds and
       * AttributeRestrictions contained in this rule.
       *
       * VerbAll represents all kinds.
       */
      verbs: string[];
  }/**
   * AggregationRule for {@link k8s.ClusterRole}
   *
   * @public
   */
  export declare interface AggregationRule {
      /**
       * ClusterRoleSelectors holds a list of selectors which will be used to
       * find ClusterRoles and create the rules.
       *
       * If any of the selectors match, then the ClusterRole's permissions will be added
       */
      clusterRoleSelector: LabelSelector;
  }/** @public */
  export declare interface ResourceClusterRole extends ResourceBase {
      apiVersion: "rbac.authorization.k8s.io/v1";
      kind: "ClusterRole";
      aggregationRule?: AggregationRule;
      rules?: PolicyRule[];
  }/**
   * RoleRef for {@link k8s.ResourceClusterRoleBinding}
   *
   * @public
   */
  export declare interface RoleRef {
      /** apiGroup is the group for the resource being referenced */
      apiGroup: string;
      /** kind is the type of resource being referenced */
      kind: string;
      /** Name is the name of resource being referenced */
      name: string;
  }/**
   * Subject for {@link k8s.ResourceClusterRoleBinding}
   *
   * @public
   */
  export declare interface Subject {
      /** apiGroup is the group for the object being referenced */
      apiGroup: string;
      /** kind is the type of object being referenced */
      kind: string;
      /**
       * Name of the object being referenced.
       */
      name: string;
      /**
       * Namespace of the referenced object.
       *
       * If the object kind is non-namespace, such as "User" or "Group", and this value
       * is not empty the Authorizer should report an error.
       */
      namespace?: string;
  }/** @public */
  export declare interface ResourceClusterRoleBinding extends ResourceBase {
      apiVersion: "rbac.authorization.k8s.io/v1";
      kind: "ClusterRoleBinding";
      roleRef: RoleRef;
      subjects: Subject[];
  }/** @public */
  export declare interface ResourceDaemonSet extends ResourceBase {
      apiVersion: "apps/v1";
      kind: "DaemonSet";
      spec: DaemonSetSpec;
  }/** @public */
  export declare interface ResourcePod extends ResourceBase {
      kind: "Pod";
      spec: PodSpec;
  }/** @public */
  export declare interface ResourceService extends ResourceBase {
      kind: "Service";
      spec: ServiceSpec;
  }/** @public */
  export declare interface ResourceServiceAccount extends ResourceBase {
      kind: "ServiceAccount";
      automountServiceAccountToken?: boolean;
      imagePullSecrets?: {
          name: string;
      }[];
      secrets?: ObjectReference[];
  }/** @public */
  export declare interface ResourceConfigMap extends ResourceBase {
      kind: "ConfigMap";
      binaryData?: {
          [key: string]: string;
      };
      data?: {
          [key: string]: string;
      };
      /** @beta */
      immutable?: boolean;
  }/** @public */
  export declare interface ResourceSecret extends ResourceBase {
      kind: "Secret";
      data?: {
          [key: string]: string;
      };
      stringData?: {
          [key: string]: string;
      };
      type?: string;
  }/** @public */
  export declare interface ResourceCR extends ResourceBase {
      kind: string;
      spec: CRSpec;
  }/** @public */
  export declare interface Kubeconfig {
      apiVersion?: "v1";
      kind: "Config";
      "current-context": string;
      contexts: {
          name: string;
          context: {
              cluster: string;
              user: string;
          };
      }[];
      clusters: {
          name: string;
          cluster: {
              "certificate-authority-data": string;
              server: string;
          };
      }[];
      preferences?: unknown;
      users: {
          name: string;
          user: {
              "client-certificate-data"?: string;
              "client-key-data"?: string;
              "username"?: string;
              "password"?: string;
          };
      }[];
  }/** @public */
  export declare interface LabelSelector {
      /**
       * matchExpressions is a list of label selector requirements. The requirements are ANDed.
       */
      matchExpressions?: LabelSelectorRequirement[];
      /**
       * matchLabels is a map of `{key,value}`pairs. A single `{key,value}` in the matchLabels map
       * is equivalent to an element of matchExpressions, whose key field is "key", the operator
       * is "In", and the values array contains only "value". The requirements are ANDed.
       */
      matchLabels?: {
          [key: string]: string;
      };
  }/** @public */
  export declare interface LocalObjectReference {
      /**
       * Name of the referent.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names}
       */
      name: string;
  }/**
   * PodTemplateSpec from k8s API
   *
   * @public
   */
  export declare interface PodTemplateSpec {
      /**
       * Standard object's metadata.
       * More Info: {@link https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata}
       */
      metadata: Metadata;
      /**
       * Specification of the desired behavior of the pod.
       * More Info: {@link https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status}
       */
      spec: PodSpec;
  }/**
   * ObjectReference from k8s API
   *
   * @public
   */
  export declare interface ObjectReference {
      /**
       * If referring to a piece of an object instead of an entire object,
       * this string should contain a valid JSON/Go field access statement,
       * such as desiredState.manifest.containers[2].
       *
       * For example, if the object reference is to a container within a pod,
       * this would take on a value like: "spec.containers\{name\}" (where "name"
       * refers to the name of the container that triggered the event) or if no
       * container name is specified "spec.containers[2]"
       * (container with index 2 in this pod).
       * This syntax is chosen only to have some well-defined way of referencing a
       * part of an object.
       */
      fieldPath: string;
      /**
       * Name of the referent.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names}
       *
       */
      name: string;
      /**
       * Namespace of the referent.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/}
       */
      namespace: string;
      /**
       * Specific resourceVersion to which this reference is made, if any.
       *
       * More info: {@link https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency}
       */
      resourceVersion: string;
      /**
       * UID of the referent.
       *
       * More info: {@link https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids}
       */
      uid: string;
  }/**
   * Make a {@link k8s.ClusterInfo} object suitable for use with k8s resources
   *
   * @remarks
   *
   * This function will take a set of options and generate a {@link k8s.ClusterInfo}
   * object that contains the kubeconfig, registryPrefix for private images, and any other
   * relevant information for the cluster
   *
   * See {@link k8s.MakeClusterInfoOptions} for information on how the information
   * is computed.
   *
   * @returns A {@link k8s.ClusterInfo} object.
   *
   * @public
   */
  export declare function makeClusterInfo(options: MakeClusterInfoOptions): Promise<ClusterInfo>;/** @internal */
  export declare function isResourcePodTemplate(x: any): x is AdaptElement<ResourcePod>;/**
   * Hook that allows a prop to be either an array of handle to k8s resources and values
   *
   * @param initial - initial value of the prop, before the handles are be resolved
   * @param notReady - is a marker value to indicate that a handle's value isn't available yet
   * @param kinds - an array of legal k8s Kinds that a prop handle can point to
   * @param thisResourceName - the name of the resource using the hook, for error messages
   * @param propName - the name of the prop being resolved, again for error messages
   *
   * @returns A two element array, the first element is the current value, the second the update function
   *
   * This hook will start by returning the initial value and an update function that updates
   * the value the hook returns.  The update function takes 2 arguments - the prop value which
   * is an array with a mix of values and handles to be resolved, and a function that receives
   * the elements that any handles point to along with that elements props.  This function
   * can be passed by the caller of update to resolve handles as appropriate for the component.
   *
   * For example, {@link k8s.ClusterRoleBinding} uses this hook to resolve the subjects prop,
   * which is an array of other objects (typically {@link ServiceAccount}) that a particular
   * {@link k8s.ClusterRole} should point to.  When ClusterRoleBinding calls the update method,
   * it passes a function that will convert a {@link k8s.Resource} element of Kind `ServiceAccount`
   * to the underlying `Subject` object that kubernetes expects, namely
   * `{ apiGroup: "", kind: "ServiceAccount", name: resourceIdToName(elem, deployID), namespace: <element namespace> }`
   *
   * @example
   * ```
   * function MyResource({ serviceAccountNames }: { serviceAccountNames: (string | Handle)[]}) {
   *   const { deployID } = useBuildHelpers();
   *   const [ resolvedServiceAccountNames, updateSANs] = useResources({
   *      initial: [],
   *      notReady: null,
   *      kinds: ["ServiceAccount"],
   *      thisResourceName: "MyResources",
   *      propName: "serviceAccountNames",
   *   });
   *
   *   updateSANs(serviceAccountNames, (e, props) => {
   *      return {
   *        apiGroup: (e.metadata.apiVersion?.split("/")[0]) || "",
   *        name: resourceElementToName(e, deployID),
   *        namespace: props.metadata.namespace,
   *      }
   *   });
   *
   *   return null;
   * }
   * ```
   *
   * @beta
   */
  export declare function useResources<ValT, NotReadyT>({ initial, notReady, kinds, thisResourceName, propName, }: {
      initial: ValT[];
      notReady: NotReadyT;
      kinds: string[];
      thisResourceName: string;
      propName: string;
  }): [
      (ValT | NotReadyT)[],
      (props: (ValT | Handle)[], f: (e: AdaptMountedElement, props: ResourceProps) => Promise<ValT> | ValT) => void
  ];/**
   * Hook to allow conversion of a prop that could be a value or a handle
   *
   * This function behaves similarly to {@link k8s.useResources}, but works for
   * a prop that is either a Handle or a single value instead of an array of
   * Handles and values.
   *
   * See {@link k8s.useResources} for more detailed documentation.
   *
   * @beta
   */
  export declare function useResource<ValT, NotReadyT>(opts: {
      initial: ValT | NotReadyT;
      notReady: NotReadyT;
      kinds: string[];
      thisResourceName: string;
      propName: string;
  }): [
      ValT | NotReadyT,
      (prop: ValT | Handle, f: (e: AdaptMountedElement, props: ResourceProps) => Promise<ValT> | ValT) => void
  ];/**
   * Options for {@link k8s.makeClusterInfo}
   *
   * @public
   */
  export declare interface MakeClusterInfoOptions {
      /**
       * A Javascript Object representing a valid kubeconfig, or a YAML string, or a path to a kubeconfig file.
       *
       * @remarks
       * If this is a Javascript object, it will be treated like a parsed kubeconfig.  If this is a string,
       * {@link k8s.makeClusterInfo} will first attempt to parse it as JSON.  If that fails, it will attempt
       * to parse it as YAML.  If that fails it will treat the string as a path of configs (like with the `KUBECONFIG`
       * environment variable).
       *
       * If kubeconfig is missing {@link k8s.makeClusterInfo} will use the `KUBECONFIG` environment variable to build
       * a suitable config using `kubectl config view --flatten` and return that as the kubeconfig in the resulting
       * {@link k8s.ClusterInfo}
       */
      kubeconfig?: Kubeconfig | string;
      /**
       * URL to the docker registry that this cluster uses to pull private images.
       *
       * @remarks
       * This is identical to the `registryPrefix` field in {@link k8s.ClusterInfo}.  It will
       * be returned verbatim in the resulting {@link k8s.ClusterInfo} object.
       */
      registryPrefix?: string | DockerSplitRegistryInfo;
  }
}

/**
 * Network links to create for a {@link Container}.
 *
 * @remarks
 * See the
 * {@link https://docs.docker.com/engine/api/v1.40/#operation/ContainerCreate | Docker API Reference}
 * for more information.
 * @public
 */
export declare interface Links {
    [internalName: string]: string;
}

/**
 * Element representing a local compute instance
 *
 * @alpha
 */
export declare class LocalCompute extends PrimitiveComponent<ComputeProps> {
    static defaultProps: {
        ip: string;
    };
    static noPlugin: boolean;
}

/** @alpha */
export declare type LocalComputeProps = ComputeProps;

/**
 * @deprecated Use {@link docker.DockerContainer} instead
 * @internal
 */
export declare class LocalContainer extends PrimitiveComponent<ContainerProps> {
}

/**
 * @deprecated Use {@link docker.DockerContainer} instead
 * @internal
 */
export declare type LocalContainerProps = ContainerProps;

/**
 * Represents the local docker host
 *
 * @alpha
 */
export declare class LocalDockerHost extends PrimitiveComponent<DockerHostProps> {
    updateState(state: any): void;
}

/**
 * Find the value of an environment variable in an {@link Environment}
 *
 * @param e - {@link Environment} to search
 * @param name - variable to search for
 * @returns the value of the variable name in e, or undefined if not found
 *
 * @public
 */
export declare function lookupEnvVar(e: Environment, name: string): string | undefined;

/**
 * Creates a function for generating unique names for Adapt Elements.
 * @remarks
 * The unique names are unique by probability, based on a SHA256 hash.
 * They are are made up of:
 *
 * - The Element's key, with any invalid characters removed.
 *
 * - A separator character (or string)
 *
 * - A portion of the SHA256 hash of the Element's ID and the deployID.
 *
 * @param invalidChars - A regular expression that matches all invalid
 * characters that should NOT be included in the resulting name. Must have
 * the global flag set. For example, if only alphabetic characters and dashes
 * are allowed, set `invalidChars` to: `/[^a-zA-Z-]/g`
 * @param maxLen - The maximum allowed length of name that should be generated.
 * @param sep - The separator string to be used between they key and the hash.
 *
 * @public
 */
export declare function makeResourceName(invalidChars: RegExp, maxLen: number, sep?: string): (elemKey: string, elemID: string, deployID: string) => string;

/**
 * Combine multiple {@link Environment} objects into a single array of
 * {@link EnvPair} objects. Returns `undefined` if there are no `Environment`
 * objects provided.
 * @remarks
 * If more than one `Environment` object specifies the same environment variable
 * name, the last one present in the array of arguments takes precedence.
 * @public
 */
export declare function mergeEnvPairs(...envs: (Environment | undefined)[]): EnvPairs | undefined;

/**
 * Combine multiple {@link Environment} objects into a single
 * {@link EnvSimple} object. Returns `undefined` if there are no `Environment`
 * objects provided.
 * @remarks
 * If more than one `Environment` object specifies the same environment variable
 * name, the last one present in the array of arguments takes precedence.
 * @public
 */
export declare function mergeEnvSimple(...envs: (Environment | undefined)[]): EnvSimple | undefined;

export declare namespace mongodb {
/**
   * Abstract MongoDB component
   *
   * @remarks
   * This component is used to denote a needed {@link https://www.mongodb.com | MongoDB}
   * service.  Users should use a style sheet to subsitute a concrete MongoDB instance
   * that provides the service.  {@link mongodb.TestMongoDB} is such a component, suitable for
   * test environments.
   *
   * All implementations of this component should implmenent {@link ConnectToInstance}
   * that provides a `MONGODB_URI` variable of the form `mongodb://<hostname>:<port>`.
   *
   * @public
   */
  export declare abstract class MongoDB extends PrimitiveComponent implements ConnectToInstance {
      connectEnv(_scope?: NetworkScope): undefined;
  }/**
   * Test {@link https://www.mongodb.com | MongoDB} Service
   *
   * @remarks
   *
   * Uses an abstract {@link Service}, {@link NetworkService}, and {@link Container}
   * component that must be substituted in a style sheet.
   *
   * See {@link mongodb.TestMongoDBProps}.
   *
   * @public
   */
  export declare function TestMongoDB(props: SFCDeclProps<TestMongoDBProps, typeof testMongoDefaultProps>): Adapt.JSX.Element;/**
   * Props for {@link mongodb.TestMongoDB}
   *
   * @public
   */
  export declare interface TestMongoDBProps {
      /** Image used for TestMongoDB container, defaults to mongo:latest */
      image: string;
      /** Specifies when to pull image, defaults to `"Always"` */
      imagePullPolicy: "Always" | "IfNotPresent" | "Never" | undefined;
      /** Port on which the Mongo DB service is exposed */
      port: number;
  }/**
   * Abstract MongoDB component
   *
   * @remarks
   * This component is used to denote a needed {@link https://www.mongodb.com | MongoDB}
   * service.  Users should use a style sheet to subsitute a concrete MongoDB instance
   * that provides the service.  {@link mongodb.TestMongoDB} is such a component, suitable for
   * test environments.
   *
   * All implementations of this component should implmenent {@link ConnectToInstance}
   * that provides a `MONGODB_URI` variable of the form `mongodb://<hostname>:<port>`.
   *
   * @public
   */
  export declare abstract class MongoDB extends PrimitiveComponent implements ConnectToInstance {
      connectEnv(_scope?: NetworkScope): undefined;
  }/**
   * Test {@link https://www.mongodb.com | MongoDB} Service
   *
   * @remarks
   *
   * Uses an abstract {@link Service}, {@link NetworkService}, and {@link Container}
   * component that must be substituted in a style sheet.
   *
   * See {@link mongodb.TestMongoDBProps}.
   *
   * @public
   */
  export declare function TestMongoDB(props: SFCDeclProps<TestMongoDBProps, typeof testMongoDefaultProps>): Adapt.JSX.Element;/**
   * Props for {@link mongodb.TestMongoDB}
   *
   * @public
   */
  export declare interface TestMongoDBProps {
      /** Image used for TestMongoDB container, defaults to mongo:latest */
      image: string;
      /** Specifies when to pull image, defaults to `"Always"` */
      imagePullPolicy: "Always" | "IfNotPresent" | "Never" | undefined;
      /** Port on which the Mongo DB service is exposed */
      port: number;
  }
}

/**
 * Mount information for {@link ContainerStatus}
 * @public
 */
export declare interface MountStatus {
    Type: "bind" | "volume" | "tmpfs";
    Source?: string;
    Destination: string;
    Mode: string;
    RW: boolean;
    Propagation: "shared" | "slave" | "private" | "rshared" | "rslave" | "rprivate";
}

/**
 * Type for various network address scopes
 *
 * @remarks
 * The details of this type are very experimental.  Use the constants `NetworkScope.external`
 * and `NetworkScope.default` instead of strings to reduce the chance of breakage.
 *
 * @beta
 */
export declare enum NetworkScope {
    external = "external",
    default = "default"
}

/**
 * An abstract component that represents a network service.
 *
 * @public
 */
export declare abstract class NetworkService extends PrimitiveComponent<NetworkServiceProps> implements NetworkServiceInstance {
    static defaultProps: {
        protocol: string;
        scope: string;
    };
    /**
     * Returns the hostname of the NetworkService, once it is known.
     */
    hostname(scope: NetworkScope): string | undefined;
    /**
     * Returns the port number of the NetworkService, once it is known.
     */
    port(): number | undefined;
}

/**
 * Interface for components that expose Network Services via hostname and port
 *
 * @beta
 */
export declare interface NetworkServiceInstance {
    /**
     * Returns the hostname for the service from the given scope
     *
     * @param scope - the scope of the desired hostname ("default" cluster/internal, "external" - world accessible)
     * @returns - the requested hostname, or undefined if it is not yet available
     *
     * @remarks
     * This function should return the external, world accessible name if there is no cluster/internal only name.
     * The function should throw an error if an external name is requested, but no name/address is available
     * (e.g., the service is internally acessible only.)
     */
    hostname(scope?: NetworkScope): string | undefined;
    /**
     * Returns the TCP or UDP port of the exposed service
     *
     * @remarks
     * Will return undefined if the port information is not yet available
     */
    port(): number | undefined;
}

/**
 * Props for the {@link NetworkService} element
 * @public
 */
export declare interface NetworkServiceProps extends WithChildren {
    /** IP address of the network service */
    ip?: string;
    /** Name of the network service */
    name?: string;
    /** Port on which clients connect to this service */
    port: ServicePort;
    /** Protocol used by the network service */
    protocol?: string;
    /** Scope of the service */
    scope?: NetworkServiceScope;
    /** Port on the endpoint that provides this service */
    targetPort?: ServicePort;
    /** Endpoint that provides the service */
    endpoint?: Handle;
}

/**
 * Network service scope used by {@link NetworkService}
 * @public
 */
export declare type NetworkServiceScope = "local" | "cluster-internal" | "cluster-public" | "external";

export declare namespace nginx {
/**
   * {@link http.HttpServer} implementation based on {@link https://nginx.org | nginx}
   *
   * @public
   */
  declare function HttpServer(propsIn: SFCDeclProps<HttpServerProps, typeof defaultProps>): Adapt.JSX.Element;/**
   * {@link http.HttpServer} implementation based on {@link https://nginx.org | nginx}
   *
   * @public
   */
  declare function HttpServer(propsIn: SFCDeclProps<HttpServerProps, typeof defaultProps>): Adapt.JSX.Element;/**
   * {@link http.UrlRouter} implementation based on {@link https://nginx.org | nginx}
   *
   * @public
   */
  declare function UrlRouter(propsIn: SFCDeclProps<UrlRouterProps, typeof defaultProps>): Adapt.JSX.Element;/**
   * Props for {@link nginx.UrlRouter}
   *
   * @public
   */
  export declare interface UrlRouterProps extends AbsUrlRouterProps {
      debug: boolean;
  }/**
   * {@link http.UrlRouter} implementation based on {@link https://nginx.org | nginx}
   *
   * @public
   */
  declare function UrlRouter(propsIn: SFCDeclProps<UrlRouterProps, typeof defaultProps>): Adapt.JSX.Element;/**
   * {@link http.HttpServer} implementation based on {@link https://nginx.org | nginx}
   *
   * @public
   */
  declare function HttpServer(propsIn: SFCDeclProps<HttpServerProps, typeof defaultProps>): Adapt.JSX.Element;/**
   * {@link http.HttpServer} implementation based on {@link https://nginx.org | nginx}
   *
   * @public
   */
  declare function HttpServer(propsIn: SFCDeclProps<HttpServerProps, typeof defaultProps>): Adapt.JSX.Element;/**
   * {@link http.UrlRouter} implementation based on {@link https://nginx.org | nginx}
   *
   * @public
   */
  declare function UrlRouter(propsIn: SFCDeclProps<UrlRouterProps, typeof defaultProps>): Adapt.JSX.Element;/**
   * Props for {@link nginx.UrlRouter}
   *
   * @public
   */
  export declare interface UrlRouterProps extends AbsUrlRouterProps {
      debug: boolean;
  }/**
   * {@link http.UrlRouter} implementation based on {@link https://nginx.org | nginx}
   *
   * @public
   */
  declare function UrlRouter(propsIn: SFCDeclProps<UrlRouterProps, typeof defaultProps>): Adapt.JSX.Element;
}

export declare namespace nodejs {
/**
   * A partially abstract component that builds Node.js source code into a Container
   * and exposes a NetworkService.
   *
   * @remarks
   * To use this component, the `srcDir` prop must be the path to the root of
   * a Node.js project, which contains a package.json file. The component will
   * build a Docker container image by:
   *
   * - starting with an official Node.js base image
   *
   * - copying `srcDir` into the container image
   *
   * - executing `npm run build`
   *
   * - setting the container CMD to execute the `main` file specified in
   *   package.json
   *
   * Abstract components:
   *
   * This component uses the following abstract components which must be
   * replaced via style sheet rules:
   *
   * - {@link Service}
   *
   * - {@link NetworkService}
   *
   * - {@link Container}
   *
   * The {@link NetworkService} and {@link Container} components are both
   * children of the {@link Service} component.
   *
   * Instance methods:
   *
   * - `hostname(): string | undefined`
   *
   *   Returns the hostname of the NetworkService, once it is known.
   *
   * - `port(): number | undefined`
   *
   *   Returns the port number of the NetworkService, once it is known.
   *
   * - `image():` {@link docker.ImageInfo} | `undefined`
   *
   *   Information about the successfully built image, once it has been built.
   *
   * @param props - See {@link nodejs.NodeServiceProps}
   * @public
   */
  declare function NodeService(props: SFCDeclProps<NodeServiceProps, typeof defaultProps>): Adapt.JSX.Element;/**
   * Props for {@link nodejs.NodeService}.
   * @public
   */
  export declare interface NodeServiceProps {
      /**
       * Image build options to pass to {@link nodejs.LocalNodeImage}.
       */
      buildOptions: NodeImageBuildOptions;
      /**
       * Handles for services that this component connects to.
       * @remarks
       * The referenced service components must implement the
       * {@link ConnectToInstance} interface. The Node Container will be
       * started with the combined set of environment variables that are
       * provided by all of the referenced components'
       * {@link ConnectToInstance.connectEnv | connectEnv} methods.
       *
       * In case of environment variable naming conflicts among those in
       * from the `connectTo` prop, the value from the handle with the highest
       * index in the `connectTo` array will take precedence.
       * In case of naming conflicts between `connectTo` and `env`, the value
       * in `env` will take precedence.
       * @defaultValue `[]`
       */
      connectTo: Handle<ConnectToInstance> | Handle<ConnectToInstance>[];
      /**
       * Dependencies that must be deployed before the Container image will
       * build.
       * @remarks
       * Note that the NetworkService will also not deploy before the
       * Container image has been built.
       * @defaultValue `[]`
       */
      deps: Handle | Handle[];
      /**
       * Object containing environment variables that the Container will be
       * started with.
       * @defaultValue `{}`
       */
      env: Environment;
      /**
       * The port that the NetworkService will expose.
       * @defaultValue Use the same port number as `port`
       */
      externalPort?: number;
      /**
       * The port number that the Node Container will use.
       * @defaultValue 8080
       */
      port: number;
      /**
       * Scope within which the NetworkService will be exposed.
       * @defaultValue "cluster-internal"
       */
      scope: NetworkServiceScope;
      /**
       * Root directory (which contains package.json) for the Node.js app
       * source code.
       */
      srcDir: string;
  }/**
   * A partially abstract component that builds Node.js source code into a Container
   * and exposes a NetworkService.
   *
   * @remarks
   * To use this component, the `srcDir` prop must be the path to the root of
   * a Node.js project, which contains a package.json file. The component will
   * build a Docker container image by:
   *
   * - starting with an official Node.js base image
   *
   * - copying `srcDir` into the container image
   *
   * - executing `npm run build`
   *
   * - setting the container CMD to execute the `main` file specified in
   *   package.json
   *
   * Abstract components:
   *
   * This component uses the following abstract components which must be
   * replaced via style sheet rules:
   *
   * - {@link Service}
   *
   * - {@link NetworkService}
   *
   * - {@link Container}
   *
   * The {@link NetworkService} and {@link Container} components are both
   * children of the {@link Service} component.
   *
   * Instance methods:
   *
   * - `hostname(): string | undefined`
   *
   *   Returns the hostname of the NetworkService, once it is known.
   *
   * - `port(): number | undefined`
   *
   *   Returns the port number of the NetworkService, once it is known.
   *
   * - `image():` {@link docker.ImageInfo} | `undefined`
   *
   *   Information about the successfully built image, once it has been built.
   *
   * @param props - See {@link nodejs.NodeServiceProps}
   * @public
   */
  declare function NodeService(props: SFCDeclProps<NodeServiceProps, typeof defaultProps>): Adapt.JSX.Element;/**
   * Locally builds a docker image for a {@link https://www.nodejs.org | Node.js} program.
   *
   * @remarks
   * Implements {@link docker.DockerImageInstance}.
   *
   * See {@link nodejs.LocalNodeImageProps}.
   *
   * @public
   */
  export declare function LocalNodeImage(props: LocalNodeImageProps): Adapt.JSX.Element | null;/**
   * Props for {@link nodejs.LocalNodeImage}
   *
   * @public
   */
  export declare interface LocalNodeImageProps extends Partial<BuiltinProps> {
      /** Source directory for the Node.js program */
      srcDir: string;
      /** Build options */
      options?: NodeImageBuildOptions;
  }/**
   * Options controlling how the Docker image is built in
   * {@link nodejs.LocalNodeImage}.
   * @public
   */
  export declare interface NodeImageBuildOptions extends DockerBuildOptions {
      /**
       * Base Docker image used to build {@link nodejs.LocalNodeImage}.
       *
       * @defaultValue "node:14-stretch-slim"
       */
      baseImage?: NameTagString;
      /**
       * Environment variables that should be present during docker build
       *
       * @remarks
       * This adds an `ARG <varName>` line to the Dockerfile for every variable in env, and sets the
       * variable in the environment before running `docker build`.
       */
      buildArgs?: Environment;
      /**
       * Default command to run in container
       *
       * @remarks
       *
       * If this is a string, the Dockerfile used to build the image will use
       * shell form for the command, i.e., `CMD <cmd value>`.  If this
       * is an array of string, exec form will be used instead, i.e.,
       * `CMD ["cmd[0]", "cmd[1]", "cmd[2]", ...]`.
       *
       * If `cmd` is not specified, the default command of `node` with
       * the value of `main` from the top-level package.json will be used.
       */
      cmd?: string | string[];
      /**
       * Node version used to build {@link nodejs.LocalNodeImage}.
       *
       * @defaultValue 14
       *
       * @remarks
       * If baseImage is specified, this option is ignored and baseImage
       * is used instead.  Otherwise, `node:${nodeVersion}-stretch-slim` is
       * used as the baseImage.
       */
      nodeVersion?: number | string;
      /**
       * Build an image that allows for better layer caching of node_modules
       *
       * Copies all `package.json`, `yarn.lock`, `package-log.json`, and `npm-shrinkwrap.json`
       * files, then installs node_modules, then copies all the source files, and
       * reruns install.  This allows the first install of node_modules to be its
       * own cacheable layer that does not need to be rebuilt when the source code
       * changes, only when one of the aforementioned files changes.
       *
       * There are certain caveats to using this option.  First, if `baseImage` or
       * nodeVersion runs npm version 7 or later (nodeVersion \>= 15), or you are
       * using yarn, any lifecycle scripts you have cannot fail if the full source
       * directory is not present.  Neither yarn nor npm have a way to
       * install node_modules, run the lifecycle scripts for dependencies, but
       * skip these scripts for the main package.  As a result, the preinstall
       * run will run the lifecycle scripts without the full source present.
       * It appears that npm versions prior to 7 don't run the lifecycle scripts
       * for the main package, so this should not be an issue.  Caveat emptor.
       *
       * @defaultValue false
       */
      optimizedImage?: boolean;
      /**
       * Package manager to use in build steps in the generated Dockerfile
       * that builds {@link nodejs.LocalNodeImage}.
       *
       * @defaultValue "npm"
       */
      packageManager?: "npm" | "yarn" | string;
      /**
       * Scripts that are defined in your
       * {@link https://docs.npmjs.com/files/package.json | package.json file}
       * that should be run during the image build.
       */
      runNpmScripts?: string | string[];
  }/**
   * A partially abstract component that builds
   * {@link https://reactjs.org | ReactJS} source code and serves the resulting
   * files via an {@link http.HttpServer}.
   *
   * @remarks
   * To use this component, the `srcDir` prop must be the path to the root of
   * a ReactJS project, which contains a package.json file. The component will
   * build a Docker container image by:
   *
   * - starting with an official Node.js base image
   *
   * - copying `srcDir` into the container image
   *
   * - executing `yarn run build`
   *
   * It will then copy the resulting `build` directory into an {@link http.HttpServer}
   * component.
   *
   * Abstract components:
   *
   * This component uses the following abstract components (via
   * {@link http.HttpServer})which must be replaced via style sheet rules:
   *
   * - {@link Service}
   *
   * - {@link NetworkService}
   *
   * - {@link Container}
   *
   * The {@link NetworkService} and {@link Container} components are both
   * children of the {@link Service} component.
   *
   * Instance methods:
   *
   * - hostname(): string | undefined
   *
   *   Returns the hostname of the NetworkService, once it is known.
   *
   * - port(): number | undefined
   *
   *   Returns the port number of the NetworkService, once it is known.
   *
   * @public
   */
  export declare function ReactApp(props: SFCDeclProps<ReactAppProps, typeof defaultOptions>): Adapt.JSX.Element;/**
   * Props for {@link nodejs.ReactApp}.
   * @public
   */
  export declare interface ReactAppProps {
      /**
       * The source code directory to build.
       * @remarks
       * This directory should contain the `package.json` file for the React
       * app.
       */
      srcDir: string;
      /**
       * Options to be passed to the `LocalNodeImage` prop called `options`.
       */
      buildOptions: NodeImageBuildOptions;
      /**
       * Options to be passed to the `HttpServer` component.
       */
      httpOptions: Partial<HttpServerProps>;
  }/**
   * A partially abstract component that builds Node.js source code into a Container
   * and exposes a NetworkService.
   *
   * @remarks
   * To use this component, the `srcDir` prop must be the path to the root of
   * a Node.js project, which contains a package.json file. The component will
   * build a Docker container image by:
   *
   * - starting with an official Node.js base image
   *
   * - copying `srcDir` into the container image
   *
   * - executing `npm run build`
   *
   * - setting the container CMD to execute the `main` file specified in
   *   package.json
   *
   * Abstract components:
   *
   * This component uses the following abstract components which must be
   * replaced via style sheet rules:
   *
   * - {@link Service}
   *
   * - {@link NetworkService}
   *
   * - {@link Container}
   *
   * The {@link NetworkService} and {@link Container} components are both
   * children of the {@link Service} component.
   *
   * Instance methods:
   *
   * - `hostname(): string | undefined`
   *
   *   Returns the hostname of the NetworkService, once it is known.
   *
   * - `port(): number | undefined`
   *
   *   Returns the port number of the NetworkService, once it is known.
   *
   * - `image():` {@link docker.ImageInfo} | `undefined`
   *
   *   Information about the successfully built image, once it has been built.
   *
   * @param props - See {@link nodejs.NodeServiceProps}
   * @public
   */
  declare function NodeService(props: SFCDeclProps<NodeServiceProps, typeof defaultProps>): Adapt.JSX.Element;/**
   * Props for {@link nodejs.NodeService}.
   * @public
   */
  export declare interface NodeServiceProps {
      /**
       * Image build options to pass to {@link nodejs.LocalNodeImage}.
       */
      buildOptions: NodeImageBuildOptions;
      /**
       * Handles for services that this component connects to.
       * @remarks
       * The referenced service components must implement the
       * {@link ConnectToInstance} interface. The Node Container will be
       * started with the combined set of environment variables that are
       * provided by all of the referenced components'
       * {@link ConnectToInstance.connectEnv | connectEnv} methods.
       *
       * In case of environment variable naming conflicts among those in
       * from the `connectTo` prop, the value from the handle with the highest
       * index in the `connectTo` array will take precedence.
       * In case of naming conflicts between `connectTo` and `env`, the value
       * in `env` will take precedence.
       * @defaultValue `[]`
       */
      connectTo: Handle<ConnectToInstance> | Handle<ConnectToInstance>[];
      /**
       * Dependencies that must be deployed before the Container image will
       * build.
       * @remarks
       * Note that the NetworkService will also not deploy before the
       * Container image has been built.
       * @defaultValue `[]`
       */
      deps: Handle | Handle[];
      /**
       * Object containing environment variables that the Container will be
       * started with.
       * @defaultValue `{}`
       */
      env: Environment;
      /**
       * The port that the NetworkService will expose.
       * @defaultValue Use the same port number as `port`
       */
      externalPort?: number;
      /**
       * The port number that the Node Container will use.
       * @defaultValue 8080
       */
      port: number;
      /**
       * Scope within which the NetworkService will be exposed.
       * @defaultValue "cluster-internal"
       */
      scope: NetworkServiceScope;
      /**
       * Root directory (which contains package.json) for the Node.js app
       * source code.
       */
      srcDir: string;
  }/**
   * A partially abstract component that builds Node.js source code into a Container
   * and exposes a NetworkService.
   *
   * @remarks
   * To use this component, the `srcDir` prop must be the path to the root of
   * a Node.js project, which contains a package.json file. The component will
   * build a Docker container image by:
   *
   * - starting with an official Node.js base image
   *
   * - copying `srcDir` into the container image
   *
   * - executing `npm run build`
   *
   * - setting the container CMD to execute the `main` file specified in
   *   package.json
   *
   * Abstract components:
   *
   * This component uses the following abstract components which must be
   * replaced via style sheet rules:
   *
   * - {@link Service}
   *
   * - {@link NetworkService}
   *
   * - {@link Container}
   *
   * The {@link NetworkService} and {@link Container} components are both
   * children of the {@link Service} component.
   *
   * Instance methods:
   *
   * - `hostname(): string | undefined`
   *
   *   Returns the hostname of the NetworkService, once it is known.
   *
   * - `port(): number | undefined`
   *
   *   Returns the port number of the NetworkService, once it is known.
   *
   * - `image():` {@link docker.ImageInfo} | `undefined`
   *
   *   Information about the successfully built image, once it has been built.
   *
   * @param props - See {@link nodejs.NodeServiceProps}
   * @public
   */
  declare function NodeService(props: SFCDeclProps<NodeServiceProps, typeof defaultProps>): Adapt.JSX.Element;/**
   * Locally builds a docker image for a {@link https://www.nodejs.org | Node.js} program.
   *
   * @remarks
   * Implements {@link docker.DockerImageInstance}.
   *
   * See {@link nodejs.LocalNodeImageProps}.
   *
   * @public
   */
  export declare function LocalNodeImage(props: LocalNodeImageProps): Adapt.JSX.Element | null;/**
   * Props for {@link nodejs.LocalNodeImage}
   *
   * @public
   */
  export declare interface LocalNodeImageProps extends Partial<BuiltinProps> {
      /** Source directory for the Node.js program */
      srcDir: string;
      /** Build options */
      options?: NodeImageBuildOptions;
  }/**
   * Options controlling how the Docker image is built in
   * {@link nodejs.LocalNodeImage}.
   * @public
   */
  export declare interface NodeImageBuildOptions extends DockerBuildOptions {
      /**
       * Base Docker image used to build {@link nodejs.LocalNodeImage}.
       *
       * @defaultValue "node:14-stretch-slim"
       */
      baseImage?: NameTagString;
      /**
       * Environment variables that should be present during docker build
       *
       * @remarks
       * This adds an `ARG <varName>` line to the Dockerfile for every variable in env, and sets the
       * variable in the environment before running `docker build`.
       */
      buildArgs?: Environment;
      /**
       * Default command to run in container
       *
       * @remarks
       *
       * If this is a string, the Dockerfile used to build the image will use
       * shell form for the command, i.e., `CMD <cmd value>`.  If this
       * is an array of string, exec form will be used instead, i.e.,
       * `CMD ["cmd[0]", "cmd[1]", "cmd[2]", ...]`.
       *
       * If `cmd` is not specified, the default command of `node` with
       * the value of `main` from the top-level package.json will be used.
       */
      cmd?: string | string[];
      /**
       * Node version used to build {@link nodejs.LocalNodeImage}.
       *
       * @defaultValue 14
       *
       * @remarks
       * If baseImage is specified, this option is ignored and baseImage
       * is used instead.  Otherwise, `node:${nodeVersion}-stretch-slim` is
       * used as the baseImage.
       */
      nodeVersion?: number | string;
      /**
       * Build an image that allows for better layer caching of node_modules
       *
       * Copies all `package.json`, `yarn.lock`, `package-log.json`, and `npm-shrinkwrap.json`
       * files, then installs node_modules, then copies all the source files, and
       * reruns install.  This allows the first install of node_modules to be its
       * own cacheable layer that does not need to be rebuilt when the source code
       * changes, only when one of the aforementioned files changes.
       *
       * There are certain caveats to using this option.  First, if `baseImage` or
       * nodeVersion runs npm version 7 or later (nodeVersion \>= 15), or you are
       * using yarn, any lifecycle scripts you have cannot fail if the full source
       * directory is not present.  Neither yarn nor npm have a way to
       * install node_modules, run the lifecycle scripts for dependencies, but
       * skip these scripts for the main package.  As a result, the preinstall
       * run will run the lifecycle scripts without the full source present.
       * It appears that npm versions prior to 7 don't run the lifecycle scripts
       * for the main package, so this should not be an issue.  Caveat emptor.
       *
       * @defaultValue false
       */
      optimizedImage?: boolean;
      /**
       * Package manager to use in build steps in the generated Dockerfile
       * that builds {@link nodejs.LocalNodeImage}.
       *
       * @defaultValue "npm"
       */
      packageManager?: "npm" | "yarn" | string;
      /**
       * Scripts that are defined in your
       * {@link https://docs.npmjs.com/files/package.json | package.json file}
       * that should be run during the image build.
       */
      runNpmScripts?: string | string[];
  }/**
   * A partially abstract component that builds
   * {@link https://reactjs.org | ReactJS} source code and serves the resulting
   * files via an {@link http.HttpServer}.
   *
   * @remarks
   * To use this component, the `srcDir` prop must be the path to the root of
   * a ReactJS project, which contains a package.json file. The component will
   * build a Docker container image by:
   *
   * - starting with an official Node.js base image
   *
   * - copying `srcDir` into the container image
   *
   * - executing `yarn run build`
   *
   * It will then copy the resulting `build` directory into an {@link http.HttpServer}
   * component.
   *
   * Abstract components:
   *
   * This component uses the following abstract components (via
   * {@link http.HttpServer})which must be replaced via style sheet rules:
   *
   * - {@link Service}
   *
   * - {@link NetworkService}
   *
   * - {@link Container}
   *
   * The {@link NetworkService} and {@link Container} components are both
   * children of the {@link Service} component.
   *
   * Instance methods:
   *
   * - hostname(): string | undefined
   *
   *   Returns the hostname of the NetworkService, once it is known.
   *
   * - port(): number | undefined
   *
   *   Returns the port number of the NetworkService, once it is known.
   *
   * @public
   */
  export declare function ReactApp(props: SFCDeclProps<ReactAppProps, typeof defaultOptions>): Adapt.JSX.Element;/**
   * Props for {@link nodejs.ReactApp}.
   * @public
   */
  export declare interface ReactAppProps {
      /**
       * The source code directory to build.
       * @remarks
       * This directory should contain the `package.json` file for the React
       * app.
       */
      srcDir: string;
      /**
       * Options to be passed to the `LocalNodeImage` prop called `options`.
       */
      buildOptions: NodeImageBuildOptions;
      /**
       * Options to be passed to the `HttpServer` component.
       */
      httpOptions: Partial<HttpServerProps>;
  }/**
   * A partially abstract component that builds Node.js source code into a Container
   * and exposes a NetworkService.
   *
   * @remarks
   * To use this component, the `srcDir` prop must be the path to the root of
   * a Node.js project, which contains a package.json file. The component will
   * build a Docker container image by:
   *
   * - starting with an official Node.js base image
   *
   * - copying `srcDir` into the container image
   *
   * - executing `npm run build`
   *
   * - setting the container CMD to execute the `main` file specified in
   *   package.json
   *
   * Abstract components:
   *
   * This component uses the following abstract components which must be
   * replaced via style sheet rules:
   *
   * - {@link Service}
   *
   * - {@link NetworkService}
   *
   * - {@link Container}
   *
   * The {@link NetworkService} and {@link Container} components are both
   * children of the {@link Service} component.
   *
   * Instance methods:
   *
   * - `hostname(): string | undefined`
   *
   *   Returns the hostname of the NetworkService, once it is known.
   *
   * - `port(): number | undefined`
   *
   *   Returns the port number of the NetworkService, once it is known.
   *
   * - `image():` {@link docker.ImageInfo} | `undefined`
   *
   *   Information about the successfully built image, once it has been built.
   *
   * @param props - See {@link nodejs.NodeServiceProps}
   * @public
   */
  declare function NodeService(props: SFCDeclProps<NodeServiceProps, typeof defaultProps>): Adapt.JSX.Element;/**
   * Props for {@link nodejs.NodeService}.
   * @public
   */
  export declare interface NodeServiceProps {
      /**
       * Image build options to pass to {@link nodejs.LocalNodeImage}.
       */
      buildOptions: NodeImageBuildOptions;
      /**
       * Handles for services that this component connects to.
       * @remarks
       * The referenced service components must implement the
       * {@link ConnectToInstance} interface. The Node Container will be
       * started with the combined set of environment variables that are
       * provided by all of the referenced components'
       * {@link ConnectToInstance.connectEnv | connectEnv} methods.
       *
       * In case of environment variable naming conflicts among those in
       * from the `connectTo` prop, the value from the handle with the highest
       * index in the `connectTo` array will take precedence.
       * In case of naming conflicts between `connectTo` and `env`, the value
       * in `env` will take precedence.
       * @defaultValue `[]`
       */
      connectTo: Handle<ConnectToInstance> | Handle<ConnectToInstance>[];
      /**
       * Dependencies that must be deployed before the Container image will
       * build.
       * @remarks
       * Note that the NetworkService will also not deploy before the
       * Container image has been built.
       * @defaultValue `[]`
       */
      deps: Handle | Handle[];
      /**
       * Object containing environment variables that the Container will be
       * started with.
       * @defaultValue `{}`
       */
      env: Environment;
      /**
       * The port that the NetworkService will expose.
       * @defaultValue Use the same port number as `port`
       */
      externalPort?: number;
      /**
       * The port number that the Node Container will use.
       * @defaultValue 8080
       */
      port: number;
      /**
       * Scope within which the NetworkService will be exposed.
       * @defaultValue "cluster-internal"
       */
      scope: NetworkServiceScope;
      /**
       * Root directory (which contains package.json) for the Node.js app
       * source code.
       */
      srcDir: string;
  }/**
   * A partially abstract component that builds Node.js source code into a Container
   * and exposes a NetworkService.
   *
   * @remarks
   * To use this component, the `srcDir` prop must be the path to the root of
   * a Node.js project, which contains a package.json file. The component will
   * build a Docker container image by:
   *
   * - starting with an official Node.js base image
   *
   * - copying `srcDir` into the container image
   *
   * - executing `npm run build`
   *
   * - setting the container CMD to execute the `main` file specified in
   *   package.json
   *
   * Abstract components:
   *
   * This component uses the following abstract components which must be
   * replaced via style sheet rules:
   *
   * - {@link Service}
   *
   * - {@link NetworkService}
   *
   * - {@link Container}
   *
   * The {@link NetworkService} and {@link Container} components are both
   * children of the {@link Service} component.
   *
   * Instance methods:
   *
   * - `hostname(): string | undefined`
   *
   *   Returns the hostname of the NetworkService, once it is known.
   *
   * - `port(): number | undefined`
   *
   *   Returns the port number of the NetworkService, once it is known.
   *
   * - `image():` {@link docker.ImageInfo} | `undefined`
   *
   *   Information about the successfully built image, once it has been built.
   *
   * @param props - See {@link nodejs.NodeServiceProps}
   * @public
   */
  declare function NodeService(props: SFCDeclProps<NodeServiceProps, typeof defaultProps>): Adapt.JSX.Element;/**
   * Locally builds a docker image for a {@link https://www.nodejs.org | Node.js} program.
   *
   * @remarks
   * Implements {@link docker.DockerImageInstance}.
   *
   * See {@link nodejs.LocalNodeImageProps}.
   *
   * @public
   */
  export declare function LocalNodeImage(props: LocalNodeImageProps): Adapt.JSX.Element | null;/**
   * Props for {@link nodejs.LocalNodeImage}
   *
   * @public
   */
  export declare interface LocalNodeImageProps extends Partial<BuiltinProps> {
      /** Source directory for the Node.js program */
      srcDir: string;
      /** Build options */
      options?: NodeImageBuildOptions;
  }/**
   * Options controlling how the Docker image is built in
   * {@link nodejs.LocalNodeImage}.
   * @public
   */
  export declare interface NodeImageBuildOptions extends DockerBuildOptions {
      /**
       * Base Docker image used to build {@link nodejs.LocalNodeImage}.
       *
       * @defaultValue "node:14-stretch-slim"
       */
      baseImage?: NameTagString;
      /**
       * Environment variables that should be present during docker build
       *
       * @remarks
       * This adds an `ARG <varName>` line to the Dockerfile for every variable in env, and sets the
       * variable in the environment before running `docker build`.
       */
      buildArgs?: Environment;
      /**
       * Default command to run in container
       *
       * @remarks
       *
       * If this is a string, the Dockerfile used to build the image will use
       * shell form for the command, i.e., `CMD <cmd value>`.  If this
       * is an array of string, exec form will be used instead, i.e.,
       * `CMD ["cmd[0]", "cmd[1]", "cmd[2]", ...]`.
       *
       * If `cmd` is not specified, the default command of `node` with
       * the value of `main` from the top-level package.json will be used.
       */
      cmd?: string | string[];
      /**
       * Node version used to build {@link nodejs.LocalNodeImage}.
       *
       * @defaultValue 14
       *
       * @remarks
       * If baseImage is specified, this option is ignored and baseImage
       * is used instead.  Otherwise, `node:${nodeVersion}-stretch-slim` is
       * used as the baseImage.
       */
      nodeVersion?: number | string;
      /**
       * Build an image that allows for better layer caching of node_modules
       *
       * Copies all `package.json`, `yarn.lock`, `package-log.json`, and `npm-shrinkwrap.json`
       * files, then installs node_modules, then copies all the source files, and
       * reruns install.  This allows the first install of node_modules to be its
       * own cacheable layer that does not need to be rebuilt when the source code
       * changes, only when one of the aforementioned files changes.
       *
       * There are certain caveats to using this option.  First, if `baseImage` or
       * nodeVersion runs npm version 7 or later (nodeVersion \>= 15), or you are
       * using yarn, any lifecycle scripts you have cannot fail if the full source
       * directory is not present.  Neither yarn nor npm have a way to
       * install node_modules, run the lifecycle scripts for dependencies, but
       * skip these scripts for the main package.  As a result, the preinstall
       * run will run the lifecycle scripts without the full source present.
       * It appears that npm versions prior to 7 don't run the lifecycle scripts
       * for the main package, so this should not be an issue.  Caveat emptor.
       *
       * @defaultValue false
       */
      optimizedImage?: boolean;
      /**
       * Package manager to use in build steps in the generated Dockerfile
       * that builds {@link nodejs.LocalNodeImage}.
       *
       * @defaultValue "npm"
       */
      packageManager?: "npm" | "yarn" | string;
      /**
       * Scripts that are defined in your
       * {@link https://docs.npmjs.com/files/package.json | package.json file}
       * that should be run during the image build.
       */
      runNpmScripts?: string | string[];
  }/**
   * A partially abstract component that builds
   * {@link https://reactjs.org | ReactJS} source code and serves the resulting
   * files via an {@link http.HttpServer}.
   *
   * @remarks
   * To use this component, the `srcDir` prop must be the path to the root of
   * a ReactJS project, which contains a package.json file. The component will
   * build a Docker container image by:
   *
   * - starting with an official Node.js base image
   *
   * - copying `srcDir` into the container image
   *
   * - executing `yarn run build`
   *
   * It will then copy the resulting `build` directory into an {@link http.HttpServer}
   * component.
   *
   * Abstract components:
   *
   * This component uses the following abstract components (via
   * {@link http.HttpServer})which must be replaced via style sheet rules:
   *
   * - {@link Service}
   *
   * - {@link NetworkService}
   *
   * - {@link Container}
   *
   * The {@link NetworkService} and {@link Container} components are both
   * children of the {@link Service} component.
   *
   * Instance methods:
   *
   * - hostname(): string | undefined
   *
   *   Returns the hostname of the NetworkService, once it is known.
   *
   * - port(): number | undefined
   *
   *   Returns the port number of the NetworkService, once it is known.
   *
   * @public
   */
  export declare function ReactApp(props: SFCDeclProps<ReactAppProps, typeof defaultOptions>): Adapt.JSX.Element;/**
   * Props for {@link nodejs.ReactApp}.
   * @public
   */
  export declare interface ReactAppProps {
      /**
       * The source code directory to build.
       * @remarks
       * This directory should contain the `package.json` file for the React
       * app.
       */
      srcDir: string;
      /**
       * Options to be passed to the `LocalNodeImage` prop called `options`.
       */
      buildOptions: NodeImageBuildOptions;
      /**
       * Options to be passed to the `HttpServer` component.
       */
      httpOptions: Partial<HttpServerProps>;
  }
}

/**
 * A set of ports to be bound for a {@link Container}.
 *
 * @remarks
 * See the
 * {@link https://docs.docker.com/engine/api/v1.40/#operation/ContainerCreate | Docker API Reference}
 * for more information.
 * @public
 */
export declare interface PortBinding {
    [ctrPort: number]: number;
    [ctrPort: string]: number;
}

/**
 * PortBindings for {@link ContainerStatus}
 * @public
 */
export declare interface PortBindingsStatus {
    [ctrPort: string]: PortBindingStatus[];
}

/**
 * PortBinding information for {@link ContainerStatus}
 * @public
 */
export declare interface PortBindingStatus {
    HostIp: string;
    HostPort: string;
}

/**
 * Description of a network port for a {@link Container}.
 *
 * @remarks
 * See the
 * {@link https://docs.docker.com/engine/api/v1.40/#operation/ContainerCreate | Docker API Reference}
 * for more information.
 * @public
 */
export declare type PortDescription = string | number;

export declare namespace postgres {
/**
   * An abstract component representing a Postgres database within a Postgres
   * server or service.
   *
   * @remarks
   *
   * Implements the {@link ConnectToInstance} interface.
   *
   * Instance methods:
   *
   * - `connectEnv(scope?: NetworkScope): Environment | undefined`
   *
   *   Returns the set of environment variables that have all the information
   *   needed for a Postgres client to connect to this database. The
   *   returned environment variables are named such that some common Postgres
   *   clients can use them directly:
   *
   *   `PGHOST`: The host to connect to.
   *
   *   `PGDATABASE`: The name of the database.
   *
   *   `PGUSER`: Username to use to authenticate to the database server or service.
   *
   *   `PGPASSWORD`: Password to use to authenticate to the database server or service.
   *
   *   Note that because this component is an abstract component, `connectEnv`
   *   always returns `undefined`. This abstract component should be replaced
   *   (using a style sheet) with a non-abstract component, such as
   *   {@link postgres.TestPostgres} that will provide its own implementation
   *   of `connectEnv`.
   *
   * @public
   */
  export declare function Postgres(): null;/**
   * A component suitable for creating test scenarios that creates a simple,
   * temporary Postgres database that loads test data from a .sql file and
   * which implements the abstract {@link postgres.Postgres} interface.
   *
   * @remarks
   *
   * Implements the {@link ConnectToInstance} interface.
   *
   * Instance methods:
   *
   * - `connectEnv(scope?: NetworkScope): Environment | undefined`
   *
   *   Returns the set of environment variables that have all the information
   *   needed for a Postgres client to connect to this database. The
   *   returned environment variables are named such that some common Postgres
   *   clients can use them directly:
   *
   *   `PGHOST`: The host to connect to.
   *
   *   `PGDATABASE`: The name of the database.
   *
   *   `PGUSER`: Username to use to authenticate to the database server or service.
   *
   *   `PGPASSWORD`: Password to use to authenticate to the database server or service.
   *
   * @public
   */
  export declare function TestPostgres(props: SFCDeclProps<TestPostgresProps>): Adapt.JSX.Element;/**
   * Props for the {@link postgres.TestPostgres} component
   *
   * @public
   */
  export declare interface TestPostgresProps {
      mockDataPath: string;
      mockDbName: string;
  }/**
   * Creates a throw-away {@link https://www.postgresql.org | Postgres} database with preloaded data.
   *
   * @remarks
   * Implements {@link docker.DockerImageInstance}.
   *
   * See {@link postgres.PreloadedPostgresImageProps}
   *
   * @public
   */
  export declare function PreloadedPostgresImage(props: PreloadedPostgresImageProps): Adapt.JSX.Element | null;/**
   * Props for {@link postgres.PreloadedPostgresImage}
   *
   * @public
   */
  export declare interface PreloadedPostgresImageProps {
      /** Name of database in which to load mock data */
      mockDbName: string;
      /**
       * Path to a sql file with both schema and data to load into the database
       *
       * @remarks
       *
       * This data can be produced by standing up a postgres instance, populating it with
       * the required data and then running {@link https://www.postgresql.org/docs/9.1/app-pgdump.html | pg_dump}.
       */
      mockDataPath: string;
  }/**
   * Component that represents an external provider of a Postgres database
   *
   * @remarks
   *
   * See {@link postgres.PostgresProviderProps}.
   *
   * Use this component to connect other cloud components to a external
   * Postgres services, such as Google CloudSQL or Amazon RDS.
   *
   * @example
   *
   * ```
   * const pg = handle();
   *
   * <PostgresProvider handle={pg}
   *   hostname="mypostgres.com:5432"
   *   db="db"
   *   user="myuser"
   *   password={process.env.PGPASSWORD}
   * />
   *
   * <NodeService src="/somedir" connectTo={pg} />
   * ```
   *
   * @public
   */
  declare function PostgresProvider(props: PostgresProviderProps): null;/**
   * Props for the {@link postgres.PostgresProvider} component
   *
   * @public
   */
  export declare interface PostgresProviderProps {
      /** Hostname for the Postgres database as it would appear in the PGHOST environment variable */
      host?: string;
      /** Postgres database name as it would appear in the PGDATABASE environment variable */
      database?: string;
      /** Postgres username as it would appear in the PGUSER environment variable */
      user?: string;
      /** Postgres password as it would appear in the PGPASSWORD environment variable */
      password?: string;
  }/**
   * Component that represents an external provider of a Postgres database
   *
   * @remarks
   *
   * See {@link postgres.PostgresProviderProps}.
   *
   * Use this component to connect other cloud components to a external
   * Postgres services, such as Google CloudSQL or Amazon RDS.
   *
   * @example
   *
   * ```
   * const pg = handle();
   *
   * <PostgresProvider handle={pg}
   *   hostname="mypostgres.com:5432"
   *   db="db"
   *   user="myuser"
   *   password={process.env.PGPASSWORD}
   * />
   *
   * <NodeService src="/somedir" connectTo={pg} />
   * ```
   *
   * @public
   */
  declare function PostgresProvider(props: PostgresProviderProps): null;/**
   * An abstract component representing a Postgres database within a Postgres
   * server or service.
   *
   * @remarks
   *
   * Implements the {@link ConnectToInstance} interface.
   *
   * Instance methods:
   *
   * - `connectEnv(scope?: NetworkScope): Environment | undefined`
   *
   *   Returns the set of environment variables that have all the information
   *   needed for a Postgres client to connect to this database. The
   *   returned environment variables are named such that some common Postgres
   *   clients can use them directly:
   *
   *   `PGHOST`: The host to connect to.
   *
   *   `PGDATABASE`: The name of the database.
   *
   *   `PGUSER`: Username to use to authenticate to the database server or service.
   *
   *   `PGPASSWORD`: Password to use to authenticate to the database server or service.
   *
   *   Note that because this component is an abstract component, `connectEnv`
   *   always returns `undefined`. This abstract component should be replaced
   *   (using a style sheet) with a non-abstract component, such as
   *   {@link postgres.TestPostgres} that will provide its own implementation
   *   of `connectEnv`.
   *
   * @public
   */
  export declare function Postgres(): null;/**
   * A component suitable for creating test scenarios that creates a simple,
   * temporary Postgres database that loads test data from a .sql file and
   * which implements the abstract {@link postgres.Postgres} interface.
   *
   * @remarks
   *
   * Implements the {@link ConnectToInstance} interface.
   *
   * Instance methods:
   *
   * - `connectEnv(scope?: NetworkScope): Environment | undefined`
   *
   *   Returns the set of environment variables that have all the information
   *   needed for a Postgres client to connect to this database. The
   *   returned environment variables are named such that some common Postgres
   *   clients can use them directly:
   *
   *   `PGHOST`: The host to connect to.
   *
   *   `PGDATABASE`: The name of the database.
   *
   *   `PGUSER`: Username to use to authenticate to the database server or service.
   *
   *   `PGPASSWORD`: Password to use to authenticate to the database server or service.
   *
   * @public
   */
  export declare function TestPostgres(props: SFCDeclProps<TestPostgresProps>): Adapt.JSX.Element;/**
   * Props for the {@link postgres.TestPostgres} component
   *
   * @public
   */
  export declare interface TestPostgresProps {
      mockDataPath: string;
      mockDbName: string;
  }/**
   * Creates a throw-away {@link https://www.postgresql.org | Postgres} database with preloaded data.
   *
   * @remarks
   * Implements {@link docker.DockerImageInstance}.
   *
   * See {@link postgres.PreloadedPostgresImageProps}
   *
   * @public
   */
  export declare function PreloadedPostgresImage(props: PreloadedPostgresImageProps): Adapt.JSX.Element | null;/**
   * Props for {@link postgres.PreloadedPostgresImage}
   *
   * @public
   */
  export declare interface PreloadedPostgresImageProps {
      /** Name of database in which to load mock data */
      mockDbName: string;
      /**
       * Path to a sql file with both schema and data to load into the database
       *
       * @remarks
       *
       * This data can be produced by standing up a postgres instance, populating it with
       * the required data and then running {@link https://www.postgresql.org/docs/9.1/app-pgdump.html | pg_dump}.
       */
      mockDataPath: string;
  }/**
   * Component that represents an external provider of a Postgres database
   *
   * @remarks
   *
   * See {@link postgres.PostgresProviderProps}.
   *
   * Use this component to connect other cloud components to a external
   * Postgres services, such as Google CloudSQL or Amazon RDS.
   *
   * @example
   *
   * ```
   * const pg = handle();
   *
   * <PostgresProvider handle={pg}
   *   hostname="mypostgres.com:5432"
   *   db="db"
   *   user="myuser"
   *   password={process.env.PGPASSWORD}
   * />
   *
   * <NodeService src="/somedir" connectTo={pg} />
   * ```
   *
   * @public
   */
  declare function PostgresProvider(props: PostgresProviderProps): null;/**
   * Props for the {@link postgres.PostgresProvider} component
   *
   * @public
   */
  export declare interface PostgresProviderProps {
      /** Hostname for the Postgres database as it would appear in the PGHOST environment variable */
      host?: string;
      /** Postgres database name as it would appear in the PGDATABASE environment variable */
      database?: string;
      /** Postgres username as it would appear in the PGUSER environment variable */
      user?: string;
      /** Postgres password as it would appear in the PGPASSWORD environment variable */
      password?: string;
  }/**
   * Component that represents an external provider of a Postgres database
   *
   * @remarks
   *
   * See {@link postgres.PostgresProviderProps}.
   *
   * Use this component to connect other cloud components to a external
   * Postgres services, such as Google CloudSQL or Amazon RDS.
   *
   * @example
   *
   * ```
   * const pg = handle();
   *
   * <PostgresProvider handle={pg}
   *   hostname="mypostgres.com:5432"
   *   db="db"
   *   user="myuser"
   *   password={process.env.PGPASSWORD}
   * />
   *
   * <NodeService src="/somedir" connectTo={pg} />
   * ```
   *
   * @public
   */
  declare function PostgresProvider(props: PostgresProviderProps): null;/**
   * An abstract component representing a Postgres database within a Postgres
   * server or service.
   *
   * @remarks
   *
   * Implements the {@link ConnectToInstance} interface.
   *
   * Instance methods:
   *
   * - `connectEnv(scope?: NetworkScope): Environment | undefined`
   *
   *   Returns the set of environment variables that have all the information
   *   needed for a Postgres client to connect to this database. The
   *   returned environment variables are named such that some common Postgres
   *   clients can use them directly:
   *
   *   `PGHOST`: The host to connect to.
   *
   *   `PGDATABASE`: The name of the database.
   *
   *   `PGUSER`: Username to use to authenticate to the database server or service.
   *
   *   `PGPASSWORD`: Password to use to authenticate to the database server or service.
   *
   *   Note that because this component is an abstract component, `connectEnv`
   *   always returns `undefined`. This abstract component should be replaced
   *   (using a style sheet) with a non-abstract component, such as
   *   {@link postgres.TestPostgres} that will provide its own implementation
   *   of `connectEnv`.
   *
   * @public
   */
  export declare function Postgres(): null;/**
   * A component suitable for creating test scenarios that creates a simple,
   * temporary Postgres database that loads test data from a .sql file and
   * which implements the abstract {@link postgres.Postgres} interface.
   *
   * @remarks
   *
   * Implements the {@link ConnectToInstance} interface.
   *
   * Instance methods:
   *
   * - `connectEnv(scope?: NetworkScope): Environment | undefined`
   *
   *   Returns the set of environment variables that have all the information
   *   needed for a Postgres client to connect to this database. The
   *   returned environment variables are named such that some common Postgres
   *   clients can use them directly:
   *
   *   `PGHOST`: The host to connect to.
   *
   *   `PGDATABASE`: The name of the database.
   *
   *   `PGUSER`: Username to use to authenticate to the database server or service.
   *
   *   `PGPASSWORD`: Password to use to authenticate to the database server or service.
   *
   * @public
   */
  export declare function TestPostgres(props: SFCDeclProps<TestPostgresProps>): Adapt.JSX.Element;/**
   * Props for the {@link postgres.TestPostgres} component
   *
   * @public
   */
  export declare interface TestPostgresProps {
      mockDataPath: string;
      mockDbName: string;
  }/**
   * Creates a throw-away {@link https://www.postgresql.org | Postgres} database with preloaded data.
   *
   * @remarks
   * Implements {@link docker.DockerImageInstance}.
   *
   * See {@link postgres.PreloadedPostgresImageProps}
   *
   * @public
   */
  export declare function PreloadedPostgresImage(props: PreloadedPostgresImageProps): Adapt.JSX.Element | null;/**
   * Props for {@link postgres.PreloadedPostgresImage}
   *
   * @public
   */
  export declare interface PreloadedPostgresImageProps {
      /** Name of database in which to load mock data */
      mockDbName: string;
      /**
       * Path to a sql file with both schema and data to load into the database
       *
       * @remarks
       *
       * This data can be produced by standing up a postgres instance, populating it with
       * the required data and then running {@link https://www.postgresql.org/docs/9.1/app-pgdump.html | pg_dump}.
       */
      mockDataPath: string;
  }/**
   * Component that represents an external provider of a Postgres database
   *
   * @remarks
   *
   * See {@link postgres.PostgresProviderProps}.
   *
   * Use this component to connect other cloud components to a external
   * Postgres services, such as Google CloudSQL or Amazon RDS.
   *
   * @example
   *
   * ```
   * const pg = handle();
   *
   * <PostgresProvider handle={pg}
   *   hostname="mypostgres.com:5432"
   *   db="db"
   *   user="myuser"
   *   password={process.env.PGPASSWORD}
   * />
   *
   * <NodeService src="/somedir" connectTo={pg} />
   * ```
   *
   * @public
   */
  declare function PostgresProvider(props: PostgresProviderProps): null;/**
   * Props for the {@link postgres.PostgresProvider} component
   *
   * @public
   */
  export declare interface PostgresProviderProps {
      /** Hostname for the Postgres database as it would appear in the PGHOST environment variable */
      host?: string;
      /** Postgres database name as it would appear in the PGDATABASE environment variable */
      database?: string;
      /** Postgres username as it would appear in the PGUSER environment variable */
      user?: string;
      /** Postgres password as it would appear in the PGPASSWORD environment variable */
      password?: string;
  }/**
   * Component that represents an external provider of a Postgres database
   *
   * @remarks
   *
   * See {@link postgres.PostgresProviderProps}.
   *
   * Use this component to connect other cloud components to a external
   * Postgres services, such as Google CloudSQL or Amazon RDS.
   *
   * @example
   *
   * ```
   * const pg = handle();
   *
   * <PostgresProvider handle={pg}
   *   hostname="mypostgres.com:5432"
   *   db="db"
   *   user="myuser"
   *   password={process.env.PGPASSWORD}
   * />
   *
   * <NodeService src="/somedir" connectTo={pg} />
   * ```
   *
   * @public
   */
  declare function PostgresProvider(props: PostgresProviderProps): null;/**
   * An abstract component representing a Postgres database within a Postgres
   * server or service.
   *
   * @remarks
   *
   * Implements the {@link ConnectToInstance} interface.
   *
   * Instance methods:
   *
   * - `connectEnv(scope?: NetworkScope): Environment | undefined`
   *
   *   Returns the set of environment variables that have all the information
   *   needed for a Postgres client to connect to this database. The
   *   returned environment variables are named such that some common Postgres
   *   clients can use them directly:
   *
   *   `PGHOST`: The host to connect to.
   *
   *   `PGDATABASE`: The name of the database.
   *
   *   `PGUSER`: Username to use to authenticate to the database server or service.
   *
   *   `PGPASSWORD`: Password to use to authenticate to the database server or service.
   *
   *   Note that because this component is an abstract component, `connectEnv`
   *   always returns `undefined`. This abstract component should be replaced
   *   (using a style sheet) with a non-abstract component, such as
   *   {@link postgres.TestPostgres} that will provide its own implementation
   *   of `connectEnv`.
   *
   * @public
   */
  export declare function Postgres(): null;/**
   * A component suitable for creating test scenarios that creates a simple,
   * temporary Postgres database that loads test data from a .sql file and
   * which implements the abstract {@link postgres.Postgres} interface.
   *
   * @remarks
   *
   * Implements the {@link ConnectToInstance} interface.
   *
   * Instance methods:
   *
   * - `connectEnv(scope?: NetworkScope): Environment | undefined`
   *
   *   Returns the set of environment variables that have all the information
   *   needed for a Postgres client to connect to this database. The
   *   returned environment variables are named such that some common Postgres
   *   clients can use them directly:
   *
   *   `PGHOST`: The host to connect to.
   *
   *   `PGDATABASE`: The name of the database.
   *
   *   `PGUSER`: Username to use to authenticate to the database server or service.
   *
   *   `PGPASSWORD`: Password to use to authenticate to the database server or service.
   *
   * @public
   */
  export declare function TestPostgres(props: SFCDeclProps<TestPostgresProps>): Adapt.JSX.Element;/**
   * Props for the {@link postgres.TestPostgres} component
   *
   * @public
   */
  export declare interface TestPostgresProps {
      mockDataPath: string;
      mockDbName: string;
  }/**
   * Creates a throw-away {@link https://www.postgresql.org | Postgres} database with preloaded data.
   *
   * @remarks
   * Implements {@link docker.DockerImageInstance}.
   *
   * See {@link postgres.PreloadedPostgresImageProps}
   *
   * @public
   */
  export declare function PreloadedPostgresImage(props: PreloadedPostgresImageProps): Adapt.JSX.Element | null;/**
   * Props for {@link postgres.PreloadedPostgresImage}
   *
   * @public
   */
  export declare interface PreloadedPostgresImageProps {
      /** Name of database in which to load mock data */
      mockDbName: string;
      /**
       * Path to a sql file with both schema and data to load into the database
       *
       * @remarks
       *
       * This data can be produced by standing up a postgres instance, populating it with
       * the required data and then running {@link https://www.postgresql.org/docs/9.1/app-pgdump.html | pg_dump}.
       */
      mockDataPath: string;
  }/**
   * Component that represents an external provider of a Postgres database
   *
   * @remarks
   *
   * See {@link postgres.PostgresProviderProps}.
   *
   * Use this component to connect other cloud components to a external
   * Postgres services, such as Google CloudSQL or Amazon RDS.
   *
   * @example
   *
   * ```
   * const pg = handle();
   *
   * <PostgresProvider handle={pg}
   *   hostname="mypostgres.com:5432"
   *   db="db"
   *   user="myuser"
   *   password={process.env.PGPASSWORD}
   * />
   *
   * <NodeService src="/somedir" connectTo={pg} />
   * ```
   *
   * @public
   */
  declare function PostgresProvider(props: PostgresProviderProps): null;/**
   * Props for the {@link postgres.PostgresProvider} component
   *
   * @public
   */
  export declare interface PostgresProviderProps {
      /** Hostname for the Postgres database as it would appear in the PGHOST environment variable */
      host?: string;
      /** Postgres database name as it would appear in the PGDATABASE environment variable */
      database?: string;
      /** Postgres username as it would appear in the PGUSER environment variable */
      user?: string;
      /** Postgres password as it would appear in the PGPASSWORD environment variable */
      password?: string;
  }/**
   * Component that represents an external provider of a Postgres database
   *
   * @remarks
   *
   * See {@link postgres.PostgresProviderProps}.
   *
   * Use this component to connect other cloud components to a external
   * Postgres services, such as Google CloudSQL or Amazon RDS.
   *
   * @example
   *
   * ```
   * const pg = handle();
   *
   * <PostgresProvider handle={pg}
   *   hostname="mypostgres.com:5432"
   *   db="db"
   *   user="myuser"
   *   password={process.env.PGPASSWORD}
   * />
   *
   * <NodeService src="/somedir" connectTo={pg} />
   * ```
   *
   * @public
   */
  declare function PostgresProvider(props: PostgresProviderProps): null;
}

export declare namespace redis {
/**
   * Abstract Redis component
   *
   * @remarks
   * This component is used to denote a needed {@link https://redis.io | Redis} service.
   * Users should use a style sheet to subsitute a concrete Redis instance that provides
   * the service.  {@link redis.TestRedis} is such a component, suitable for test
   * environments.
   *
   * All implementations of this component should implmenent {@link ConnectToInstance}
   * that provides a `REDIS_URI` variable of the form `redis://<hostname>:<port>`.
   *
   * @public
   */
  export declare abstract class Redis extends PrimitiveComponent implements ConnectToInstance {
      connectEnv(_scope?: NetworkScope): undefined;
  }/**
   * Deploys a {@link https://redis.io | Redis} container suitable for testing
   *
   * @remarks
   *
   * Uses an abstract {@link Service}, {@link NetworkService}, and {@link Container}
   * component that must be substituted in a style sheet.
   *
   * * See {@link redis.TestRedisProps}.
   *
   * @public
   */
  export declare function TestRedis(props: SFCDeclProps<TestRedisProps, typeof testRedisDefaultProps>): Adapt.JSX.Element;/**
   * Props for {@link redis.TestRedis}.
   *
   * @public
   */
  export declare interface TestRedisProps {
      /** Image to use for container, defaults to redis:buster */
      image: string;
      /** Specifies when to pull image, defaults to `"Always"` */
      imagePullPolicy: "Always" | "IfNotPresent" | "Never" | undefined;
      /** Port on which the Redis service is exposed */
      port: number;
  }/**
   * Abstract Redis component
   *
   * @remarks
   * This component is used to denote a needed {@link https://redis.io | Redis} service.
   * Users should use a style sheet to subsitute a concrete Redis instance that provides
   * the service.  {@link redis.TestRedis} is such a component, suitable for test
   * environments.
   *
   * All implementations of this component should implmenent {@link ConnectToInstance}
   * that provides a `REDIS_URI` variable of the form `redis://<hostname>:<port>`.
   *
   * @public
   */
  export declare abstract class Redis extends PrimitiveComponent implements ConnectToInstance {
      connectEnv(_scope?: NetworkScope): undefined;
  }/**
   * Deploys a {@link https://redis.io | Redis} container suitable for testing
   *
   * @remarks
   *
   * Uses an abstract {@link Service}, {@link NetworkService}, and {@link Container}
   * component that must be substituted in a style sheet.
   *
   * * See {@link redis.TestRedisProps}.
   *
   * @public
   */
  export declare function TestRedis(props: SFCDeclProps<TestRedisProps, typeof testRedisDefaultProps>): Adapt.JSX.Element;/**
   * Props for {@link redis.TestRedis}.
   *
   * @public
   */
  export declare interface TestRedisProps {
      /** Image to use for container, defaults to redis:buster */
      image: string;
      /** Specifies when to pull image, defaults to `"Always"` */
      imagePullPolicy: "Always" | "IfNotPresent" | "Never" | undefined;
      /** Port on which the Redis service is exposed */
      port: number;
  }
}

/**
 * Renames all variables in `e` based on `mapping`
 *
 * @param e - {@link Environment} to rename
 * @param mapping - Object with `(key, value)` pairs that are `(originalName, newName)` pairs.
 *
 * @returns A new {@link Environment} object with all variables renamed according to `mapping`
 *
 * @public
 */
export declare function renameEnvVars(e: Environment, mapping: {
    [orig: string]: string;
}): Environment;

/**
 * The behavior to apply when the container exits.
 * @remarks
 * See the
 * {@link https://docs.docker.com/engine/api/v1.40/#operation/ContainerCreate | Docker API Reference}
 * for more information.
 * @public
 */
export declare interface RestartPolicy {
    /** The type of behavior to apply */
    name: RestartPolicyName;
    /** If `OnFailure` is used, the number of times to retry before giving up */
    maximumRetryCount?: number;
}

/**
 * Names for {@link RestartPolicy}
 *
 * @remarks
 * - `Always` - Always restart the container.
 * - `Never` - Do not automatically restart the container.
 * - `OnFailure` - Restart only when the container exit code is non-zero.
 * - `UnlessStopped` - Always restart the container, except if it has been
 *   manually stopped by user intervention.
 *
 * See the
 * {@link https://docs.docker.com/engine/api/v1.40/#operation/ContainerCreate | Docker API Reference}
 * for more information.
 * @public
 */
export declare type RestartPolicyName = "Always" | "Never" | "OnFailure" | "UnlessStopped";

/**
 * Restart policy status for {@link ContainerStatus}
 * @public
 */
export declare interface RestartPolicyStatus {
    Name: "no" | "always" | "on-failure" | "unless-stopped";
    MaximumRetryCount: number;
}

/**
 * An abstract component that represents a group of components that
 * implements a service. Note that this is not necessarily a network
 * service, but will often be.
 *
 * @remarks
 * Typical children will be {@link NetworkService} and {@link Container} elements.
 *
 * @public
 */
export declare abstract class Service extends Component<ServiceProps, {}> {
}

/**
 * Port for {@link NetworkService }
 * @public
 */
export declare type ServicePort = number | string;

/**
 * Props for {@link Service}
 * @public
 */
export declare interface ServiceProps extends WithChildren {
    /** Optional name for the service */
    name?: string;
}

/**
 * Computes the target port that will be used for a NetworkService
 *
 * @param elemOrProps - a {@link NetworkService} element or its props
 * @returns The target port of the {@link NetworkService} object
 *
 * @public
 */
export declare function targetPort(elemOrProps: NetworkServiceProps | AdaptElement): ServicePort;

/**
 * Updates the names and/or values of variables in an {@link Environment}
 *
 * @param e - The source {@link Environment}
 * @param upd - Updated function that returns an EnvPair with the new name and value of the variable
 * @returns - A new {@link Environment} that is identical to `e` except for the updates done by `upd`
 *
 * @public
 */
export declare function updateEnvVars(e: Environment, upd: (name: string, value: string) => EnvPair | undefined): Environment;

/**
 * Hook that will build an {@link Environment} object from components that comply with {@link ConnectToInstance}
 *
 * @param connectTo - A handle or array of handles that point to components that implement {@link ConnectToInstance}
 * @param xform - A method that can transform the provided environment before it is returned
 * @returns Merged {@link Environment} with variables provided by `connectTo` components, or undefined
 *
 * @remarks
 * Note that this is a hook, and so on first run this will return undefined.
 * After a full build, a state update will trigger a rebuild, at which point
 * the returned Environment will begin to be populated with the variables as
 * the various components are ready to provide them.  However, it can take multiple
 * turns of the build-deploy loop to get all the variables.
 *
 * Moreover, just because a component returns connection information in a variable
 * does not mean it is ready to accept traffic at that time.  Components that use this
 * hook to get connection information for other services must be prepared for those
 * services to be temporarily unavailable.
 *
 * See {@link renameEnvVars} as a function that is useful as an `xform` argument.
 *
 * @public
 */
export declare function useConnectTo(connectTo: Handle | Handle[], xform?: (e: Environment) => Environment): Environment | undefined;

/**
 * Hook that will build an {@link Environment} object from components that comply with {@link ConnectToInstance}
 *
 * @param connectTo - A handle or array of handles that point to components that implement {@link ConnectToInstance}
 * @param options - {@link UseConnectToOptions} options for useConnectTo
 * @returns Merged {@link Environment} with variables provided by `connectTo` components, or undefined
 *
 * @remarks
 * Note that this is a hook, and so on first run this will return undefined.
 * After a full build, a state update will trigger a rebuild, at which point
 * the returned Environment will begin to be populated with the variables as
 * the various components are ready to provide them.  However, it can take multiple
 * turns of the build-deploy loop to get all the variables.
 *
 * Moreover, just because a component returns connection information in a variable
 * does not mean it is ready to accept traffic at that time.  Components that use this
 * hook to get connection information for other services must be prepared for those
 * services to be temporarily unavailable.
 *
 * See {@link renameEnvVars} as a function that is useful as an `xform` option.
 *
 * @public
 */
export declare function useConnectTo(connectTo: Handle | Handle[], options?: UseConnectToOptions): Environment | undefined;

/**
 * Options for {@link useConnectTo}
 *
 * @public
 */
export declare interface UseConnectToOptions {
    /**
     * A function that will transform each environment before it is merged
     *
     * @param e - Environment to be transformed
     * @returns - A transformed Environment
     *
     * @remarks
     * See {@link renameEnvVars} as a function that is useful as an `xform` option.
     */
    xform?: (e: Environment) => Environment;
    /**
     * Scope from which returned connection information should be usable
     */
    scope?: NetworkScope;
}

/**
 * Hook function to translate an {@link ImageId} (which can be either a
 * Handle or an image name string) into an image name string.
 * @beta
 */
export declare function useLatestImageFrom(source: ImageId): string | undefined;

export { }
